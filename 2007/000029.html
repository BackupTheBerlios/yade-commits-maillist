<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1064 - in trunk: yade-core/src/yade yade-doc	yade-extra/clump	yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1064%20-%20in%20trunk%3A%20yade-core/src/yade%20yade-doc%0A%09yade-extra/clump%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw%0A%09yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider&In-Reply-To=%3C200702191924.l1JJOlb3017799%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000028.html">
   <LINK REL="Next"  HREF="000030.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1064 - in trunk: yade-core/src/yade yade-doc	yade-extra/clump	yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1064%20-%20in%20trunk%3A%20yade-core/src/yade%20yade-doc%0A%09yade-extra/clump%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw%0A%09yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider&In-Reply-To=%3C200702191924.l1JJOlb3017799%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1064 - in trunk: yade-core/src/yade yade-doc	yade-extra/clump	yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider">eudoxos at mail.berlios.de
       </A><BR>
    <I>Mon Feb 19 20:24:47 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000028.html">[Yade-commits] r1063 - in trunk: yade-core/src/yade	yade-extra/clump yade-libs/yade-lib-base/src/yade-lib-base	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw
</A></li>
        <LI>Next message: <A HREF="000030.html">[Yade-commits] r1065 - in trunk: yade-core/src/yade yade-doc	yade-extra/clump	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29">[ date ]</a>
              <a href="thread.html#29">[ thread ]</a>
              <a href="subject.html#29">[ subject ]</a>
              <a href="author.html#29">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2007-02-19 20:24:42 +0100 (Mon, 19 Feb 2007)
New Revision: 1064

Modified:
   trunk/yade-core/src/yade/Body.cpp
   trunk/yade-core/src/yade/Body.hpp
   trunk/yade-doc/Doxyfile
   trunk/yade-extra/clump/Clump.cpp
   trunk/yade-extra/clump/Clump.hpp
   trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator/LeapFrogPositionIntegrator.cpp
   trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp
   trunk/yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine/InteractionGeometryMetaEngine.cpp
   trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp
Log:
1. Fixes in the clump code
2. InteractionGeometryMetaEngine doesn't crash if a body doesn't have interactingGeometry (like Clump)
3. Fixes in the collider, related to the clump code
4. ClumpSubBodyMover is now a DeuxExMachina
5. discovered bug in Wm3::Matrix3::EigenDecomposition
6. ClumpTestGen generates a usable testcase (either a random one, or with one-sphere clump and an equivalent sphere) for testing purposes. Parameters etc. are physically wrong, but at least there are no crashes.
7. ClumpTestGen temporarily sets rootBody in Omega so that Body::byId is usable



Modified: trunk/yade-core/src/yade/Body.cpp
===================================================================
--- trunk/yade-core/src/yade/Body.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-core/src/yade/Body.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -16,7 +16,18 @@
 
 #ifdef HIGHLEVEL_CLUMPS
 	const id_t Body::ID_NONE=UINT_MAX;
-	/*! the definition will change once Omega disappears, but the interface should be the same. */
+	/*! The definition will change once Omega disappears, but the interface should be the same.
+	 * \warning This relies on Omega::instance().getRootBody() returning the respective rootBody.
+	 * Therefore, if you use this from a FileGenerator, you will need to call something like \code
+		shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
+		Omega::instance().setRootBody(rootBody);
+		// ...
+		// do your stuff here
+		// ...
+		Omega::instance().setRootBody(oldRootBody);
+		\endcode
+		\warning Make sure that a simulation is not running during generation, otherwise it will most likely crash. It seems that Omega::getRootBodyMutex that could be used for this purpose is just a dummy function.
+	 * */
 	shared_ptr&lt;Body&gt; Body::byId(Body::id_t _id){return (*(Omega::instance().getRootBody()-&gt;bodies))[_id];}
 #endif
 

Modified: trunk/yade-core/src/yade/Body.hpp
===================================================================
--- trunk/yade-core/src/yade/Body.hpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-core/src/yade/Body.hpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -49,6 +49,7 @@
 			static const id_t ID_NONE;
 			//! get Body pointer given its id. 
 			static shared_ptr&lt;Body&gt; byId(id_t _id);
+			//bool isClump(){return id==clumpId;}
 		#endif
 		unsigned int getId() const {return id;};
 

Modified: trunk/yade-doc/Doxyfile
===================================================================
--- trunk/yade-doc/Doxyfile	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-doc/Doxyfile	2007-02-19 19:24:42 UTC (rev 1064)
@@ -28,9 +28,9 @@
 STRIP_FROM_PATH        = ../
 STRIP_FROM_INC_PATH    = 
 SHORT_NAMES            = NO
-JAVADOC_AUTOBRIEF      = NO
+JAVADOC_AUTOBRIEF      = YES
 MULTILINE_CPP_IS_BRIEF = NO
-DETAILS_AT_TOP         = NO
+DETAILS_AT_TOP         = YES
 INHERIT_DOCS           = YES
 SEPARATE_MEMBER_PAGES  = NO
 TAB_SIZE               = 8
@@ -43,7 +43,7 @@
 #---------------------------------------------------------------------------
 # Build related configuration options
 #---------------------------------------------------------------------------
-EXTRACT_ALL            = NO
+EXTRACT_ALL            = YES # was: NO
 EXTRACT_PRIVATE        = YES
 EXTRACT_STATIC         = YES
 EXTRACT_LOCAL_CLASSES  = YES
@@ -129,7 +129,8 @@
 EXCLUDE_SYMLINKS       = NO
 EXCLUDE_PATTERNS       = */yade-flat/* \
 									*/include/* \
-									*/.*
+									*/.* \
+									*/yade-lib-loki/*
 EXAMPLE_PATH           = 
 EXAMPLE_PATTERNS       = *
 EXAMPLE_RECURSIVE      = NO

Modified: trunk/yade-extra/clump/Clump.cpp
===================================================================
--- trunk/yade-extra/clump/Clump.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-extra/clump/Clump.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -18,25 +18,44 @@
 CREATE_LOGGER(ClumpSubBodyMover);
 CREATE_LOGGER(ClumpTestGen);
 
-//! Constructor must be in the .cpp file (?)
-ClumpSubBodyMover::ClumpSubBodyMover(): PhysicalParametersEngineUnit() {/*createIndex();*/ }
+/**************************************************************************************
+ ************************************* ClumpSubBodyMover ******************************
+ **************************************************************************************/
 
+// Constructor must be in the .cpp file (?)
+ClumpSubBodyMover::ClumpSubBodyMover(){/*createIndex();*/ LOG_TRACE(&quot;constructor&quot;); }
+
 /*! We only call clump's method, since it belongs there logically. It makes encapsulation of private members nicer, too.
  * @param pp passed by the dispatcher
  * @param clump passed by the dispatcher
  */
-void ClumpSubBodyMover::go(const shared_ptr&lt;PhysicalParameters&gt;&amp; pp, Body* clump){
-	if(!clump-&gt;isDynamic) return; // perhaps clump that has been desactivated?!
-	dynamic_cast&lt;Clump*&gt;(clump)-&gt;moveSubBodies();
+void ClumpSubBodyMover::applyCondition(Body* _rootBody){
+	MetaBody* rootBody = dynamic_cast&lt;MetaBody*&gt;(_rootBody);
+	for(BodyContainer::iterator I=rootBody-&gt;bodies-&gt;begin(); I!=rootBody-&gt;bodies-&gt;end(); ++I){
+		shared_ptr&lt;Body&gt; b = *I;
+		// is this a clump?
+		if(b-&gt;getId()==b-&gt;clumpId){
+			//LOG_TRACE(&quot;Applying movement to clump #&quot;&lt;&lt;b-&gt;getId());
+			dynamic_pointer_cast&lt;Clump&gt;(b)-&gt;moveSubBodies();
+		}
+	}
+	//if(!clump-&gt;isDynamic) return; // perhaps clump that has been desactivated?!
 }
 
+/**************************************************************************************
+ ******************************************** Clump ***********************************
+ **************************************************************************************/
 
 /*! Create zero'ed RigidBodyParameters; they should not be manipulated directly, since they are all calculated in Clump::update.
  * @todo do we need to do the same for GeomtricalModel, InteractingGeometry and BoundingVolume? They will never be used. Sort that out for sure.
+ * @bug setting Clump::isDynamic in constructor is not enough (as if it were modified somewhere), must be set explicitly by the user after construction (why?)
  */
 Clump::Clump(): Body(){
-	isDynamic=false;
+	isDynamic=true;
 	physicalParameters=shared_ptr&lt;RigidBodyParameters&gt;(new RigidBodyParameters);
+
+	// these will not be defined for the moment...
+#if 0
 	boundingVolume=shared_ptr&lt;AABB&gt;(new AABB);
 	boundingVolume-&gt;diffuseColor=Vector3r(1,0,0);
 
@@ -45,6 +64,7 @@
 
 	geometricalModel=shared_ptr&lt;GeometricalModel&gt;(new GeometricalModel);
 	geometricalModel-&gt;diffuseColor=Vector3f(0,0,0); geometricalModel-&gt;wire=false; geometricalModel-&gt;visible=false; geometricalModel-&gt;shadowCaster=false;
+#endif
 
 }
 
@@ -66,6 +86,9 @@
 	subBody-&gt;isDynamic=false;
 	// for now, push just unitialized se3; will be updated by updateProperties
 	subBodies[subId]=Se3r();
+
+	clumpId=getId(); // identifies a clump
+
 	LOG_DEBUG(&quot;Added body #&quot;&lt;&lt;subId&lt;&lt;&quot; to clump #&quot;&lt;&lt;getId());
 }
 
@@ -89,11 +112,14 @@
 void Clump::moveSubBodies(){
 	const Se3r&amp; mySe3(physicalParameters-&gt;se3);
 	for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
-		// now, I-&gt;first is Body::id_t, I-&gt;second is Se3r of that body
+		// now, I-&gt;first is Body::id_t, I-&gt;second is Se3r of that body in the clump
 		shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 		shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
+		//LOG_TRACE(&quot;Old #&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;position: &quot;&lt;&lt;subRBP-&gt;se3.position);
 		subRBP-&gt;se3.position=mySe3.position+mySe3.orientation*I-&gt;second.position;
 		subRBP-&gt;se3.orientation=mySe3.orientation*I-&gt;second.orientation;
+		//LOG_TRACE(&quot;New #&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;position: &quot;&lt;&lt;subRBP-&gt;se3.position);
+		//LOG_TRACE(&quot;Clump #&quot;&lt;&lt;getId()&lt;&lt;&quot; moved #&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;.&quot;);
 	}
 }
 
@@ -121,7 +147,7 @@
 
 	@note User is responsible for calling this function when appropriate (after adding/removing bodies and before any subsequent simulation). This function can be rather slow by virtue of numerical integration.
 	@note subBodie's velocities are not taken into account. This means that clump will be at still after being created, even if its composing particles did have some velocities. If this is concern for someone, it needs to be completed in the code below. See Clump::moveSubBodies for complementary issue.
-	@todo Needs to be implemented and tested.
+	@todo Needs to be tested for physical correctness
 	@param intersecting if true, evaluate mass and inertia numerically; otherwise, use analytical methods (parallel axes theorem) which disregard any intersections, but are much faster. */
 void Clump::updateProperties(bool intersecting){
 	LOG_DEBUG(&quot;Updating clump #&quot;&lt;&lt;getId()&lt;&lt;&quot; parameters&quot;);
@@ -151,18 +177,43 @@
 			// transform from local to global coords
 			// FIXME: verify this!
 			Quaternionr subRBP_orientation_conjugate=subRBP-&gt;se3.orientation.Conjugate();
-			Ig+=Clump::inertiaTensorTranslate(Clump::inertiaTensorRotate(Matrix3r(subRBP-&gt;inertia),subRBP_orientation_conjugate),-subRBP-&gt;mass,-1.*subRBP-&gt;se3.position);
+			Matrix3r Imatrix(subRBP-&gt;inertia[0],subRBP-&gt;inertia[1],subRBP-&gt;inertia[2]); TRWM3MAT(Imatrix);
+			TRWM3QUAT(subRBP_orientation_conjugate);
+			Ig+=Clump::inertiaTensorTranslate(Clump::inertiaTensorRotate(Imatrix,subRBP_orientation_conjugate),-subRBP-&gt;mass,-1.*subRBP-&gt;se3.position);
+
+			//TRWM3MAT(Clump::inertiaTensorRotate(Matrix3r(subRBP-&gt;inertia),subRBP_orientation_conjugate));
 		}
 	}else{LOG_ERROR(&quot;Self-intersecting clumps not implemented.&quot;);}
+	TRVAR1(M);
+	TRWM3MAT(Ig);
+	TRWM3VEC(Sg);
 
+	/*! @bug incorrect results; these are vars traced for one and only sphere:
+	 *
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:153 updateProperties: Updating clump #1 parameters
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:182 updateProperties: subRBP-&gt;inertia=(104.72 104.72 104.72)
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:183 updateProperties: Clump::inertiaTensorRotate(Matrix3r(subRBP-&gt;inertia),subRBP_orientation_conjugate)=((0 0 0)(0 0 0)(0 0 0))
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:186 updateProperties: M=1047.2; 
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:187 updateProperties: Ig=((0 0 0)(0 0 0)(0 0 0))
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:188 updateProperties: Sg=(0 0 0)
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:200 updateProperties: Ic=((0 0 0)(0 0 0)(0 0 0))
+DEBUG yade.Clump yade-extra/clump/Clump.cpp:201 updateProperties: Clump::inertiaTensorRotate(Ic_orientG,R_g2c)=((0 nan nan)(nan nan nan)(nan nan nan))
 
+*/
+
+
 	mySe3.position=Sg/M; // clump's centroid
 	// this will calculate translation only, since rotation is zero
 	Matrix3r Ic_orientG=Clump::inertiaTensorTranslate(Ig, -M /* negative mass means towards centroid */, mySe3.position); // inertia at clump's centroid but with world orientation
 
-	Matrix3r R_g2c; //rotation matrix
+	Matrix3r R_g2c(true); //rotation matrix
 	Ic_orientG(1,0)=Ic_orientG(0,1); Ic_orientG(2,0)=Ic_orientG(0,2); Ic_orientG(2,1)=Ic_orientG(1,2); // symmetrize
+	Ic_orientG(0,0)+=.1;
+	TRWM3MAT(Ic_orientG);
 	Ic_orientG.EigenDecomposition(R_g2c,Ic);
+	/*! @bug: eigendecomposition is wrong. see <A HREF="http://article.gmane.org/gmane.science.physics.yade.devel/99">http://article.gmane.org/gmane.science.physics.yade.devel/99</A> for message. */
+	// has NaNs for identity matrix!
+	TRWM3MAT(R_g2c);
 
 	// these two should give the same result!
 	TRWM3MAT(Ic);
@@ -188,7 +239,7 @@
 		I-&gt;second.orientation=mySe3.orientation.Conjugate()*subRBP-&gt;se3.orientation;
 		I-&gt;second.position=mySe3.orientation.Conjugate()*(subRBP-&gt;se3.position-mySe3.position);
 	}
-
+#if 0
 	// update bounding box; we could have done this in previous loops, but this is cleaner
 	Vector3r min(0,0,0),max(0,0,0);
 	for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
@@ -199,6 +250,7 @@
 	}
 	shared_ptr&lt;AABB&gt; aabb=dynamic_pointer_cast&lt;AABB&gt;(boundingVolume);
 	aabb-&gt;center=(min+max)*.5; aabb-&gt;halfSize=(max-min)*.5;
+#endif
 }
 
 /*! @brief Recalculates inertia tensor of a body after translation away from (default) or towards its centroid.
@@ -211,12 +263,14 @@
 Matrix3r Clump::inertiaTensorTranslate(const Matrix3r&amp; I,const Real m, const Vector3r&amp; off){
 	Real ooff=off.Dot(off);
 	Matrix3r I2=I;
+	//TRWM3VEC(off); TRVAR2(ooff,m); TRWM3MAT(I);
 	// translation away from centroid
 	/* I^c_jk=I'_jk-M*(delta_jk R.R - R_j*R_k) [<A HREF="http://en.wikipedia.org/wiki/Moments_of_inertia#Parallel_axes_theorem">http://en.wikipedia.org/wiki/Moments_of_inertia#Parallel_axes_theorem</A>] */
 	I2+=m*Matrix3r(/* dIxx */ ooff-off[0]*off[0], /* dIxy */ -off[0]*off[1], /* dIxz */ -off[0]*off[2],
 		/* sym */ 0, /* dIyy */ ooff-off[1]*off[1], /* dIyz */ -off[1]*off[2],
 		/* sym */ 0, /* sym */ 0, /* dIzz */ ooff-off[2]*off[2]);
 	I2(1,0)=I2(0,1); I2(2,0)=I2(0,2); I2(2,1)=I2(1,2);
+	//TRWM3MAT(I2);
 	return I2;
 }
 
@@ -228,6 +282,7 @@
  */
 Matrix3r Clump::inertiaTensorRotate(const Matrix3r&amp; I,const Matrix3r&amp; T){
 	/* [<A HREF="http://www.kwon3d.com/theory/moi/triten.html">http://www.kwon3d.com/theory/moi/triten.html</A>] */
+	//TRWM3MAT(I); TRWM3MAT(T);
 	return T.Transpose()*I*T;
 }
 
@@ -326,9 +381,10 @@
 //#include &quot;BodyMacroParameters.hpp&quot;
 
 
+// generate either random spheres, or (if not defined) just one sphere and one one-sphere clump
+//#define CLUMP_COMPLICATED
 
 
-
 string ClumpTestGen::generate()
 {
 	{ // root body
@@ -369,19 +425,22 @@
 
 	// some clumps
 	setMessage(&quot;Elements...&quot;);
-	for(int i=0;i&lt;2;i++)
-	{
-		if(shouldTerminate()) return &quot;&quot;;
-		for(int j=0;j&lt;2;j++)
-			for(int k=0;k&lt;2;k++)
-			{
-				//shared_ptr&lt;Body&gt; clump;
-				createOneClump(rootBody,i,j,k);
-				//rootBody-&gt;bodies-&gt;insert(clump);
-				setProgress(i*j*k/(2*2*2));
-			}
+	#ifdef CLUMP_COMPLICATED
+		for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++){
+	#else
+		{ int i=0,j=0,k=0;
+	#endif
+			if(shouldTerminate()) return &quot;&quot;;
+			createOneClump(rootBody,i,j,k);
+			setProgress(i*j*k/(2*2*2));
 	}
 
+	#ifndef CLUMP_COMPLICATED
+	// for the simple case, create a standalone sphere as well
+		shared_ptr&lt;Body&gt; sphere=createOneSphere(Vector3r(1,0,0),.5);
+		rootBody-&gt;bodies-&gt;insert(sphere);
+	#endif
+
 	// restore Omega
 	Omega::instance().setRootBody(oldRootBody);
 	
@@ -396,121 +455,82 @@
 
 void ClumpTestGen::createOneClump(shared_ptr&lt;MetaBody&gt;&amp; rootBody, int i, int j, int k)
 {
-	Vector3r clumpPos=Vector3r(i,j,k)+Vector3r(.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom());
-	Real density=2000;
+	// empty clump	
+	shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
+	shared_ptr&lt;Body&gt; clumpAsBody=dynamic_pointer_cast&lt;Body&gt;(clump);
+	rootBody-&gt;bodies-&gt;insert(clumpAsBody);
 
-	int nSpheres=(int)(Mathr::UnitRandom()*4+1);
+	clump-&gt;isDynamic=true;
+	// if subscribedBodies work some day: clumpMover-&gt;subscribedBodies.push_back(clump-&gt;getId());
+	
+	#ifdef CLUMP_COMPLICATED	
+		Vector3r clumpPos=Vector3r(i,j,k)+Vector3r(.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom());	int nSpheres=(int)(Mathr::UnitRandom()*4+1);
+	#else
+		Vector3r clumpPos=Vector3r(i,j,k); int nSpheres=1;
+	#endif
+
 	LOG_TRACE(&quot;Will generate &quot;&lt;&lt;nSpheres&lt;&lt;&quot; shperes around the point &quot;&lt;&lt;clumpPos);
+
 	vector&lt;Body::id_t&gt; subBodyIDs;
 	// create a few spheres that will be part of the clump afterwards
 	for(int i=0; i&lt;nSpheres; i++){
-		//body
-		shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,55));
-		body-&gt;isDynamic=true;
+		shared_ptr&lt;Body&gt; sphere=
+			#ifdef CLUMP_COMPLICATED
+			// positined around future clump's position
+				createOneSphere(clumpPos+.3*Vector3r(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom()),Mathr::IntervalRandom(.1,.3));
+			#else
+				createOneSphere(clumpPos,.5);
+			#endif
+		Body::id_t lastId=(Body::id_t)rootBody-&gt;bodies-&gt;insert(sphere);
+		clump-&gt;add(lastId);
 
-		// physics
-		shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
-		// positined around future clump's position
-		Vector3r position=clumpPos+.3*Vector3r(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom());
-		Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0);
-		Real radius=Mathr::IntervalRandom(.2,.5);
-		physics-&gt;angularVelocity=Vector3r(0,0,0);
-		physics-&gt;velocity=Vector3r(0,0,0);
-		physics-&gt;mass=4.0/3.0*Mathr::PI*radius*radius*radius*density;
-		physics-&gt;inertia=Vector3r(2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius);
-		physics-&gt;se3=Se3r(position,q);
-		physics-&gt;young=2e7;
-		physics-&gt;poisson=.3;
-		physics-&gt;frictionAngle=40*Mathr::PI/180.0;
-		body-&gt;physicalParameters=physics;
-
-		// aabb
-		shared_ptr&lt;AABB&gt; aabb(new AABB);
-		aabb-&gt;diffuseColor=Vector3r(0,1,0);
-		body-&gt;boundingVolume=aabb;
-
-		// mold
-		shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
-		shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
-		iSphere-&gt;radius=radius;
-		iSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
-		body-&gt;interactingGeometry=iSphere;
-
-		//shape
-		gSphere-&gt;radius=radius;
-		gSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
-		gSphere-&gt;wire=false;
-		gSphere-&gt;visible=true;
-		gSphere-&gt;shadowCaster=true;
-		body-&gt;geometricalModel=gSphere;
-
-		Body::id_t lastId=(Body::id_t)rootBody-&gt;bodies-&gt;insert(body);
-		subBodyIDs.push_back(lastId);
-		LOG_TRACE(&quot;Generated sphere #&quot;&lt;&lt;lastId);
+		LOG_TRACE(&quot;Generated clumped sphere #&quot;&lt;&lt;lastId);
 	}
 
-	shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
-	shared_ptr&lt;Body&gt; clumpAsBody=dynamic_pointer_cast&lt;Body&gt;(clump);
-#if 0
-	//FIXME
-	rootBody-&gt;bodies-&gt;insert(clumpAsBody);
-	for(size_t i=0; i&lt;subBodyIDs.size(); i++){clump-&gt;add(subBodyIDs[i]);}
 	clump-&gt;updateProperties(false);
-#endif
+}
 
-/*
-	body = shared_ptr&lt;Body&gt;(new Body(0,1));
-	shared_ptr&lt;ElasticBodyParameters&gt; physics(new ElasticBodyParameters);
-	shared_ptr&lt;AABB&gt; aabb(new AABB);
-	shared_ptr&lt;SlumShape&gt; slum(new SlumShape);
-	
-	Quaternionr q;// = Quaternionr::IDENTITY;
-	q.FromAxisAngle(Vector3r(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom()),Mathr::SymmetricRandom());
-	q.Normalize();
-	physics-&gt;se3=Se3r(position,q);
+shared_ptr&lt;Body&gt; ClumpTestGen::createOneSphere(Vector3r position, Real radius){
+	Real density=2000;
 
-	slum-&gt;c.push_back(Vector3r(0,0,0)); slum-&gt;r.push_back(1);
-	slum-&gt;c.push_back(Vector3r(1,1,0)); slum-&gt;r.push_back(1);
-	density=1;
+	// body itself
+	shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,55));
+	body-&gt;isDynamic=true;
 
-	calculatePropertiesAndReposition(slum, physics, density);
-
-	slum-&gt;diffuseColor=Vector3f(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
-	slum-&gt;wire=false;
-	slum-&gt;visible=true;
-	slum-&gt;shadowCaster=false;
-
+	// physics
+	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+	Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0);
 	physics-&gt;angularVelocity=Vector3r(0,0,0);
 	physics-&gt;velocity=Vector3r(0,0,0);
+	physics-&gt;mass=4.0/3.0*Mathr::PI*radius*radius*radius*density;
+	physics-&gt;inertia=Vector3r(2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius);
+	physics-&gt;se3=Se3r(position,q);
+	physics-&gt;young=2e7;
+	physics-&gt;poisson=.3;
+	physics-&gt;frictionAngle=40*Mathr::PI/180.0;
+	body-&gt;physicalParameters=physics;
 
-	physics-&gt;mass=density;
-	physics-&gt;inertia=Vector3r(1,1,1);
-
-	physics-&gt;young=youngModulus;
+	// aabb
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor=Vector3r(0,1,0);
+	body-&gt;boundingVolume=aabb;
 
-	body-&gt;isDynamic=true;
+	// mold
+	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
+	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
+	iSphere-&gt;radius=radius;
+	iSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	body-&gt;interactingGeometry=iSphere;
 
-	// properly initialized by SlumShape2SlumMold::go
-	shared_ptr&lt;InteractingGeometry&gt; mold(new SlumMold);
-	mold-&gt;diffuseColor=Vector3f(0,0,0); // no-op values to prevent nan's in the XML file
-	body-&gt;interactingGeometry=mold;
+	//shape
+	gSphere-&gt;radius=radius;
+	gSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;wire=false;
+	gSphere-&gt;visible=true;
+	gSphere-&gt;shadowCaster=true;
+	body-&gt;geometricalModel=gSphere;
 
-	body-&gt;geometricalModel=slum;
-	body-&gt;boundingVolume=aabb;
-
-	// Vaclav,
-	//
-	// Here I use ElasticBodyParameters for physics, because this very simple example
-	// of four spheres in a tetrahedron nvoid SDECLinkedSpheres::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
-{
-eeds only young modulus. (stiffness)
-	// and nothing more.
-	//
-	// if you need some other physical data about tetrahedron (not just stiffness)
-	// then you will need to make a new class.
-	//
-	body-&gt;physicalParameters=physics;*/
+	return body;
 }
 
 void ClumpTestGen::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
@@ -562,6 +582,9 @@
 	shared_ptr&lt;ElasticCohesiveLaw&gt; constitutiveLaw2(new ElasticCohesiveLaw);
 	constitutiveLaw2-&gt;sdecGroupMask = 55;
 	constitutiveLaw2-&gt;momentRotationLaw = momentRotationLaw;*/
+
+	// clumps will be subscribed later, as they are generated
+	clumpMover=shared_ptr&lt;ClumpSubBodyMover&gt;(new ClumpSubBodyMover);
 	
 	rootBody-&gt;engines.clear();
 	rootBody-&gt;engines.push_back(sdecTimeStepper);
@@ -577,9 +600,63 @@
 	rootBody-&gt;engines.push_back(applyActionDispatcher);
 	rootBody-&gt;engines.push_back(positionIntegrator);
 	rootBody-&gt;engines.push_back(orientationIntegrator);
+	rootBody-&gt;engines.push_back(clumpMover);
 
 	rootBody-&gt;initializers.clear();
 	rootBody-&gt;initializers.push_back(physicalActionInitializer);
 	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
 }
 
+/*
+	body = shared_ptr&lt;Body&gt;(new Body(0,1));
+	shared_ptr&lt;ElasticBodyParameters&gt; physics(new ElasticBodyParameters);
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	shared_ptr&lt;SlumShape&gt; slum(new SlumShape);
+	
+	Quaternionr q;// = Quaternionr::IDENTITY;
+	q.FromAxisAngle(Vector3r(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom()),Mathr::SymmetricRandom());
+	q.Normalize();
+	physics-&gt;se3=Se3r(position,q);
+
+	slum-&gt;c.push_back(Vector3r(0,0,0)); slum-&gt;r.push_back(1);
+	slum-&gt;c.push_back(Vector3r(1,1,0)); slum-&gt;r.push_back(1);
+	density=1;
+
+	calculatePropertiesAndReposition(slum, physics, density);
+
+	slum-&gt;diffuseColor=Vector3f(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
+	slum-&gt;wire=false;
+	slum-&gt;visible=true;
+	slum-&gt;shadowCaster=false;
+
+	physics-&gt;angularVelocity=Vector3r(0,0,0);
+	physics-&gt;velocity=Vector3r(0,0,0);
+
+	physics-&gt;mass=density;
+	physics-&gt;inertia=Vector3r(1,1,1);
+
+	physics-&gt;young=youngModulus;
+	aabb-&gt;diffuseColor=Vector3r(0,1,0);
+
+	body-&gt;isDynamic=true;
+
+	// properly initialized by SlumShape2SlumMold::go
+	shared_ptr&lt;InteractingGeometry&gt; mold(new SlumMold);
+	mold-&gt;diffuseColor=Vector3f(0,0,0); // no-op values to prevent nan's in the XML file
+	body-&gt;interactingGeometry=mold;
+
+	body-&gt;geometricalModel=slum;
+	body-&gt;boundingVolume=aabb;
+
+	// Vaclav,
+	//
+	// Here I use ElasticBodyParameters for physics, because this very simple example
+	// of four spheres in a tetrahedron nvoid SDECLinkedSpheres::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
+{
+eeds only young modulus. (stiffness)
+	// and nothing more.
+	//
+	// if you need some other physical data about tetrahedron (not just stiffness)
+	// then you will need to make a new class.
+	//
+	body-&gt;physicalParameters=physics;*/

Modified: trunk/yade-extra/clump/Clump.hpp
===================================================================
--- trunk/yade-extra/clump/Clump.hpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-extra/clump/Clump.hpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -14,6 +14,7 @@
 #include&lt;yade/yade-core/Body.hpp&gt;
 #include&lt;yade/yade-core/MetaBody.hpp&gt;
 #include&lt;yade/yade-core/FileGenerator.hpp&gt;
+#include&lt;yade/yade-core/DeusExMachina.hpp&gt;
 #include&lt;yade/yade-lib-factory/Factorable.hpp&gt;
 #include&lt;boost/shared_ptr.hpp&gt;
 #include&lt;yade/yade-package-common/PhysicalParametersEngineUnit.hpp&gt;
@@ -27,19 +28,20 @@
 	#error HIGHLEVEL_CLUMPS must be defined if clumps are to work!
 #endif
 
-/*! \brief Body representing clump (aggregate) composed by other existing bodies.
+/*! Body representing clump (rigid aggregate) composed by other existing bodies.
 
+	Clump is one of bodies that reside in rootBody-&gt;bodies.
 	When an existing body is added to ::Clump, it's ::Body::isDynamic flag is set to false
 	(it is still subscribed to all its engines, to make it possible to remove it from the clump again).
-	All forces acting on |subBodies| are made to act on the clump itself, which will ensure that they
-	 influence all |subBodies| as if the clump were a rigid particle.
+	All forces acting on Clump::subBodies are made to act on the clump itself, which will ensure that they
+	influence all Clump::subBodies as if the clump were a rigid particle.
  
 	What are clump requirements so that they function?
 	-# Given any body, tell
 		- if it is a clump member \code Body::clumpId!=Body::ID_NONE \endcode
 		- what is it's clump id (Body::clumpId)
-	 	- if it is a clump (is instance of ::Clump)
-		- could be `Body::clumpId==Body::id`, but we can't guarantee consistency here; `id`s are assigned automatically by `BodyContainer` and it would have to be conscient of the body being clump... or not? This will probably be used not very often (engines use templates, not RTTI (?))
+	 	- if it is a clump \code Body::clumpId==Body::id \endcode This is assured at each call to Clump::add.
+		 - we could use RTTI instead? Would that be more reliable?
 	-# given the root body, tell
 		- what clumps it contains (enumerate all bodies and filter clumps, see above)
 	-#	given a clump, tell
@@ -55,6 +57,9 @@
 	-# Recalculate ::subBodies position and orientation (same class as previously will handle that automatically)
 
 	Some more information can be found <A HREF="http://beta.arcig.cz/~eudoxos/phd/index.cgi/YaDe/HighLevelClumps">http://beta.arcig.cz/~eudoxos/phd/index.cgi/YaDe/HighLevelClumps</A>
+
+	\note PersistentSAPCollider and SAPCollider bypass Clump by virtue of no boundingVolume being defined. Different logic would have to be implemented if Clump were to have its own boundingVolume.
+	\note Clump relies on its id being assigned (as well as id of its components); therefore, only bodies that have already been inserted to the container may be added to Clump which has been itself already added to the container.
  
  */
 
@@ -95,17 +100,19 @@
 
 REGISTER_SERIALIZABLE(Clump,false);
 
-/*! \brief  Update ::Clump::subBodies positions so that the Clump behaves as a rigid body.
+/*! Update ::Clump::subBodies positions so that the Clump behaves as a rigid body.
+ *
+ *
 */
-class ClumpSubBodyMover: public PhysicalParametersEngineUnit {
+class ClumpSubBodyMover: public DeusExMachina {
 	public:
-		//! This is the engine's working part
-		virtual void go(const shared_ptr&lt;PhysicalParameters&gt;&amp; pp, Body* clump);
+		//! Interates over rootBody-&gt;bodies and calls Clump::moveSubBodies() for clumps.
+		virtual void applyCondition(Body* rootBody);
 		ClumpSubBodyMover();
 		virtual ~ClumpSubBodyMover(){};
 
 	REGISTER_CLASS_NAME(ClumpSubBodyMover);
-	REGISTER_BASE_CLASS_NAME(PhysicalParametersEngineUnit);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 	// REGISTER_CLASS_INDEX(ClumpSubBodyMover,PhysicalParametersEngineUnit);
 	DECLARE_LOGGER;
 };
@@ -122,10 +129,12 @@
 		//bool		 rotationBlocked;
 		//void createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents);
 		void createOneClump(shared_ptr&lt;MetaBody&gt;&amp; rootBody, int i, int j, int k);
+		shared_ptr&lt;Body&gt; createOneSphere(Vector3r position, Real radius);
 		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		//void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		//void calculatePropertiesAndReposition(const shared_ptr&lt;SlumShape&gt;&amp; slum, shared_ptr&lt;ElasticBodyParameters&gt;&amp; rbp, Real density);
 		//void makeTet(shared_ptr&lt;Tetrahedron&gt;&amp; tet, Real radius);
+		shared_ptr&lt;ClumpSubBodyMover&gt; clumpMover;
 	public :
 		ClumpTestGen (){};
 		~ClumpTestGen (){};

Modified: trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator/LeapFrogPositionIntegrator.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator/LeapFrogPositionIntegrator.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/LeapFrogPositionIntegrator/LeapFrogPositionIntegrator.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -35,6 +35,8 @@
 	prevVelocities[id] = p-&gt;velocity+((Real)0.5)*dt*p-&gt;acceleration;
 	p-&gt;se3.position += prevVelocities[id]*dt;
 
+	//cerr&lt;&lt;&quot;#&quot;&lt;&lt;body-&gt;getId()&lt;&lt;&quot;dx=&quot;&lt;&lt;prevVelocities[id]*dt&lt;&lt;endl;
+
 	firsts[id] = false;
 }
 

Modified: trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -37,13 +37,18 @@
 //	std::cin &gt;&gt; ch;
 
 	#ifdef HIGHLEVEL_CLUMPS
-	if (bb-&gt;clumpId==Body::ID_NONE) p-&gt;acceleration = af-&gt;force/p-&gt;mass; // normal behavior of a standalone particle
+	// normal behavior of a standalone particle or a clump itself
+	//cerr&lt;&lt;&quot;#&quot;&lt;&lt;bb-&gt;getId()&lt;&lt;&quot; mass:&quot;&lt;&lt;p-&gt;mass&lt;&lt;endl;
+	if (bb-&gt;clumpId==Body::ID_NONE || bb-&gt;clumpId==bb-&gt;getId()) {
+		p-&gt;acceleration = af-&gt;force/p-&gt;mass;
+	}
 	else{
 		shared_ptr&lt;Body&gt; clump=Body::byId(bb-&gt;clumpId);
-		RigidBodyParameters* clumpPP=dynamic_cast&lt;RigidBodyParameters*&gt;(clump-&gt;physicalParameters.get());
+		RigidBodyParameters* clumpRBP=dynamic_cast&lt;RigidBodyParameters*&gt;(clump-&gt;physicalParameters.get());
 		/* TODO: the FIXME above still applies!!! */
-		clumpPP-&gt;acceleration+=af-&gt;force/clumpPP-&gt;mass;
-		clumpPP-&gt;angularAcceleration+=(b-&gt;se3.position-clumpPP-&gt;se3.position).Cross(af-&gt;force); //momentum generated by the force WRT particle centroid on the clump centroid
+		clumpRBP-&gt;acceleration+=af-&gt;force/clumpRBP-&gt;mass;
+		clumpRBP-&gt;angularAcceleration+=(b-&gt;se3.position-clumpRBP-&gt;se3.position).Cross(af-&gt;force); //momentum generated by the force WRT particle centroid on the clump centroid
+		//cerr&lt;&lt;&quot;#&quot;&lt;&lt;bb-&gt;getId()&lt;&lt;&quot; (clump #&quot;&lt;&lt;bb-&gt;clumpId&lt;&lt;&quot;): acceleration=&quot;&lt;&lt;clumpRBP-&gt;acceleration&lt;&lt;&quot;, angularAcceleration=&quot;&lt;&lt;clumpRBP-&gt;angularAcceleration&lt;&lt;endl;
 	}
 	#else
 		p-&gt;acceleration = af-&gt;force/p-&gt;mass;

Modified: trunk/yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine/InteractionGeometryMetaEngine.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine/InteractionGeometryMetaEngine.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-packages/yade-package-common/src/Engine/MetaEngine/InteractionGeometryMetaEngine/InteractionGeometryMetaEngine.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -43,11 +43,16 @@
 		shared_ptr&lt;Body&gt;&amp; b2 = (*bodies)[interaction-&gt;getId2()];
 		
 		interaction-&gt;isReal =
-
-		// FIXME put this inside VolatileInteractionCriterion dynlib
+			b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; // some bodies do not have interactingGeometry
+			// FIXME put this inside VolatileInteractionCriterion dynlib
 			( persistentInteractions-&gt;find(interaction-&gt;getId1(),interaction-&gt;getId2()) == 0 )
 		 	&amp;&amp;
 			operator()( b1-&gt;interactingGeometry , b2-&gt;interactingGeometry , b1-&gt;physicalParameters-&gt;se3 , b2-&gt;physicalParameters-&gt;se3 , interaction );
+
+		//tmp
+		if(!(b1-&gt;interactingGeometry&amp;&amp;b2-&gt;interactingGeometry)){
+			cerr&lt;&lt;__FILE__&lt;&lt;&quot;:&quot;&lt;&lt;__LINE__&lt;&lt;&quot;: no interacting geometry &quot;&lt;&lt; (b1-&gt;interactingGeometry?b1-&gt;getId():-1)&lt;&lt;&quot; &quot;&lt;&lt;(b2-&gt;interactingGeometry?b2-&gt;getId():-1)&lt;&lt;endl;
+		}
 			
 	}
 }

Modified: trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp	2007-02-18 17:40:39 UTC (rev 1063)
+++ trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp	2007-02-19 19:24:42 UTC (rev 1064)
@@ -66,6 +66,7 @@
 		b = *bi;
 		
 		offset = 3*i;
+		//FIXME: this is broken: bodies without boundingVolume are just skipped, which means that some garbage values are used later!
 		if(b-&gt;boundingVolume) // can't assume that everybody has BoundingVolume
 		{
 			min = b-&gt;boundingVolume-&gt;min;
@@ -176,7 +177,7 @@
 void PersistentSAPCollider::updateOverlapingBBSet(int id1,int id2)
 {
 
-// 	// look if the paiur (id1,id2) already exists in the overleppingBB collection
+// 	// look if the pair (id1,id2) already exists in the overleppingBB collection
 	bool found = (transientInteractions-&gt;find(id1,id2)!=0);
 	
 	// test if the AABBs of the spheres number &quot;id1&quot; and &quot;id2&quot; are overlapping
@@ -185,19 +186,20 @@
 	#ifdef HIGHLEVEL_CLUMPS
 		Body::id_t clumpId1=Body::byId(id1)-&gt;clumpId, clumpId2=Body::byId(id2)-&gt;clumpId;
 	#endif
-	bool overlapp =
+	bool overlap =
 	#ifdef HIGHLEVEL_CLUMPS
-		(clumpId1==Body::ID_NONE || clumpId2&lt;Body::ID_NONE || clumpId1!=clumpId2) &amp;&amp; // only collide if at least one particle is non-clump or belong to different clumps
+		(clumpId1==Body::ID_NONE || clumpId2==Body::ID_NONE || clumpId1!=clumpId2) &amp;&amp; // only collide if at least one particle is standalone or belongs to different clumps
+		clumpId1!=(Body::id_t)id1 &amp;&amp; clumpId2!=(Body::id_t)id2 &amp;&amp; // do not collide clumps, since they are just containers, they never interact
 	#endif
 		!(maximums[offset1]&lt;minimums[offset2] || maximums[offset2]&lt;minimums[offset1] || 
 		maximums[offset1+1]&lt;minimums[offset2+1] || maximums[offset2+1]&lt;minimums[offset1+1] || 
 		maximums[offset1+2]&lt;minimums[offset2+2] || maximums[offset2+2]&lt;minimums[offset1+2]);
 
-	// inserts the pair p=(id1,id2) if the two AABB overlapps and if p does not exists in the overlappingBB
-	if (overlapp &amp;&amp; !found)
+	// inserts the pair p=(id1,id2) if the two AABB overlaps and if p does not exists in the overlappingBB
+	if (overlap &amp;&amp; !found)
 		transientInteractions-&gt;insert(id1,id2);
 	// removes the pair p=(id1,id2) if the two AABB do not overlapp any more and if p already exists in the overlappingBB
-	else if (!overlapp &amp;&amp; found)
+	else if (!overlap &amp;&amp; found)
 		transientInteractions-&gt;erase(id1,id2);
 
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000028.html">[Yade-commits] r1063 - in trunk: yade-core/src/yade	yade-extra/clump yade-libs/yade-lib-base/src/yade-lib-base	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw
</A></li>
	<LI>Next message: <A HREF="000030.html">[Yade-commits] r1065 - in trunk: yade-core/src/yade yade-doc	yade-extra/clump	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#29">[ date ]</a>
              <a href="thread.html#29">[ thread ]</a>
              <a href="subject.html#29">[ subject ]</a>
              <a href="author.html#29">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
