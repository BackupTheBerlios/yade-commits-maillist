<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1075 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider	yade-scripts
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1075%20-%20in%20trunk%3A%20.%20yade-core/src/yade%0A%09yade-extra/clump%20yade-guis/yade-gui-qt/src/QtGUI%0A%09yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider%0A%09yade-scripts&In-Reply-To=%3C200702271609.l1RG97dh024112%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000039.html">
   <LINK REL="Next"  HREF="000041.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1075 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider	yade-scripts</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1075%20-%20in%20trunk%3A%20.%20yade-core/src/yade%0A%09yade-extra/clump%20yade-guis/yade-gui-qt/src/QtGUI%0A%09yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw%0A%09yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider%0A%09yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider%0A%09yade-scripts&In-Reply-To=%3C200702271609.l1RG97dh024112%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1075 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider	yade-scripts">eudoxos at mail.berlios.de
       </A><BR>
    <I>Tue Feb 27 17:09:07 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000039.html">[Yade-commits] r1074 - in trunk: yade-core/src/yade yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI yade-libs/yade-lib-opengl/src/yade-lib-opengl yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere yade-packages/yade-package-dem/src/PreProcessor/Funnel yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall yade-packages/yade-package-! dem/src/PreProcessor/SDECSpheresPlane yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader yade-packages/yade-package-fem/src/PreProcessor/FEMBeam yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder yade! -packages/yade-package-lattice/src/PreProcessor/LatticeExample! yade-pa
</A></li>
        <LI>Next message: <A HREF="000041.html">[Yade-commits] r1076 - in trunk: . yade-scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40">[ date ]</a>
              <a href="thread.html#40">[ thread ]</a>
              <a href="subject.html#40">[ subject ]</a>
              <a href="author.html#40">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2007-02-27 17:09:05 +0100 (Tue, 27 Feb 2007)
New Revision: 1075

Modified:
   trunk/Makefile
   trunk/SConstruct
   trunk/yade-core/src/yade/Body.cpp
   trunk/yade-core/src/yade/Body.hpp
   trunk/yade-core/src/yade/FileGenerator.cpp
   trunk/yade-core/src/yade/Omega.hpp
   trunk/yade-core/src/yade/yade.cpp
   trunk/yade-extra/clump/Clump.cpp
   trunk/yade-extra/clump/Clump.hpp
   trunk/yade-extra/clump/PythonRecorder.cpp
   trunk/yade-extra/clump/PythonRecorder.hpp
   trunk/yade-extra/clump/Shop.cpp
   trunk/yade-extra/clump/Shop.hpp
   trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp
   trunk/yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine/GravityEngine.cpp
   trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp
   trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw/NewtonsMomentumLaw.cpp
   trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp
   trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider/SAPCollider.cpp
   trunk/yade-scripts/erskine3-apply.sh
Log:
Many extensive changes:

1. HIGHLEVEL_CLUMPS removed, as if it were defined always. Minor things to do with clumps are calculating member velocities at every iteration and figuring out if CundallNonViscousDamping works differently than for standalone bodies.
2. signal handles if linked with python so that ^C works as expected.
3. Fixes in the Shop code.
4. scons builds should support even separate headers for different postfixes.



Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/Makefile	2007-02-27 16:09:05 UTC (rev 1075)
@@ -10,7 +10,7 @@
 	$(MAKE) -C yade-guis clean
 	$(MAKE) -C yade-packages clean
 	$(MAKE) -C yade-extra clean
-	rm -rf config.log scons.config .sconf_temp include .sconsign.dblite
+	rm -rf config.log .sconf_temp include .sconsign.dblite # scons.config should be kept alone
 	find -name &quot;.sconsign&quot; -exec rm -rf {} \;
 	find -name &quot;SConscript&quot; -exec rm -rf {} \;
 
@@ -52,5 +52,5 @@
 	$(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install || $(MAKE) compile_install
 
 eudoxos:
-	$(MAKE) ci -j4 INSTALL_DIR='/YADE' PREFIX_DIR=/tmp CXX=&quot;g++-4.0&quot; LINK=&quot;g++-4.0&quot; CXXFLAGS=&quot;-I/usr/local/include/wm3&quot;
+	$(MAKE) ci -j4 INSTALL_DIR='/YADE' PREFIX_DIR=/tmp CXX=&quot;distcc g++-4.0&quot; LINK=&quot;g++-4.0&quot; CXXFLAGS=&quot;-I/usr/local/include/wm3&quot;
 

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/SConstruct	2007-02-27 16:09:05 UTC (rev 1075)
@@ -147,7 +147,12 @@
 ############# BUILDING ###################################################################
 ##########################################################################################
 
-env.SourceSignatures('MD5')
+if 1:
+	env.SourceSignatures('MD5')
+	env.SetOption('max_drift',5) # cache md5sums of files older than 5 seconds
+	SetOption('implicit_cache',1) # cahe #include files etc.
+	env.SourceCode(&quot;.&quot;,None) # skip dotted directories
+	SetOption('num_jobs',6)
 
 ### DIRECTORIES
 libDirs=['yade-libs','yade-packages/yade-package-common','yade-packages/yade-package-dem','yade-packages/yade-package-fem','yade-packages/yade-package-lattice','yade-packages/yade-package-mass-spring','yade-packages/yade-package-realtime-rigidbody','yade-extra','yade-guis']
@@ -159,7 +164,6 @@
 ### PREPROCESSOR
 env.Append(CPPPATH=['#/include'])
 env.Append(CPPDEFINES=[('POSTFIX',r'$POSTFIX'),('PREFIX',r'$PREFIX')])
-env.Append(CPPDEFINES=['HIGHLEVEL_CLUMPS'])
 
 ### COMPILER
 if env['debug']: env.Append(CXXFLAGS='-ggdb3',CPPDEFINES=['DEBUG'])
@@ -215,10 +219,31 @@
 	#print &quot;prepareIncludes(prefix='%s')&quot;%prefix
 	global env
 	import os,string,re
-	from os.path import join,split,isabs,isdir,exists
+	from os.path import join,split,isabs,isdir,exists,islink,isfile
 	if not prefix: yadeRoot='.' # MUST be relative, otherwise relative symlinks for the local includes will break badly
 	else: yadeRoot=prefix
 	yadeInc=join(yadeRoot,'include','yade')
+	#### POSTFIX_INCLUDES
+	# make the headure install directory symlink to postfixed version
+	# e.g. ./include/yade -&gt; ./include/yade-debug
+	# 	./include/yade will be deleted at this point
+	# 	./include/yade-debug will be created if it doesn't exist
+	# 	symlink yade -&gt; yade-&gt;debug will be created
+	# This makes all headers installed to ./include/yade go actually to ./include/yade-debug
+	#
+	# I hope this doesn't break scons' algorithm for dependency detection
+	if len(env['POSTFIX'])&gt;0:
+		import shutil
+		yadeIncPostfix=yadeInc+env.subst(&quot;$POSTFIX&quot;)
+		
+		if not exists(yadeInc): pass
+		elif islink(yadeInc) or isfile(yadeInc): os.remove(yadeInc) # simply remove the link/file
+		else: shutil.rmtree(yadeInc)
+		assert(not isfile(yadeInc))
+
+		if not exists(yadeIncPostfix): os.makedirs(yadeIncPostfix)
+		os.symlink(env.subst(&quot;yade$POSTFIX&quot;),yadeInc)
+
 	for root, dirs, files in os.walk('.'):
 		for d in ('.svn','yade-flat','include'):
 			try: dirs.remove(d)

Modified: trunk/yade-core/src/yade/Body.cpp
===================================================================
--- trunk/yade-core/src/yade/Body.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-core/src/yade/Body.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -14,31 +14,28 @@
 #include &quot;MetaBody.hpp&quot;
 #include &quot;Omega.hpp&quot;
 
-#ifdef HIGHLEVEL_CLUMPS
-	const id_t Body::ID_NONE=UINT_MAX;
-	/*! The definition will change once Omega disappears, but the interface should be the same.
-	 * \warning This relies on Omega::instance().getRootBody() returning the respective rootBody.
-	 * Therefore, if you use this from a FileGenerator, you will need to call something like \code
-		shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
-		Omega::instance().setRootBody(rootBody);
-		// ...
-		// do your stuff here
-		// ...
-		Omega::instance().setRootBody(oldRootBody);
-		\endcode
-		\warning Make sure that a simulation is not running during generation, otherwise it will most likely crash. It seems that Omega::getRootBodyMutex that could be used for this purpose is just a dummy function.
-	 * */
-	shared_ptr&lt;Body&gt; Body::byId(Body::id_t _id){return (*(Omega::instance().getRootBody()-&gt;bodies))[_id];}
-#endif
+//! This could be -1 if id_t is re-typedef'ed as `int'
+const id_t Body::ID_NONE=UINT_MAX;
+/*! The definition will change once Omega disappears, but the interface should be the same.
+ * \warning This relies on Omega::instance().getRootBody() returning the respective rootBody.
+ * Therefore, if you use this from a FileGenerator, you will need to call something like \code
+	shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
+	Omega::instance().setRootBody(rootBody);
+	// ...
+	// do your stuff here
+	// ...
+	Omega::instance().setRootBody(oldRootBody);
+	\endcode
+	\warning Make sure that a simulation is not running during generation, otherwise it will most likely crash. It seems that Omega::getRootBodyMutex that could be used for this purpose is just a dummy function.
+ * */
+shared_ptr&lt;Body&gt; Body::byId(Body::id_t _id){return (*(Omega::instance().getRootBody()-&gt;bodies))[_id];}
 
 // we must initialize id = 0, otherwise BodyContainer will crash.
 Body::Body () : 
 	  Serializable()
 	, id(0)
 	, groupMask(1)
-	#ifdef HIGHLEVEL_CLUMPS
 	,clumpId(ID_NONE)
-	#endif
 {
 }
 
@@ -46,9 +43,7 @@
 	  Serializable()
 	, id(newId)
 	, groupMask(newGroup)
-	#ifdef HIGHLEVEL_CLUMPS
 	,clumpId(ID_NONE)
-	#endif
 	, physicalParameters(shared_ptr&lt;PhysicalParameters&gt;())
 	, geometricalModel(shared_ptr&lt;GeometricalModel&gt;())
 	, interactingGeometry(shared_ptr&lt;InteractingGeometry&gt;())
@@ -68,8 +63,6 @@
 	REGISTER_ATTRIBUTE(geometricalModel);
 	REGISTER_ATTRIBUTE(interactingGeometry);
 	REGISTER_ATTRIBUTE(boundingVolume);
-	#ifdef HIGHLEVEL_CLUMPS
 	REGISTER_ATTRIBUTE(clumpId);
-	#endif
 }
 

Modified: trunk/yade-core/src/yade/Body.hpp
===================================================================
--- trunk/yade-core/src/yade/Body.hpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-core/src/yade/Body.hpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -38,24 +38,27 @@
 		 * from some selected bodies */
 		int groupMask;
 	public	:
-		#ifdef HIGHLEVEL_CLUMPS
-			/*! \brief Numerical type for ::Body::id.
-			 * \bug  Current code mixes singed and unsigned int, this might be a way to enforce consistence. */
-			typedef unsigned int id_t;
-			//! Clump of which this body makes part. If it is not part of a clump, set to Body::ID_NONE.
-			id_t clumpId;
-			//! symbolic constant for body that doesn't exist.
-			static const id_t ID_NONE;
-			//! get Body pointer given its id. 
-			static shared_ptr&lt;Body&gt; byId(id_t _id);
-			//! Whether this Body is a Clump.
-			//! @note The following is always true: \code (Body::isClump() XOR Body::isClumpMember() XOR Body::isStandalone()) \endcode
-			bool isClump() const {return clumpId!=ID_NONE &amp;&amp; id==clumpId;}
-			//! Whether this Body is member of a Clump.
-			bool isClumpMember() const {return clumpId!=ID_NONE &amp;&amp; id!=clumpId;}
-			//! Whether this body is standalone (neither Clump, nor member of a Clump)
-			bool isStandalone() const {return clumpId==ID_NONE;}
-		#endif
+		/*! \brief Numerical type for ::Body::id.
+		 * \bug  Current code mixes signed and unsigned int, this might be a way to enforce consistence. */
+		typedef unsigned int id_t;
+		//! Clump of which this body makes part. If it is not part of a clump, set to Body::ID_NONE.
+		id_t clumpId;
+		//! symbolic constant for body that doesn't exist.
+		static const id_t ID_NONE;
+		//! get Body pointer given its id. 
+		static shared_ptr&lt;Body&gt; byId(id_t _id);
+		//! Whether this Body is a Clump.
+		//! @note The following is always true: \code (Body::isClump() XOR Body::isClumpMember() XOR Body::isStandalone()) \endcode
+		bool isClump() const {return clumpId!=ID_NONE &amp;&amp; id==clumpId;}
+		//! Whether this Body is member of a Clump.
+		bool isClumpMember() const {return clumpId!=ID_NONE &amp;&amp; id!=clumpId;}
+		//! Whether this body is standalone (neither Clump, nor member of a Clump)
+		bool isStandalone() const {return clumpId==ID_NONE;}
+		/*! Hook for clump to update position of members when user-forced reposition and redraw (through GUI) occurs.
+		 * This is useful only in cases when engines that do that in every iteration are not active - i.e. when the simulation is paused.
+		 * (otherwise, GLViewer would depend on Clump and therefore Clump would have to go to yade-core...) */
+		virtual void userForcedDisplacementRedrawHook(){return;}
+
 		unsigned int getId() const {return id;};
 
 		// FIXME - but we SHOULDN'T use them in InteractionSolver, because it allows

Modified: trunk/yade-core/src/yade/FileGenerator.cpp
===================================================================
--- trunk/yade-core/src/yade/FileGenerator.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-core/src/yade/FileGenerator.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -67,7 +67,7 @@
 	catch(MultiMethodsError&amp; e){return string(&quot;MultiMethodsError: &quot;)+e.what();}
 	catch(std::exception&amp; e){
 		LOG_FATAL(&quot;Unhandled exception: &quot;&lt;&lt;typeid(e).name()&lt;&lt;&quot; : &quot;&lt;&lt;e.what());
-		exit(1);
+		abort(); // use abort, since we may want to inspect core
 	}
 
 	if(shouldTerminate())

Modified: trunk/yade-core/src/yade/Omega.hpp
===================================================================
--- trunk/yade-core/src/yade/Omega.hpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-core/src/yade/Omega.hpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -75,9 +75,7 @@
 		shared_ptr&lt;Preferences&gt; preferences;
 		string 				 yadeConfigPath;	// FIXME - must be private and more clean
 		string 				 yadeVersionName;	// FIXME - public ?
-		#ifdef HIGHLEVEL_CLUMPS
-			list&lt;Body::id_t&gt; selectedBodies;
-		#endif
+		list&lt;Body::id_t&gt; selectedBodies;
 	
 		void logMessage(const string&amp; str);
 		void logError(const string&amp; str);

Modified: trunk/yade-core/src/yade/yade.cpp
===================================================================
--- trunk/yade-core/src/yade/yade.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-core/src/yade/yade.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -10,6 +10,7 @@
 
 #ifdef EMBED_PYTHON
 	#include&lt;Python.h&gt;
+	#include&lt;signal.h&gt;
 #endif
 
 #include &lt;iostream&gt;
@@ -32,6 +33,16 @@
 log4cxx::LoggerPtr logger=log4cxx::Logger::getLogger(&quot;yade&quot;);
 #endif
 
+#ifdef EMBED_PYTHON
+void sigintHandler(int sig){
+	LOG_DEBUG(&quot;Finalizing Python...&quot;);
+	Py_Finalize();
+	// <A HREF="http://www.cons.org/cracauer/sigint.html">http://www.cons.org/cracauer/sigint.html</A>
+	signal(SIGINT,SIG_DFL); // reset to default
+	kill(getpid(),SIGINT); // kill ourselves, this time without Python
+}
+#endif
+
 // FIXME - those two function will be moved to some class responsible for configuration
 std::string getPrefix()
 {
@@ -135,6 +146,7 @@
 	#ifdef EMBED_PYTHON
 		Py_Initialize();
 		LOG_DEBUG(&quot;Python interpreter initialized.&quot;);
+		signal(SIGINT,sigintHandler);
 	#endif
 
 	

Modified: trunk/yade-extra/clump/Clump.cpp
===================================================================
--- trunk/yade-extra/clump/Clump.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/Clump.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -101,10 +101,10 @@
 	LOG_DEBUG(&quot;Removed body #&quot;&lt;&lt;subId&lt;&lt;&quot; from clump #&quot;&lt;&lt;getId());
 }
 
-/*! @brief Calculate positions and orientations of members based on Clump's Se3.
+/*! @brief Calculate positions and orientations of members based on Clump's Se3; resets acceleration and angularAccelration to zero.
  *
  * This method is called by the ClumpMemberMover engine after each timestep.
- * @note Velocities of members are not updated, since members have isdynamic==false. It is possible, though, that someone needs to have a moving clump that is later broken apart and that liberated particle continue to move in the same way as theydid within the clump. In that case, this will have to be completed.
+ * @note Velocities of members are not updated, since members have isdynamic==false. It is possible, though, that someone needs to have a moving clump that is later broken apart and that liberated particle continue to move in the same way as they did within the clump. In that case, this will have to be completed.
  */
 void Clump::moveMembers(){
 	const Se3r&amp; mySe3(physicalParameters-&gt;se3);
@@ -117,9 +117,11 @@
 		subRBP-&gt;se3.orientation=mySe3.orientation*I-&gt;second.orientation;
 		//LOG_TRACE(&quot;New #&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;position: &quot;&lt;&lt;subRBP-&gt;se3.position);
 		//LOG_TRACE(&quot;Clump #&quot;&lt;&lt;getId()&lt;&lt;&quot; moved #&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;.&quot;);
+
+		//! FIXME: need to set velocity as well, because of damping?!
 	}
 	/* @bug Temporarily we reset acceleration and angularAcceleration of the clump here;
-	 * should be a new negine that will take care of that.
+	 * should be a new negine that will take care of that?
 	 */
 	shared_ptr&lt;RigidBodyParameters&gt; clumpRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(physicalParameters);
 	#if 0
@@ -139,6 +141,12 @@
 
 /*! Clump's se3 will be updated (origin at centroid and axes coincident with principal inertia axes) and subSe3 modified in such a way that members positions in world coordinates will not change.
 
+	The clump values that are changed are:
+	-# Clump::members (holds position and orientation in clump's coordinate system)
+	-# Clump::physicalParameters-&gt;mass (sum of masses of all members)
+	-# Clump::physicalParameters-&gt;inertia (inertia of the aggregate - in clump coordinate system)
+	-# Clump::physicalParameters-&gt;se3 (position and orientation of the clump; it is such that absolute positions and orientation of members will not chage)
+
 	The algorithm is as follows:
 	-# Clump::members values and Clump::physicalParameters::se3 are invalid from this point
 	-# M=0; S=vector3r(0,0,0); I=zero tensor; (ALL calculations are in world coordinates!)
@@ -166,20 +174,35 @@
 void Clump::updateProperties(bool intersecting){
 	LOG_DEBUG(&quot;Updating clump #&quot;&lt;&lt;getId()&lt;&lt;&quot; parameters&quot;);
 	assert(members.size()&gt;0);
-	// maybe handle the case of only one clump subBody specially here?!
-	if(intersecting){
-		LOG_WARN(&quot;Self-intersecting clumps not yet implemented, intersections will be ignored.&quot;);
-		intersecting=false;}
 
 	/* quantities suffixed by
 		g: global (world) coordinates
 		s: local subBody's coordinates
 		c: local clump coordinates */
-	double M=0;
+	double M=0; // mass
 	Vector3r Sg(0,0,0); // static moment
-	Matrix3r Ig(true /* fill with zeros */ ), Ic(true); // tensor of inertia; is upper triangular, zeros instead of symmetric elements
+	Matrix3r Ig(true /* fill with zeros */ ), Ic(true); // tensors of inertia; is upper triangular, zeros instead of symmetric elements
 	Se3r&amp; mySe3(physicalParameters-&gt;se3);
+	const shared_ptr&lt;RigidBodyParameters&gt;&amp; clumpRBP(dynamic_pointer_cast&lt;RigidBodyParameters&gt;(physicalParameters));
 
+	if(members.size()==1){
+		LOG_DEBUG(&quot;Clump of size one will be treated specially.&quot;)
+		memberMap::iterator I=members.begin();
+		shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
+		shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
+		mySe3.position=subRBP-&gt;se3.position;
+		mySe3.orientation=subRBP-&gt;se3.orientation;
+		clumpRBP-&gt;inertia=subRBP-&gt;inertia;
+		clumpRBP-&gt;mass=subRBP-&gt;mass;
+		clumpRBP-&gt;velocity=Vector3r(0,0,0);
+		clumpRBP-&gt;angularVelocity=Vector3r(0,0,0);
+		return;
+	}
+
+	if(intersecting){
+		LOG_WARN(&quot;Self-intersecting clumps not yet implemented, intersections will be ignored.&quot;);
+		intersecting=false;}
+
 	// begin non-intersecting loop here
 	if(!intersecting){
 		for(memberMap::iterator I=members.begin(); I!=members.end(); I++){
@@ -197,27 +220,11 @@
 
 			//TRWM3MAT(Clump::inertiaTensorRotate(Matrix3r(subRBP-&gt;inertia),subRBP_orientation_conjugate));
 		}
-	}else{LOG_ERROR(&quot;Self-intersecting clumps not implemented. Results will be very wrong.&quot;);}
+	}
 	TRVAR1(M);
 	TRWM3MAT(Ig);
 	TRWM3VEC(Sg);
 
-	/*! @bug incorrect results; these are vars traced for one and only sphere:
-	 *
-\verbatim
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:153 updateProperties: Updating clump #1 parameters
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:182 updateProperties: subRBP-&gt;inertia=(104.72 104.72 104.72)
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:183 updateProperties: Clump::inertiaTensorRotate(Matrix3r(subRBP-&gt;inertia),subRBP_orientation_conjugate)=((0 0 0)(0 0 0)(0 0 0))
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:186 updateProperties: M=1047.2; 
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:187 updateProperties: Ig=((0 0 0)(0 0 0)(0 0 0))
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:188 updateProperties: Sg=(0 0 0)
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:200 updateProperties: Ic=((0 0 0)(0 0 0)(0 0 0))
-DEBUG yade.Clump yade-extra/clump/Clump.cpp:201 updateProperties: Clump::inertiaTensorRotate(Ic_orientG,R_g2c)=((0 nan nan)(nan nan nan)(nan nan nan))
-\endverbatim
-
-*/
-
-
 	mySe3.position=Sg/M; // clump's centroid
 	// this will calculate translation only, since rotation is zero
 	Matrix3r Ic_orientG=Clump::inertiaTensorTranslate(Ig, -M /* negative mass means towards centroid */, mySe3.position); // inertia at clump's centroid but with world orientation
@@ -238,7 +245,6 @@
 	// set quaternion from rotation matrix
 	mySe3.orientation.FromRotationMatrix(R_g2c);
 	// now Ic is diagonal
-	shared_ptr&lt;RigidBodyParameters&gt; clumpRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(physicalParameters);
 	clumpRBP-&gt;inertia=Vector3r(Ic(0,0),Ic(1,1),Ic(2,2));
 	clumpRBP-&gt;mass=M;
 
@@ -246,7 +252,7 @@
 	// this block will be removed once EigenDecomposition works for diagonal matrices
 	#if 1
 		if(isnan(R_g2c(0,0))||isnan(R_g2c(0,1))||isnan(R_g2c(0,2))||isnan(R_g2c(1,0))||isnan(R_g2c(1,1))||isnan(R_g2c(1,2))||isnan(R_g2c(2,0))||isnan(R_g2c(2,1))||isnan(R_g2c(2,2))){
-			LOG_WARN(&quot;WigenDecomposition gave some NaNs, we will use imaginary values for clump inertia and orientation instead!&quot;);
+			LOG_FATAL(&quot;EigenDecomposition gave some NaNs, we will use imaginary values for clump inertia and orientation instead. I thought this may happen only for 1-member clumps which are now treated specially. Something is broken!&quot;);
 			//FIXME: since EigenDecomposition is broken, use inertia of the first body instead;
 			//!!!!! note that this is HIGHLY incorrect for all non-single clumps !!!!!
 			memberMap::iterator I=members.begin();
@@ -259,7 +265,7 @@
 	#endif
 	TRWM3VEC(clumpRBP-&gt;inertia);
 
-	// these might be calculated from members... but complicated
+	// TODO: these might be calculated from members... but complicated... - someone needs that?!
 	clumpRBP-&gt;velocity=Vector3r(0,0,0);
 	clumpRBP-&gt;angularVelocity=Vector3r(0,0,0);
 
@@ -273,19 +279,6 @@
 		I-&gt;second.position=mySe3.orientation.Conjugate()*(subRBP-&gt;se3.position-mySe3.position);
 	}
 
-	// clump as such has no bounding box, since it is probably never needed. The following may be safely removed unless someone needs it.
-	#if 0
-		// update bounding box; we could have done this in previous loops, but this is cleaner
-		Vector3r min(0,0,0),max(0,0,0);
-		for(memberMap::iterator I=members.begin(); I!=members.end(); I++){
-			shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
-			shared_ptr&lt;AABB&gt; subAabb=dynamic_pointer_cast&lt;AABB&gt;(subBody-&gt;boundingVolume);
-			if (I!=members.begin()){min=componentMinVector(min,subAabb-&gt;center-subAabb-&gt;halfSize);	max=componentMinVector(max,subAabb-&gt;center+subAabb-&gt;halfSize);}
-			else {min=subAabb-&gt;center-subAabb-&gt;halfSize; max=subAabb-&gt;center+subAabb-&gt;halfSize;}
-		}
-		shared_ptr&lt;AABB&gt; aabb=dynamic_pointer_cast&lt;AABB&gt;(boundingVolume);
-		aabb-&gt;center=(min+max)*.5; aabb-&gt;halfSize=(max-min)*.5;
-	#endif
 }
 
 /*! @brief Recalculates inertia tensor of a body after translation away from (default) or towards its centroid.
@@ -341,53 +334,11 @@
 
 #include &lt;yade/yade-core/MetaBody.hpp&gt;
 
-/*#include &lt;yade/yade-package-common/MetaInteractingGeometry2AABB.hpp&gt;
-#include &lt;yade/yade-package-common/MetaInteractingGeometry.hpp&gt;
-#include &lt;yade/yade-package-common/Box.hpp&gt;
-#include &lt;yade/yade-package-common/AABB.hpp&gt;
-#include &lt;yade/yade-package-common/Sphere.hpp&gt;
-#include &lt;yade/yade-package-common/PersistentSAPCollider.hpp&gt;
-
-#include &lt;yade/yade-package-common/BodyRedirectionVector.hpp&gt;
-#include &lt;yade/yade-package-common/InteractionVecSet.hpp&gt;
-#include &lt;yade/yade-package-common/PhysicalActionVectorVector.hpp&gt;
-
-#include &lt;yade/yade-package-common/InteractingBox.hpp&gt;
-#include &lt;yade/yade-package-common/InteractingSphere.hpp&gt;
-
-
-#include &lt;yade/yade-package-common/PhysicalActionContainerReseter.hpp&gt;
-#include &lt;yade/yade-package-common/PhysicalActionContainerInitializer.hpp&gt;
-#include &lt;yade/yade-package-common/PhysicalParametersMetaEngine.hpp&gt;
-
-#include &lt;yade/yade-package-common/InteractionGeometryMetaEngine.hpp&gt;
-#include &lt;yade/yade-package-common/InteractionPhysicsMetaEngine.hpp&gt;
-#include &lt;yade/yade-package-common/BoundingVolumeMetaEngine.hpp&gt;
-#include &lt;yade/yade-package-common/PhysicalActionDamper.hpp&gt;
-#include &lt;yade/yade-package-common/PhysicalActionApplier.hpp&gt;
-#include &lt;yade/yade-package-common/CundallNonViscousForceDamping.hpp&gt;
-#include &lt;yade/yade-package-common/CundallNonViscousMomentumDamping.hpp&gt;
-#include &lt;yade/yade-package-common/GravityEngine.hpp&gt;
-
-
-
-#include &lt;yade/yade-package-dem/BodyMacroParameters.hpp&gt;
-#include &lt;yade/yade-package-dem/ElasticCriterionTimeStepper.hpp&gt;
-#include &lt;yade/yade-package-dem/ElasticContactLaw.hpp&gt;
-
-#include&lt;yade/yade-extra/PythonRecorder.hpp&gt; */
-//#include &quot;ElasticCohesiveLaw.hpp&quot;
-//#include &quot;MacroMicroElasticRelationships.hpp&quot;
-//#include &quot;BodyMacroParameters.hpp&quot;
-
-
-// generate either random spheres, or (if not defined) regular one sphere and {1,2,3,4}-clumps
-//#define CLUMP_COMPLICATED
-
 string ClumpTestGen::generate()
 {
+	Shop::setDefault(&quot;param_pythonExpr&quot;,string(&quot;if (S.i%50==0): print len(S.sel),B[1].x, B[1].E&quot;));
+
 	rootBody=Shop::rootBody();
-	Shop::setDefault(&quot;param_pythonExpr&quot;,&quot;if (S.i%50==0) and len(S.sel)&gt;=2:\n\tprint B[S.sel[0]].E\n\tprint '=========END OF OUTPUT==============='&quot;);
 	Shop::rootBodyActors(rootBody);
 
 	shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
@@ -395,6 +346,9 @@
 
 	shared_ptr&lt;Body&gt; ground=Shop::box(Vector3r(0,0,-1),Vector3r(3,3,.2));
 	ground-&gt;isDynamic=false;
+	// revert random colors for this single case...
+	ground-&gt;geometricalModel-&gt;diffuseColor=Vector3r(.6,.6,.6);
+	ground-&gt;interactingGeometry-&gt;diffuseColor=Vector3r(.3,.3,.3);
 	rootBody-&gt;bodies-&gt;insert(ground);
 
 	vector&lt;Vector3r&gt; relPos; vector&lt;Real&gt; radii; Vector3r clumpPos;
@@ -431,7 +385,7 @@
 
 	// restore Omega
 	Omega::instance().setRootBody(oldRootBody);
-
+	
 	return &quot;OK&quot;;
 }
 
@@ -469,282 +423,3 @@
 	clump-&gt;updateProperties(false);
 }
 
-
-
-
-
-
-
-#if 0
-
-
-string ClumpTestGen::generate()
-{
-	rootBody=Shop::rootBody();
-	{ // root body
-		rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody); rootBody-&gt;isDynamic=false;
-		shared_ptr&lt;ParticleParameters&gt; physics(new ParticleParameters); Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0); physics-&gt;se3=Se3r(Vector3r(0,0,0),q); physics-&gt;mass=0; physics-&gt;velocity=Vector3r::ZERO; physics-&gt;acceleration=Vector3r::ZERO;
-		rootBody-&gt;physicalParameters=physics;
-		shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());	set-&gt;diffuseColor=Vector3r(0,0,1);
-		rootBody-&gt;interactingGeometry=dynamic_pointer_cast&lt;InteractingGeometry&gt;(set);	
-		shared_ptr&lt;AABB&gt; aabb(new AABB); aabb-&gt;diffuseColor=Vector3r(0,0,1);
-		rootBody-&gt;boundingVolume=dynamic_pointer_cast&lt;BoundingVolume&gt;(aabb);
-		createActors(rootBody);
-		// Containers
-		rootBody-&gt;persistentInteractions=shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-		rootBody-&gt;transientInteractions=shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
-		rootBody-&gt;physicalActions=shared_ptr&lt;PhysicalActionContainer&gt;(new PhysicalActionVectorVector);
-		rootBody-&gt;bodies=shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
-	}
-
-	// FIXME: this is to make Body::byId work; otherwise crash will occur. Save rootBody, restore after generation is completed
-	// FIXME: will not be restored if generation crashes.
-	// FIXME: is it ever needed to restore rootBody?
-	shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
-	Omega::instance().setRootBody(rootBody);
-	
-	{ // ground
-		Vector3r extents(3,3,.2);
-		shared_ptr&lt;Body&gt; ground=shared_ptr&lt;Body&gt;(new Body(0,55)); ground-&gt;isDynamic=false;
-		shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters); Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0); physics-&gt;angularVelocity=Vector3r(0,0,0); physics-&gt;velocity=Vector3r(0,0,0); physics-&gt;mass=1; physics-&gt;inertia=Vector3r(1,1,1); physics-&gt;se3=Se3r(Vector3r(0,0,-1),q); physics-&gt;young=1e7; physics-&gt;poisson=.3; physics-&gt;frictionAngle=30*Mathr::PI/180.0;
-		ground-&gt;physicalParameters=physics;
-		shared_ptr&lt;AABB&gt; aabb(new AABB);aabb-&gt;diffuseColor=Vector3r(1,0,0);
-		ground-&gt;boundingVolume=aabb;
-		shared_ptr&lt;Box&gt; gBox(new Box);gBox-&gt;extents=extents; gBox-&gt;diffuseColor=Vector3r(1,1,1); gBox-&gt;wire=false; gBox-&gt;visible=true; gBox-&gt;shadowCaster=true;
-		ground-&gt;geometricalModel=gBox;
-		shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox); iBox-&gt;extents=extents; iBox-&gt;diffuseColor=Vector3r(1,1,1);
-		ground-&gt;interactingGeometry=iBox;
-		rootBody-&gt;bodies-&gt;insert(ground);
-	}
-
-	setMessage(&quot;Elements...&quot;);
-
-	vector&lt;Vector3r&gt; relPos; vector&lt;Real&gt; radii; Vector3r clumpPos;
-	#ifdef CLUMP_COMPLICATED
-		for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++){
-			relPos.clear(); radii.clear();
-			clumpPos=Vector3r(i,j,k)+Vector3r(.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom(),.2*Mathr::SymmetricRandom());
-			int nSpheres=(int)(Mathr::UnitRandom()*4+1);
-			for(int l=0; l&lt;nSpheres; l++) {
-				relPos.push_back(.3*Vector3r(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom()));
-				radii.push_back(Mathr::IntervalRandom(.1,.3));
-			}
-			createOneClump(rootBody,clumpPos,relPos,radii);
-		}
-	#else
-		#if 1
-		// standalone (non-clump!) sphere as well
-		shared_ptr&lt;Body&gt; sphere=createOneSphere(Vector3r(0,0,0),.5);
-		rootBody-&gt;bodies-&gt;insert(sphere);
-
-		// one-sphere clump
-		clumpPos=Vector3r(-2,0,0);
-		relPos.push_back(Vector3r(0,0,0)); radii.push_back(.5);
-		createOneClump(rootBody,clumpPos,relPos,radii);
-		relPos.clear(); radii.clear();
-		#endif
-		
-		// two-sphere clump
-		clumpPos=Vector3r(2,0,0);
-		relPos.push_back(Vector3r(0,-.5,.5)); radii.push_back(.5);
-		relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
-		createOneClump(rootBody,clumpPos,relPos,radii);
-		relPos.clear(); radii.clear();
-
-		#if 1
-		// three-sphere slump
-		clumpPos=Vector3r(0,2,0);
-		relPos.push_back(Vector3r(0,-.5,.5)); radii.push_back(.5);
-		relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
-		relPos.push_back(Vector3r(.5,0,0)); radii.push_back(.5);
-		createOneClump(rootBody,clumpPos,relPos,radii);
-		relPos.clear(); radii.clear();
-
-		// four-sphere slump
-		clumpPos=Vector3r(0,-2,0);
-		relPos.push_back(Vector3r(0,0,0)); radii.push_back(.5);
-		relPos.push_back(Vector3r(.5,0,0)); radii.push_back(.5);
-		relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
-		relPos.push_back(Vector3r(0,0,.5)); radii.push_back(.5);
-		createOneClump(rootBody,clumpPos,relPos,radii);
-		relPos.clear(); radii.clear();
-		#endif
-	#endif
-
-	// restore Omega
-	Omega::instance().setRootBody(oldRootBody);
-	
-
-	return &quot;Garbage generated, since your IQ is &lt;200...&quot;;
-}
-
-
-/*! \brief Generate clump of spheres, the result will be inserted into rootBody.
- *
- * To create a clump, first the clump itself needs to be instantiated \em and inserted into rootBody (this will assign an Body::id).
- * In order for this to work, Omega::roootBody must have been assigned; within generators, use Omega::setRootBody for this.
- *
- * The body to add to clump must have been also created and added to the rootBody (so that it has id, again).
- *
- * Finally, call Clump::updateProperties to get physical properties physically right (inertia, position, orientation, mass, ...).
- *
- * @param clumpPos Center of the clump (not necessarily centroid); serves merely as reference for sphere positions.
- * @param relPos Relative positions of individual spheres' centers.
- * @param radii Radii of composing spheres. Must have the same length as relPos.
- */
-void ClumpTestGen::createOneClump(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r clumpPos, vector&lt;Vector3r&gt; relPos, vector&lt;Real&gt; radii)
-{
-	assert(relPos.size()==radii.size());
-	
-	// empty clump	
-	shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
-	shared_ptr&lt;Body&gt; clumpAsBody=dynamic_pointer_cast&lt;Body&gt;(clump);
-	rootBody-&gt;bodies-&gt;insert(clumpAsBody);
-
-	clump-&gt;isDynamic=true;
-	// if subscribedBodies work some day: clumpMover-&gt;subscribedBodies.push_back(clump-&gt;getId());
-	
-	for(size_t i=0; i&lt;relPos.size(); i++){
-		shared_ptr&lt;Body&gt; sphere=createOneSphere(clumpPos+relPos[i],radii[i]);
-		Body::id_t lastId=(Body::id_t)rootBody-&gt;bodies-&gt;insert(sphere);
-		clump-&gt;add(lastId);
-		LOG_TRACE(&quot;Generated clumped sphere #&quot;&lt;&lt;lastId);
-	}
-	clump-&gt;updateProperties(false);
-}
-
-/* Create single Sphere with some sane default parameters.
- *
- * @return Sphere (as Body) that can be readily used.
- */
-shared_ptr&lt;Body&gt; ClumpTestGen::createOneSphere(Vector3r position, Real radius){
-	Real density=2000;
-
-	// body itself
-	shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,55));
-	body-&gt;isDynamic=true;
-
-	// physics
-	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
-	Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0);
-	physics-&gt;angularVelocity=Vector3r(0,0,0);
-	physics-&gt;velocity=Vector3r(0,0,0);
-	physics-&gt;mass=4.0/3.0*Mathr::PI*radius*radius*radius*density;
-	physics-&gt;inertia=Vector3r(2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius);
-	physics-&gt;se3=Se3r(position,q);
-	physics-&gt;young=8e7;
-	physics-&gt;poisson=.3;
-	physics-&gt;frictionAngle=40*Mathr::PI/180.0;
-	body-&gt;physicalParameters=physics;
-
-	// aabb
-	shared_ptr&lt;AABB&gt; aabb(new AABB);
-	aabb-&gt;diffuseColor=Vector3r(0,1,0);
-	body-&gt;boundingVolume=aabb;
-
-	// mold
-	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
-	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
-	iSphere-&gt;radius=radius;
-	iSphere-&gt;diffuseColor=Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
-	body-&gt;interactingGeometry=iSphere;
-
-	//shape
-	gSphere-&gt;radius=radius;
-	gSphere-&gt;diffuseColor=Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
-	gSphere-&gt;wire=false;
-	gSphere-&gt;visible=true;
-	gSphere-&gt;shadowCaster=true;
-	body-&gt;geometricalModel=gSphere;
-
-	return body;
-}
-/*! Instantiate engines acting on bodies during simulation.
- *
- * For simplicity, physical constants are not parametrized but hardcoded.
- * Damping is not used so that energy conservation may be asserted.
- */
-void ClumpTestGen::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
-{
-	shared_ptr&lt;PhysicalActionContainerInitializer&gt; physicalActionInitializer(new PhysicalActionContainerInitializer);
-	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Force&quot;);
-	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Momentum&quot;);
-	
-	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
-	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;InteractingSphere&quot;,&quot;InteractingSphere2InteractingSphere4SpheresContactGeometry&quot;);
-	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;InteractingBox&quot;,&quot;InteractingBox2InteractingSphere4SpheresContactGeometry&quot;);
-
-	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; interactionPhysicsDispatcher(new InteractionPhysicsMetaEngine);
-	interactionPhysicsDispatcher-&gt;add(&quot;BodyMacroParameters&quot;,&quot;BodyMacroParameters&quot;,&quot;MacroMicroElasticRelationships&quot;);
-		
-	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
-	boundingVolumeDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;AABB&quot;,&quot;InteractingSphere2AABB&quot;);
-	boundingVolumeDispatcher-&gt;add(&quot;InteractingBox&quot;,&quot;AABB&quot;,&quot;InteractingBox2AABB&quot;);
-	boundingVolumeDispatcher-&gt;add(&quot;MetaInteractingGeometry&quot;,&quot;AABB&quot;,&quot;MetaInteractingGeometry2AABB&quot;);
-		
-	shared_ptr&lt;GravityEngine&gt; gravityCondition(new GravityEngine);
-	gravityCondition-&gt;gravity=Vector3r(0,0,-10);
-	
-	shared_ptr&lt;CundallNonViscousForceDamping&gt; actionForceDamping(new CundallNonViscousForceDamping);
-	actionForceDamping-&gt;damping = .2;
-	shared_ptr&lt;CundallNonViscousMomentumDamping&gt; actionMomentumDamping(new CundallNonViscousMomentumDamping);
-	actionMomentumDamping-&gt;damping = .2;
-	shared_ptr&lt;PhysicalActionDamper&gt; actionDampingDispatcher(new PhysicalActionDamper);
-	actionDampingDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;CundallNonViscousForceDamping&quot;,actionForceDamping);
-	actionDampingDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;CundallNonViscousMomentumDamping&quot;,actionMomentumDamping);
-	
-	shared_ptr&lt;PhysicalActionApplier&gt; applyActionDispatcher(new PhysicalActionApplier);
-	applyActionDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;NewtonsForceLaw&quot;);
-	applyActionDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;NewtonsMomentumLaw&quot;);
-	
-	shared_ptr&lt;PhysicalParametersMetaEngine&gt; positionIntegrator(new PhysicalParametersMetaEngine);
-	positionIntegrator-&gt;add(&quot;ParticleParameters&quot;,&quot;LeapFrogPositionIntegrator&quot;);
-	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
-	orientationIntegrator-&gt;add(&quot;RigidBodyParameters&quot;,&quot;LeapFrogOrientationIntegrator&quot;);
- 	
-	shared_ptr&lt;ElasticCriterionTimeStepper&gt; sdecTimeStepper(new ElasticCriterionTimeStepper);
-	sdecTimeStepper-&gt;sdecGroupMask = 55;
-	sdecTimeStepper-&gt;timeStepUpdateInterval = 300;
-	
-	shared_ptr&lt;ElasticContactLaw&gt; constitutiveLaw(new ElasticContactLaw);
-	constitutiveLaw-&gt;sdecGroupMask = 55;
-	constitutiveLaw-&gt;momentRotationLaw = true;
-/*// FIXME FIXME FIXME ....	
-	shared_ptr&lt;ElasticCohesiveLaw&gt; constitutiveLaw2(new ElasticCohesiveLaw);
-	constitutiveLaw2-&gt;sdecGroupMask = 55;
-	constitutiveLaw2-&gt;momentRotationLaw = momentRotationLaw;*/
-
-	// clumps will be subscribed later, as they are generated
-	clumpMover=shared_ptr&lt;ClumpMemberMover&gt;(new ClumpMemberMover);
-
-	
-	rootBody-&gt;engines.clear();
-	rootBody-&gt;engines.push_back(sdecTimeStepper);
-	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PhysicalActionContainerReseter));
-	rootBody-&gt;engines.push_back(boundingVolumeDispatcher);
-	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PersistentSAPCollider));
-	rootBody-&gt;engines.push_back(interactionGeometryDispatcher);
-	rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
-	rootBody-&gt;engines.push_back(constitutiveLaw);
-	//rootBody-&gt;engines.push_back(constitutiveLaw2);
-	rootBody-&gt;engines.push_back(gravityCondition);
-	//rootBody-&gt;engines.push_back(actionDampingDispatcher);
-	rootBody-&gt;engines.push_back(applyActionDispatcher);
-	rootBody-&gt;engines.push_back(positionIntegrator);
-	rootBody-&gt;engines.push_back(orientationIntegrator);
-	rootBody-&gt;engines.push_back(clumpMover);
-	#ifdef EMBED_PYTHON
-		shared_ptr&lt;PythonRecorder&gt; pythonRecorder=shared_ptr&lt;PythonRecorder&gt;(new PythonRecorder);
-		//pythonRecorder-&gt;expression=&quot;print 'x2=',B[2].x,'v4=',B[4].I&quot;;
-		//pythonRecorder-&gt;expression=&quot;print 'x=',B[2].x,'v=',B[2].v,'m=',B[2].m,'energy=',B[2].Etrans+B[2].Erot+B[2].Epot,'(trans=',B[2].Etrans,'rot=',B[2].Erot,'pot=',B[2].Epot,')'&quot;;
-		//pythonRecorder-&gt;expression=&quot;if (S.i%50==0): print 'file=',S.file,'iteration =',S.i,'t= ',S.t,'x2 =',B[2].x&quot;;
-		pythonRecorder-&gt;expression=&quot;if (S.i%50==0) and len(S.sel)&gt;=2:\n\tprint B[S.sel[0]].E\n\tprint '=========END OF OUTPUT==============='&quot;;
-		rootBody-&gt;engines.push_back(pythonRecorder);
-	#endif
-
-	rootBody-&gt;initializers.clear();
-	rootBody-&gt;initializers.push_back(physicalActionInitializer);
-	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
-}
-
-#endif

Modified: trunk/yade-extra/clump/Clump.hpp
===================================================================
--- trunk/yade-extra/clump/Clump.hpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/Clump.hpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -24,10 +24,6 @@
 #include&lt;yade/yade-lib-base/yadeWm3Extra.hpp&gt;
 
 
-#ifndef HIGHLEVEL_CLUMPS
-	#error HIGHLEVEL_CLUMPS must be defined if clumps are to work!
-#endif
-
 /*! Body representing clump (rigid aggregate) composed by other existing bodies.
 
 	Clump is one of bodies that reside in rootBody-&gt;bodies.
@@ -85,6 +81,8 @@
 		void updateProperties(bool intersecting);
 		//! Calculate positions and orientations of members based on my own Se3.
 		void moveMembers();
+		//! update member positions after clump being moved by mouse (in case simulation is paused and engines will not do that).
+		void userForcedDisplacementRedrawHook(){moveMembers();}
 	private: // may be made public, but once properly tested...
 		//! Recalculates inertia tensor of a body after translation away from (default) or towards its centroid.
 		static Matrix3r inertiaTensorTranslate(const Matrix3r&amp; I,const Real m, const Vector3r&amp; off);

Modified: trunk/yade-extra/clump/PythonRecorder.cpp
===================================================================
--- trunk/yade-extra/clump/PythonRecorder.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/PythonRecorder.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -36,9 +36,13 @@
 }
 
 void PythonRecorder::postProcessAttributes(bool deserializing){
-	if(outputFile.length()==0) return;
-	PyRun_SimpleString(string(&quot;import os; import sys; ofile=file('&quot;+outputFile+&quot;','w+'); sys.stdout=ofile&quot;).c_str());
-	LOG_DEBUG(&quot;Python stdout redirected to &quot;&lt;&lt;outputFile);
+	if(outputFile.length()&gt;0){
+		LOG_DEBUG(&quot;Redirecting python stdout to `&quot;&lt;&lt;outputFile&lt;&lt;&quot;'.&quot;);
+		PyRun_SimpleString(string(&quot;import os; import sys; ofile=file('&quot;+outputFile+&quot;','w+'); sys.stdout=ofile&quot;).c_str());
+	}
+	if(initExpression.length()&gt;0){
+		PyRun_SimpleString(initExpression.c_str());
+	}
 }
 
 void PythonRecorder::action(Body *_rootBody)

Modified: trunk/yade-extra/clump/PythonRecorder.hpp
===================================================================
--- trunk/yade-extra/clump/PythonRecorder.hpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/PythonRecorder.hpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -24,7 +24,7 @@
 		PythonRecorder();
 		virtual void action(Body* b);
 		virtual bool isActivated(){return true;}
-		virtual void registerAttributes(){DataRecorder::registerAttributes(); REGISTER_ATTRIBUTE(expression); REGISTER_ATTRIBUTE(outputFile);}
+		virtual void registerAttributes(){DataRecorder::registerAttributes(); REGISTER_ATTRIBUTE(expression); REGISTER_ATTRIBUTE(initExpression); REGISTER_ATTRIBUTE(outputFile);}
 		//! This expression will be interpreted when the engine is called.
 		std::string expression;
 		//! Piece of python code run on intialization

Modified: trunk/yade-extra/clump/Shop.cpp
===================================================================
--- trunk/yade-extra/clump/Shop.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/Shop.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -45,17 +45,32 @@
 #define _SPEC_CAST(orig,cast) template&lt;&gt; void Shop::setDefault&lt;orig&gt;(string key, orig val){setDefault(key,cast(val));}
 _SPEC_CAST(const char*,string);
 _SPEC_CAST(char*,string);
-_SPEC_CAST(int,long);
-_SPEC_CAST(unsigned int,long);
-_SPEC_CAST(unsigned long,long);
 #undef _SPEC_CAST
 
 map&lt;string,boost::any&gt; Shop::defaults;
 
+CREATE_LOGGER(Shop);
+
+template &lt;typename valType&gt; valType Shop::getDefault(const string&amp; key) {
+	ensureInit();
+	try{return boost::any_cast&lt;valType&gt;(defaults[key]);}
+	catch(boost::bad_any_cast&amp; e){
+		LOG_FATAL(&quot;Cast error while getting key `&quot;&lt;&lt;key&lt;&lt;&quot;' of type `&quot;&lt;&lt;typeid(valType).name()&lt;&lt;&quot;' (&quot;&lt;&lt;e.what()&lt;&lt;&quot;).&quot;);
+		if(!hasDefault(key) || (defaults[key].type()==typeid(void))){LOG_FATAL(&quot;Key `&quot;&lt;&lt;key&lt;&lt;&quot;' not defined in the map.&quot;);}
+		else{LOG_INFO(&quot;(key `&quot;&lt;&lt;key&lt;&lt;&quot;' exists and if of type `&quot;&lt;&lt;defaults[key].type().name()&lt;&lt;&quot;').&quot;);}
+		throw;
+	}
+}
+
 void Shop::init(){
+	//LOG_INFO(&quot;Container length is &quot;&lt;&lt;defaults.size()&lt;&lt;endl);
+	/*for(map&lt;string,boost::any&gt;::iterator I=defaults.begin(); I!=defaults.end(); I++){
+		LOG_INFO(&quot;Key `&quot;&lt;&lt;I-&gt;first&lt;&lt;&quot;, type `&quot;&lt;&lt;I-&gt;second.type().name()&lt;&lt;&quot;'.&quot;);
+	}*/
+
 	defaults[&quot;container_is_not_empty&quot;]=boost::any(0); // prevent loops from ensureInit();
 
-	setDefault(&quot;body_sdecGroupMask&quot;,55);
+	setDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;,55);
 	
 	setDefault(&quot;phys_density&quot;,2e3);
 	setDefault(&quot;phys_young&quot;,4e7);
@@ -78,10 +93,11 @@
 
 	setDefault(&quot;param_damping&quot;,.2);
 	setDefault(&quot;param_gravity&quot;,Vector3r(0,0,-10));
-	setDefault(&quot;param_timeStepUpdateInterval&quot;,300);
+	setDefault&lt;int&gt;(&quot;param_timeStepUpdateInterval&quot;,300);
 	setDefault(&quot;param_momentRotationLaw&quot;,true);
 
-	setDefault(&quot;param_python&quot;,false);
+	setDefault(&quot;param_pythonInitExpr&quot;,string(&quot;print 'Hello world!'&quot;));
+	setDefault(&quot;param_pythonExpr&quot;,string(&quot;&quot;));
 
 }
 
@@ -132,10 +148,16 @@
 	//engines
 	rootBody-&gt;engines.clear();
 
-	if(getDefault&lt;long&gt;(&quot;param_timeStepUpdateInterval&quot;)&gt;0){
+	/* big fat FIXME:
+	 * for some */
+	#define GO(type) try{cerr&lt;&lt;&quot;Cast to&quot; #type&lt;&lt;&quot; gives: &quot;&lt;&lt;getDefault&lt;type&gt;(&quot;body_sdecGroupMask&quot;)&lt;&lt;endl;} catch(boost::bad_any_cast){}
+	/*	GO(unsigned short); GO(short); GO(char);GO(int);GO(unsigned int);GO(long);GO(unsigned long);GO(long long);GO(unsigned long long); */
+	
+	if(getDefault&lt;int&gt;(&quot;param_timeStepUpdateInterval&quot;)&gt;0){
 		shared_ptr&lt;ElasticCriterionTimeStepper&gt; sdecTimeStepper(new ElasticCriterionTimeStepper);
-		sdecTimeStepper-&gt;sdecGroupMask=getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
-		sdecTimeStepper-&gt;timeStepUpdateInterval=getDefault&lt;long&gt;(&quot;param_timeStepUpdateInterval&quot;);
+		sdecTimeStepper-&gt;sdecGroupMask=getDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;);
+		sdecTimeStepper-&gt;timeStepUpdateInterval=getDefault&lt;int&gt;(&quot;param_timeStepUpdateInterval&quot;);
+		sdecTimeStepper-&gt;timeStepUpdateInterval=300;
 		rootBody-&gt;engines.push_back(sdecTimeStepper);
 	}
 
@@ -155,12 +177,12 @@
 	rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
 		
 	shared_ptr&lt;ElasticContactLaw&gt; constitutiveLaw(new ElasticContactLaw);
-	constitutiveLaw-&gt;sdecGroupMask = getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
+	constitutiveLaw-&gt;sdecGroupMask = getDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;);
 	constitutiveLaw-&gt;momentRotationLaw = getDefault&lt;bool&gt;(&quot;param_momentRotationLaw&quot;);
 	rootBody-&gt;engines.push_back(constitutiveLaw);
 
 	shared_ptr&lt;ElasticCohesiveLaw&gt; constitutiveLaw2(new ElasticCohesiveLaw);
-	constitutiveLaw2-&gt;sdecGroupMask = getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
+	constitutiveLaw2-&gt;sdecGroupMask = getDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;);
 	constitutiveLaw2-&gt;momentRotationLaw = getDefault&lt;bool&gt;(&quot;param_momentRotationLaw&quot;);
 	rootBody-&gt;engines.push_back(constitutiveLaw2);
 	
@@ -198,8 +220,9 @@
 	rootBody-&gt;engines.push_back(shared_ptr&lt;ClumpMemberMover&gt;(new ClumpMemberMover));
 
 	#ifdef EMBED_PYTHON
-		if(getDefault&lt;string&gt;(&quot;param_pythonExpr&quot;).size()&gt;0){
+		if(getDefault&lt;string&gt;(&quot;param_pythonExpr&quot;).length()&gt;0 || getDefault&lt;string&gt;(&quot;param_pythonInitExpr&quot;).length()&gt;0){
 			shared_ptr&lt;PythonRecorder&gt; pythonRecorder=shared_ptr&lt;PythonRecorder&gt;(new PythonRecorder);
+			pythonRecorder-&gt;initExpression=getDefault&lt;string&gt;(&quot;param_pythonInitExpr&quot;);
 			pythonRecorder-&gt;expression=getDefault&lt;string&gt;(&quot;param_pythonExpr&quot;);
 			rootBody-&gt;engines.push_back(pythonRecorder);
 		}
@@ -210,7 +233,7 @@
 /*! Create body - sphere. */
 shared_ptr&lt;Body&gt; Shop::sphere(Vector3r center, Real radius){
 	// body itself
-	shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;)));
+	shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;)));
 	body-&gt;isDynamic=true;
 
 	// physics
@@ -251,7 +274,7 @@
 
 /*! Create body - box. */
 shared_ptr&lt;Body&gt; Shop::box(Vector3r center, Vector3r extents){
-		shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;)));
+		shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;int&gt;(&quot;body_sdecGroupMask&quot;)));
 		body-&gt;isDynamic=true;
 
 		shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);

Modified: trunk/yade-extra/clump/Shop.hpp
===================================================================
--- trunk/yade-extra/clump/Shop.hpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-extra/clump/Shop.hpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -3,12 +3,14 @@
 #include&lt;string&gt;
 #include&lt;map&gt;
 #include&lt;iostream&gt;
+#include&lt;typeinfo&gt;
 #include&lt;boost/any.hpp&gt;
 #include&lt;boost/shared_ptr.hpp&gt;
 
 #include&lt;Wm3Vector3.h&gt;
 #include&lt;Wm3Quaternion.h&gt;
 #include&lt;yade/yade-lib-base/yadeWm3.hpp&gt;
+#include&lt;yade/yade-lib-base/Logging.hpp&gt;
 
 /*
 #include&lt;yade/yade-core/MetaBody.hpp&gt;
@@ -23,6 +25,7 @@
 
 class Shop{
 	private:
+		DECLARE_LOGGER;
 	public:
 		/*! map of &lt;attribute name,value&gt;. */
 		static map&lt;string,boost::any&gt; defaults;
@@ -31,12 +34,14 @@
 		/*! Calls Shop::init if Shop::defaults is empty (when setting or getting a default). */
 		static void ensureInit(){if(defaults.size()==0) init();}
 	public:
+		static bool hasDefault(const string&amp; key){return defaults.find(key)!=defaults.end();}
 		/*! Retrieve default value from the map. User is responsible for casting it to the right type. */
-		template &lt;typename valType&gt; static valType getDefault(string key){ensureInit(); return boost::any_cast&lt;valType&gt;(defaults[key]);}
+		template &lt;typename valType&gt; static valType getDefault(const string&amp; key);
 		//template &lt;typename valType&gt; static valType getDefault(string key){ensureInit(); return boost::any_cast&lt;valType&gt;(defaults[key]);}
 		/*! Set the default value. Overrides existing value or creates new entry. Integer types are always cast to long (be careful when retrieving them). */
-		template &lt;typename valType&gt; static void setDefault(string key, const valType value){ensureInit(); defaults[key]=boost::any(value);}
-
+		template &lt;typename valType&gt; static void setDefault(string key, const valType value){
+			ensureInit(); //cerr&lt;&lt;&quot;Shop: Setting `&quot;&lt;&lt;key&lt;&lt;&quot;'=&quot;&lt;&lt;value&lt;&lt;&quot; (type `&quot;&lt;&lt;typeid(valType).name()&lt;&lt;&quot;').&quot;&lt;&lt;endl;
+			defaults[key]=boost::any(value);}		
 		static shared_ptr&lt;MetaBody&gt; rootBody();
 		static void rootBodyActors(shared_ptr&lt;MetaBody&gt;);
 		static shared_ptr&lt;Body&gt; sphere(Vector3r center, Real radius);

Modified: trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp
===================================================================
--- trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -14,9 +14,6 @@
 #include &lt;yade/yade-core/Body.hpp&gt;
 #include &lt;yade/yade-core/Interaction.hpp&gt;
 #include &lt;yade/yade-core/Omega.hpp&gt;
-#ifdef HIGHLEVEL_CLUMPS
-#include&lt;yade/yade-extra/Clump.hpp&gt;
-#endif
 
 
 GLViewer::GLViewer(int id, shared_ptr&lt;RenderingEngine&gt; rendererInit, const QGLFormat&amp; format, QWidget * parent, QGLWidget * shareWidget) : QGLViewer(format,parent,&quot;glview&quot;,shareWidget)//, qglThread(this,rendererInit)
@@ -156,13 +153,7 @@
 			manipulatedFrame()-&gt;getOrientation(q0,q1,q2,q3);
 			q[0]=q0;q[1]=q1;q[2]=q2;q[3]=q3;
 
-			#ifdef HIGHLEVEL_CLUMPS
-				shared_ptr&lt;Body&gt; b=Body::byId(selection);
-				if(b-&gt;isClump()){
-					Clump* clump=dynamic_cast&lt;Clump*&gt;(Body::byId(b-&gt;clumpId).get());
-					clump-&gt;moveMembers();
-				}
-			#endif
+			(*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;userForcedDisplacementRedrawHook();	
 		}
 		
 	// FIXME - here we want to actually call all responsible GLDraw Actors
@@ -194,13 +185,12 @@
 	}
 	if( (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selection) )
 	{
-		#ifdef HIGHLEVEL_CLUMPS
-			if(Body::byId(selection)-&gt;isClumpMember()){ // select clump (invisible) instead of its member
-				cerr&lt;&lt;&quot;Clump member #&quot;&lt;&lt;selection&lt;&lt;&quot; selected, selecting clump instead.&quot;&lt;&lt;endl;
-				selection=Body::byId(selection)-&gt;clumpId;
-				setSelectedName(selection);
-			}
-		#endif
+		if(Body::byId(selection)-&gt;isClumpMember()){ // select clump (invisible) instead of its member
+			cerr&lt;&lt;&quot;Clump member #&quot;&lt;&lt;selection&lt;&lt;&quot; selected, selecting clump instead.&quot;&lt;&lt;endl;
+			selection=Body::byId(selection)-&gt;clumpId;
+			setSelectedName(selection);
+		}
+
 		std::cerr &lt;&lt; &quot;new selection &quot; &lt;&lt; selection &lt;&lt; &quot;\n&quot;;
 		wasDynamic = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;isDynamic;
 		(*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;isDynamic = false;

Modified: trunk/yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine/GravityEngine.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine/GravityEngine.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine/GravityEngine.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -37,15 +37,14 @@
 	for( ; bi!=biEnd ; ++bi )
 	{
 		shared_ptr&lt;Body&gt; b = *bi;
-		#ifdef HIGHLEVEL_CLUMPS
-			/* skip bodies that are within a clump;
-			 * even if they are marked isDynamic==false, forces applied to them are passed to the clump, which is dynamic;
-			 * and since clump is a body with mass equal to the sum of masses of its components, it would have gravity applied twice.
-			 *
-			 * The choice is to skip (b-&gt;isClumpMember()) or (b-&gt;isClump()). We rather skip members,
-			 * since that will apply smaller number of forces and (theoretically) improve numerical stability ;-) */
-			if(b-&gt;isClumpMember()) continue;
-		#endif
+		/* skip bodies that are within a clump;
+		 * even if they are marked isDynamic==false, forces applied to them are passed to the clump, which is dynamic;
+		 * and since clump is a body with mass equal to the sum of masses of its components, it would have gravity applied twice.
+		 *
+		 * The choice is to skip (b-&gt;isClumpMember()) or (b-&gt;isClump()). We rather skip members,
+		 * since that will apply smaller number of forces and (theoretically) improve numerical stability ;-) */
+		if(b-&gt;isClumpMember()) continue;
+
 		ParticleParameters* p = dynamic_cast&lt;ParticleParameters*&gt;(b-&gt;physicalParameters.get());
 		if (p)
 			static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find( b-&gt;getId() , actionParameterForce-&gt;getClassIndex() ).get() )-&gt;force += gravity * p-&gt;mass;

Modified: trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw/NewtonsForceLaw.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -21,8 +21,6 @@
 	Force * af = dynamic_cast&lt;Force*&gt;(a.get());
 	ParticleParameters * p = dynamic_cast&lt;ParticleParameters*&gt;(b.get());
 	
-	//! FIXME FIXME: the following seems to be no longer truth with PhysicalActionContainerReseter?!!
-	
 	//FIXME : should be += and we should add an Engine that reset acceleration at the beginning
 	// if another PhysicalAction also acts on acceleration then we are overwritting it here
 	//
@@ -33,32 +31,21 @@
 	// then above will have to be fixed. And example of such action is: Acceleration
 	//
 	
-//	std::cout &lt;&lt; bb-&gt;getId() &lt;&lt; std::endl;
-//	std::cout &lt;&lt; a-&gt;getClassIndex() &lt;&lt; &quot; &quot; &lt;&lt; a-&gt;getClassName() &lt;&lt; std::endl;
-//	std::string ch;
-//	std::cin &gt;&gt; ch;
 
-	#ifdef HIGHLEVEL_CLUMPS
 	// TODO: remove debugging stuff from the following
 	// normal behavior of a standalone particle or a clump itself
-	if (bb-&gt;isStandalone() || bb-&gt;isClump()) {
-		// FIXME: reset accel for standalones, just as original NewtonForceLaw does; for clumps, done in Clump::moveSubBodies
-		if(bb-&gt;isStandalone()) p-&gt;acceleration=Vector3r(0,0,0);
+	if (bb-&gt;isStandalone()) p-&gt;acceleration=af-&gt;force/p-&gt;mass;
+	else if (bb-&gt;isClump()) {
+		// accel for clump reset in Clump::moveMembers, called by ClumpMemberMover engine
 		p-&gt;acceleration+=af-&gt;force/p-&gt;mass;
-		//if(bb-&gt;isClump())cerr&lt;&lt;&quot;##&quot;&lt;&lt;bb-&gt;getId()&lt;&lt;&quot;      : force=&quot;&lt;&lt;af-&gt;force&lt;&lt;&quot;, mass=&quot;&lt;&lt;p-&gt;mass&lt;&lt;&quot;, accel=&quot;&lt;&lt;p-&gt;acceleration&lt;&lt;endl; //&quot;, angularAcceleration=&quot;&lt;&lt;p-&gt;angularAcceleration&lt;&lt;endl;
 	}
-	else{
-		shared_ptr&lt;Body&gt; clump=Body::byId(bb-&gt;clumpId);
+	else{ // force applied to a clump member is applied to clump itself
+		const shared_ptr&lt;Body&gt;&amp; clump(Body::byId(bb-&gt;clumpId));
 		RigidBodyParameters* clumpRBP=dynamic_cast&lt;RigidBodyParameters*&gt;(clump-&gt;physicalParameters.get());
-		/* TODO: the FIXME above still applies??!!! */
-		//cerr&lt;&lt;&quot;#&quot;&lt;&lt;bb-&gt;getId()&lt;&lt;&quot; orig (##&quot;&lt;&lt;bb-&gt;clumpId&lt;&lt;&quot;): acceleration=&quot;&lt;&lt;clumpRBP-&gt;acceleration&lt;&lt;&quot;, angularAcceleration=&quot;&lt;&lt;clumpRBP-&gt;angularAcceleration&lt;&lt;endl;
+		// accels reset by Clump::moveMembers in last iteration
 		clumpRBP-&gt;acceleration+=af-&gt;force/clumpRBP-&gt;mass;
 		clumpRBP-&gt;angularAcceleration+=diagDiv((b-&gt;se3.position-clumpRBP-&gt;se3.position).Cross(af-&gt;force),clumpRBP-&gt;inertia); //acceleration from torque generated by the force WRT particle centroid on the clump centroid
-		//if(af-&gt;force!=Vector3r(0,0,0)) cerr&lt;&lt;&quot;#&quot;&lt;&lt;bb-&gt;getId()&lt;&lt;&quot; (##&quot;&lt;&lt;bb-&gt;clumpId&lt;&lt;&quot;): force=&quot;&lt;&lt;af-&gt;force&lt;&lt;&quot;, accel=&quot;&lt;&lt;clumpRBP-&gt;acceleration&lt;&lt;&quot;, aAccel=&quot;&lt;&lt;clumpRBP-&gt;angularAcceleration&lt;&lt;endl; //&quot;, force=&quot;&lt;&lt;af-&gt;force&lt;&lt;endl;
 	}
-	#else
-		p-&gt;acceleration = af-&gt;force/p-&gt;mass;
-	#endif
 }
 
 

Modified: trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw/NewtonsMomentumLaw.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw/NewtonsMomentumLaw.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw/NewtonsMomentumLaw.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -22,17 +22,14 @@
 	RigidBodyParameters * rb = static_cast&lt;RigidBodyParameters*&gt;(b.get());
 	
 	//FIXME : should be += and we should add an Engine that reset acceleration at the beginning
-	#ifdef HIGHLEVEL_CLUMPS
-	if(bb-&gt;clumpId==Body::ID_NONE) rb-&gt;angularAcceleration = diagDiv(am-&gt;momentum,rb-&gt;inertia);
-	else{
-		shared_ptr&lt;Body&gt; clump=Body::byId(bb-&gt;clumpId);
+	if(bb-&gt;isStandalone()) rb-&gt;angularAcceleration=diagDiv(am-&gt;momentum,rb-&gt;inertia);
+	else if(bb-&gt;isClump()) rb-&gt;angularAcceleration+=diagDiv(am-&gt;momentum,rb-&gt;inertia);
+	else { // isClumpMember()
+		const shared_ptr&lt;Body&gt;&amp; clump(Body::byId(bb-&gt;clumpId));
 		RigidBodyParameters* clumpRBP=dynamic_cast&lt;RigidBodyParameters*&gt;(clump-&gt;physicalParameters.get());
-		/* TODO: the FIXME above still applies!!! */
+		/* angularAcceleration is reset by ClumpMemberMover engine */
 		clumpRBP-&gt;angularAcceleration+=diagDiv(am-&gt;momentum,clumpRBP-&gt;inertia);
 	}
-	#else
-	rb-&gt;angularAcceleration = diagDiv(am-&gt;momentum,rb-&gt;inertia);
-	#endif
 }
 
 

Modified: trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider/PersistentSAPCollider.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -183,14 +183,13 @@
 	// test if the AABBs of the spheres number &quot;id1&quot; and &quot;id2&quot; are overlapping
 	int offset1 = 3*id1;
 	int offset2 = 3*id2;
-	#ifdef HIGHLEVEL_CLUMPS
-		shared_ptr&lt;Body&gt; b1=Body::byId(id1), b2=Body::byId(id2);
-	#endif
+	// FIXME: this is perhaps an expensive operation?!
+	const shared_ptr&lt;Body&gt;&amp; b1(Body::byId(id1)), b2(Body::byId(id2));
 	bool overlap =
-	#ifdef HIGHLEVEL_CLUMPS
+
 		(b1-&gt;isStandalone() || b2-&gt;isStandalone() || b1-&gt;clumpId!=b2-&gt;clumpId ) &amp;&amp; // only collide if at least one particle is standalone or they belong to different clumps
 		!b1-&gt;isClump() &amp;&amp; !b2-&gt;isClump() &amp;&amp; // do not collide clumps, since they are just containers, never interact
-	#endif
+
 		!(maximums[offset1]&lt;minimums[offset2] || maximums[offset2]&lt;minimums[offset1] || 
 		maximums[offset1+1]&lt;minimums[offset2+1] || maximums[offset2+1]&lt;minimums[offset1+1] || 
 		maximums[offset1+2]&lt;minimums[offset2+2] || maximums[offset2+2]&lt;minimums[offset1+2]);

Modified: trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider/SAPCollider.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider/SAPCollider.cpp	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider/SAPCollider.cpp	2007-02-27 16:09:05 UTC (rev 1075)
@@ -117,13 +117,12 @@
 		{
 			// FIXME - this assumes that bodies are numbered from zero with one number increments, BAD!!!
 //			if (!(bodies-&gt;find(i)-&gt;isDynamic==false &amp;&amp; bodies-&gt;find(*it)-&gt;isDynamic==false))
-			#ifdef HIGHLEVEL_CLUMPS
+//			FIXME: this is broken for clumps!!!
+//			!!!!!!!!!!!!!!!!!!!!!!!!!! BROKEN !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 				if( (*bodies)[i]-&gt;isDynamic &amp;&amp; (*bodies)[*it]-&gt;isDynamic &amp;&amp; // old stuff: both bodies must be dynamic
 					( (*bodies)[i]-&gt;clumpId==Body::ID_NONE || (*bodies)[*it]-&gt;clumpId==Body::ID_NONE || ( (*bodies)[i]-&gt;clumpId != (*bodies)[*it]-&gt;clumpId )) // either (at least) one of them is not within a clump or they are not part of the same clump
 					)
-			#else
-			if (!((*bodies)[i]-&gt;isDynamic==false &amp;&amp; (*bodies)[*it]-&gt;isDynamic==false))
-			#endif
+			// pre-clump code: if (!((*bodies)[i]-&gt;isDynamic==false &amp;&amp; (*bodies)[*it]-&gt;isDynamic==false))
 			{
 				nbPotentialInteractions++;
 				shared_ptr&lt;Interaction&gt; inter(new Interaction(i,*it));

Modified: trunk/yade-scripts/erskine3-apply.sh
===================================================================
--- trunk/yade-scripts/erskine3-apply.sh	2007-02-26 19:24:57 UTC (rev 1074)
+++ trunk/yade-scripts/erskine3-apply.sh	2007-02-27 16:09:05 UTC (rev 1075)
@@ -26,3 +26,5 @@
 $ERSKINE $ENGINE $YADE/yade-packages/yade-package-mass-spring/src/yade-package-mass-spring.pro $YADE/yade-packages/yade-package-mass-spring &gt; $YADE/yade-packages/yade-package-mass-spring/$SCRIPT
 $ERSKINE $ENGINE $YADE/yade-packages/yade-package-realtime-rigidbody/src/yade-package-realtime-rigidbody.pro $YADE/yade-packages/yade-package-realtime-rigidbody &gt; $YADE/yade-packages/yade-package-realtime-rigidbody/$SCRIPT
 
+echo Creating entry for yade-extra/Clump in $YADE/yade-extra/$SCRIPT
+echo &quot;env.SConscript(dirs=['Clump'])&quot; &gt;&gt; $YADE/yade-extra/$SCRIPT


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000039.html">[Yade-commits] r1074 - in trunk: yade-core/src/yade yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI yade-libs/yade-lib-opengl/src/yade-lib-opengl yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere yade-packages/yade-package-dem/src/PreProcessor/Funnel yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall yade-packages/yade-package-! dem/src/PreProcessor/SDECSpheresPlane yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader yade-packages/yade-package-fem/src/PreProcessor/FEMBeam yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder yade! -packages/yade-package-lattice/src/PreProcessor/LatticeExample! yade-pa
</A></li>
	<LI>Next message: <A HREF="000041.html">[Yade-commits] r1076 - in trunk: . yade-scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#40">[ date ]</a>
              <a href="thread.html#40">[ thread ]</a>
              <a href="subject.html#40">[ subject ]</a>
              <a href="author.html#40">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
