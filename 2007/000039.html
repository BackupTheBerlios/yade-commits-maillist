<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1074 - in trunk: yade-core/src/yade yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI yade-libs/yade-lib-opengl/src/yade-lib-opengl yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere yade-packages/yade-package-dem/src/PreProcessor/Funnel yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall yade-packages/yade-package-! dem/src/PreProcessor/SDECSpheresPlane yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader yade-packages/yade-package-fem/src/PreProcessor/FEMBeam yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder yade! -packages/yade-package-lattice/src/PreProcessor/LatticeExample! yade-pa
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1074%20-%20in%20trunk%3A%20yade-core/src/yade%0A%20yade-extra/clump%20yade-guis/yade-gui-qt/src/QtGUI%0A%20yade-libs/yade-lib-opengl/src/yade-lib-opengl%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere%0A%20yade-packages/yade-package-dem/src/PreProcessor/Funnel%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall%0A%20yade-packages/yade-package-%21%20dem/src/PreProcessor/SDECSpheresPlane%0A%20yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest%0A%20yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending%0A%20yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest%0A%20yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron%0A%20yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry%0A%20yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader%0A%20yade-packages/yade-package-fem/src/PreProcessor/FEMBeam%0A%20yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder%0A%20yade%21%20-packages/yade-package-lattice/src/PreProcessor/LatticeExample%21%0A%20yade-pa&In-Reply-To=%3C200702261925.l1QJP0GF019174%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000038.html">
   <LINK REL="Next"  HREF="000040.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1074 - in trunk: yade-core/src/yade yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI yade-libs/yade-lib-opengl/src/yade-lib-opengl yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere yade-packages/yade-package-dem/src/PreProcessor/Funnel yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall yade-packages/yade-package-! dem/src/PreProcessor/SDECSpheresPlane yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader yade-packages/yade-package-fem/src/PreProcessor/FEMBeam yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder yade! -packages/yade-package-lattice/src/PreProcessor/LatticeExample! yade-pa</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1074%20-%20in%20trunk%3A%20yade-core/src/yade%0A%20yade-extra/clump%20yade-guis/yade-gui-qt/src/QtGUI%0A%20yade-libs/yade-lib-opengl/src/yade-lib-opengl%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox%0A%20yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere%0A%20yade-packages/yade-package-dem/src/PreProcessor/Funnel%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres%0A%20yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall%0A%20yade-packages/yade-package-%21%20dem/src/PreProcessor/SDECSpheresPlane%0A%20yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest%0A%20yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending%0A%20yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest%0A%20yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron%0A%20yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry%0A%20yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader%0A%20yade-packages/yade-package-fem/src/PreProcessor/FEMBeam%0A%20yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder%0A%20yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder%0A%20yade%21%20-packages/yade-package-lattice/src/PreProcessor/LatticeExample%21%0A%20yade-pa&In-Reply-To=%3C200702261925.l1QJP0GF019174%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1074 - in trunk: yade-core/src/yade yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI yade-libs/yade-lib-opengl/src/yade-lib-opengl yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere yade-packages/yade-package-dem/src/PreProcessor/Funnel yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall yade-packages/yade-package-! dem/src/PreProcessor/SDECSpheresPlane yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader yade-packages/yade-package-fem/src/PreProcessor/FEMBeam yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder yade! -packages/yade-package-lattice/src/PreProcessor/LatticeExample! yade-pa">eudoxos at mail.berlios.de
       </A><BR>
    <I>Mon Feb 26 20:25:00 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000038.html">[Yade-commits] r1073 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-libs/yade-lib-serialization/src/yade-lib-serialization	yade-packages/yade-package-dem/src/Engine/DeusExMachina/ResultantForceEngine	yade-packages/yade-package-dem/src/Engine/DeusExMachina/TriaxialCompressionEngine	yade-packages/yade-package-dem/src/Engine/DeusExMachina/TriaxialStressController	yade-packages/yade-package-dem/src/Engine/EngineUnit/InteractingMyTetrahedron2AABB	yade-packages/yade-package-dem/src/Engine/StandAloneEngine/GeometricalModelForceColorizer	yade-packages/yade-package-dem/src/Engine/StandAloneEngine/MyTetrahedronLaw	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSDECLinkGeometry	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry	yade-scripts
</A></li>
        <LI>Next message: <A HREF="000040.html">[Yade-commits] r1075 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider	yade-scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39">[ date ]</a>
              <a href="thread.html#39">[ thread ]</a>
              <a href="subject.html#39">[ subject ]</a>
              <a href="author.html#39">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2007-02-26 20:24:57 +0100 (Mon, 26 Feb 2007)
New Revision: 1074

Added:
   trunk/yade-extra/clump/Shop.cpp
   trunk/yade-extra/clump/Shop.hpp
Modified:
   trunk/yade-core/src/yade/Body.hpp
   trunk/yade-core/src/yade/GeometricalModel.hpp
   trunk/yade-core/src/yade/InteractingGeometry.hpp
   trunk/yade-core/src/yade/yadeWm3Extra.hpp
   trunk/yade-extra/clump/Clump.cpp
   trunk/yade-extra/clump/Clump.hpp
   trunk/yade-extra/clump/SConscript
   trunk/yade-guis/yade-gui-qt/src/QtGUI/GLEngineEditor.hpp
   trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp
   trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/GLWindow.hpp
   trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/OpenGLWrapper.hpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox/GLDrawBox.cpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral/GLDrawQuadrilateral.cpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere/GLDrawSphere.cpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron/GLDrawTetrahedron.cpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox/GLDrawInteractingBox.cpp
   trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere/GLDrawInteractingSphere.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/Funnel/Funnel.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.hpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres/SDECLinkedSpheres.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall/SDECMovingWall.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECSpheresPlane/SDECSpheresPlane.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest/TetrahedronsTest.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending/ThreePointBending.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.cpp
   trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.hpp
   trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron/GLDrawInteractingMyTetrahedron.cpp
   trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp
   trunk/yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader/FEMSetTextLoader.cpp
   trunk/yade-packages/yade-package-fem/src/PreProcessor/FEMBeam/FEMBeam.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams/LatticeSet2LatticeBeams.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder/BeamRecorder.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson/MeasurePoisson.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport/MovingSupport.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder/NodeRecorder.cpp
   trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder/StrainRecorder.cpp
   trunk/yade-packages/yade-package-lattice/src/PreProcessor/LatticeExample/LatticeExample.cpp
   trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeBeamState/GLDrawLatticeBeamState.cpp
   trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeInteractingGeometry/GLDrawLatticeInteractingGeometry.cpp
   trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp
   trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLineSegment/GLDrawLineSegment.cpp
   trunk/yade-packages/yade-package-mass-spring/src/PreProcessor/HangingCloth/HangingCloth.cpp
   trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/BoxStack/BoxStack.cpp
   trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/RotatingBox/RotatingBox.cpp
Log:
1. OK, the floats floating around for colors drove me nuts, so I replace all of that garbage by doubles. Since for one particular case (glMaterialv) the corresponding function taking double (glMaterialdv) is not defined in mesa (and perhaps not in most other gl libs), for that one the argument was converted explicitly.
2. New Shop class, that defines static methods for easy things, along with a dictionary of default parameters for some useful stuff: like getting a rootbody with reasonable set of actors, sphere body, box body. That's all for the moment. Add your own stuff. Filegenerators may shrink considerably this way.
3. Clump::subBodies renamed to Clump::members, Clump::moveSubBodies to Clump::moveMembers, ClumpSubBodyMover to ClumpMemberMover - to be consistent with Body::isClumpMember. Clump still not moved to DEM, that will wait till later - at the moment, QGLViewer depends on Clump (for moving clump when selected and moved with mouse).

There may be some borken things here, do not use this revision for anything.



Modified: trunk/yade-core/src/yade/Body.hpp
===================================================================
--- trunk/yade-core/src/yade/Body.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-core/src/yade/Body.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -28,8 +28,7 @@
 
 
 /*! \brief Abstract interface for bodies stored in BodyContainer, Body represents the atomic element of simulation.
-*/
-
+ */
 class Body : public Serializable
 {
 	private	:

Modified: trunk/yade-core/src/yade/GeometricalModel.hpp
===================================================================
--- trunk/yade-core/src/yade/GeometricalModel.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-core/src/yade/GeometricalModel.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -24,7 +24,7 @@
 				,wire
 				,shadowCaster;
 
-		Vector3f	diffuseColor;
+		Vector3r	diffuseColor;
 
 	protected : 
 		void registerAttributes();

Modified: trunk/yade-core/src/yade/InteractingGeometry.hpp
===================================================================
--- trunk/yade-core/src/yade/InteractingGeometry.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-core/src/yade/InteractingGeometry.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -25,7 +25,7 @@
 class InteractingGeometry : public Serializable, public Indexable
 {
 	public :
-		Vector3f diffuseColor;	// FIXME - why here? and then - why no
+		Vector3r diffuseColor;	// FIXME - why here? and then - why no
 					// bool wire; even though GeometricalModel has bool wire ?
 	
 /// Serialization

Modified: trunk/yade-core/src/yade/yadeWm3Extra.hpp
===================================================================
--- trunk/yade-core/src/yade/yadeWm3Extra.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-core/src/yade/yadeWm3Extra.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -37,9 +37,9 @@
 	template&lt;class RealType1, class RealType2&gt;
 	Vector3&lt;RealType2&gt; operator* (RealType1 fScalar, const Vector3&lt;RealType2&gt;&amp; rkV){ return Vector3&lt;RealType2&gt;(fScalar*rkV[0],fScalar*rkV[1],fScalar*rkV[2]);}
 
-	/*__attribute__((deprecated)) Vector3f operator*(const double s, const Vector3f&amp; v){return Vector3f(s*v[0],s*v[1],s*v[2]);}
+	/*__attribute__((deprecated)) Vector3r operator*(const double s, const Vector3r&amp; v){return Vector3r(s*v[0],s*v[1],s*v[2]);}
 	__attribute__((deprecated)) Vector3d operator*(const float s, const Vector3d&amp; v){return Vector3d(s*v[0],s*v[1],s*v[2]);}
-	__attribute__((deprecated)) Vector3f operator*(const Vector3f&amp; v, const double s){return Vector3f(s*v[0],s*v[1],s*v[2]);}
+	__attribute__((deprecated)) Vector3r operator*(const Vector3r&amp; v, const double s){return Vector3r(s*v[0],s*v[1],s*v[2]);}
 	__attribute__((deprecated)) Vector3d operator*(const Vector3d&amp; v, const float s){return Vector3d(s*v[0],s*v[1],s*v[2]);}*/
 
 	std::ostream &amp; operator&lt;&lt; (std::ostream &amp;os, const Vector3r &amp;v){ return os &lt;&lt; v[0] &lt;&lt; &quot; &quot; &lt;&lt; v[1] &lt;&lt; &quot; &quot; &lt;&lt; v[2];}

Modified: trunk/yade-extra/clump/Clump.cpp
===================================================================
--- trunk/yade-extra/clump/Clump.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-extra/clump/Clump.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -1,39 +1,39 @@
 // (c) 2007 Vaclav Smilauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt; 
 
 #include&quot;Clump.hpp&quot;
-
+#include&lt;yade/yade-extra/Shop.hpp&gt;
 #include&lt;algorithm&gt;
 
 char* yadePluginClasses[]={
 	&quot;Clump&quot;,
-	&quot;ClumpSubBodyMover&quot;,
+	&quot;ClumpMemberMover&quot;,
 	&quot;ClumpTestGen&quot;,
 	NULL /*sentinel*/
 };
 
 CREATE_LOGGER(Clump);
-CREATE_LOGGER(ClumpSubBodyMover);
+CREATE_LOGGER(ClumpMemberMover);
 CREATE_LOGGER(ClumpTestGen);
 
 /**************************************************************************************
- ************************************* ClumpSubBodyMover ******************************
+ ************************************* ClumpMemberMover ******************************
  **************************************************************************************/
 
 // Constructor must be in the .cpp file (?)
-ClumpSubBodyMover::ClumpSubBodyMover(){/*createIndex();*/ }
+ClumpMemberMover::ClumpMemberMover(){/*createIndex();*/ }
 
 /*! We only call clump's method, since it belongs there logically. It makes encapsulation of private members nicer, too.
  * @param pp passed by the dispatcher
  * @param clump passed by the dispatcher
  */
-void ClumpSubBodyMover::applyCondition(Body* _rootBody){
+void ClumpMemberMover::applyCondition(Body* _rootBody){
 	MetaBody* rootBody = dynamic_cast&lt;MetaBody*&gt;(_rootBody);
 	for(BodyContainer::iterator I=rootBody-&gt;bodies-&gt;begin(); I!=rootBody-&gt;bodies-&gt;end(); ++I){
 		shared_ptr&lt;Body&gt; b = *I;
 		// is this a clump?
 		if(b-&gt;getId()==b-&gt;clumpId){
 			//LOG_TRACE(&quot;Applying movement to clump #&quot;&lt;&lt;b-&gt;getId());
-			dynamic_pointer_cast&lt;Clump&gt;(b)-&gt;moveSubBodies();
+			dynamic_pointer_cast&lt;Clump&gt;(b)-&gt;moveMembers();
 		}
 	}
 	//if(!clump-&gt;isDynamic) return; // perhaps clump that has been desactivated?!
@@ -57,10 +57,10 @@
 	boundingVolume-&gt;diffuseColor=Vector3r(1,0,0);
 
 	interactingGeometry=shared_ptr&lt;InteractingGeometry&gt;(new InteractingGeometry);
-	interactingGeometry-&gt;diffuseColor=Vector3f(0,0,0);
+	interactingGeometry-&gt;diffuseColor=Vector3r(0,0,0);
 
 	geometricalModel=shared_ptr&lt;GeometricalModel&gt;(new GeometricalModel);
-	geometricalModel-&gt;diffuseColor=Vector3f(0,0,0); geometricalModel-&gt;wire=false; geometricalModel-&gt;visible=false; geometricalModel-&gt;shadowCaster=false;
+	geometricalModel-&gt;diffuseColor=Vector3r(0,0,0); geometricalModel-&gt;wire=false; geometricalModel-&gt;visible=false; geometricalModel-&gt;shadowCaster=false;
 #endif
 
 }
@@ -76,13 +76,13 @@
 	// preconditions
 	assert(subBody-&gt;isDynamic);
 	assert(physicalParameters);
-	assert(subBodies.count(subId)==0);
+	assert(members.count(subId)==0);
 
 	// begin actual setup
 	subBody-&gt;clumpId=getId();
 	subBody-&gt;isDynamic=false;
 	// for now, push just unitialized se3; will be updated by updateProperties
-	subBodies[subId]=Se3r();
+	members[subId]=Se3r();
 
 	clumpId=getId(); // identifies a clump
 
@@ -93,7 +93,7 @@
  */
 void Clump::del(Body::id_t subId){
 	// erase the subBody; removing body that is not part of the clump is error
-	assert(subBodies.erase(subId)==1);
+	assert(members.erase(subId)==1);
 	// restore body's internal parameters;
 	shared_ptr&lt;Body&gt; subBody=Body::byId(subId);
 	subBody-&gt;clumpId=Body::ID_NONE;
@@ -101,14 +101,14 @@
 	LOG_DEBUG(&quot;Removed body #&quot;&lt;&lt;subId&lt;&lt;&quot; from clump #&quot;&lt;&lt;getId());
 }
 
-/*! @brief Calculate positions and orientations of subBodies based on Clump's Se3.
+/*! @brief Calculate positions and orientations of members based on Clump's Se3.
  *
- * This method is called by the ClumpSubBodyMover engine after each timestep.
- * @note Velocities of subBodies are not updated, since subBodies have isdynamic==false. It is possible, though, that someone needs to have a moving clump that is later broken apart and that liberated particle continue to move in the same way as theydid within the clump. In that case, this will have to be completed.
+ * This method is called by the ClumpMemberMover engine after each timestep.
+ * @note Velocities of members are not updated, since members have isdynamic==false. It is possible, though, that someone needs to have a moving clump that is later broken apart and that liberated particle continue to move in the same way as theydid within the clump. In that case, this will have to be completed.
  */
-void Clump::moveSubBodies(){
+void Clump::moveMembers(){
 	const Se3r&amp; mySe3(physicalParameters-&gt;se3);
-	for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
+	for(Clump::memberMap::iterator I=members.begin(); I!=members.end(); I++){
 		// now, I-&gt;first is Body::id_t, I-&gt;second is Se3r of that body in the clump
 		shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 		shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
@@ -137,12 +137,12 @@
 	
 }
 
-/*! Clump's se3 will be updated (origin at centroid and axes coincident with principal inertia axes) and subSe3 modified in such a way that subBodies positions in world coordinates will not change.
+/*! Clump's se3 will be updated (origin at centroid and axes coincident with principal inertia axes) and subSe3 modified in such a way that members positions in world coordinates will not change.
 
 	The algorithm is as follows:
-	-# Clump::subBodies values and Clump::physicalParameters::se3 are invalid from this point
+	-# Clump::members values and Clump::physicalParameters::se3 are invalid from this point
 	-# M=0; S=vector3r(0,0,0); I=zero tensor; (ALL calculations are in world coordinates!)
-	-# loop over Clump::subBodies (position x_i, mass m_i, inertia at subBody's centroid I_i) [this loop will be replaced by numerical integration (rasterization) for the intersecting case; the rest will be the same]
+	-# loop over Clump::members (position x_i, mass m_i, inertia at subBody's centroid I_i) [this loop will be replaced by numerical integration (rasterization) for the intersecting case; the rest will be the same]
 		- M+=m_i
 		- S+=m_i*x_i (local static moments are zero (centroid)
 		- get inertia tensor of subBody in world coordinates, by rotating the principal (local) tensor against subBody-&gt;se3-&gt;orientation; then translate it to world origin (parallel axes theorem), then I+=I_i_world
@@ -160,12 +160,12 @@
 	@todo implement the loop for intersecting bodies (may cut'n'paste from slum code, but that will work for spheres only!)
 
 	@note User is responsible for calling this function when appropriate (after adding/removing bodies and before any subsequent simulation). This function can be rather slow by virtue of numerical integration.
-	@note subBodie's velocities are not taken into account. This means that clump will be at still after being created, even if its composing particles did have some velocities. If this is concern for someone, it needs to be completed in the code below. See Clump::moveSubBodies for complementary issue.
+	@note subBodie's velocities are not taken into account. This means that clump will be at still after being created, even if its composing particles did have some velocities. If this is concern for someone, it needs to be completed in the code below. See Clump::moveMembers for complementary issue.
 	@todo Needs to be tested for physical correctness
 	@param intersecting if true, evaluate mass and inertia numerically; otherwise, use analytical methods (parallel axes theorem) which disregard any intersections, but are much faster. */
 void Clump::updateProperties(bool intersecting){
 	LOG_DEBUG(&quot;Updating clump #&quot;&lt;&lt;getId()&lt;&lt;&quot; parameters&quot;);
-	assert(subBodies.size()&gt;0);
+	assert(members.size()&gt;0);
 	// maybe handle the case of only one clump subBody specially here?!
 	if(intersecting){
 		LOG_WARN(&quot;Self-intersecting clumps not yet implemented, intersections will be ignored.&quot;);
@@ -182,7 +182,7 @@
 
 	// begin non-intersecting loop here
 	if(!intersecting){
-		for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
+		for(memberMap::iterator I=members.begin(); I!=members.end(); I++){
 			// now, I-&gt;first is Body::id_t, I-&gt;second is Se3r of that body
 			shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 			shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
@@ -249,7 +249,7 @@
 			LOG_WARN(&quot;WigenDecomposition gave some NaNs, we will use imaginary values for clump inertia and orientation instead!&quot;);
 			//FIXME: since EigenDecomposition is broken, use inertia of the first body instead;
 			//!!!!! note that this is HIGHLY incorrect for all non-single clumps !!!!!
-			clumpMap::iterator I=subBodies.begin();
+			memberMap::iterator I=members.begin();
 			shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 			shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
 			clumpRBP-&gt;inertia=subRBP-&gt;inertia*10.; // 10 is arbitrary; just to have inertia of clump bigger
@@ -259,13 +259,13 @@
 	#endif
 	TRWM3VEC(clumpRBP-&gt;inertia);
 
-	// these might be calculated from subBodies... but complicated
+	// these might be calculated from members... but complicated
 	clumpRBP-&gt;velocity=Vector3r(0,0,0);
 	clumpRBP-&gt;angularVelocity=Vector3r(0,0,0);
 
 	// update subBodySe3s; subtract clump orientation (apply its inverse first) to subBody's orientation
 	// Conjugate is equivalent to Inverse for normalized quaternions
-	for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
+	for(memberMap::iterator I=members.begin(); I!=members.end(); I++){
 		// now, I-&gt;first is Body::id_t, I-&gt;second is Se3r of that body
 		shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 		shared_ptr&lt;RigidBodyParameters&gt; subRBP=dynamic_pointer_cast&lt;RigidBodyParameters&gt;(subBody-&gt;physicalParameters);
@@ -277,10 +277,10 @@
 	#if 0
 		// update bounding box; we could have done this in previous loops, but this is cleaner
 		Vector3r min(0,0,0),max(0,0,0);
-		for(clumpMap::iterator I=subBodies.begin(); I!=subBodies.end(); I++){
+		for(memberMap::iterator I=members.begin(); I!=members.end(); I++){
 			shared_ptr&lt;Body&gt; subBody=Body::byId(I-&gt;first);
 			shared_ptr&lt;AABB&gt; subAabb=dynamic_pointer_cast&lt;AABB&gt;(subBody-&gt;boundingVolume);
-			if (I!=subBodies.begin()){min=componentMinVector(min,subAabb-&gt;center-subAabb-&gt;halfSize);	max=componentMinVector(max,subAabb-&gt;center+subAabb-&gt;halfSize);}
+			if (I!=members.begin()){min=componentMinVector(min,subAabb-&gt;center-subAabb-&gt;halfSize);	max=componentMinVector(max,subAabb-&gt;center+subAabb-&gt;halfSize);}
 			else {min=subAabb-&gt;center-subAabb-&gt;halfSize; max=subAabb-&gt;center+subAabb-&gt;halfSize;}
 		}
 		shared_ptr&lt;AABB&gt; aabb=dynamic_pointer_cast&lt;AABB&gt;(boundingVolume);
@@ -339,12 +339,13 @@
  ********************* ClumpTestGen ***************************************************
  **************************************************************************************/
 
-#include &lt;yade/yade-package-common/MetaInteractingGeometry2AABB.hpp&gt;
+#include &lt;yade/yade-core/MetaBody.hpp&gt;
+
+/*#include &lt;yade/yade-package-common/MetaInteractingGeometry2AABB.hpp&gt;
 #include &lt;yade/yade-package-common/MetaInteractingGeometry.hpp&gt;
 #include &lt;yade/yade-package-common/Box.hpp&gt;
 #include &lt;yade/yade-package-common/AABB.hpp&gt;
 #include &lt;yade/yade-package-common/Sphere.hpp&gt;
-#include &lt;yade/yade-core/MetaBody.hpp&gt;
 #include &lt;yade/yade-package-common/PersistentSAPCollider.hpp&gt;
 
 #include &lt;yade/yade-package-common/BodyRedirectionVector.hpp&gt;
@@ -374,7 +375,7 @@
 #include &lt;yade/yade-package-dem/ElasticCriterionTimeStepper.hpp&gt;
 #include &lt;yade/yade-package-dem/ElasticContactLaw.hpp&gt;
 
-#include&lt;yade/yade-extra/PythonRecorder.hpp&gt;
+#include&lt;yade/yade-extra/PythonRecorder.hpp&gt; */
 //#include &quot;ElasticCohesiveLaw.hpp&quot;
 //#include &quot;MacroMicroElasticRelationships.hpp&quot;
 //#include &quot;BodyMacroParameters.hpp&quot;
@@ -383,14 +384,108 @@
 // generate either random spheres, or (if not defined) regular one sphere and {1,2,3,4}-clumps
 //#define CLUMP_COMPLICATED
 
+string ClumpTestGen::generate()
+{
+	rootBody=Shop::rootBody();
+	Shop::setDefault(&quot;param_pythonExpr&quot;,&quot;if (S.i%50==0) and len(S.sel)&gt;=2:\n\tprint B[S.sel[0]].E\n\tprint '=========END OF OUTPUT==============='&quot;);
+	Shop::rootBodyActors(rootBody);
 
+	shared_ptr&lt;MetaBody&gt; oldRootBody=Omega::instance().getRootBody();
+	Omega::instance().setRootBody(rootBody);
+
+	shared_ptr&lt;Body&gt; ground=Shop::box(Vector3r(0,0,-1),Vector3r(3,3,.2));
+	ground-&gt;isDynamic=false;
+	rootBody-&gt;bodies-&gt;insert(ground);
+
+	vector&lt;Vector3r&gt; relPos; vector&lt;Real&gt; radii; Vector3r clumpPos;
+
+	// standalone (non-clump!) sphere as well
+	shared_ptr&lt;Body&gt; sphere=Shop::sphere(Vector3r(0,0,0),.5);
+	rootBody-&gt;bodies-&gt;insert(sphere);
+	// one-sphere clump
+	clumpPos=Vector3r(-2,0,0);
+	relPos.push_back(Vector3r(0,0,0)); radii.push_back(.5);
+	createOneClump(rootBody,clumpPos,relPos,radii);
+	relPos.clear(); radii.clear();
+	// two-sphere clump
+	clumpPos=Vector3r(2,0,0);
+	relPos.push_back(Vector3r(0,-.5,.5)); radii.push_back(.5);
+	relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
+	createOneClump(rootBody,clumpPos,relPos,radii);
+	relPos.clear(); radii.clear();
+	// three-sphere slump
+	clumpPos=Vector3r(0,2,0);
+	relPos.push_back(Vector3r(0,-.5,.5)); radii.push_back(.5);
+	relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
+	relPos.push_back(Vector3r(.5,0,0)); radii.push_back(.5);
+	createOneClump(rootBody,clumpPos,relPos,radii);
+	relPos.clear(); radii.clear();
+	// four-sphere slump
+	clumpPos=Vector3r(0,-2,0);
+	relPos.push_back(Vector3r(0,0,0)); radii.push_back(.5);
+	relPos.push_back(Vector3r(.5,0,0)); radii.push_back(.5);
+	relPos.push_back(Vector3r(0,.5,0)); radii.push_back(.5);
+	relPos.push_back(Vector3r(0,0,.5)); radii.push_back(.5);
+	createOneClump(rootBody,clumpPos,relPos,radii);
+	relPos.clear(); radii.clear();
+
+	// restore Omega
+	Omega::instance().setRootBody(oldRootBody);
+
+	return &quot;OK&quot;;
+}
+
+/*! \brief Generate clump of spheres, the result will be inserted into rootBody.
+ *
+ * To create a clump, first the clump itself needs to be instantiated \em and inserted into rootBody (this will assign an Body::id).
+ * In order for this to work, Omega::roootBody must have been assigned; within generators, use Omega::setRootBody for this.
+ *
+ * The body to add to clump must have been also created and added to the rootBody (so that it has id, again).
+ *
+ * Finally, call Clump::updateProperties to get physical properties physically right (inertia, position, orientation, mass, ...).
+ *
+ * @param clumpPos Center of the clump (not necessarily centroid); serves merely as reference for sphere positions.
+ * @param relPos Relative positions of individual spheres' centers.
+ * @param radii Radii of composing spheres. Must have the same length as relPos.
+ */
+void ClumpTestGen::createOneClump(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r clumpPos, vector&lt;Vector3r&gt; relPos, vector&lt;Real&gt; radii)
+{
+	assert(relPos.size()==radii.size());
+	
+	// empty clump	
+	shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
+	shared_ptr&lt;Body&gt; clumpAsBody=dynamic_pointer_cast&lt;Body&gt;(clump);
+	rootBody-&gt;bodies-&gt;insert(clumpAsBody);
+
+	clump-&gt;isDynamic=true;
+	// if subscribedBodies work some day: clumpMover-&gt;subscribedBodies.push_back(clump-&gt;getId());
+	
+	for(size_t i=0; i&lt;relPos.size(); i++){
+		shared_ptr&lt;Body&gt; sphere=Shop::sphere(clumpPos+relPos[i],radii[i]);
+		Body::id_t lastId=(Body::id_t)rootBody-&gt;bodies-&gt;insert(sphere);
+		clump-&gt;add(lastId);
+		LOG_TRACE(&quot;Generated clumped sphere #&quot;&lt;&lt;lastId);
+	}
+	clump-&gt;updateProperties(false);
+}
+
+
+
+
+
+
+
+#if 0
+
+
 string ClumpTestGen::generate()
 {
+	rootBody=Shop::rootBody();
 	{ // root body
 		rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody); rootBody-&gt;isDynamic=false;
 		shared_ptr&lt;ParticleParameters&gt; physics(new ParticleParameters); Quaternionr q; q.FromAxisAngle(Vector3r(0,0,1),0); physics-&gt;se3=Se3r(Vector3r(0,0,0),q); physics-&gt;mass=0; physics-&gt;velocity=Vector3r::ZERO; physics-&gt;acceleration=Vector3r::ZERO;
 		rootBody-&gt;physicalParameters=physics;
-		shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());	set-&gt;diffuseColor=Vector3f(0,0,1);
+		shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());	set-&gt;diffuseColor=Vector3r(0,0,1);
 		rootBody-&gt;interactingGeometry=dynamic_pointer_cast&lt;InteractingGeometry&gt;(set);	
 		shared_ptr&lt;AABB&gt; aabb(new AABB); aabb-&gt;diffuseColor=Vector3r(0,0,1);
 		rootBody-&gt;boundingVolume=dynamic_pointer_cast&lt;BoundingVolume&gt;(aabb);
@@ -415,9 +510,9 @@
 		ground-&gt;physicalParameters=physics;
 		shared_ptr&lt;AABB&gt; aabb(new AABB);aabb-&gt;diffuseColor=Vector3r(1,0,0);
 		ground-&gt;boundingVolume=aabb;
-		shared_ptr&lt;Box&gt; gBox(new Box);gBox-&gt;extents=extents; gBox-&gt;diffuseColor=Vector3f(1,1,1); gBox-&gt;wire=false; gBox-&gt;visible=true; gBox-&gt;shadowCaster=true;
+		shared_ptr&lt;Box&gt; gBox(new Box);gBox-&gt;extents=extents; gBox-&gt;diffuseColor=Vector3r(1,1,1); gBox-&gt;wire=false; gBox-&gt;visible=true; gBox-&gt;shadowCaster=true;
 		ground-&gt;geometricalModel=gBox;
-		shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox); iBox-&gt;extents=extents; iBox-&gt;diffuseColor=Vector3f(1,1,1);
+		shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox); iBox-&gt;extents=extents; iBox-&gt;diffuseColor=Vector3r(1,1,1);
 		ground-&gt;interactingGeometry=iBox;
 		rootBody-&gt;bodies-&gt;insert(ground);
 	}
@@ -551,12 +646,12 @@
 	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
 	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
 	iSphere-&gt;radius=radius;
-	iSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor=Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	body-&gt;interactingGeometry=iSphere;
 
 	//shape
 	gSphere-&gt;radius=radius;
-	gSphere-&gt;diffuseColor=Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor=Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire=false;
 	gSphere-&gt;visible=true;
 	gSphere-&gt;shadowCaster=true;
@@ -620,7 +715,7 @@
 	constitutiveLaw2-&gt;momentRotationLaw = momentRotationLaw;*/
 
 	// clumps will be subscribed later, as they are generated
-	clumpMover=shared_ptr&lt;ClumpSubBodyMover&gt;(new ClumpSubBodyMover);
+	clumpMover=shared_ptr&lt;ClumpMemberMover&gt;(new ClumpMemberMover);
 
 	
 	rootBody-&gt;engines.clear();
@@ -652,3 +747,4 @@
 	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
 }
 
+#endif

Modified: trunk/yade-extra/clump/Clump.hpp
===================================================================
--- trunk/yade-extra/clump/Clump.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-extra/clump/Clump.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -33,8 +33,8 @@
 	Clump is one of bodies that reside in rootBody-&gt;bodies.
 	When an existing body is added to ::Clump, it's ::Body::isDynamic flag is set to false
 	(it is still subscribed to all its engines, to make it possible to remove it from the clump again).
-	All forces acting on Clump::subBodies are made to act on the clump itself, which will ensure that they
-	influence all Clump::subBodies as if the clump were a rigid particle.
+	All forces acting on Clump::members are made to act on the clump itself, which will ensure that they
+	influence all Clump::members as if the clump were a rigid particle.
  
 	What are clump requirements so that they function?
 	-# Given any body, tell
@@ -46,17 +46,17 @@
 	-# given the root body, tell
 		- what clumps it contains (enumerate all bodies and filter clumps, see above)
 	-#	given a clump, tell
-		- what bodies it contains (keys of ::Clump::subBodies)
-		- what are se3 of these bodies (values of ::Clump::subBodies)
+		- what bodies it contains (keys of ::Clump::members)
+		- what are se3 of these bodies (values of ::Clump::members)
 	-# add/delete bodies from/to clump (::Clump::add, ::Clump::del)
 		- This includes saving se3 of the subBody: it \em must be in clump's local coordinates so that it is constant. The transformation from global to local is given by clump's se3 at the moment of addition. Clump's se3 is initially (origin,identity)
 	-# Update clump's physical properties (Clump::updateProperties)
-		- This \em must reposition subBodies so that they have the same se3 globally
-	-# Apply forces acting on subBodies to the clump instead (done in NewtonsForceLaw, NewtonsMomentumLaw) - uses world coordinates to calculate effect on the clump's centroid
+		- This \em must reposition members so that they have the same se3 globally
+	-# Apply forces acting on members to the clump instead (done in NewtonsForceLaw, NewtonsMomentumLaw) - uses world coordinates to calculate effect on the clump's centroid
 	-# Integrate position and orientation of the clump
 		- LeapFrogPositionIntegrator and LeapFrogOrientationIntegrator move clump as whole
 			- clump members are skipped, since they have Body::isDynamic==false. 
-		- ClumpSubBodyMover is an engine that updates positions of the clump memebers in each timestep (calls Clump::moveSubBodies internally)
+		- ClumpMemberMover is an engine that updates positions of the clump memebers in each timestep (calls Clump::moveSubBodies internally)
 
 	Some more information can be found <A HREF="http://beta.arcig.cz/~eudoxos/phd/index.cgi/YaDe/HighLevelClumps">http://beta.arcig.cz/~eudoxos/phd/index.cgi/YaDe/HighLevelClumps</A>
 
@@ -70,10 +70,10 @@
  */
 
 class Clump: public Body {
-		//! mapping of body IDs to their relative positions; replaces subBodies and subSe3s;
+		//! mapping of body IDs to their relative positions; replaces members and subSe3s;
 	public:
-		typedef std::map&lt;Body::id_t,Se3r&gt; clumpMap;
-		clumpMap subBodies;
+		typedef std::map&lt;Body::id_t,Se3r&gt; memberMap;
+		memberMap members;
 
 		Clump();
 		virtual ~Clump(){};
@@ -83,8 +83,8 @@
 		void del(Body::id_t);
 		//! Recalculate physical properties of Clump.
 		void updateProperties(bool intersecting);
-		//! Calculate positions and orientations of subBodies based on my own Se3.
-		void moveSubBodies();
+		//! Calculate positions and orientations of members based on my own Se3.
+		void moveMembers();
 	private: // may be made public, but once properly tested...
 		//! Recalculates inertia tensor of a body after translation away from (default) or towards its centroid.
 		static Matrix3r inertiaTensorTranslate(const Matrix3r&amp; I,const Real m, const Vector3r&amp; off);
@@ -93,7 +93,7 @@
 		//! Recalculate body's inertia tensor in rotated coordinates.
 		static Matrix3r inertiaTensorRotate(const Matrix3r&amp; I, const Quaternionr&amp; rot);
 
-	void registerAttributes(){Body::registerAttributes(); REGISTER_ATTRIBUTE(subBodies);}
+	void registerAttributes(){Body::registerAttributes(); REGISTER_ATTRIBUTE(members);}
 	REGISTER_CLASS_NAME(Clump);
 	REGISTER_BASE_CLASS_NAME(Body);
 	// REGISTER_CLASS_INDEX(Clump,Body);
@@ -102,24 +102,24 @@
 
 REGISTER_SERIALIZABLE(Clump,false);
 
-/*! Update ::Clump::subBodies positions so that the Clump behaves as a rigid body.
+/*! Update ::Clump::members positions so that the Clump behaves as a rigid body.
  *
  *
 */
-class ClumpSubBodyMover: public DeusExMachina {
+class ClumpMemberMover: public DeusExMachina {
 	public:
 		//! Interates over rootBody-&gt;bodies and calls Clump::moveSubBodies() for clumps.
 		virtual void applyCondition(Body* rootBody);
-		ClumpSubBodyMover();
-		virtual ~ClumpSubBodyMover(){};
+		ClumpMemberMover();
+		virtual ~ClumpMemberMover(){};
 
-	REGISTER_CLASS_NAME(ClumpSubBodyMover);
+	REGISTER_CLASS_NAME(ClumpMemberMover);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
-	// REGISTER_CLASS_INDEX(ClumpSubBodyMover,PhysicalParametersEngineUnit);
+	// REGISTER_CLASS_INDEX(ClumpMemberMover,PhysicalParametersEngineUnit);
 	DECLARE_LOGGER;
 };
 
-REGISTER_SERIALIZABLE(ClumpSubBodyMover,false);
+REGISTER_SERIALIZABLE(ClumpMemberMover,false);
 
 /*! \brief Test some basic clump functionality; show how to use clumps as well. */
 class ClumpTestGen : public FileGenerator {
@@ -131,12 +131,12 @@
 		//bool		 rotationBlocked;
 		//void createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents);
 		void createOneClump(shared_ptr&lt;MetaBody&gt;&amp; rootBody, Vector3r clumpPos, vector&lt;Vector3r&gt; relPos, vector&lt;Real&gt; radii);
-		shared_ptr&lt;Body&gt; createOneSphere(Vector3r position, Real radius);
-		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
+		//shared_ptr&lt;Body&gt; createOneSphere(Vector3r position, Real radius);
+		//void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		//void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
 		//void calculatePropertiesAndReposition(const shared_ptr&lt;SlumShape&gt;&amp; slum, shared_ptr&lt;ElasticBodyParameters&gt;&amp; rbp, Real density);
 		//void makeTet(shared_ptr&lt;Tetrahedron&gt;&amp; tet, Real radius);
-		shared_ptr&lt;ClumpSubBodyMover&gt; clumpMover;
+		shared_ptr&lt;ClumpMemberMover&gt; clumpMover;
 	public :
 		ClumpTestGen (){};
 		~ClumpTestGen (){};

Modified: trunk/yade-extra/clump/SConscript
===================================================================
--- trunk/yade-extra/clump/SConscript	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-extra/clump/SConscript	2007-02-26 19:24:57 UTC (rev 1074)
@@ -3,6 +3,57 @@
 	env.SharedLibrary('Clump',
 		['Clump.cpp'],
 		LIBS=env['LIBS']+[
+			#'ElasticContactLaw',
+			#'ElasticCohesiveLaw',
+			#'MacroMicroElasticRelationships',
+			#'ElasticCriterionTimeStepper',
+			#'PhysicalActionVectorVector',
+			#'InteractionVecSet',
+			#'BodyRedirectionVector',
+			#'InteractingSphere',
+			#'InteractingBox',
+			#'CundallNonViscousMomentumDamping',
+			#'CundallNonViscousForceDamping',
+			#'MetaInteractingGeometry',
+			#'GravityEngine',
+			#'yade-lib-serialization',
+			#'yade-lib-base',
+			#'Wm3Foundation',
+			#'PhysicalActionContainerInitializer',
+			#'PhysicalActionContainerReseter',
+			#'InteractionGeometryMetaEngine',
+			#'InteractionPhysicsMetaEngine',
+			#'PhysicalActionApplier',
+			#'PhysicalParametersMetaEngine',
+			#'BoundingVolumeMetaEngine',
+			#'Box',
+			#'Sphere',
+			#'AABB',
+			#'PersistentSAPCollider',
+			#'ParticleParameters',
+			#'SAPCollider',
+			#'MetaInteractingGeometry2AABB',
+			#'PythonRecorder',
+			#'yade-lib-multimethods',
+			'Shop'],
+		LIBPATH=env['LIBPATH']),
+	#env.Program('tryI',['tryI.cpp'],LIBS=env['LIBS']+['yade-lib-base','Wm3Foundation'])
+	#	LIBS=env['LIBS']+[
+	#		'yade-lib-serialization',
+	#		'yade-lib-base',
+	#		'Wm3Foundation',])
+	#env.Program('pyrec',['pyrec.cpp'])
+	#env.SharedLibrary('emb',['emb.cc'],SHLIBPREFIX='')
+	## PythonRecorder
+	env.SharedLibrary('PythonRecorder',['PythonRecorder.cpp']),
+	env.SharedLibrary('_pyade',['pyade.cpp'],SHLIBPREFIX='',
+		LIBS=env['LIBS']+['yade-lib-base','Wm3Foundation','ParticleParameters','RigidBodyParameters'],
+	),
+	env.File('pyade.py'),
+
+	env.SharedLibrary('Shop',
+		['Shop.cpp'],
+		LIBS=env['LIBS']+[
 			'ElasticContactLaw',
 			'ElasticCohesiveLaw',
 			'MacroMicroElasticRelationships',
@@ -34,19 +85,5 @@
 			'SAPCollider',
 			'MetaInteractingGeometry2AABB',
 			'PythonRecorder',
-			'yade-lib-multimethods'],
-		LIBPATH=env['LIBPATH']),
-	#env.Program('tryI',['tryI.cpp'],LIBS=env['LIBS']+['yade-lib-base','Wm3Foundation'])
-	#	LIBS=env['LIBS']+[
-	#		'yade-lib-serialization',
-	#		'yade-lib-base',
-	#		'Wm3Foundation',])
-	#env.Program('pyrec',['pyrec.cpp'])
-	#env.SharedLibrary('emb',['emb.cc'],SHLIBPREFIX='')
-	## PythonRecorder
-	env.SharedLibrary('PythonRecorder',['PythonRecorder.cpp']),
-	env.SharedLibrary('_pyade',['pyade.cpp'],SHLIBPREFIX='',
-		LIBS=env['LIBS']+['yade-lib-base','Wm3Foundation','ParticleParameters','RigidBodyParameters'],
-	),
-	env.File('pyade.py'),
+			'yade-lib-multimethods']),
 ])

Added: trunk/yade-extra/clump/Shop.cpp
===================================================================
--- trunk/yade-extra/clump/Shop.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-extra/clump/Shop.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -0,0 +1,289 @@
+// 2007 &#194;&#169; V&#195;&#161;clav &#197;&#160;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt;
+#include&quot;Shop.hpp&quot;
+
+#include&lt;yade/yade-core/MetaBody.hpp&gt;
+#include&lt;yade/yade-core/Body.hpp&gt;
+
+#include&lt;yade/yade-package-common/MetaInteractingGeometry2AABB.hpp&gt;
+#include&lt;yade/yade-package-common/MetaInteractingGeometry.hpp&gt;
+#include&lt;yade/yade-package-common/Box.hpp&gt;
+#include&lt;yade/yade-package-common/AABB.hpp&gt;
+#include&lt;yade/yade-package-common/Sphere.hpp&gt;
+#include&lt;yade/yade-package-common/PersistentSAPCollider.hpp&gt;
+
+#include&lt;yade/yade-package-common/BodyRedirectionVector.hpp&gt;
+#include&lt;yade/yade-package-common/InteractionVecSet.hpp&gt;
+#include&lt;yade/yade-package-common/PhysicalActionVectorVector.hpp&gt;
+
+#include&lt;yade/yade-package-common/InteractingBox.hpp&gt;
+#include&lt;yade/yade-package-common/InteractingSphere.hpp&gt;
+
+
+#include&lt;yade/yade-package-common/PhysicalActionContainerReseter.hpp&gt;
+#include&lt;yade/yade-package-common/PhysicalActionContainerInitializer.hpp&gt;
+#include&lt;yade/yade-package-common/PhysicalParametersMetaEngine.hpp&gt;
+
+#include&lt;yade/yade-package-common/InteractionGeometryMetaEngine.hpp&gt;
+#include&lt;yade/yade-package-common/InteractionPhysicsMetaEngine.hpp&gt;
+#include&lt;yade/yade-package-common/BoundingVolumeMetaEngine.hpp&gt;
+#include&lt;yade/yade-package-common/PhysicalActionDamper.hpp&gt;
+#include&lt;yade/yade-package-common/PhysicalActionApplier.hpp&gt;
+#include&lt;yade/yade-package-common/CundallNonViscousForceDamping.hpp&gt;
+#include&lt;yade/yade-package-common/CundallNonViscousMomentumDamping.hpp&gt;
+#include&lt;yade/yade-package-common/GravityEngine.hpp&gt;
+
+#include&lt;yade/yade-package-dem/BodyMacroParameters.hpp&gt;
+#include&lt;yade/yade-package-dem/ElasticCriterionTimeStepper.hpp&gt;
+#include&lt;yade/yade-package-dem/ElasticContactLaw.hpp&gt;
+#include&lt;yade/yade-package-dem/ElasticCohesiveLaw.hpp&gt;
+
+#include&lt;yade/yade-extra/PythonRecorder.hpp&gt;
+#include&lt;yade/yade-extra/Clump.hpp&gt;
+//#include &quot;BodyMacroParameters.hpp&quot;
+
+
+#define _SPEC_CAST(orig,cast) template&lt;&gt; void Shop::setDefault&lt;orig&gt;(string key, orig val){setDefault(key,cast(val));}
+_SPEC_CAST(const char*,string);
+_SPEC_CAST(char*,string);
+_SPEC_CAST(int,long);
+_SPEC_CAST(unsigned int,long);
+_SPEC_CAST(unsigned long,long);
+#undef _SPEC_CAST
+
+map&lt;string,boost::any&gt; Shop::defaults;
+
+void Shop::init(){
+	defaults[&quot;container_is_not_empty&quot;]=boost::any(0); // prevent loops from ensureInit();
+
+	setDefault(&quot;body_sdecGroupMask&quot;,55);
+	
+	setDefault(&quot;phys_density&quot;,2e3);
+	setDefault(&quot;phys_young&quot;,4e7);
+	setDefault(&quot;phys_poisson&quot;,.3);
+	setDefault(&quot;phys_frictionAngle&quot;,0.5236); //30&#203;&#154;
+	setDefault(&quot;phys_se3_orientation&quot;,Quaternionr(Vector3r(0,0,1),0));
+
+	setDefault(&quot;aabb_randomColor&quot;,false);
+	setDefault(&quot;aabb_color&quot;,Vector3r(0,1,0));
+
+	setDefault(&quot;mold_randomColor&quot;,true);
+	setDefault(&quot;mold_color&quot;,Vector3r(1,0,0));
+
+	setDefault(&quot;shape_randomColor&quot;,true);
+	setDefault(&quot;shape_color&quot;,Vector3r(0,0,1));
+
+	setDefault(&quot;shape_wire&quot;,false);
+	setDefault(&quot;shape_visible&quot;,true);
+	setDefault(&quot;shape_shadowCaster&quot;,true);
+
+	setDefault(&quot;param_damping&quot;,.2);
+	setDefault(&quot;param_gravity&quot;,Vector3r(0,0,-10));
+	setDefault(&quot;param_timeStepUpdateInterval&quot;,300);
+	setDefault(&quot;param_momentRotationLaw&quot;,true);
+
+	setDefault(&quot;param_python&quot;,false);
+
+}
+
+/*! Create root body. */
+shared_ptr&lt;MetaBody&gt; Shop::rootBody(){
+	shared_ptr&lt;MetaBody&gt; rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
+	rootBody-&gt;isDynamic=false;
+	
+	shared_ptr&lt;ParticleParameters&gt; physics(new ParticleParameters);
+	physics-&gt;se3=Se3r(Vector3r(0,0,0),Quaternionr(Vector3r(0,0,1),0));
+	physics-&gt;mass=0;
+	physics-&gt;velocity=Vector3r::ZERO;
+	physics-&gt;acceleration=Vector3r::ZERO;
+	rootBody-&gt;physicalParameters=physics;
+
+	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());	set-&gt;diffuseColor=Vector3r(0,0,1);
+	rootBody-&gt;interactingGeometry=dynamic_pointer_cast&lt;InteractingGeometry&gt;(set);	
+	
+	shared_ptr&lt;AABB&gt; aabb(new AABB); aabb-&gt;diffuseColor=Vector3r(0,0,1);
+	rootBody-&gt;boundingVolume=dynamic_pointer_cast&lt;BoundingVolume&gt;(aabb);
+	
+	rootBody-&gt;persistentInteractions=shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
+	rootBody-&gt;transientInteractions=shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
+	rootBody-&gt;physicalActions=shared_ptr&lt;PhysicalActionContainer&gt;(new PhysicalActionVectorVector);
+	rootBody-&gt;bodies=shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
+
+	return rootBody;
+}
+
+
+/*! Assign default set of actors (initializers and engines) to an existing MetaBody.
+ */
+void Shop::rootBodyActors(shared_ptr&lt;MetaBody&gt; rootBody){
+	// initializers	
+	rootBody-&gt;initializers.clear();
+
+	shared_ptr&lt;PhysicalActionContainerInitializer&gt; physicalActionInitializer(new PhysicalActionContainerInitializer);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Force&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Momentum&quot;);
+	rootBody-&gt;initializers.push_back(physicalActionInitializer);
+	
+	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;AABB&quot;,&quot;InteractingSphere2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingBox&quot;,&quot;AABB&quot;,&quot;InteractingBox2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;MetaInteractingGeometry&quot;,&quot;AABB&quot;,&quot;MetaInteractingGeometry2AABB&quot;);
+	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
+
+	//engines
+	rootBody-&gt;engines.clear();
+
+	if(getDefault&lt;long&gt;(&quot;param_timeStepUpdateInterval&quot;)&gt;0){
+		shared_ptr&lt;ElasticCriterionTimeStepper&gt; sdecTimeStepper(new ElasticCriterionTimeStepper);
+		sdecTimeStepper-&gt;sdecGroupMask=getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
+		sdecTimeStepper-&gt;timeStepUpdateInterval=getDefault&lt;long&gt;(&quot;param_timeStepUpdateInterval&quot;);
+		rootBody-&gt;engines.push_back(sdecTimeStepper);
+	}
+
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PhysicalActionContainerReseter));
+
+	rootBody-&gt;engines.push_back(boundingVolumeDispatcher);
+
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PersistentSAPCollider));
+
+	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
+	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;InteractingSphere&quot;,&quot;InteractingSphere2InteractingSphere4SpheresContactGeometry&quot;);
+	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;InteractingBox&quot;,&quot;InteractingBox2InteractingSphere4SpheresContactGeometry&quot;);
+	rootBody-&gt;engines.push_back(interactionGeometryDispatcher);
+
+	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; interactionPhysicsDispatcher(new InteractionPhysicsMetaEngine);
+	interactionPhysicsDispatcher-&gt;add(&quot;BodyMacroParameters&quot;,&quot;BodyMacroParameters&quot;,&quot;MacroMicroElasticRelationships&quot;);
+	rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
+		
+	shared_ptr&lt;ElasticContactLaw&gt; constitutiveLaw(new ElasticContactLaw);
+	constitutiveLaw-&gt;sdecGroupMask = getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
+	constitutiveLaw-&gt;momentRotationLaw = getDefault&lt;bool&gt;(&quot;param_momentRotationLaw&quot;);
+	rootBody-&gt;engines.push_back(constitutiveLaw);
+
+	shared_ptr&lt;ElasticCohesiveLaw&gt; constitutiveLaw2(new ElasticCohesiveLaw);
+	constitutiveLaw2-&gt;sdecGroupMask = getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;);
+	constitutiveLaw2-&gt;momentRotationLaw = getDefault&lt;bool&gt;(&quot;param_momentRotationLaw&quot;);
+	rootBody-&gt;engines.push_back(constitutiveLaw2);
+	
+	if(getDefault&lt;Vector3r&gt;(&quot;param_gravity&quot;)!=Vector3r(0,0,0)){
+		shared_ptr&lt;GravityEngine&gt; gravityCondition(new GravityEngine);
+		gravityCondition-&gt;gravity=getDefault&lt;Vector3r&gt;(&quot;param_gravity&quot;);
+		rootBody-&gt;engines.push_back(gravityCondition);
+	}
+	
+	if(getDefault&lt;double&gt;(&quot;param_damping&quot;)&gt;0){
+		shared_ptr&lt;CundallNonViscousForceDamping&gt; actionForceDamping(new CundallNonViscousForceDamping);
+		actionForceDamping-&gt;damping = getDefault&lt;double&gt;(&quot;param_damping&quot;);
+		shared_ptr&lt;CundallNonViscousMomentumDamping&gt; actionMomentumDamping(new CundallNonViscousMomentumDamping);
+		actionMomentumDamping-&gt;damping = getDefault&lt;double&gt;(&quot;param_damping&quot;);
+		shared_ptr&lt;PhysicalActionDamper&gt; actionDampingDispatcher(new PhysicalActionDamper);
+		actionDampingDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;CundallNonViscousForceDamping&quot;,actionForceDamping);
+		actionDampingDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;CundallNonViscousMomentumDamping&quot;,actionMomentumDamping);
+		rootBody-&gt;engines.push_back(actionDampingDispatcher);
+	}
+	
+	shared_ptr&lt;PhysicalActionApplier&gt; applyActionDispatcher(new PhysicalActionApplier);
+	applyActionDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;NewtonsForceLaw&quot;);
+	applyActionDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;NewtonsMomentumLaw&quot;);
+	rootBody-&gt;engines.push_back(applyActionDispatcher);
+	
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; positionIntegrator(new PhysicalParametersMetaEngine);
+	positionIntegrator-&gt;add(&quot;ParticleParameters&quot;,&quot;LeapFrogPositionIntegrator&quot;);
+	rootBody-&gt;engines.push_back(positionIntegrator);
+
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
+	orientationIntegrator-&gt;add(&quot;RigidBodyParameters&quot;,&quot;LeapFrogOrientationIntegrator&quot;);
+	rootBody-&gt;engines.push_back(orientationIntegrator);
+
+	// clumps do not need to subscribe currently (that will most likely change, though)
+	rootBody-&gt;engines.push_back(shared_ptr&lt;ClumpMemberMover&gt;(new ClumpMemberMover));
+
+	#ifdef EMBED_PYTHON
+		if(getDefault&lt;string&gt;(&quot;param_pythonExpr&quot;).size()&gt;0){
+			shared_ptr&lt;PythonRecorder&gt; pythonRecorder=shared_ptr&lt;PythonRecorder&gt;(new PythonRecorder);
+			pythonRecorder-&gt;expression=getDefault&lt;string&gt;(&quot;param_pythonExpr&quot;);
+			rootBody-&gt;engines.push_back(pythonRecorder);
+		}
+	#endif
+}
+
+
+/*! Create body - sphere. */
+shared_ptr&lt;Body&gt; Shop::sphere(Vector3r center, Real radius){
+	// body itself
+	shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;)));
+	body-&gt;isDynamic=true;
+
+	// physics
+	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+	physics-&gt;angularVelocity=Vector3r(0,0,0);
+	physics-&gt;velocity=Vector3r(0,0,0);
+	physics-&gt;mass=4.0/3.0*Mathr::PI*radius*radius*radius*getDefault&lt;double&gt;(&quot;phys_density&quot;);
+	physics-&gt;inertia=Vector3r(2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius,2.0/5.0*physics-&gt;mass*radius*radius);
+	physics-&gt;se3=Se3r(center,Quaternionr(Vector3r(0,0,1),0));
+	physics-&gt;young=getDefault&lt;double&gt;(&quot;phys_young&quot;);
+	physics-&gt;poisson=getDefault&lt;double&gt;(&quot;phys_poisson&quot;);
+	physics-&gt;frictionAngle=getDefault&lt;double&gt;(&quot;phys_frictionAngle&quot;);
+	body-&gt;physicalParameters=physics;
+
+	// aabb
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	aabb-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;aabb_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;aabb_color&quot;);
+	body-&gt;boundingVolume=aabb;
+
+	// mold
+	shared_ptr&lt;InteractingSphere&gt; mold(new InteractingSphere);
+	mold-&gt;radius=radius;
+	mold-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;mold_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;mold_color&quot;);
+	body-&gt;interactingGeometry=mold;
+
+	//shape
+	shared_ptr&lt;Sphere&gt; shape(new Sphere);
+	shape-&gt;radius=radius;
+	shape-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;shape_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;shape_color&quot;);
+	shape-&gt;wire=getDefault&lt;bool&gt;(&quot;shape_wire&quot;);
+	shape-&gt;visible=getDefault&lt;bool&gt;(&quot;shape_visible&quot;);
+	shape-&gt;shadowCaster=getDefault&lt;bool&gt;(&quot;shape_shadowCaster&quot;);
+	body-&gt;geometricalModel=shape;
+
+	return body;
+
+}
+
+/*! Create body - box. */
+shared_ptr&lt;Body&gt; Shop::box(Vector3r center, Vector3r extents){
+		shared_ptr&lt;Body&gt; body=shared_ptr&lt;Body&gt;(new Body(0,getDefault&lt;long&gt;(&quot;body_sdecGroupMask&quot;)));
+		body-&gt;isDynamic=true;
+
+		shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+		physics-&gt;angularVelocity=Vector3r(0,0,0);
+		physics-&gt;velocity=Vector3r(0,0,0);
+		physics-&gt;mass=8*extents[0]*extents[1]*extents[2]*getDefault&lt;double&gt;(&quot;phys_density&quot;);
+		physics-&gt;inertia=Vector3r(physics-&gt;mass*(4*extents[1]*extents[1]+4*extents[2]*extents[2])/12.,physics-&gt;mass*(4*extents[0]*extents[0]+4*extents[2]*extents[2])/12.,physics-&gt;mass*(4*extents[0]*extents[0]+4*extents[1]*extents[1])/12.);
+		physics-&gt;se3=Se3r(center,Quaternionr(Vector3r(0,0,1),0));
+		physics-&gt;young=getDefault&lt;double&gt;(&quot;phys_young&quot;);
+		physics-&gt;poisson=getDefault&lt;double&gt;(&quot;phys_poisson&quot;);
+		physics-&gt;frictionAngle=getDefault&lt;double&gt;(&quot;phys_frictionAngle&quot;);
+		body-&gt;physicalParameters=physics;
+
+		// aabb
+		shared_ptr&lt;AABB&gt; aabb(new AABB);
+		aabb-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;aabb_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;aabb_color&quot;);
+		body-&gt;boundingVolume=aabb;
+
+		//shape
+		shared_ptr&lt;Box&gt; shape(new Box);
+		shape-&gt;extents=extents;
+		shape-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;shape_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;shape_color&quot;);
+		shape-&gt;wire=getDefault&lt;bool&gt;(&quot;shape_wire&quot;);
+		shape-&gt;visible=getDefault&lt;bool&gt;(&quot;shape_visible&quot;);
+		shape-&gt;shadowCaster=getDefault&lt;bool&gt;(&quot;shape_shadowCaster&quot;);
+		body-&gt;geometricalModel=shape;
+
+		// mold
+		shared_ptr&lt;InteractingBox&gt; mold(new InteractingBox);
+		mold-&gt;extents=extents;
+		mold-&gt;diffuseColor=getDefault&lt;bool&gt;(&quot;mold_randomColor&quot;)?Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom()):getDefault&lt;Vector3r&gt;(&quot;mold_color&quot;);
+		body-&gt;interactingGeometry=mold;
+
+		return body;
+}

Added: trunk/yade-extra/clump/Shop.hpp
===================================================================
--- trunk/yade-extra/clump/Shop.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-extra/clump/Shop.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -0,0 +1,45 @@
+// 2007 &#194;&#169; V&#195;&#161;clav &#197;&#160;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt;
+
+#include&lt;string&gt;
+#include&lt;map&gt;
+#include&lt;iostream&gt;
+#include&lt;boost/any.hpp&gt;
+#include&lt;boost/shared_ptr.hpp&gt;
+
+#include&lt;Wm3Vector3.h&gt;
+#include&lt;Wm3Quaternion.h&gt;
+#include&lt;yade/yade-lib-base/yadeWm3.hpp&gt;
+
+/*
+#include&lt;yade/yade-core/MetaBody.hpp&gt;
+#include&lt;yade/yade-core/Body.hpp&gt;
+#include&lt;yade/yade-core/Omega.hpp&gt;
+*/
+class MetaBody;
+class Body;
+
+using namespace std;
+using boost::shared_ptr;
+
+class Shop{
+	private:
+	public:
+		/*! map of &lt;attribute name,value&gt;. */
+		static map&lt;string,boost::any&gt; defaults;
+		/*! fills Shop::defaults with values. Called automatically. */ 
+		static void init();
+		/*! Calls Shop::init if Shop::defaults is empty (when setting or getting a default). */
+		static void ensureInit(){if(defaults.size()==0) init();}
+	public:
+		/*! Retrieve default value from the map. User is responsible for casting it to the right type. */
+		template &lt;typename valType&gt; static valType getDefault(string key){ensureInit(); return boost::any_cast&lt;valType&gt;(defaults[key]);}
+		//template &lt;typename valType&gt; static valType getDefault(string key){ensureInit(); return boost::any_cast&lt;valType&gt;(defaults[key]);}
+		/*! Set the default value. Overrides existing value or creates new entry. Integer types are always cast to long (be careful when retrieving them). */
+		template &lt;typename valType&gt; static void setDefault(string key, const valType value){ensureInit(); defaults[key]=boost::any(value);}
+
+		static shared_ptr&lt;MetaBody&gt; rootBody();
+		static void rootBodyActors(shared_ptr&lt;MetaBody&gt;);
+		static shared_ptr&lt;Body&gt; sphere(Vector3r center, Real radius);
+		static shared_ptr&lt;Body&gt; box(Vector3r center, Vector3r extents);
+};
+

Modified: trunk/yade-guis/yade-gui-qt/src/QtGUI/GLEngineEditor.hpp
===================================================================
--- trunk/yade-guis/yade-gui-qt/src/QtGUI/GLEngineEditor.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-guis/yade-gui-qt/src/QtGUI/GLEngineEditor.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -44,7 +44,7 @@
 		int endX;
 		int endY;
 		int selectedEngine;
-		Vector3f savedColor;
+		Vector3r savedColor;
 		int firstEngine;
 
 		void drawGrid();

Modified: trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp
===================================================================
--- trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-guis/yade-gui-qt/src/QtGUI/GLViewer.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -159,9 +159,8 @@
 			#ifdef HIGHLEVEL_CLUMPS
 				shared_ptr&lt;Body&gt; b=Body::byId(selection);
 				if(b-&gt;isClump()){
-					Clump* c=dynamic_cast&lt;Clump*&gt;(Body::byId(b-&gt;clumpId).get());
-					c-&gt;moveSubBodies();
-					//for(Clump::clumpMap::iterator I=c-&gt;subBodies.begin(); I!=c-&gt;subBodies.end(); I++)renderer-&gt;render(Omega::instance().getRootBody(), I-&gt;first);
+					Clump* clump=dynamic_cast&lt;Clump*&gt;(Body::byId(b-&gt;clumpId).get());
+					clump-&gt;moveMembers();
 				}
 			#endif
 		}

Modified: trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/GLWindow.hpp
===================================================================
--- trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/GLWindow.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/GLWindow.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -65,6 +65,7 @@
 		
 		void setBackgroundColor(float r, float g, float b) { color[0] = r; color[1] = g; color[2] = b;};	
 		void getBackgroundColor(float&amp; r, float&amp; g, float&amp; b) { r=color[0]; g=color[1]; b=color[2];};	
+		void getBackgroundColor(double&amp; r, double&amp; g, double&amp; b) { r=color[0]; g=color[1]; b=color[2];};	
 		
 		void setSelectionColor(float r, float g, float b) { selectionColor[0] = r; selectionColor[1] = g; selectionColor[2] = b;};		
 		void setBorderColor(float r, float g, float b) { borderColor[0] = r; borderColor[1] = g; borderColor[2] = b;};			

Modified: trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/OpenGLWrapper.hpp
===================================================================
--- trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/OpenGLWrapper.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-libs/yade-lib-opengl/src/yade-lib-opengl/OpenGLWrapper.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -249,6 +249,7 @@
 template&lt; &gt; inline void glRect&lt; short &gt;			(short	x1,short  y1,short x2,short y2 )	{	glRects(x1,y1,x2,y2);	};
 
 template&lt; &gt; inline void glMaterial&lt; float &gt;			( GLenum face, GLenum pname, float param )			{	glMaterialf(face,pname,param);		};
+template&lt; &gt; inline void glMaterial&lt; double &gt;			( GLenum face, GLenum pname, double param )			{	glMaterialf(face,pname,param);		};
 template&lt; &gt; inline void glMaterial&lt; int &gt;			( GLenum face, GLenum pname, int param )			{	glMateriali(face,pname,param);		};
 template&lt; &gt; inline void glMaterialv&lt; Vector3&lt;float&gt; &gt;		( GLenum face, GLenum pname, const Vector3&lt;float&gt; params )	{	glMaterialfv(face,pname,params);	};
 template&lt; &gt; inline void glMaterialv&lt; Vector3&lt;int&gt; &gt;		( GLenum face, GLenum pname, const Vector3&lt;int&gt; params )	{	glMaterialiv(face,pname,params);	};

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox/GLDrawBox.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox/GLDrawBox.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawBox/GLDrawBox.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -16,7 +16,7 @@
 void GLDrawBox::go(const shared_ptr&lt;GeometricalModel&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)
 {
 	// FIXME : check that : one of those 2 lines are useless
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
 	
 	Vector3r &amp;extents = (static_cast&lt;Box*&gt;(gm.get()))-&gt;extents;

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral/GLDrawQuadrilateral.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral/GLDrawQuadrilateral.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral/GLDrawQuadrilateral.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -11,12 +11,12 @@
 #include &lt;yade/yade-core/MetaBody.hpp&gt;
 #include &lt;yade/yade-lib-opengl/OpenGLWrapper.hpp&gt;
 
-Vector3f makeColor(double val,double min,double max)
+Vector3r makeColor(double val,double min,double max)
 {
 	Real sc01 = ((val-min)/(max-min))*2.0-1.0;
-	if(sc01 &lt; 0) return Vector3f(0.9,0.9,1.0) + sc01 * Vector3f(0.9,0.9,0.0);
-	if(sc01 &gt; 0) return Vector3f(1.0,0.9,0.9) - sc01 * Vector3f(0.0,0.9,0.9);
-	return Vector3f(0.9,0.9,0.9);
+	if(sc01 &lt; 0) return Vector3r(0.9,0.9,1.0) + sc01 * Vector3r(0.9,0.9,0.0);
+	if(sc01 &gt; 0) return Vector3r(1.0,0.9,0.9) - sc01 * Vector3r(0.0,0.9,0.9);
+	return Vector3r(0.9,0.9,0.9);
 }
 
 void GLDrawQuadrilateral::go(const shared_ptr&lt;GeometricalModel&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere/GLDrawSphere.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere/GLDrawSphere.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere/GLDrawSphere.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -88,7 +88,7 @@
 	
 	Real radius = (static_cast&lt;Sphere*&gt;(gm.get()))-&gt;radius;
 	
-	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
  	if (gm-&gt;wire || wire)
  	{

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron/GLDrawTetrahedron.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron/GLDrawTetrahedron.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron/GLDrawTetrahedron.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -15,7 +15,7 @@
 void GLDrawTetrahedron::go(const shared_ptr&lt;GeometricalModel&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)
 {
 	// FIXME : check that : one of those 2 lines are useless
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
 	
 	Tetrahedron* tet = static_cast&lt;Tetrahedron*&gt;(gm.get());

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox/GLDrawInteractingBox.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox/GLDrawInteractingBox.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox/GLDrawInteractingBox.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -13,7 +13,7 @@
 void GLDrawInteractingBox::go(const shared_ptr&lt;InteractingGeometry&gt;&amp; cg, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool)
 {
 	// FIXME : check that : one of those 2 lines are useless
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, cg-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(cg-&gt;diffuseColor[0],cg-&gt;diffuseColor[1],cg-&gt;diffuseColor[2]));
 	glColor3v(cg-&gt;diffuseColor);
 	
 	Vector3r &amp;extents = (static_cast&lt;InteractingBox*&gt;(cg.get()))-&gt;extents;

Modified: trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere/GLDrawInteractingSphere.cpp
===================================================================
--- trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere/GLDrawInteractingSphere.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-common/src/RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere/GLDrawInteractingSphere.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -77,7 +77,7 @@
 	
 	Real radius = (static_cast&lt;InteractingSphere*&gt;(cm.get()))-&gt;radius;
 	
-	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, cm-&gt;diffuseColor);
+	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(cm-&gt;diffuseColor[0],cm-&gt;diffuseColor[1],cm-&gt;diffuseColor[2]));
 	glColor3v(cm-&gt;diffuseColor);
 // 	if (cm-&gt;wire)
 // 	{

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/Funnel/Funnel.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/Funnel/Funnel.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/Funnel/Funnel.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -205,13 +205,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(0.8,0.3,0.3);
+	iSphere-&gt;diffuseColor		= Vector3r(0.8,0.3,0.3);
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -252,13 +252,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -345,7 +345,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 		
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 	
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -83,7 +83,7 @@
 	wall_2_wire		= true;
 	wall_3_wire		= true;
 	wall_4_wire		= true;
-	spheresColor		= Vector3f(0.8,0.3,0.3);
+	spheresColor		= Vector3r(0.8,0.3,0.3);
 	spheresRandomColor	= false;
 	recordBottomForce	= true;
 	forceRecordFile		= &quot;../data/force&quot;;
@@ -395,7 +395,7 @@
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -436,13 +436,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -552,7 +552,7 @@
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
 	
-	set-&gt;diffuseColor		= Vector3f(0,0,1);
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor		= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.hpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECImpactTest/SDECImpactTest.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -24,7 +24,7 @@
 				,lowerCorner
 				,upperCorner;
 
-		Vector3f	 spheresColor;
+		Vector3r	 spheresColor;
 
 		Real		 thickness
 				,sphereYoungModulus

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres/SDECLinkedSpheres.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres/SDECLinkedSpheres.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECLinkedSpheres/SDECLinkedSpheres.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -250,13 +250,13 @@
 
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -296,13 +296,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -397,7 +397,7 @@
 	physics-&gt;acceleration		= Vector3r::ZERO;
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor		= Vector3f(0,0,1);
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor		= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall/SDECMovingWall.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall/SDECMovingWall.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECMovingWall/SDECMovingWall.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -239,13 +239,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(0.7,0.7,0.7);
+	gSphere-&gt;diffuseColor		= Vector3r(0.7,0.7,0.7);
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(0.8,0.3,0.3);
+	iSphere-&gt;diffuseColor		= Vector3r(0.8,0.3,0.3);
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -288,13 +288,13 @@
 //	position.normalize();
 //	gSphere-&gt;diffuseColor		= position;
 // a simple way to have alternating colors per layer
-	gSphere-&gt;diffuseColor		= Vector3f(std::sin((float)j),std::cos((float)j),j/nbSpheres[1]);
+	gSphere-&gt;diffuseColor		= Vector3r(std::sin((float)j),std::cos((float)j),j/nbSpheres[1]);
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(0.8,0.3,0.3);
+	iSphere-&gt;diffuseColor		= Vector3r(0.8,0.3,0.3);
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -335,13 +335,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -440,7 +440,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 		
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 	
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECSpheresPlane/SDECSpheresPlane.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECSpheresPlane/SDECSpheresPlane.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/SDECSpheresPlane/SDECSpheresPlane.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -210,13 +210,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(0.7,0.7,0.7);
+	gSphere-&gt;diffuseColor		= Vector3r(0.7,0.7,0.7);
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(0.8,0.3,0.3);
+	iSphere-&gt;diffuseColor		= Vector3r(0.8,0.3,0.3);
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -258,13 +258,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(0.8,0.3,0.3);
+	iSphere-&gt;diffuseColor		= Vector3r(0.8,0.3,0.3);
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -305,13 +305,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -402,7 +402,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 		
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 	
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest/TetrahedronsTest.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest/TetrahedronsTest.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/TetrahedronsTest/TetrahedronsTest.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -194,7 +194,7 @@
 	physics-&gt;velocity		= Vector3r(0,0,0);
 
 	makeTet(tet,radius);
-	tet-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	tet-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	tet-&gt;wire			= false;
 	tet-&gt;visible			= true;
 	tet-&gt;shadowCaster		= false;
@@ -234,7 +234,7 @@
 
 	// interactingGeometry is filled with data by Tetrahedron2InteractingMyTetrahedron
 	shared_ptr&lt;InteractingGeometry&gt; imt(new InteractingMyTetrahedron);
-	imt-&gt;diffuseColor               = Vector3f(0.5,0.5,1.0);
+	imt-&gt;diffuseColor               = Vector3r(0.5,0.5,1.0);
 	body-&gt;interactingGeometry	= imt;
 
 	body-&gt;geometricalModel		= tet;
@@ -284,13 +284,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -408,7 +408,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 		
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 	
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending/ThreePointBending.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending/ThreePointBending.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/ThreePointBending/ThreePointBending.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -315,13 +315,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -422,7 +422,7 @@
 	physics-&gt;acceleration		= Vector3r::ZERO;
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor		= Vector3f(0,0,1);
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor		= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -105,7 +105,7 @@
 	wall_2_wire		= true;
 	wall_3_wire		= true;
 	wall_4_wire		= true;
-	spheresColor		= Vector3f(0.8,0.3,0.3);
+	spheresColor		= Vector3r(0.8,0.3,0.3);
 	spheresRandomColor	= false;
 	recordBottomForce	= true;
 	forceRecordFile		= &quot;../data/force&quot;;
@@ -489,7 +489,7 @@
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -531,13 +531,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -702,7 +702,7 @@
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
 	
-	set-&gt;diffuseColor		= Vector3f(0,0,1);
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor		= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.hpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.hpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/PreProcessor/TriaxialTest/TriaxialTest.hpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -31,7 +31,7 @@
 				,lowerCorner
 				,upperCorner;
 
-		Vector3f	 spheresColor;
+		Vector3r	 spheresColor;
 
 		Real		 thickness
 				,sphereYoungModulus

Modified: trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron/GLDrawInteractingMyTetrahedron.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron/GLDrawInteractingMyTetrahedron.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron/GLDrawInteractingMyTetrahedron.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -11,7 +11,7 @@
 
 void GLDrawInteractingMyTetrahedron::go(const shared_ptr&lt;InteractingGeometry&gt;&amp; cm, const shared_ptr&lt;PhysicalParameters&gt;&amp; ,bool)
 {
-	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, cm-&gt;diffuseColor);
+	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(cm-&gt;diffuseColor[0],cm-&gt;diffuseColor[1],cm-&gt;diffuseColor[2]));
 	glColor3v(cm-&gt;diffuseColor);
 
 	InteractingMyTetrahedron* t = static_cast&lt;InteractingMyTetrahedron*&gt;(cm.get());

Modified: trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp
===================================================================
--- trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -70,8 +70,8 @@
 			glScalef(mid,mid*0.05,mid*0.05);
 		glColor3(0.5,0.5,0.5);
 	// ///////////
-
-//		glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+ 
+ 	 	//glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 		glEnable(GL_LIGHTING);
 		glutSolidCube(1.0);
 

Modified: trunk/yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader/FEMSetTextLoader.cpp
===================================================================
--- trunk/yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader/FEMSetTextLoader.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-fem/src/Engine/EngineUnit/FEMSetTextLoader/FEMSetTextLoader.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -84,7 +84,7 @@
 	physics-&gt;initialPosition	= position;
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(0.9,0.9,0.3);
+	gSphere-&gt;diffuseColor		= Vector3r(0.9,0.9,0.3);
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
@@ -121,7 +121,7 @@
 	// FIXME - remove Se3 - FEMTetrahedron DOES NOT need Se3 !
 	physics-&gt;se3 			= Se3r( Vector3r(0,0,0) , Quaternionr(0,0,0,0) );
 
-	gTet-&gt;diffuseColor		= Vector3f(1,1,1);
+	gTet-&gt;diffuseColor		= Vector3r(1,1,1);
 	gTet-&gt;wire			= false;
 	gTet-&gt;visible			= true;
 	gTet-&gt;shadowCaster		= true;

Modified: trunk/yade-packages/yade-package-fem/src/PreProcessor/FEMBeam/FEMBeam.cpp
===================================================================
--- trunk/yade-packages/yade-package-fem/src/PreProcessor/FEMBeam/FEMBeam.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-fem/src/PreProcessor/FEMBeam/FEMBeam.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -203,13 +203,13 @@
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
 	
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);
 
 	shared_ptr&lt;GeometricalModel&gt; gm 	= dynamic_pointer_cast&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;FEMSetGeometry&quot;));
-	gm-&gt;diffuseColor 			= Vector3f(1,1,1);
+	gm-&gt;diffuseColor 			= Vector3r(1,1,1);
 	gm-&gt;wire 				= false;
 	gm-&gt;visible 				= true;
 	gm-&gt;shadowCaster 			= true;
@@ -246,7 +246,7 @@
 				&amp;&amp; pos[2] &lt; max[2] )
 			{
 				b-&gt;isDynamic = false;
-				b-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1,0,0);
+				b-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1,0,0);
 				translationCondition-&gt;subscribedBodies.push_back(b-&gt;getId());
 			}
 		}

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams/LatticeSet2LatticeBeams.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams/LatticeSet2LatticeBeams.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/EngineUnit/LatticeSet2LatticeBeams/LatticeSet2LatticeBeams.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -36,11 +36,11 @@
 			line-&gt;length                    = beam-&gt;length;
 
 			// FIXME - display aggregates as brown, bonds as dark brown.
-			      if(beam-&gt;criticalTensileStrain &gt; 0.00015) line-&gt;diffuseColor = Vector3f(0.6,0.6,0.6); else // CEMENT
-			      if(beam-&gt;criticalTensileStrain &gt; 0.00006) line-&gt;diffuseColor = Vector3f(0.0,0.0,0.0); else // AGGREGATE
-			                                                line-&gt;diffuseColor = Vector3f(0.3,0.3,0.3);      // BOND
+			      if(beam-&gt;criticalTensileStrain &gt; 0.00015) line-&gt;diffuseColor = Vector3r(0.6,0.6,0.6); else // CEMENT
+			      if(beam-&gt;criticalTensileStrain &gt; 0.00006) line-&gt;diffuseColor = Vector3r(0.0,0.0,0.0); else // AGGREGATE
+			                                                line-&gt;diffuseColor = Vector3r(0.3,0.3,0.3);      // BOND
 
-			      if(beam-&gt;longitudalStiffness &gt; 3.6 ) line-&gt;diffuseColor = Vector3f(0.4,0.4,1.0); // NON-DESTROY
+			      if(beam-&gt;longitudalStiffness &gt; 3.6 ) line-&gt;diffuseColor = Vector3r(0.4,0.4,1.0); // NON-DESTROY
 		}
 	}
 }

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder/BeamRecorder.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder/BeamRecorder.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/BeamRecorder/BeamRecorder.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -155,7 +155,7 @@
 				stress_x += s_x;
 				stress_y += s_y;
 
-				(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,0.0,((float)section)/3.0); // FIXME [1]
+				(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,0.0,((float)section)/3.0); // FIXME [1]
 			}
 		}
 

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson/MeasurePoisson.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson/MeasurePoisson.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MeasurePoisson/MeasurePoisson.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -72,13 +72,13 @@
 	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
 
 	LatticeNodeParameters* node_left   = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[left  ]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[left  ]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,1.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[left  ]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,1.0,0.0); // FIXME [1]
 	LatticeNodeParameters* node_right  = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[right ]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[right ]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,1.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[right ]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,1.0,0.0); // FIXME [1]
 	LatticeNodeParameters* node_bottom = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[bottom]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[bottom]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,1.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[bottom]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,1.0,0.0); // FIXME [1]
 	LatticeNodeParameters* node_upper  = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[upper ]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[upper ]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,1.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[upper ]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,1.0,0.0); // FIXME [1]
 	
 	// FIXME - zamiast &#182;ledzi&#230; tylko dwa punkty (jeden na dole i jeden u g&#243;ry), to lepiej zaznaczy&#230; dwa obszary punkt&#243;w i liczy&#230; &#182;redni&#177; ich po&#179;o&#191;enia,
 	// bo teraz, je&#182;li kt&#243;ry&#182; punkt zostanie wykasowany, to nie jest mo&#191;liwe kontynuowanie pomiar&#243;w.

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport/MovingSupport.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport/MovingSupport.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/MovingSupport/MovingSupport.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -174,8 +174,8 @@
 				node1-&gt;displacementIncremental += DI; 
 				node2-&gt;displacementIncremental -= DI;
 
-				(*(ncb-&gt;bodies))[id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.0,0.0,((float)section)/2.0); // FIXME [1]
-				(*(ncb-&gt;bodies))[id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.0,0.0,((float)section)/2.0); // FIXME [1]
+				(*(ncb-&gt;bodies))[id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,0.0,((float)section)/2.0); // FIXME [1]
+				(*(ncb-&gt;bodies))[id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,0.0,((float)section)/2.0); // FIXME [1]
 			}
 		}
 	}

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder/NodeRecorder.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder/NodeRecorder.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/NodeRecorder/NodeRecorder.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -121,7 +121,7 @@
 				sum+=(*(ncb-&gt;bodies))[*i]-&gt;physicalParameters-&gt;se3.position;
 				++count;
 				
-				(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.0,1.0,((float)region)/1.5); // FIXME [1]
+				(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,1.0,((float)region)/1.5); // FIXME [1]
 			}
 		}
 

Modified: trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder/StrainRecorder.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder/StrainRecorder.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/Engine/StandAloneEngine/StrainRecorder/StrainRecorder.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -64,11 +64,11 @@
 	
 	if(!ncb-&gt;bodies-&gt;exists(*i)) std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;, exit(1);
 	LatticeNodeParameters* node1 = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,0.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,0.0,0.0); // FIXME [1]
 	++i;
 	if(!ncb-&gt;bodies-&gt;exists(*i)) std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;, exit(1);
 	LatticeNodeParameters* node2 = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
-	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(1.0,0.0,0.0); // FIXME [1]
+	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,0.0,0.0); // FIXME [1]
 	++i;
 	// FIXME - zamiast &#182;ledzi&#230; tylko dwa punkty (jeden na dole i jeden u g&#243;ry), to lepiej zaznaczy&#230; dwa obszary punkt&#243;w i liczy&#230; &#182;redni&#177; ich po&#179;o&#191;enia,
 	// bo teraz, je&#182;li kt&#243;ry&#182; punkt zostanie wykasowany, to nie jest mo&#191;liwe kontynuowanie pomiar&#243;w.
@@ -90,7 +90,7 @@
 			//Real s_nonl_y =0;
 			//if(nonlocal)
 			//	s_nonl_y 		= (beam-&gt;nonLocalStrain / beam-&gt;nonLocalDivisor) * std::abs(beam-&gt;direction[1]);
-			(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.0,1.0,1.0); // FIXME [1]
+			(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,1.0,1.0); // FIXME [1]
 			stress_y += s_y;
 			//stress_nonlocal_y += s_nonl_y;
 		}

Modified: trunk/yade-packages/yade-package-lattice/src/PreProcessor/LatticeExample/LatticeExample.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/PreProcessor/LatticeExample/LatticeExample.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/PreProcessor/LatticeExample/LatticeExample.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -814,7 +814,7 @@
 	physics-&gt;se3			= Se3r(position,q);
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(0.8,0.8,0.8);
+	gSphere-&gt;diffuseColor		= Vector3r(0.8,0.8,0.8);
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= false;
@@ -860,7 +860,7 @@
 	physics-&gt;mass			= 0;
 	physics-&gt;velocity		= Vector3r(0,0,0);
 
-	gQuad-&gt;diffuseColor		= Vector3f(0.0,0.0,0.0);
+	gQuad-&gt;diffuseColor		= Vector3r(0.0,0.0,0.0);
 	gQuad-&gt;visible			= true;
 	gQuad-&gt;wire			= false;
 	gQuad-&gt;shadowCaster		= false;
@@ -886,7 +886,7 @@
 	physics-&gt;id2 			= j;
 
 	gBeam-&gt;length			= length;
-	gBeam-&gt;diffuseColor		= Vector3f(0.6,0.6,0.6);
+	gBeam-&gt;diffuseColor		= Vector3r(0.6,0.6,0.6);
 	gBeam-&gt;wire			= false;
 	gBeam-&gt;visible			= true;
 	gBeam-&gt;shadowCaster		= false;
@@ -1081,13 +1081,13 @@
         shared_ptr&lt;LatticeInteractingGeometry&gt; set(new LatticeInteractingGeometry());
        
 
-	set-&gt;diffuseColor		= Vector3f(0,0,1);
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor		= Vector3r(0,0,1);
 
 	shared_ptr&lt;GeometricalModel&gt; gm = dynamic_pointer_cast&lt;GeometricalModel&gt;(ClassFactory::instance().createShared(&quot;LatticeSetGeometry&quot;));
-	gm-&gt;diffuseColor 		= Vector3f(1,1,1);
+	gm-&gt;diffuseColor 		= Vector3r(1,1,1);
 	gm-&gt;wire 			= false;
 	gm-&gt;visible 			= true;
 	gm-&gt;shadowCaster 		= true;
@@ -1135,7 +1135,7 @@
 				)
 			{
 				b-&gt;isDynamic = false;
-				b-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.3,0.3,0.3);
+				b-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.3,0.3,0.3);
 				translationCondition-&gt;subscribedBodies.push_back(b-&gt;getId());
 			}
 		}
@@ -1235,8 +1235,8 @@
                 beam-&gt;longitudalStiffness       = 10.0;
                 beam-&gt;bendingStiffness          = 2.8;
                 beam-&gt;torsionalStiffness        = 2.8;
-                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.2,0.5,0.7);
-                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.2,0.5,0.7);
+                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.2,0.5,0.7);
+                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.2,0.5,0.7);
         }
 }
 
@@ -1420,8 +1420,8 @@
                                 beam-&gt;criticalTensileStrain     = agg_critTensileStrain;
                                 beam-&gt;criticalCompressiveStrain = agg_critCompressStrain;
                 
-                                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.6,0.2,0.0);
-                                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.6,0.2,0.0);
+                                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.6,0.2,0.0);
+                                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.6,0.2,0.0);
                         }
                         else if(ovv==1) // bond
                         {
@@ -1431,8 +1431,8 @@
                                 beam-&gt;criticalTensileStrain     = bond_critTensileStrain;
                                 beam-&gt;criticalCompressiveStrain = bond_critCompressStrain;
                 
-                                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.6,0.6,0.0);
-                                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.6,0.6,0.0);
+                                (*(rootBody-&gt;bodies))[beam-&gt;id1]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.6,0.6,0.0);
+                                (*(rootBody-&gt;bodies))[beam-&gt;id2]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.6,0.6,0.0);
                         }
                 }
         }

Modified: trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeBeamState/GLDrawLatticeBeamState.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeBeamState/GLDrawLatticeBeamState.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeBeamState/GLDrawLatticeBeamState.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -34,12 +34,12 @@
 	if(factor &gt; 0 &amp;&amp; maxTensileFactor &gt; 0)
 	{
 		factor                  /= maxTensileFactor;
-		glColor3v(Vector3f(0.9,0.9,1.0) - factor * Vector3f(0.9,0.9,0.0));
+		glColor3v(Vector3r(0.9,0.9,1.0) - factor * Vector3r(0.9,0.9,0.0));
 	}
 	else if (factor &lt; 0 &amp;&amp; maxCompressFactor &lt; 0)
 	{
 		factor                  /= maxCompressFactor; // both are negative, so result is positive
-		glColor3v(Vector3f(1.0,0.9,0.9) - factor * Vector3f(0.0,0.9,0.9));
+		glColor3v(Vector3r(1.0,0.9,0.9) - factor * Vector3r(0.0,0.9,0.9));
 	}
 	else
 		glColor3(0.9,0.9,0.9);

Modified: trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeInteractingGeometry/GLDrawLatticeInteractingGeometry.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeInteractingGeometry/GLDrawLatticeInteractingGeometry.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeInteractingGeometry/GLDrawLatticeInteractingGeometry.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -78,7 +78,7 @@
 	if(damaged.size()&lt;=a) damaged.resize(a+1,0);
 	++damaged[a];
 
-	//(*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor = Vector3f(0.0,0.0,((float)section)/2.0);
+	//(*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,0.0,((float)section)/2.0);
 };
 
 void GLDrawLatticeInteractingGeometry::go(const shared_ptr&lt;InteractingGeometry&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)
@@ -110,8 +110,8 @@
 				LatticeBeamParameters* b2 = static_cast&lt;LatticeBeamParameters*&gt;(((*(bodies))[(*angles)-&gt;getId2()])-&gt;physicalParameters.get());
 				unsigned int A = b2-&gt;id1,
 					     B = b2-&gt;id2;
-				Vector3f c1 = (*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor;
-				Vector3f c2 = (*(bodies))[B]-&gt;geometricalModel-&gt;diffuseColor;
+				Vector3r c1 = (*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor;
+				Vector3r c2 = (*(bodies))[B]-&gt;geometricalModel-&gt;diffuseColor;
 				// beams that have nodes with red=0 and green=0 in geometrical model are used by MovingSupport, so I want to exclude them...
 				if( !((c1[0]==0 &amp;&amp; c1[1]==0) || (c2[0]==0 &amp;&amp; c2[1]==0)) )
 					damagedNeighbor((*angles)-&gt;getId2());
@@ -123,8 +123,8 @@
 				LatticeBeamParameters* b1 = static_cast&lt;LatticeBeamParameters*&gt;(((*(bodies))[(*angles)-&gt;getId1()])-&gt;physicalParameters.get());
 				unsigned int A = b1-&gt;id1,
 					     B = b1-&gt;id2;
-				Vector3f c1 = (*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor;
-				Vector3f c2 = (*(bodies))[B]-&gt;geometricalModel-&gt;diffuseColor;
+				Vector3r c1 = (*(bodies))[A]-&gt;geometricalModel-&gt;diffuseColor;
+				Vector3r c2 = (*(bodies))[B]-&gt;geometricalModel-&gt;diffuseColor;
 				if( !((c1[0]==0 &amp;&amp; c1[1]==0) || (c2[0]==0 &amp;&amp; c2[1]==0)) )
 					damagedNeighbor((*angles)-&gt;getId1());
 			}
@@ -133,7 +133,7 @@
 		angles_end = interactions-&gt;end();
 	}
 
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3(0.5,0.5,0.9);
 	glDisable(GL_CULL_FACE);
 	glEnable(GL_LIGHTING);

Modified: trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -171,7 +171,7 @@
 	}
 
 	// FIXME : check that : one of those 2 lines are useless
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
 	
 	//Real len = (static_cast&lt;LatticeSetGeometry*&gt;(gm.get()))-&gt;length;

Modified: trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLineSegment/GLDrawLineSegment.cpp
===================================================================
--- trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLineSegment/GLDrawLineSegment.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-lattice/src/RenderingEngine/GLDrawLineSegment/GLDrawLineSegment.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -17,7 +17,7 @@
 void GLDrawLineSegment::go(const shared_ptr&lt;GeometricalModel&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)
 {
 	// FIXME : check that : one of those 2 lines are useless
-  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, gm-&gt;diffuseColor);
+  	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
 	
 	Real len = (static_cast&lt;LineSegment*&gt;(gm.get()))-&gt;length;

Modified: trunk/yade-packages/yade-package-mass-spring/src/PreProcessor/HangingCloth/HangingCloth.cpp
===================================================================
--- trunk/yade-packages/yade-package-mass-spring/src/PreProcessor/HangingCloth/HangingCloth.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-mass-spring/src/PreProcessor/HangingCloth/HangingCloth.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -230,13 +230,13 @@
 	rootBody-&gt;isDynamic	= false;
 
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor	= Vector3f(0,0,1);
+	set-&gt;diffuseColor	= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor	= Vector3r(0,0,1);
 
 	shared_ptr&lt;Mesh2D&gt; mesh2d(new Mesh2D);
-	mesh2d-&gt;diffuseColor	= Vector3f(0,0,1);
+	mesh2d-&gt;diffuseColor	= Vector3r(0,0,1);
 	mesh2d-&gt;wire		= false;
 	mesh2d-&gt;visible		= true;
 	mesh2d-&gt;shadowCaster	= false;
@@ -258,7 +258,7 @@
 			node-&gt;isDynamic		= true;
 			
 			shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
-			iSphere-&gt;diffuseColor	= Vector3f(0,0,1);
+			iSphere-&gt;diffuseColor	= Vector3r(0,0,1);
 			iSphere-&gt;radius		= cellSize/2.2;
 
 // BEGIN ORIGINAL							
@@ -334,7 +334,7 @@
 		Body * body = static_cast&lt;Body*&gt;((*(rootBody-&gt;bodies))[offset(0,0)].get());
 		ParticleParameters * p = static_cast&lt;ParticleParameters*&gt;(body-&gt;physicalParameters.get());
 		p-&gt;mass = 1;
-		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3f(1.0,0.0,0.0);
+		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3r(1.0,0.0,0.0);
 		body-&gt;isDynamic = false;
 	}
 
@@ -343,7 +343,7 @@
 		Body * body = static_cast&lt;Body*&gt;((*(rootBody-&gt;bodies))[offset(width-1,0)].get());
 		ParticleParameters * p = static_cast&lt;ParticleParameters*&gt;(body-&gt;physicalParameters.get());
 		p-&gt;mass = 1;
-		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3f(1.0,0.0,0.0);
+		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3r(1.0,0.0,0.0);
 		body-&gt;isDynamic = false;
 	}
 
@@ -352,7 +352,7 @@
 		Body * body = static_cast&lt;Body*&gt;((*(rootBody-&gt;bodies))[offset(0,height-1)].get());
 		ParticleParameters * p = static_cast&lt;ParticleParameters*&gt;(body-&gt;physicalParameters.get());
 		p-&gt;mass = 1;
-		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3f(1.0,0.0,0.0);
+		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3r(1.0,0.0,0.0);
 		body-&gt;isDynamic = false;
 	}
 
@@ -361,7 +361,7 @@
 		Body * body = static_cast&lt;Body*&gt;((*(rootBody-&gt;bodies))[offset(width-1,height-1)].get());
 		ParticleParameters * p = static_cast&lt;ParticleParameters*&gt;(body-&gt;physicalParameters.get());
 		p-&gt;mass = 1;
-		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3f(1.0,0.0,0.0);
+		body-&gt;interactingGeometry-&gt;diffuseColor = Vector3r(1.0,0.0,0.0);
 		body-&gt;isDynamic = false;
 	}
 
@@ -499,13 +499,13 @@
 
 
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -540,13 +540,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;

Modified: trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/BoxStack/BoxStack.cpp
===================================================================
--- trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/BoxStack/BoxStack.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/BoxStack/BoxStack.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -147,13 +147,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 	
 	gBox-&gt;extents			= size;
-	gBox-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= size;
-	iBox-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iBox;
 	body-&gt;geometricalModel		= gBox;
@@ -189,13 +189,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 	
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -226,13 +226,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -317,7 +317,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);

Modified: trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/RotatingBox/RotatingBox.cpp
===================================================================
--- trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/RotatingBox/RotatingBox.cpp	2007-02-24 16:42:01 UTC (rev 1073)
+++ trunk/yade-packages/yade-package-realtime-rigidbody/src/PreProcessor/RotatingBox/RotatingBox.cpp	2007-02-26 19:24:57 UTC (rev 1074)
@@ -165,13 +165,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 	
 	gBox-&gt;extents			= size;
-	gBox-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gBox-&gt;wire			= false;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= true;
 	
 	iBox-&gt;extents			= size;
-	iBox-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iBox-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iBox;
 	body-&gt;geometricalModel		= gBox;
@@ -208,13 +208,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
 	
 	gSphere-&gt;radius			= radius;
-	gSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	gSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
 	gSphere-&gt;shadowCaster		= true;
 	
 	iSphere-&gt;radius			= radius;
-	iSphere-&gt;diffuseColor		= Vector3f(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
 
 	body-&gt;interactingGeometry	= iSphere;
 	body-&gt;geometricalModel		= gSphere;
@@ -245,13 +245,13 @@
 	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
 
 	gBox-&gt;extents			= extents;
-	gBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
 	gBox-&gt;wire			= wire;
 	gBox-&gt;visible			= true;
 	gBox-&gt;shadowCaster		= false;
 	
 	iBox-&gt;extents			= extents;
-	iBox-&gt;diffuseColor		= Vector3f(1,1,1);
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
 
 	body-&gt;boundingVolume		= aabb;
 	body-&gt;interactingGeometry	= iBox;
@@ -337,7 +337,7 @@
 	physics-&gt;acceleration			= Vector3r::ZERO;
 	
 	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
-	set-&gt;diffuseColor			= Vector3f(0,0,1);
+	set-&gt;diffuseColor			= Vector3r(0,0,1);
 
 	shared_ptr&lt;AABB&gt; aabb(new AABB);
 	aabb-&gt;diffuseColor			= Vector3r(0,0,1);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000038.html">[Yade-commits] r1073 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-libs/yade-lib-serialization/src/yade-lib-serialization	yade-packages/yade-package-dem/src/Engine/DeusExMachina/ResultantForceEngine	yade-packages/yade-package-dem/src/Engine/DeusExMachina/TriaxialCompressionEngine	yade-packages/yade-package-dem/src/Engine/DeusExMachina/TriaxialStressController	yade-packages/yade-package-dem/src/Engine/EngineUnit/InteractingMyTetrahedron2AABB	yade-packages/yade-package-dem/src/Engine/StandAloneEngine/GeometricalModelForceColorizer	yade-packages/yade-package-dem/src/Engine/StandAloneEngine/MyTetrahedronLaw	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawInteractingMyTetrahedron	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSDECLinkGeometry	yade-packages/yade-package-dem/src/RenderingEngine/GLDrawSpheresContactGeometry	yade-scripts
</A></li>
	<LI>Next message: <A HREF="000040.html">[Yade-commits] r1075 - in trunk: . yade-core/src/yade	yade-extra/clump yade-guis/yade-gui-qt/src/QtGUI	yade-packages/yade-package-common/src/Engine/DeusExMachina/GravityEngine	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsForceLaw	yade-packages/yade-package-common/src/Engine/EngineUnit/NewtonsMomentumLaw	yade-packages/yade-package-common/src/Engine/StandAloneEngine/PersistentSAPCollider	yade-packages/yade-package-common/src/Engine/StandAloneEngine/SAPCollider	yade-scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#39">[ date ]</a>
              <a href="thread.html#39">[ thread ]</a>
              <a href="subject.html#39">[ subject ]</a>
              <a href="author.html#39">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
