<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1182 - in trunk: . core extra/clump lib/base	pkg/dem pkg/dem/DataClass/InteractionGeometry	pkg/dem/DataClass/InteractionPhysics	pkg/dem/DataClass/PhysicalParameters	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1182%20-%20in%20trunk%3A%20.%20core%20extra/clump%20lib/base%0A%09pkg/dem%20pkg/dem/DataClass/InteractionGeometry%0A%09pkg/dem/DataClass/InteractionPhysics%0A%09pkg/dem/DataClass/PhysicalParameters%0A%09pkg/dem/Engine/DeusExMachina%20pkg/dem/Engine/EngineUnit%0A%09pkg/dem/Engine/StandAloneEngine%20pkg/dem/PreProcessor&In-Reply-To=%3C200705311822.l4VIM7L2002109%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000146.html">
   <LINK REL="Next"  HREF="000148.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1182 - in trunk: . core extra/clump lib/base	pkg/dem pkg/dem/DataClass/InteractionGeometry	pkg/dem/DataClass/InteractionPhysics	pkg/dem/DataClass/PhysicalParameters	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor</H1>
    <B>chareyre at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1182%20-%20in%20trunk%3A%20.%20core%20extra/clump%20lib/base%0A%09pkg/dem%20pkg/dem/DataClass/InteractionGeometry%0A%09pkg/dem/DataClass/InteractionPhysics%0A%09pkg/dem/DataClass/PhysicalParameters%0A%09pkg/dem/Engine/DeusExMachina%20pkg/dem/Engine/EngineUnit%0A%09pkg/dem/Engine/StandAloneEngine%20pkg/dem/PreProcessor&In-Reply-To=%3C200705311822.l4VIM7L2002109%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1182 - in trunk: . core extra/clump lib/base	pkg/dem pkg/dem/DataClass/InteractionGeometry	pkg/dem/DataClass/InteractionPhysics	pkg/dem/DataClass/PhysicalParameters	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/EngineUnit	pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor">chareyre at mail.berlios.de
       </A><BR>
    <I>Thu May 31 20:22:07 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000146.html">[Yade-commits] r1181 - in trunk: core extra/clump extra/tetra	gui/qt3 pkg/common/Container pkg/common/Engine/StandAloneEngine	pkg/common/RenderingEngine/OpenGLRenderingEngine	pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor	pkg/fem/Engine/EngineUnit pkg/lattice/PreProcessor	pkg/lattice/RenderingEngine/GLDrawLatticeInteractingGeometry	pkg/mass-spring/PreProcessor pkg/realtime-rigidbody/PreProcessor
</A></li>
        <LI>Next message: <A HREF="000148.html">[Yade-commits] r1183 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#147">[ date ]</a>
              <a href="thread.html#147">[ thread ]</a>
              <a href="subject.html#147">[ subject ]</a>
              <a href="author.html#147">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chareyre
Date: 2007-05-31 20:22:06 +0200 (Thu, 31 May 2007)
New Revision: 1182

Added:
   trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp
   trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.hpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp
   trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp
   trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp
Modified:
   trunk/Yade.kdevelop
   trunk/core/Body.hpp
   trunk/extra/clump/Shop.cpp
   trunk/lib/base/Logging.hpp
   trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp
   trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
   trunk/pkg/dem/SConscript
Log:
All files related to capillary law.




Modified: trunk/Yade.kdevelop
===================================================================
--- trunk/Yade.kdevelop	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/Yade.kdevelop	2007-05-31 18:22:06 UTC (rev 1182)
@@ -10,16 +10,16 @@
     &lt;projectname&gt;Yade&lt;/projectname&gt;
     &lt;projectdirectory&gt;.&lt;/projectdirectory&gt;
     &lt;absoluteprojectpath&gt;false&lt;/absoluteprojectpath&gt;
-    &lt;description&gt;&lt;/description&gt;
-    &lt;defaultencoding&gt;&lt;/defaultencoding&gt;
+    &lt;description/&gt;
+    &lt;defaultencoding/&gt;
     &lt;versioncontrol&gt;kdevsubversion&lt;/versioncontrol&gt;
   &lt;/general&gt;
   &lt;kdevcustomproject&gt;
     &lt;run&gt;
       &lt;mainprogram&gt;/usr/local/bin/yade-svn1148&lt;/mainprogram&gt;
       &lt;directoryradio&gt;executable&lt;/directoryradio&gt;
-      &lt;programargs&gt;&lt;/programargs&gt;
-      &lt;globaldebugarguments&gt;&lt;/globaldebugarguments&gt;
+      &lt;programargs/&gt;
+      &lt;globaldebugarguments/&gt;
       &lt;globalcwd&gt;/tmp&lt;/globalcwd&gt;
       &lt;useglobalprogram&gt;false&lt;/useglobalprogram&gt;
       &lt;terminal&gt;false&lt;/terminal&gt;
@@ -30,7 +30,7 @@
     &lt;/run&gt;
     &lt;build&gt;
       &lt;buildtool&gt;make&lt;/buildtool&gt;
-      &lt;builddir&gt;&lt;/builddir&gt;
+      &lt;builddir/&gt;
     &lt;/build&gt;
     &lt;make&gt;
       &lt;abortonerror&gt;false&lt;/abortonerror&gt;
@@ -38,8 +38,8 @@
       &lt;prio&gt;0&lt;/prio&gt;
       &lt;dontact&gt;false&lt;/dontact&gt;
       &lt;makebin&gt;scons&lt;/makebin&gt;
-      &lt;defaulttarget&gt;&lt;/defaulttarget&gt;
-      &lt;makeoptions&gt;&lt;/makeoptions&gt;
+      &lt;defaulttarget/&gt;
+      &lt;makeoptions/&gt;
       &lt;selectedenvironment&gt;default&lt;/selectedenvironment&gt;
       &lt;environments&gt;
         &lt;default/&gt;
@@ -48,11 +48,11 @@
   &lt;/kdevcustomproject&gt;
   &lt;kdevdebugger&gt;
     &lt;general&gt;
-      &lt;dbgshell&gt;&lt;/dbgshell&gt;
-      &lt;gdbpath&gt;&lt;/gdbpath&gt;
-      &lt;configGdbScript&gt;&lt;/configGdbScript&gt;
-      &lt;runShellScript&gt;&lt;/runShellScript&gt;
-      &lt;runGdbScript&gt;&lt;/runGdbScript&gt;
+      &lt;dbgshell/&gt;
+      &lt;gdbpath/&gt;
+      &lt;configGdbScript/&gt;
+      &lt;runShellScript/&gt;
+      &lt;runGdbScript/&gt;
       &lt;breakonloadinglibs&gt;true&lt;/breakonloadinglibs&gt;
       &lt;separatetty&gt;false&lt;/separatetty&gt;
       &lt;floatingtoolbar&gt;false&lt;/floatingtoolbar&gt;
@@ -124,7 +124,7 @@
       &lt;root&gt;/usr/share/qt3&lt;/root&gt;
       &lt;designerintegration&gt;EmbeddedKDevDesigner&lt;/designerintegration&gt;
       &lt;qmake&gt;/usr/bin/qmake-qt3&lt;/qmake&gt;
-      &lt;designer&gt;/usr/bin/designer-qt3&lt;/designer&gt;
+      &lt;designer&gt;&lt;/designer&gt;
       &lt;designerpluginpaths/&gt;
     &lt;/qt&gt;
     &lt;codecompletion&gt;
@@ -151,7 +151,7 @@
       &lt;includePaths&gt;.;&lt;/includePaths&gt;
     &lt;/codecompletion&gt;
     &lt;creategettersetter&gt;
-      &lt;prefixGet&gt;&lt;/prefixGet&gt;
+      &lt;prefixGet/&gt;
       &lt;prefixSet&gt;set&lt;/prefixSet&gt;
       &lt;prefixVariable&gt;m_,_&lt;/prefixVariable&gt;
       &lt;parameterName&gt;theValue&lt;/parameterName&gt;
@@ -190,8 +190,7 @@
     &lt;/tree&gt;
   &lt;/kdevfileview&gt;
   &lt;ctagspart&gt;
-    &lt;customArguments&gt;&lt;/customArguments&gt;
-    &lt;customTagfilePath&gt;/home/eudoxos/yade/scons-layout/tags&lt;/customTagfilePath&gt;
+    &lt;customArguments/&gt;
     &lt;activeTagsFiles/&gt;
   &lt;/ctagspart&gt;
 &lt;/kdevelop&gt;

Modified: trunk/core/Body.hpp
===================================================================
--- trunk/core/Body.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/core/Body.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -56,7 +56,7 @@
 		bool isStandalone() const {return clumpId==ID_NONE;}
 		/*! Hook for clump to update position of members when user-forced reposition and redraw (through GUI) occurs.
 		 * This is useful only in cases when engines that do that in every iteration are not active - i.e. when the simulation is paused.
-		 * (otherwise, GLViewer would depend on Clump and therefore Clump would have to go to yade-core...) */
+		 * (otherwise, GLViewer would depend on Clump and therefore Clump would have to go to core...) */
 		virtual void userForcedDisplacementRedrawHook(){return;}
 
 		body_id_t getId() const {return id;};

Modified: trunk/extra/clump/Shop.cpp
===================================================================
--- trunk/extra/clump/Shop.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/extra/clump/Shop.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -61,7 +61,7 @@
 #include&lt;yade/extra/Tetra.hpp&gt;
 
 //#include&lt;yade/extra/Clump.hpp&gt;
-//#include &quot;BodyMacroParameters.hpp&quot;
+//#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
 
 
 #define _SPEC_CAST(orig,cast) template&lt;&gt; void Shop::setDefault&lt;orig&gt;(string key, orig val){setDefault(key,cast(val));}

Modified: trunk/lib/base/Logging.hpp
===================================================================
--- trunk/lib/base/Logging.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/lib/base/Logging.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -12,7 +12,7 @@
  *
  * All of user macros should come in 2 flavors, depending on whether we use log4cxx or not (backward compatibility).
  * The default is not to use it, unless the preprocessor macro LOG4CXX is defined. In that case, you want to #include
- * yade-core/logging.h and link with log4cxx.
+ * core/logging.h and link with log4cxx.
  *
  * TODO:
  * 1. for optimized builds, at least debugging macros should become no-ops

Modified: trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/DataClass/InteractionGeometry/SpheresContactGeometry.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -8,7 +8,7 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;SpheresContactGeometry.hpp&quot;
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
 
 SpheresContactGeometry::SpheresContactGeometry() : InteractionGeometry()
 {

Added: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,45 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &lt;yade/pkg-dem/CapillaryParameters.hpp&gt;
+
+CapillaryParameters::CapillaryParameters()
+{
+	meniscus = false;
+	Vmeniscus = 0;
+	CapillaryPressure = 0;
+	Fcap = Vector3r(0,0,0);
+	Delta1 = 0;
+	Delta2 = 0;
+	currentIndexes[0]=0;
+	currentIndexes[1]=0;
+	currentIndexes[2]=0;
+	currentIndexes[3]=0;
+}
+
+
+CapillaryParameters::~CapillaryParameters()
+{
+}
+
+// void CapillaryParameters::postProcessAttributes(bool)
+// {
+// 
+// }
+
+
+void CapillaryParameters::registerAttributes()
+{
+	ElasticContactInteraction::registerAttributes();
+	REGISTER_ATTRIBUTE(Vmeniscus);
+	REGISTER_ATTRIBUTE(CapillaryPressure);
+	REGISTER_ATTRIBUTE(Fcap);
+	REGISTER_ATTRIBUTE(Delta1);
+	REGISTER_ATTRIBUTE(Delta2);
+	REGISTER_ATTRIBUTE(meniscus);
+}


Property changes on: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,41 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CAPILLARY_PARAMETERS_HPP
+#define CAPILLARY_PARAMETERS_HPP
+
+//#include &lt;yade/core/InteractionPhysics.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+
+class CapillaryParameters : public ElasticContactInteraction
+{
+	public :CapillaryParameters();
+
+		Real		 Vmeniscus
+				,CapillaryPressure
+				,Delta1
+				,Delta2;
+				
+		Vector3r	Fcap;
+						
+		bool 		meniscus;
+		int		currentIndexes [4];// used for faster interpolation (stores previous positions in tables)
+				
+		virtual ~CapillaryParameters();
+	protected :
+		virtual void registerAttributes();
+
+	REGISTER_CLASS_NAME(CapillaryParameters);
+	REGISTER_BASE_CLASS_NAME(ElasticContactInteraction);
+
+};
+
+REGISTER_SERIALIZABLE(CapillaryParameters,false);
+
+#endif // CAPILLARY_PARAMETERS_HPP
+


Property changes on: trunk/pkg/dem/DataClass/InteractionPhysics/CapillaryParameters.hpp
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/ElasticContactInteraction.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -6,9 +6,10 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;ElasticContactInteraction.hpp&quot;
+#include &lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
 
 
+
 ElasticContactInteraction::ElasticContactInteraction()
 {
 	createIndex();

Modified: trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp
===================================================================
--- trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/DataClass/PhysicalParameters/BodyMacroParameters.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -6,7 +6,7 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;BodyMacroParameters.hpp&quot;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
 
 BodyMacroParameters::BodyMacroParameters () : ElasticBodyParameters()
 {

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,57 @@
+/*************************************************************************
+*  Copyright (C) 2006 by Luc Scholtes                                    *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">luc.scholtes at hmg.inpg.fr</A>                                              *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;CapillaryPressureEngine.hpp&quot;
+#include &lt;yade/pkg-dem/CapillaryCohesiveLaw.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+
+using namespace boost;
+using namespace std;
+
+CapillaryPressureEngine::CapillaryPressureEngine()
+{	
+	//cerr &lt;&lt; &quot;constructeur PressureEngine&quot; &lt;&lt; endl;
+	
+	capillaryCohesiveLaw = new CapillaryCohesiveLaw;
+	capillaryCohesiveLaw-&gt;sdecGroupMask = 2; // absolument n&#65533;cessaire !!!
+	
+	
+}
+
+CapillaryPressureEngine::~CapillaryPressureEngine()
+{
+}
+
+void CapillaryPressureEngine::registerAttributes()
+{
+	DeusExMachina::registerAttributes();
+	REGISTER_ATTRIBUTE(PressureVariation);
+	REGISTER_ATTRIBUTE(Pressure);
+
+}
+
+
+void CapillaryPressureEngine::applyCondition(Body * body)
+{		
+	//cerr &lt;&lt; &quot; CapillaryPressure = &quot; &lt;&lt; capillaryCohesiveLaw-&gt;CapillaryPressure &lt;&lt; endl;
+	
+	
+	capillaryCohesiveLaw-&gt;CapillaryPressure = Pressure;
+	if (Pressure&lt;100000) Pressure += PressureVariation;
+	//capillaryCohesiveLaw-&gt;CapillaryPressure += PressureVariation;
+	
+// 	cerr &lt;&lt; &quot; CapillaryPressure = &quot; &lt;&lt; capillaryCohesiveLaw-&gt;CapillaryPressure &lt;&lt; endl;
+// 	cerr &lt;&lt; &quot; PressureVariation = &quot; &lt;&lt; PressureVariation &lt;&lt; endl;
+	
+	capillaryCohesiveLaw-&gt;action(body);
+		
+	
+	
+	
+}
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,42 @@
+/*************************************************************************
+*  Copyright (C) 2006 by Luc Scholtes                                    *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">luc.scholtes at hmg.inpg.fr</A>                                              *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CAPILLARY_PRESSURE_ENGINE_HPP
+#define CAPILLARY_PRESSURE_ENGINE_HPP
+
+#include &lt;yade/core/DeusExMachina.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include &lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class CapillaryCohesiveLaw;
+
+class CapillaryPressureEngine : public DeusExMachina
+{
+	public :
+		
+		
+		CapillaryPressureEngine();
+		virtual ~CapillaryPressureEngine();
+		
+		Real PressureVariation;
+		Real Pressure;
+		//shared_ptr&lt;CapillaryCohesiveLaw&gt;  capillaryCohesiveLaw;
+		CapillaryCohesiveLaw* capillaryCohesiveLaw;
+				
+		void applyCondition(Body * body);
+
+	protected :
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(CapillaryPressureEngine);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+};
+
+REGISTER_SERIALIZABLE(CapillaryPressureEngine,false);
+
+#endif //  CAPILLARYPRESSUREENGINE_HPP
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryPressureEngine.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,119 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;CapillaryRecorder.hpp&quot;
+#include &lt;yade/pkg-common/RigidBodyParameters.hpp&gt;
+#include &lt;yade/pkg-common/ParticleParameters.hpp&gt;
+#include &lt;yade/pkg-common/Force.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryParameters.hpp&gt;
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+
+
+CapillaryRecorder::CapillaryRecorder () : DataRecorder(), actionForce(new Force)
+{
+	outputFile = &quot;&quot;;
+	interval = 1;
+}
+
+
+void CapillaryRecorder::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		ofile.open(outputFile.c_str());
+	}
+}
+
+
+void CapillaryRecorder::registerAttributes()
+{
+	DataRecorder::registerAttributes();
+	REGISTER_ATTRIBUTE(outputFile);
+	REGISTER_ATTRIBUTE(interval);
+	REGISTER_ATTRIBUTE(bigBallId);
+}
+
+
+bool CapillaryRecorder::isActivated()
+{
+	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile));
+}
+
+
+void CapillaryRecorder::action(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+		
+	Real fx=0, fy=0, fz=0;
+	
+	
+	Vector3r force = static_cast&lt;Force*&gt;(ncb-&gt;physicalActions-&gt;find(
+bigBallId, actionForce-&gt;getClassIndex() ) . get() )-&gt;force;
+		
+		fx=force[0];
+		fy=force[1];
+		fz=force[2];
+		
+	// R1 R2 -&gt; geometricalModel // &#65533;modifier cf capllaryStressRecorder
+	Real R1 = 0.001;
+	Real R2 = 0.001;
+	
+	//physicalParameters de bigBall
+	
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+	ParticleParameters* bigBallpp =
+static_cast&lt;ParticleParameters*&gt;((*bodies)[bigBallId]-&gt;physicalParameters.get())
+; ;
+		
+		Real x = bigBallpp-&gt; se3.position[0];
+		
+		Real Dintergranular = x - (R1+R2);	
+	
+	// capillary parameters
+	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
+        InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
+        
+        Real Vtotal = 0;
+        Real CapillaryPressure = 0;
+        
+        for(  ; ii!=iiEnd ; ++ii ) 
+        {
+                if ((*ii)-&gt;isReal )
+                {
+                        const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
+                         
+                        CapillaryParameters* meniscusParameters		= static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+                        
+                        if (meniscusParameters-&gt;meniscus)
+                        {
+                         
+                        CapillaryPressure = meniscusParameters-&gt;CapillaryPressure;
+                         
+                        Vtotal += meniscusParameters-&gt;Vmeniscus;
+                        
+                        }
+                        
+                        // else Vtotal = 0; // &#65533;voir!!!
+                }
+        }	
+
+	ofile &lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getSimulationTime()) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(fx) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(fy) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(fz) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(CapillaryPressure) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(Dintergranular)&lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(Vtotal)&lt;&lt; &quot; &quot; &lt;&lt; endl;
+	
+	
+}
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,48 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CAPILLARY_RECORDER_HPP
+#define CAPILLARY_RECORDER_HPP
+
+#include &lt;yade/core/DataRecorder.hpp&gt;
+
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+
+class PhysicalAction;
+
+class CapillaryRecorder : public DataRecorder
+{
+	private :
+		shared_ptr&lt;PhysicalAction&gt; actionForce;
+		std::ofstream ofile; 
+
+		bool changed;
+	
+	public :
+		std::string	 outputFile;
+		unsigned int	 interval;
+
+		int		bigBallId;
+
+		CapillaryRecorder ();
+
+		virtual void registerAttributes();
+		virtual void action(Body* b);
+		virtual bool isActivated();
+
+	protected :
+		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_CLASS_NAME(CapillaryRecorder);
+	REGISTER_BASE_CLASS_NAME(DataRecorder);
+};
+
+REGISTER_SERIALIZABLE(CapillaryRecorder,false);
+
+#endif // CAPILLARY_RECORDER_HPP
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryRecorder.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,267 @@
+/*************************************************************************
+*  Copyright (C) 2006 by luc scholt&#65533;                                    *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">luc.scholtes at hmg.inpg.fr</A>                                              *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;CapillaryStressRecorder.hpp&quot;
+#include &lt;yade/pkg-common/RigidBodyParameters.hpp&gt;
+#include &lt;yade/pkg-common/ParticleParameters.hpp&gt;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryParameters.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryCohesiveLaw.hpp&gt;
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;yade/pkg-common/Sphere.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+
+
+CapillaryStressRecorder::CapillaryStressRecorder () : DataRecorder()
+
+{
+	outputFile = &quot;&quot;;
+	interval = 1;
+	sphere_ptr = shared_ptr&lt;GeometricalModel&gt; (new Sphere);
+	SpheresClassIndex = sphere_ptr-&gt;getClassIndex();
+	height = 0;
+	width = 0;
+	depth = 0;
+	thickness = 0;
+	
+// 	upperCorner = Vector3r(0,0,0);
+// 	lowerCorner = Vector3r(0,0,0);
+	
+}
+
+
+void CapillaryStressRecorder::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		ofile.open(outputFile.c_str());
+	}
+}
+
+
+void CapillaryStressRecorder::registerAttributes()
+{
+	DataRecorder::registerAttributes();
+	REGISTER_ATTRIBUTE(outputFile);
+	REGISTER_ATTRIBUTE(interval);
+	
+	REGISTER_ATTRIBUTE(wall_bottom_id);
+ 	REGISTER_ATTRIBUTE(wall_top_id);
+ 	REGISTER_ATTRIBUTE(wall_left_id);
+ 	REGISTER_ATTRIBUTE(wall_right_id);
+ 	REGISTER_ATTRIBUTE(wall_front_id);
+ 	REGISTER_ATTRIBUTE(wall_back_id);
+ 	
+ 	REGISTER_ATTRIBUTE(height);
+	REGISTER_ATTRIBUTE(width);
+	REGISTER_ATTRIBUTE(depth);
+	REGISTER_ATTRIBUTE(thickness);
+	
+// 	REGISTER_ATTRIBUTE(upperCorner);
+// 	REGISTER_ATTRIBUTE(lowerCorner);
+	
+
+}
+
+
+bool CapillaryStressRecorder::isActivated()
+{
+	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile)); // active le truc tout les &quot;interval&quot; !??
+}
+
+
+void CapillaryStressRecorder::action(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+		
+	Real f1_cap_x=0, f1_cap_y=0, f1_cap_z=0, x1=0, y1=0, z1=0, x2=0, y2=0, z2=0;
+	
+	Real sig11_cap=0, sig22_cap=0, sig33_cap=0, sig12_cap=0, sig13_cap=0,
+	sig23_cap=0, Vwater = 0, CapillaryPressure = 0;
+	
+	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
+        InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
+        
+        int j = 0;
+        
+        for(  ; ii!=iiEnd ; ++ii ) 
+        {
+                if ((*ii)-&gt;isReal)
+                {	
+                	const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
+                
+                	CapillaryParameters* meniscusParameters		= static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+                        
+                        if (meniscusParameters-&gt;meniscus)
+                        {
+                	
+                	j=j+1;
+                	
+                        unsigned int id1 = interaction -&gt; getId1();
+			unsigned int id2 = interaction -&gt; getId2();
+			
+			Vector3r fcap = meniscusParameters-&gt;Fcap;
+			
+			f1_cap_x=fcap[0];
+			f1_cap_y=fcap[1];
+			f1_cap_z=fcap[2];
+			
+			BodyMacroParameters* de1 		= static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id1]-&gt;physicalParameters.get());
+			x1 = de1-&gt;se3.position[0];
+			y1 = de1-&gt;se3.position[1];
+			z1 = de1-&gt;se3.position[2];
+
+
+			BodyMacroParameters* de2 		= static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
+			x2 = de2-&gt;se3.position[0];
+			y2 = de2-&gt;se3.position[1];
+			z2 = de2-&gt;se3.position[2];
+
+			///Calcul des contraintes capillaires &quot;locales&quot;
+			
+			sig11_cap = sig11_cap + f1_cap_x*(x1 - x2);
+			sig22_cap = sig22_cap + f1_cap_y*(y1 - y2);
+			sig33_cap = sig33_cap + f1_cap_z*(z1 - z2);
+			sig12_cap = sig12_cap + f1_cap_x*(y1 - y2);
+			sig13_cap = sig13_cap + f1_cap_x*(z1 - z2);
+			sig23_cap = sig23_cap + f1_cap_y*(z1 - z2);
+			
+			/// Calcul du volume d'eau
+			
+ 			Vwater += meniscusParameters-&gt;Vmeniscus;
+ 			CapillaryPressure=meniscusParameters-&gt;CapillaryPressure;
+			
+			}
+			
+                }
+        }	
+
+// 	if (Omega::instance().getCurrentIteration() % 10 == 0) 
+// 	{cerr &lt;&lt; &quot;interactions capillaires = &quot; &lt;&lt; j &lt;&lt; endl;}
+
+	/// volume de l'&#65533;hantillon
+	
+	PhysicalParameters* p_bottom =
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_bottom_id]-&gt;physicalParameters.
+get());
+	PhysicalParameters* p_top   =	
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_top_id]-&gt;physicalParameters.get(
+));
+	PhysicalParameters* p_left =
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_left_id]-&gt;physicalParameters.get
+());
+	PhysicalParameters* p_right =
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_right_id]-&gt;physicalParameters.
+get());
+	PhysicalParameters* p_front =
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_front_id]-&gt;physicalParameters.
+get());
+	PhysicalParameters* p_back =
+static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_back_id]-&gt;physicalParameters.get
+());
+	
+	
+	height = p_top-&gt;se3.position.Y() - p_bottom-&gt;se3.position.Y() -
+thickness;
+	width = p_right-&gt;se3.position.X() - p_left-&gt;se3.position.X() -
+thickness;
+	depth = p_front-&gt;se3.position.Z() - p_back-&gt;se3.position.Z() -
+thickness;
+
+	Real Vech = (height) * (width) * (depth);
+
+	// degr&#65533;de saturation/porosit&#65533;	
+	BodyContainer::iterator bi = bodies-&gt;begin();
+	BodyContainer::iterator biEnd = bodies-&gt;end();
+	
+	Real Vs = 0, Rbody = 0, SR = 0;
+// 	int n = 0;
+	
+	for ( ; bi!=biEnd; ++bi) 
+	
+	{	
+		shared_ptr&lt;Body&gt; b = *bi;
+		
+		int geometryIndex = b-&gt;geometricalModel-&gt;getClassIndex();
+		//cerr &lt;&lt; &quot;model = &quot; &lt;&lt; geometryIndex &lt;&lt; endl;
+		
+		if (geometryIndex == SpheresClassIndex)
+		{
+			Sphere* sphere =
+		static_cast&lt;Sphere*&gt;(b-&gt;geometricalModel.get());
+			Rbody = sphere-&gt;radius;
+			SR+=Rbody;
+			
+			Vs += 1.333*Mathr::PI*(Rbody*Rbody*Rbody);
+		}
+	}
+	
+// 	Real Rmoy = SR/N;
+// 	Real V = (height-2*Rmoy) * (width-2*Rmoy) * (depth-2*Rmoy);
+	
+	Real Vv = Vech - Vs;
+	
+// 	cerr &lt;&lt; &quot;Vw = &quot; &lt;&lt; Vwater &lt;&lt; &quot;Vv = &quot; &lt;&lt; Vv &lt;&lt; endl;
+// 	cerr &lt;&lt; &quot;V = &quot; &lt;&lt; V &lt;&lt; &quot;Vs = &quot; &lt;&lt; Vs &lt;&lt; endl;
+	
+	Real n = Vv/Vech;
+	Real Sr = 100*Vwater/Vv;
+	if (Sr&gt;100) Sr=100;
+	Real w = 100*Vwater/Vech;
+	if (w&gt;(100*Vv/Vech)) w=100*(Vv/Vech);
+	
+	/// Calcul des contraintes &quot;globales&quot;
+	
+	Real SIG_11_cap=0, SIG_22_cap=0, SIG_33_cap=0, SIG_12_cap=0,
+	SIG_13_cap=0, SIG_23_cap=0;
+	
+	SIG_11_cap = sig11_cap/Vech;
+	SIG_22_cap = sig22_cap/Vech;
+	SIG_33_cap = sig33_cap/Vech;
+	SIG_12_cap = sig12_cap/Vech;
+	SIG_13_cap = sig13_cap/Vech;
+	SIG_23_cap = sig23_cap/Vech;
+	
+// 	// calcul des d&#65533;ormations
+// 	
+// 	Real EPS_11=0, EPS_22=0, EPS_33=0;
+// 	
+// 	Real width_0 = upperCorner[0]-lowerCorner[0], height_0 =
+// 	upperCorner[1]-lowerCorner[1],
+// 	depth_0 = upperCorner[2]-lowerCorner[2];
+// 	
+// 	//cerr &lt;&lt; &quot;width_0 = &quot; &lt;&lt; width_0 &lt;&lt; &quot; width = &quot; &lt;&lt; width &lt;&lt; endl;
+// 	
+// 	EPS_11 = (width_0 - width)/width_0;
+// 	EPS_22 = (height_0 - height)/height_0;
+// 	EPS_33 = (depth_0 - depth)/depth_0;
+	
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0) 
+// 	{cerr &lt;&lt; &quot;Vwater = &quot; &lt;&lt; Vwater;
+// 	cerr &lt;&lt; &quot; | CapillaryPressure= &quot; &lt;&lt; CapillaryPressure &lt;&lt; &quot; | Sr= &quot; &lt;&lt; Sr
+// 	&lt;&lt;endl;}
+
+	ofile &lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getSimulationTime()) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_11_cap) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_22_cap) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_33_cap) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_12_cap) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_13_cap)&lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_23_cap)&lt;&lt; &quot;   &quot;
+// 		&lt;&lt; lexical_cast&lt;string&gt;(EPS_11) &lt;&lt; &quot; &quot;
+// 		&lt;&lt; lexical_cast&lt;string&gt;(EPS_22) &lt;&lt; &quot; &quot;
+// 		&lt;&lt; lexical_cast&lt;string&gt;(EPS_33) &lt;&lt; &quot;   &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(CapillaryPressure) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(Sr)&lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(w)&lt;&lt; &quot; &quot;
+		&lt;&lt; endl;
+	
+}
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,54 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CAPILLARY_STRESS_RECORDER_HPP
+#define CAPILLARY_STRESS_RECORDER_HPP
+
+#include &lt;yade/core/DataRecorder.hpp&gt;
+
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+
+class GeometricalModel;
+
+class CapillaryStressRecorder : public DataRecorder
+{
+	private :
+		std::ofstream ofile; 
+
+		bool changed;
+		shared_ptr&lt;GeometricalModel&gt; sphere_ptr;
+		int SpheresClassIndex;
+	
+	public :
+		std::string	 outputFile;
+		unsigned int	 interval;
+		
+		Real height, width, depth;
+		Real thickness; // FIXME should retrieve &quot;extents&quot; of a InteractingBox
+		
+		Vector3r upperCorner, lowerCorner;
+
+		int wall_bottom_id, wall_top_id, wall_left_id, wall_right_id, wall_front_id, wall_back_id;
+
+		CapillaryStressRecorder ();
+
+		virtual void registerAttributes();
+		virtual void action(Body* b);
+		virtual bool isActivated();
+
+	protected :
+		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_CLASS_NAME(CapillaryStressRecorder);
+	REGISTER_BASE_CLASS_NAME(DataRecorder);
+};
+
+REGISTER_SERIALIZABLE(CapillaryStressRecorder,false);
+
+#endif // CAPILLARY_STRESS_RECORDER_HPP
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/CapillaryStressRecorder.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,381 @@
+/*************************************************************************
+*  Copyright (C) 2006 by luc scholt&#65533;                                    *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">luc.scholtes at hmg.inpg.fr</A>                                              *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;ContactStressRecorder.hpp&quot;
+#include &lt;yade/pkg-common/RigidBodyParameters.hpp&gt;
+#include &lt;yade/pkg-common/ParticleParameters.hpp&gt;
+#include &lt;yade/pkg-common/Force.hpp&gt;
+#include &lt;yade/pkg-common/Sphere.hpp&gt;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactLaw.hpp&gt;
+
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+
+#include &lt;yade/pkg-dem/TriaxialStressController.hpp&gt;
+#include &lt;yade/pkg-dem/TriaxialCompressionEngine.hpp&gt;
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+
+//#include &lt;yade/core/GeometricalModel.hpp&gt;
+
+ContactStressRecorder::ContactStressRecorder () : DataRecorder(), actionForce(new Force)
+
+{
+	outputFile = &quot;&quot;;
+	interval = 1;
+	
+	height = 0;
+	width = 0;
+	depth = 0;
+	thickness = 0;
+	upperCorner = Vector3r(0,0,0);
+	lowerCorner = Vector3r(0,0,0);
+	
+	sphere_ptr = shared_ptr&lt;GeometricalModel&gt; (new Sphere);
+	SpheresClassIndex = sphere_ptr-&gt;getClassIndex();
+	
+	triaxCompEng = new TriaxialCompressionEngine;
+	//sampleCapPressEng = new SampleCapillaryPressureEngine;
+	
+}
+
+
+void ContactStressRecorder::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		ofile.open(outputFile.c_str());
+	}
+}
+
+
+void ContactStressRecorder::registerAttributes()
+{
+	DataRecorder::registerAttributes();
+	REGISTER_ATTRIBUTE(outputFile);
+	REGISTER_ATTRIBUTE(interval);
+	
+	REGISTER_ATTRIBUTE(wall_bottom_id);
+ 	REGISTER_ATTRIBUTE(wall_top_id);
+ 	REGISTER_ATTRIBUTE(wall_left_id);
+ 	REGISTER_ATTRIBUTE(wall_right_id);
+ 	REGISTER_ATTRIBUTE(wall_front_id);
+ 	REGISTER_ATTRIBUTE(wall_back_id);
+ 	
+ 	REGISTER_ATTRIBUTE(height);
+	REGISTER_ATTRIBUTE(width);
+	REGISTER_ATTRIBUTE(depth);
+	REGISTER_ATTRIBUTE(thickness);
+	REGISTER_ATTRIBUTE(upperCorner);
+	REGISTER_ATTRIBUTE(lowerCorner);
+
+}
+
+
+bool ContactStressRecorder::isActivated()
+{
+	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile)); // active le truc tout les &quot;interval&quot; !??
+}
+
+
+void ContactStressRecorder::action(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+		
+	Real f1_el_x=0, f1_el_y=0, f1_el_z=0, x1=0, y1=0, z1=0, x2=0, y2=0, z2=0;
+	
+	Real sig11_el=0, sig22_el=0, sig33_el=0, sig12_el=0, sig13_el=0,
+	sig23_el=0, Vwater = 0, kinematicE = 0;
+	
+	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
+        InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
+        
+        Real j = 0;
+        //Real fabricTensor[3][3] = {{0,0,0},{0,0,0},{0,0,0}};
+        Real FT[3][3] = {{0,0,0},{0,0,0},{0,0,0}};
+//         cerr &lt;&lt; &quot;FabricTensorInit= &quot; &lt;&lt; FabricTensor[0][0] &lt;&lt; endl;
+			;
+        
+        for(  ; ii!=iiEnd ; ++ii ) 
+        {
+                if ((*ii)-&gt;isReal)
+                {	
+                	const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
+                
+                	unsigned int id1 = interaction -&gt; getId1();
+			unsigned int id2 = interaction -&gt; getId2();
+						
+			SpheresContactGeometry* currentContactGeometry 	=
+	static_cast&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.
+	get());
+			
+			ElasticContactInteraction* currentContactPhysics =
+	static_cast&lt;ElasticContactInteraction*&gt;
+	(interaction-&gt;interactionPhysics.get());
+			
+			Real fn = currentContactPhysics-&gt;normalForce.Length();
+
+			if (fn!=0)
+			
+			//if (currentContactGeometry-&gt;penetrationDepth &gt;= 0)
+			
+			{
+			j=j+1;
+			
+			Vector3r fel =
+currentContactPhysics-&gt;normalForce + currentContactPhysics-&gt;shearForce;
+			
+			f1_el_x=fel[0];
+			f1_el_y=fel[1];
+			f1_el_z=fel[2];
+			
+			int geometryIndex1 =
+		(*bodies)[id1]-&gt;geometricalModel-&gt;getClassIndex();
+			int geometryIndex2 =
+		(*bodies)[id2]-&gt;geometricalModel-&gt;getClassIndex();
+			
+  			if (geometryIndex1 == geometryIndex2)
+			
+			{ BodyMacroParameters* de1 =
+static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id1]-&gt;physicalParameters.get());
+			x1 = de1-&gt;se3.position[0];
+			y1 = de1-&gt;se3.position[1];
+			z1 = de1-&gt;se3.position[2];
+
+
+			BodyMacroParameters* de2 =
+static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
+			x2 = de2-&gt;se3.position[0];
+			y2 = de2-&gt;se3.position[1];
+			z2 = de2-&gt;se3.position[2];
+			
+			///Calcul des contraintes &#65533;astiques spheres/spheres
+			
+			sig11_el = sig11_el + f1_el_x*(x2 - x1);
+			sig22_el = sig22_el + f1_el_y*(y2 - y1);
+			sig33_el = sig33_el + f1_el_z*(z2 - z1);
+			sig12_el = sig12_el + f1_el_x*(y2 - y1);
+			sig13_el = sig13_el + f1_el_x*(z2 - z1);
+			sig23_el = sig23_el + f1_el_y*(z2 - z1);
+			
+			}
+			
+			else 
+			
+			{
+			Vector3r l = 
+		std::min(currentContactGeometry-&gt;radius2,
+		currentContactGeometry-&gt;radius1)	
+			*currentContactGeometry-&gt;normal;
+			
+			/// Calcul des contraintes &#65533;astiques spheres/parois
+			
+			sig11_el = sig11_el + f1_el_x*l[0];
+			sig22_el = sig22_el + f1_el_y*l[1];
+			sig33_el = sig33_el + f1_el_z*l[2];
+			sig12_el = sig12_el + f1_el_x*l[1];
+			sig13_el = sig13_el + f1_el_x*l[2];
+			sig23_el = sig23_el + f1_el_y*l[2];
+			
+			}
+
+			/// fabric tensor
+//  			if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 			{cerr &lt;&lt; &quot;normal = &quot;&lt;&lt; currentContactGeometry-&gt;normal &lt;&lt;
+// 			endl;}
+			Vector3r normal = currentContactGeometry-&gt;normal;
+			
+			for (int i=0; i&lt;3; ++i)
+			{	/*cerr &lt;&lt; &quot;boucle i&quot; &lt;&lt; endl;*/
+				for (int n=0; n&lt;3; ++n)
+				{	
+					//fabricTensor[i][n]
+					FT[i][n]
+					+= normal[i]*normal[n];
+					
+// 					cerr &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl;
+// 					cerr &lt;&lt; &quot;normal[i]=&quot; &lt;&lt; normal[i]
+// 					&lt;&lt; &quot; normal[n]=&quot; &lt;&lt; normal[n] &lt;&lt; 
+// 					&quot; FabricTensor[i][n]=&quot; &lt;&lt;
+// 					FabricTensor[i][n] &lt;&lt; endl;
+					
+				}
+			}
+			
+			}
+                }
+        }	
+
+	/// FabricTensor
+	
+	//FT = (fabricTensor/j);
+	Real traceFT = (FT[0][0]+FT[1][1]+FT[2][2])/j;
+	
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0) 
+// 	{cerr &lt;&lt; &quot;interactions de contact = &quot; &lt;&lt; j &lt;&lt; endl;}
+// 	 cerr &lt;&lt; &quot;TracefabricTensor =&quot; &lt;&lt; traceFT &lt;&lt; endl;}
+
+	/// calcul de l'&#65533;ergie cin&#65533;ique:
+	Real nbElt = 0, SR = 0, Vs=0, Rbody=0, Rmin=1, Rmax=0;
+	
+	BodyContainer::iterator bi = bodies-&gt;begin();
+	BodyContainer::iterator biEnd = bodies-&gt;end();
+	
+	for ( ; bi!=biEnd; ++bi) 
+	
+	{	
+		shared_ptr&lt;Body&gt; b = *bi;
+		
+		int geometryIndex = b-&gt;geometricalModel-&gt;getClassIndex();
+		//cerr &lt;&lt; &quot;model = &quot; &lt;&lt; geometryIndex &lt;&lt; endl;
+		
+		if (geometryIndex == SpheresClassIndex)
+		{
+			nbElt +=1;
+			ParticleParameters* pp =
+		static_cast&lt;ParticleParameters*&gt;(b-&gt;physicalParameters.get());
+			Vector3r v = pp-&gt;velocity;
+			kinematicE +=
+			0.5*(pp-&gt;mass)*(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
+			
+			Sphere* sphere =
+		static_cast&lt;Sphere*&gt;(b-&gt;geometricalModel.get());
+			Rbody = sphere-&gt;radius;
+			if (Rbody&lt;Rmin) Rmin = Rbody;
+			if (Rbody&gt;Rmax) Rmax = Rbody;
+			SR+=Rbody;
+			
+			Vs += 1.3333333*Mathr::PI*(Rbody*Rbody*Rbody);
+			
+		}
+	}
+
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 	{cerr &lt;&lt; &quot;Ek = &quot; &lt;&lt; kinematicE ;}
+	
+	/// coordination number
+	
+	Real coordN = 0;
+	coordN = 2*(j/nbElt);	// ????????????????????????????????????????????
+	
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 	{cerr /*&lt;&lt; &quot; j =&quot; &lt;&lt; j &lt;&lt; &quot; nbElt =&quot; &lt;&lt; nbElt */&lt;&lt; &quot; coordN = &quot; &lt;&lt;
+// 	coordN &lt;&lt; endl;}
+
+	/// Calcul des contraintes &quot;globales&quot;
+	
+	Real SIG_11_el=0, SIG_22_el=0, SIG_33_el=0, SIG_12_el=0, SIG_13_el=0, SIG_23_el=0;
+	
+	// volume de l'&#65533;hantillon
+	
+	PhysicalParameters* p_bottom = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_bottom_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_top   =	 static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_top_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_left 	= static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_left_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_right = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_right_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_front = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_front_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_back 	= static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_back_id]-&gt;physicalParameters.get());
+	
+	
+	height = p_top-&gt;se3.position.Y() - p_bottom-&gt;se3.position.Y() - thickness;
+	width = p_right-&gt;se3.position.X() - p_left-&gt;se3.position.X() - thickness;
+	depth = p_front-&gt;se3.position.Z() - p_back-&gt;se3.position.Z() - thickness;
+	
+	Real Rmoy = SR/nbElt;
+	if (Omega::instance().getCurrentIteration() == 1)
+	{cerr &lt;&lt; &quot;Rmoy = &quot;&lt;&lt; Rmoy &lt;&lt; &quot;  Rmin = &quot; &lt;&lt; Rmin &lt;&lt; &quot;  Rmax = &quot; &lt;&lt;
+	Rmax &lt;&lt; endl;}
+	
+// 	Real V = (height-2*Rmoy) * (width-2*Rmoy) * (depth-2*Rmoy);
+	Real V = (height) * (width) * (depth);
+	
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0) 
+// 	{cerr &lt;&lt; &quot;Vsample = &quot; &lt;&lt; V &lt;&lt; endl;}
+	
+	SIG_11_el = sig11_el/V;
+	SIG_22_el = sig22_el/V;
+	SIG_33_el = sig33_el/V;
+	SIG_12_el = sig12_el/V;
+	SIG_13_el = sig13_el/V;
+	SIG_23_el = sig23_el/V;
+	
+	// calcul des d&#65533;ormations
+	
+	Real EPS_11=0, EPS_22=0, EPS_33=0;
+	
+	Real width_0 = upperCorner[0]-lowerCorner[0], height_0 =
+	upperCorner[1]-lowerCorner[1],
+	depth_0 = upperCorner[2]-lowerCorner[2];
+	
+//	EPS_11 = (width_0 - width)/width_0;
+	EPS_11 = std::log(width_0) - std::log(width);
+//	EPS_22 = (height_0 - height)/height_0;
+	EPS_22 = std::log(height_0) - std::log(height);
+//	EPS_33 = (depth_0 - depth)/depth_0;
+	EPS_33 = std::log(depth_0) - std::log(depth);
+	
+	/// porosity 
+	
+	Real Vv = V - Vs;
+	
+	Real n = Vv/V;
+// 	Real e = Vv/Vs;
+
+// 	cerr &lt;&lt; &quot;Vw1 = &quot; &lt;&lt; Vwater &lt;&lt; &quot;Vv1 = &quot; &lt;&lt; Vv &lt;&lt; endl;
+// 	cerr &lt;&lt; &quot;V1 = &quot; &lt;&lt; V &lt;&lt; &quot;Vs1 = &quot; &lt;&lt; Vs &lt;&lt; endl;
+
+
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 	{cerr &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; &quot;e =&quot; &lt;&lt; e &lt;&lt; endl;}
+	
+// 	// mise &#65533;zero des deformations qd comp triaxiale commence
+// 	if (triaxCompEng-&gt;compressionActivated) {  }
+	
+	/// r&#65533;up&#65533;ation de UnbalancedForce
+	
+	Real equilibriumForce = triaxCompEng-&gt;ComputeUnbalancedForce(body);
+// 	Real equilibriumForce = sampleCapPressEng-&gt;ComputeUnbalancedForce(body);
+
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 	{cerr &lt;&lt; &quot;r&#65533;upUnbalancedForce = &quot; &lt;&lt; equilibriumForce &lt;&lt; endl;}
+
+	if (Omega::instance().getCurrentIteration() % 100 == 0)
+	{cerr &lt;&lt; &quot;current Iteration &quot; &lt;&lt; Omega::instance().getCurrentIteration()
+	&lt;&lt; endl;}
+		
+	ofile &lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getSimulationTime()) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getCurrentIteration()) &lt;&lt; &quot;  &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(kinematicE)&lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(equilibriumForce)&lt;&lt;&quot; &quot;
+ 		&lt;&lt; lexical_cast&lt;string&gt;(n)&lt;&lt;&quot; &quot;
+// 		&lt;&lt; lexical_cast&lt;string&gt;(e)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(coordN)&lt;&lt;&quot;   &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_11_el) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_22_el) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_33_el) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_12_el) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_13_el)&lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_23_el)&lt;&lt; &quot;   &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(EPS_11) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(EPS_22) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(EPS_33) &lt;&lt; &quot;   &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[0][0]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[0][1]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[0][2]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[1][0]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[1][1]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[1][2]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[2][0]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[2][1]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(FT[2][2]/j)&lt;&lt;&quot; &quot;
+		&lt;&lt; endl;
+	
+}
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,64 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CONTACT_STRESS_RECORDER_HPP
+#define CONTACT_STRESS_RECORDER_HPP
+
+#include &lt;yade/core/DataRecorder.hpp&gt;
+
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+
+class PhysicalAction;
+class GeometricalModel;
+class TriaxialCompressionEngine;
+// class SampleCapillaryPressureEngine;
+//class TriaxialStressController;
+
+class ContactStressRecorder : public DataRecorder
+{
+	private :
+		shared_ptr&lt;PhysicalAction&gt; actionForce; // ??? 
+		
+		shared_ptr&lt;GeometricalModel&gt; sphere_ptr;
+		int SpheresClassIndex;
+		
+		std::ofstream ofile;
+		
+		bool changed;
+	
+	public :
+		std::string	 outputFile;
+		unsigned int	 interval;
+		
+		Real height, width, depth;
+		Real thickness; // FIXME should retrieve &quot;extents&quot; of a InteractingBox
+		Vector3r upperCorner, lowerCorner;
+		
+		TriaxialCompressionEngine* triaxCompEng;
+		//TriaxialStressController* triaxStressCont;
+		//SampleCapillaryPressureEngine* sampleCapPressEng; 
+		
+		int wall_bottom_id, wall_top_id, wall_left_id, wall_right_id, wall_front_id, wall_back_id;
+
+		ContactStressRecorder ();
+
+		virtual void registerAttributes();
+		virtual void action(Body* b);
+		virtual bool isActivated();
+
+	protected :
+		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_CLASS_NAME(ContactStressRecorder);
+	REGISTER_BASE_CLASS_NAME(DataRecorder);
+};
+
+REGISTER_SERIALIZABLE(ContactStressRecorder,false);
+
+#endif // CONTACT_STRESS_RECORDER_HPP
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/ContactStressRecorder.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,202 @@
+/*************************************************************************
+*  Copyright (C) 2006 by luc scholt&#65533;                                    *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">luc.scholtes at hmg.inpg.fr</A>                                              *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;WallStressRecorder.hpp&quot;
+#include &lt;yade/pkg-common/RigidBodyParameters.hpp&gt;
+#include &lt;yade/pkg-common/ParticleParameters.hpp&gt;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+#include &lt;yade/pkg-common/Force.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactLaw.hpp&gt;
+
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+
+
+WallStressRecorder::WallStressRecorder () : DataRecorder(), actionForce(new Force)
+
+{
+	outputFile = &quot;&quot;;
+	interval = 1;
+	
+	height = 0;
+	width = 0;
+	depth = 0;
+	thickness = 0;
+}
+
+
+void WallStressRecorder::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		ofile.open(outputFile.c_str());
+	}
+}
+
+
+void WallStressRecorder::registerAttributes()
+{
+	DataRecorder::registerAttributes();
+	REGISTER_ATTRIBUTE(outputFile);
+	REGISTER_ATTRIBUTE(interval);
+	
+	REGISTER_ATTRIBUTE(wall_bottom_id);
+ 	REGISTER_ATTRIBUTE(wall_top_id);
+ 	REGISTER_ATTRIBUTE(wall_left_id);
+ 	REGISTER_ATTRIBUTE(wall_right_id);
+ 	REGISTER_ATTRIBUTE(wall_front_id);
+ 	REGISTER_ATTRIBUTE(wall_back_id);
+ 	
+ 	REGISTER_ATTRIBUTE(height);
+	REGISTER_ATTRIBUTE(width);
+	REGISTER_ATTRIBUTE(depth);
+	REGISTER_ATTRIBUTE(thickness);
+
+}
+
+
+bool WallStressRecorder::isActivated()
+{
+	return ((Omega::instance().getCurrentIteration() % interval == 0) &amp;&amp; (ofile)); // active le truc tout les &quot;interval&quot; !??
+}
+
+
+void WallStressRecorder::action(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+		
+	Real F_wall_left=0, F_wall_top=0, F_wall_front=0;
+	int i=0;
+	
+	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
+        InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
+        
+        
+        for(  ; ii!=iiEnd ; ++ii ) 
+        {
+                if ((*ii)-&gt;isReal)
+                {	
+                	const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
+                
+                	SpheresContactGeometry* currentContactGeometry 	=
+	static_cast&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.
+	get());
+
+			if (currentContactGeometry-&gt;penetrationDepth &gt;= 0)
+
+			{
+			unsigned int id1 = interaction -&gt; getId1();
+			unsigned int id2 = interaction -&gt; getId2();
+
+			ElasticContactInteraction* currentContactPhysics   
+			= static_cast&lt;ElasticContactInteraction*&gt;
+			(interaction-&gt;interactionPhysics.get());
+
+			Vector3r fel = currentContactPhysics-&gt;normalForce;
+			
+			// wall_left
+
+			if ((id1 == wall_left_id) || (id2 == wall_left_id))
+
+			{	
+				i=i+1;
+				if (id1 == wall_left_id)  F_wall_left = F_wall_left + fel[0];
+				if (id2 == wall_left_id)  F_wall_left = F_wall_left - fel[0];
+			}
+			
+			// wall_top
+
+			if ((id1 == wall_top_id) || (id2 == wall_top_id))
+
+			{	
+				i=i+1;
+				if (id1 == wall_top_id)  F_wall_top = F_wall_top - fel[1];
+				if (id2 == wall_top_id)  F_wall_top = F_wall_top + fel[1];
+			}
+	
+			// wall_front
+
+			if ((id1 == wall_front_id) || (id2 == wall_front_id))
+
+			{	
+				i=i+1;
+				if (id1 == wall_front_id)  F_wall_front = F_wall_front - fel[2];
+				if (id2 == wall_front_id)  F_wall_front = F_wall_front + fel[2];
+			}
+			
+			if ((id1 == wall_right_id) || (id2 == wall_right_id)) i=i+1;
+			if ((id1 == wall_bottom_id) || (id2 == wall_bottom_id)) i=i+1;
+			if ((id1 == wall_back_id) || (id2 == wall_back_id)) i=i+1;
+			
+			}
+                }
+        }	
+
+// 	if (Omega::instance().getCurrentIteration() % 100 == 0)
+// 	{cerr &lt;&lt; &quot;interactions spheres/murs = &quot; &lt;&lt; i &lt;&lt; endl;}
+
+	/// Calcul des contraintes &quot;globales&quot;
+	
+	Real SIG_11_wall=0, SIG_22_wall=0, SIG_33_wall=0;
+	
+	// dimensions de l'&#65533;hantillon
+	
+	PhysicalParameters* p_bottom = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_bottom_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_top   =	 static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_top_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_left 	= static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_left_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_right = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_right_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_front = static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_front_id]-&gt;physicalParameters.get());
+	PhysicalParameters* p_back 	= static_cast&lt;PhysicalParameters*&gt;((*bodies)[wall_back_id]-&gt;physicalParameters.get());
+	
+	
+	height = p_top-&gt;se3.position.Y() - p_bottom-&gt;se3.position.Y() - thickness;
+	width = p_right-&gt;se3.position.X() - p_left-&gt;se3.position.X() - thickness;
+	depth = p_front-&gt;se3.position.Z() - p_back-&gt;se3.position.Z() - thickness;
+	
+	SIG_11_wall = F_wall_left / (height*depth);
+	SIG_22_wall = F_wall_top / (depth*width);
+	SIG_33_wall = F_wall_front / (height*width);
+		
+	
+	// calcul des contraintes via forces resultantes sur murs
+	
+	Real SIG_wall_11 = 0, SIG_wall_22 = 0, SIG_wall_33 = 0;
+	
+	Vector3r F_wall_11 = static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find(wall_left_id, actionForce-&gt;getClassIndex() ). get() )-&gt;force;
+	
+	SIG_wall_11 = F_wall_11[0]/(depth*height);
+	
+	//cerr &lt;&lt; &quot; SIG_wall_11 = &quot; &lt;&lt; SIG_wall_11 &lt;&lt; &quot; SIG_11_el = &quot; &lt;&lt; SIG_11_el &lt;&lt; endl;
+	
+	Vector3r F_wall_22 = static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find(wall_top_id, actionForce-&gt;getClassIndex() ). get() )-&gt;force;
+	
+	SIG_wall_22 = F_wall_22[1]/(depth*width);
+	
+	Vector3r F_wall_33 = static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find(wall_front_id, actionForce-&gt;getClassIndex() ). get() )-&gt;force;
+	
+	SIG_wall_33 = F_wall_33[2]/(width*height);
+	
+	ofile &lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getSimulationTime()) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_11_wall) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_wall_11) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(p_left-&gt;se3.position.X()) &lt;&lt; &quot; &quot;
+ 		&lt;&lt; lexical_cast&lt;string&gt;(SIG_22_wall) &lt;&lt; &quot; &quot;
+ 		&lt;&lt; lexical_cast&lt;string&gt;(SIG_wall_22) &lt;&lt; &quot; &quot;
+ 		&lt;&lt; lexical_cast&lt;string&gt;(p_top-&gt;se3.position.Y()) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_33_wall) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(SIG_wall_33) &lt;&lt; &quot; &quot;
+		&lt;&lt; lexical_cast&lt;string&gt;(p_front-&gt;se3.position.Z()) &lt;&lt; &quot; &quot;
+		&lt;&lt; endl;
+	
+}
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,52 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef WALL_STRESS_RECORDER_HPP
+#define WALL_STRESS_RECORDER_HPP
+
+#include &lt;yade/core/DataRecorder.hpp&gt;
+
+#include &lt;string&gt;
+#include &lt;fstream&gt;
+
+class PhysicalAction;
+
+class WallStressRecorder : public DataRecorder
+{
+	private :
+		shared_ptr&lt;PhysicalAction&gt; actionForce; // ??? 
+		std::ofstream ofile;
+		
+		bool changed;
+	
+	public :
+		std::string	 outputFile;
+		unsigned int	 interval;
+		
+		Real height, width, depth;
+		Real thickness; // FIXME should retrieve &quot;extents&quot; of a InteractingBox
+		
+		
+		int wall_bottom_id, wall_top_id, wall_left_id, wall_right_id, wall_front_id, wall_back_id;
+
+		WallStressRecorder ();
+
+		virtual void registerAttributes();
+		virtual void action(Body* b);
+		virtual bool isActivated();
+
+	protected :
+		virtual void postProcessAttributes(bool deserializing);
+	REGISTER_CLASS_NAME(WallStressRecorder);
+	REGISTER_BASE_CLASS_NAME(DataRecorder);
+};
+
+REGISTER_SERIALIZABLE(WallStressRecorder,false);
+
+#endif // WALL_STRESS_RECORDER_HPP
+


Property changes on: trunk/pkg/dem/Engine/DeusExMachina/WallStressRecorder.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,189 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp&quot;
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include &lt;yade/pkg-common/InteractingSphere.hpp&gt;
+#include &lt;yade/pkg-common/InteractingBox.hpp&gt;
+
+#include &lt;yade/lib-base/yadeWm3Extra.hpp&gt;
+
+//FIXME return type should be shared_ptr&lt;Interaction&gt;
+bool InteractingBox2InteractingSphere4SpheresContactGeometryWater::go(		const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+						const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+						const Se3r&amp; se31,
+						const Se3r&amp; se32,
+						const shared_ptr&lt;Interaction&gt;&amp; c)
+{
+
+	//if (se31.orientation == Quaternionr())
+	//	return collideAABoxSphere(cm1,cm2,se31,se32,c);
+	
+	Vector3r l,t,p,q,r;
+	bool onborder = false;
+	Vector3r pt1,pt2,normal;
+	Matrix3r axisT,axis;
+	Real depth;
+
+	InteractingSphere* s = static_cast&lt;InteractingSphere*&gt;(cm2.get());
+	InteractingBox* obb = static_cast&lt;InteractingBox*&gt;(cm1.get());
+	
+	Vector3r extents = obb-&gt;extents;
+
+	se31.orientation.ToRotationMatrix(axisT);
+	axis = axisT.Transpose();
+	
+	p = se32.position-se31.position;
+	
+	l[0] = extents[0];
+	t[0] = axis.GetRow(0).Dot(p); 
+	if (t[0] &lt; -l[0]) { t[0] = -l[0]; onborder = true; }
+	if (t[0] &gt;  l[0]) { t[0] =  l[0]; onborder = true; }
+
+	l[1] = extents[1];
+	t[1] = axis.GetRow(1).Dot(p);
+	if (t[1] &lt; -l[1]) { t[1] = -l[1]; onborder = true; }
+	if (t[1] &gt;  l[1]) { t[1] =  l[1]; onborder = true; }
+
+	l[2] = extents[2];
+	t[2] = axis.GetRow(2).Dot(p);
+	if (t[2] &lt; -l[2]) { t[2] = -l[2]; onborder = true; }
+	if (t[2] &gt;  l[2]) { t[2] =  l[2]; onborder = true; }
+	
+	if (!onborder) 
+	{	//cerr &lt;&lt; &quot;!onborder&quot;;
+		// sphere center inside box. find largest `t' value
+		Real min = l[0]-fabs(t[0]);
+		int mini = 0;
+		for (int i=1; i&lt;3; i++) 
+		{
+			Real tt = l[i]-fabs(t[i]);
+			if (tt &lt; min) 
+			{
+				min = tt;
+				mini = i;
+			}
+		}
+		
+		// contact normal aligned with box edge along largest `t' value
+		Vector3r tmp = Vector3r(0,0,0);
+
+		tmp[mini] = (t[mini] &gt; 0) ? 1.0 : -1.0;
+		
+		normal = axisT*tmp;
+		
+		normal.Normalize();
+		
+		pt1 = se32.position + normal*min;
+		pt2 = se32.position - normal*s-&gt;radius;	
+
+		// FIXME : remove those uncommented lines
+		shared_ptr&lt;SpheresContactGeometry&gt; scm;
+		if (c-&gt;isNew)
+			scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+		else
+			scm = dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
+			
+		scm-&gt;contactPoint = 0.5*(pt1+pt2);
+		scm-&gt;normal = pt1-pt2;
+		scm-&gt;penetrationDepth = scm-&gt;normal.Normalize();
+		//cerr &lt;&lt; &quot;Box/Sphere penetrationdepth= &quot;&lt;&lt; scm-&gt;normal.Normalize() &lt;&lt; endl;
+		scm-&gt;radius1 = s-&gt;radius*2; /// c ici que le &quot;rayon&quot; du mur est fix&#65533;
+		//cerr &lt;&lt; &quot;1&quot; &lt;&lt; endl;
+		scm-&gt;radius2 = s-&gt;radius;
+		c-&gt;interactionGeometry = scm;
+		
+// FIXME : uncommente those lines	
+/////////////////////////////////////////////////
+// 		shared_ptr&lt;SpheresContactGeometry&gt; scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+// 		scm-&gt;contactPoint = 0.5*(pt1+pt2);
+// 		scm-&gt;normal = pt1-pt2;
+// 		scm-&gt;penetrationDepth = scm-&gt;normal.Normalize();
+// 		scm-&gt;radius1 = s-&gt;radius*2;
+// 		scm-&gt;radius2 = s-&gt;radius;
+// 		c-&gt;interactionGeometry = scm;
+		
+		return true;	
+	}
+	//FIXME : use else instead and signle return
+	
+	q = axisT*t;
+	r = p - q;
+	
+	depth = s-&gt;radius-sqrt(r.Dot(r));
+	//cerr &lt;&lt; &quot;depth = &quot; &lt;&lt; depth;
+	
+	if (depth &lt; 0) 
+	{	//cerr &lt;&lt; &quot;depth &lt; 0&quot; ;
+		return false;
+	}
+
+	pt1 = q + se31.position;
+
+	normal = r;
+	normal.Normalize();
+
+	pt2 = se32.position - normal * s-&gt;radius;
+	
+	// FIXME : remove those uncommented lines
+	shared_ptr&lt;SpheresContactGeometry&gt; scm;
+	//cerr &lt;&lt; &quot;scm = &quot; &lt;&lt; scm &lt;&lt; &quot; | c = &quot; &lt;&lt; c &lt;&lt; endl;
+	
+	if (c-&gt;isNew)
+	{	//cerr &lt;&lt; &quot;c-&gt;isNew&quot;;
+		scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+	}
+	else
+	{	//cerr &lt;&lt; &quot;else&quot;;
+		scm = dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
+	}
+	scm-&gt;contactPoint = 0.5*(pt1+pt2);
+	scm-&gt;normal = pt1-pt2;
+	scm-&gt;penetrationDepth = scm-&gt;normal.Normalize();
+	//cerr &lt;&lt; &quot;Box/Sphere penetrationdepth= &quot;&lt;&lt; scm-&gt;normal.Normalize() &lt;&lt; endl;
+	scm-&gt;radius1 = s-&gt;radius*2; /// c ici que le &quot;rayon&quot; du mur est fix&#65533;
+	//cerr &lt;&lt; &quot;2 &quot; &lt;&lt; endl;
+	scm-&gt;radius2 = s-&gt;radius;
+	c-&gt;interactionGeometry = scm;
+// FIXME : uncommente those lines	
+/////////////////////////////////////////////////	
+// 	shared_ptr&lt;SpheresContactGeometry&gt; scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+// 	scm-&gt;contactPoint = 0.5*(pt1+pt2);
+// 	scm-&gt;normal = pt1-pt2;
+// 	scm-&gt;penetrationDepth = scm-&gt;normal.Normalize();
+// 	scm-&gt;radius1 = s-&gt;radius*2;
+// 	scm-&gt;radius2 = s-&gt;radius;
+// 	c-&gt;interactionGeometry = scm;
+	
+	return true;
+}
+
+
+bool InteractingBox2InteractingSphere4SpheresContactGeometryWater::goReverse(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+						const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+						const Se3r&amp; se31,
+						const Se3r&amp; se32,
+						const shared_ptr&lt;Interaction&gt;&amp; c)
+{
+	bool isInteracting = go(cm2,cm1,se32,se31,c);
+	if (isInteracting)
+	{
+		SpheresContactGeometry* scm = static_cast&lt;SpheresContactGeometry*&gt;(c-&gt;interactionGeometry.get());
+		//Vector3r tmp = scm-&gt;closestsPoints[0].first;		
+		//scm-&gt;closestsPoints[0].first = scm-&gt;closestsPoints[0].second;
+		//scm-&gt;closestsPoints[0].second = tmp;
+		scm-&gt;normal = -scm-&gt;normal;
+		Real tmpR  = scm-&gt;radius1;
+		scm-&gt;radius1 = scm-&gt;radius2;
+		scm-&gt;radius2 = tmpR;
+	}
+	return isInteracting;
+}
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,40 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef BOX2SPHERE4SDECCONTACTMODEL_WATER_HPP
+#define BOX2SPHERE4SDECCONTACTMODEL_WATER_HPP
+
+#include &lt;yade/pkg-common/InteractionGeometryEngineUnit.hpp&gt;
+
+class InteractingBox2InteractingSphere4SpheresContactGeometryWater : public InteractionGeometryEngineUnit
+{
+	public :
+		virtual bool go(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+					const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+					const Se3r&amp; se31,
+					const Se3r&amp; se32,
+					const shared_ptr&lt;Interaction&gt;&amp; c);
+
+		virtual bool goReverse(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+					const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+					const Se3r&amp; se31,
+					const Se3r&amp; se32,
+					const shared_ptr&lt;Interaction&gt;&amp; c);
+
+	REGISTER_CLASS_NAME(InteractingBox2InteractingSphere4SpheresContactGeometryWater);
+	REGISTER_BASE_CLASS_NAME(InteractionGeometryEngineUnit);
+
+	DEFINE_FUNCTOR_ORDER_2D(InteractingBox,InteractingSphere);
+};
+
+REGISTER_SERIALIZABLE(InteractingBox2InteractingSphere4SpheresContactGeometryWater,false);
+
+#endif // __BOX2SPHERE4SDECCONTACTMODEL_WATER_H__
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,29 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+ 
+#include &quot;InteractingSphere2AABBwater.hpp&quot;
+#include &lt;yade/pkg-common/InteractingSphere.hpp&gt;
+#include &lt;yade/pkg-common/AABB.hpp&gt;
+
+void InteractingSphere2AABBwater::go(	  const shared_ptr&lt;InteractingGeometry&gt;&amp; cm
+				, shared_ptr&lt;BoundingVolume&gt;&amp; bv
+				, const Se3r&amp; se3
+				, const Body*	)
+{
+	InteractingSphere* sphere = static_cast&lt;InteractingSphere*&gt;(cm.get());
+	AABB* aabb = static_cast&lt;AABB*&gt;(bv.get());
+	
+	aabb-&gt;center = se3.position;
+	
+	aabb-&gt;halfSize = Vector3r(1.5*sphere-&gt;radius,1.5*sphere-&gt;radius,1.5*sphere-&gt;radius); //&#65533;a n'est peut ere pas la solution!!!!
+	
+	aabb-&gt;min = aabb-&gt;center-aabb-&gt;halfSize;
+	aabb-&gt;max = aabb-&gt;center+aabb-&gt;halfSize;	
+
+}
+	


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,28 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+ 
+#ifndef SPHERE2AABBWATER_HPP
+#define SPHERE2AABBWATER_HPP
+
+#include &lt;yade/pkg-common/BoundingVolumeEngineUnit.hpp&gt;
+
+class InteractingSphere2AABBwater : public BoundingVolumeEngineUnit
+{
+	public :
+		void go(	  const shared_ptr&lt;InteractingGeometry&gt;&amp; cm
+				, shared_ptr&lt;BoundingVolume&gt;&amp; bv
+				, const Se3r&amp; se3
+				, const Body*	);
+	REGISTER_CLASS_NAME(InteractingSphere2AABBwater);
+	REGISTER_BASE_CLASS_NAME(BoundingVolumeEngineUnit);
+};
+
+REGISTER_SERIALIZABLE(InteractingSphere2AABBwater,false);
+
+#endif // SPHERE2AABBWATER_HPP
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2AABBwater.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,95 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp&quot;
+
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include &lt;yade/pkg-common/InteractingSphere.hpp&gt;
+
+
+
+bool InteractingSphere2InteractingSphere4SpheresContactGeometryWater::go(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+							const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+							const Se3r&amp; se31,
+							const Se3r&amp; se32,
+							const shared_ptr&lt;Interaction&gt;&amp; c)
+{
+	InteractingSphere* s1 = static_cast&lt;InteractingSphere*&gt;(cm1.get());
+	InteractingSphere* s2 = static_cast&lt;InteractingSphere*&gt;(cm2.get());
+
+	/// c'est ce calcul qui semble poser pb !!!
+	Vector3r normal = se32.position-se31.position;
+	Real penetrationDepth = s1-&gt;radius+s2-&gt;radius-normal.Normalize();
+	
+	shared_ptr&lt;SpheresContactGeometry&gt; scm;
+//	shared_ptr&lt;SDECLinkGeometry&gt; linkGeometry;
+	
+	if (c-&gt;interactionGeometry)	
+	{
+		scm = dynamic_pointer_cast&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
+	}
+
+	// BEGIN .......  FIXME FIXME	- wrong hack, to make cohesion work.
+	
+	else	
+		
+	scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+		
+	//linkGeometry = shared_ptr&lt;SDECLinkGeometry&gt;(new SDECLinkGeometry());
+		
+// 	if (penetrationDepth&gt;0)
+	{
+		scm-&gt;contactPoint = se31.position+(s1-&gt;radius-0.5*penetrationDepth)*normal;//0.5*(pt1+pt2);
+		scm-&gt;normal = normal;
+		scm-&gt;penetrationDepth = penetrationDepth;
+		scm-&gt;radius1 = s1-&gt;radius;
+		scm-&gt;radius2 = s2-&gt;radius;
+		
+		// ?????
+		if (!c-&gt;interactionGeometry)
+		c-&gt;interactionGeometry = scm;
+	
+	return true;
+		
+	}
+		
+// 	else	 //d&#65533;finition de g&#65533;om&#65533;trie d'interaction pour le cas ou !contact
+// 	{
+// 	scm-&gt;normal = normal;
+// 	scm-&gt;penetrationDepth = penetrationDepth;
+// 	scm-&gt;radius1 = s1-&gt;radius;
+// 	scm-&gt;radius2 = s2-&gt;radius;
+// 	
+// 	//linkGeometry-&gt;normal.normalize();
+// 	//linkGeometry-&gt;radius1 = s1-&gt;radius;
+// 	//linkGeometry-&gt;radius2 = s2-&gt;radius;
+// 	
+// 	if (!c-&gt;interactionGeometry)
+// 		c-&gt;interactionGeometry = scm;
+// 		
+// 	//if (!c-&gt;interactionGeometry)
+// 	//	c-&gt;interactionGeometry = linkGeometry;
+// 	
+// 	return true;
+// 	//return false;
+// 	}
+}
+
+
+
+bool InteractingSphere2InteractingSphere4SpheresContactGeometryWater::goReverse(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+								const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+								const Se3r&amp; se31,
+								const Se3r&amp; se32,
+								const shared_ptr&lt;Interaction&gt;&amp; c)
+{
+	return go(cm1,cm2,se31,se32,c);
+}
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,37 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef SPHERE2SPHERE4MACROMICROCONTACTGEOMETRY_HPP
+#define SPHERE2SPHERE4MACROMICROCONTACTGEOMETRY_HPP
+
+#include &lt;yade/pkg-common/InteractionGeometryEngineUnit.hpp&gt;
+
+class InteractingSphere2InteractingSphere4SpheresContactGeometryWater : public InteractionGeometryEngineUnit
+{
+	public :
+		virtual bool go(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+					const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+					const Se3r&amp; se31,
+					const Se3r&amp; se32,
+					const shared_ptr&lt;Interaction&gt;&amp; c);
+		virtual bool goReverse(	const shared_ptr&lt;InteractingGeometry&gt;&amp; cm1,
+					const shared_ptr&lt;InteractingGeometry&gt;&amp; cm2,
+					const Se3r&amp; se31,
+					const Se3r&amp; se32,
+					const shared_ptr&lt;Interaction&gt;&amp; c);
+
+	REGISTER_CLASS_NAME(InteractingSphere2InteractingSphere4SpheresContactGeometryWater);
+	REGISTER_BASE_CLASS_NAME(InteractionGeometryEngineUnit);
+
+	DEFINE_FUNCTOR_ORDER_2D(InteractingSphere,InteractingSphere);
+};
+
+REGISTER_SERIALIZABLE(InteractingSphere2InteractingSphere4SpheresContactGeometryWater,false);
+
+#endif // SPHERE2SPHERE4MACROMICROCONTACTGEOMETRY_HPP
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,133 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;MacroMicroElasticRelationshipsWater.hpp&quot;
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryParameters.hpp&gt;
+#include &lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+#include &lt;yade/pkg-dem/SDECLinkGeometry.hpp&gt; // FIXME - I can't dispatch by SDECLinkGeometry &lt;-&gt; SpheresContactGeometry !!?
+#include &lt;yade/pkg-dem/SDECLinkPhysics.hpp&gt; // FIXME
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+
+
+MacroMicroElasticRelationshipsWater::MacroMicroElasticRelationshipsWater()
+{
+	alpha 	= 2.5;
+	beta 	= 2.0;
+	gamma 	= 2.65;
+}
+
+
+void MacroMicroElasticRelationshipsWater::registerAttributes()
+{
+	REGISTER_ATTRIBUTE(alpha);
+	REGISTER_ATTRIBUTE(beta);
+	REGISTER_ATTRIBUTE(gamma);
+}
+
+
+void MacroMicroElasticRelationshipsWater::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 // BodyMacroParameters
+					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // BodyMacroParameters
+					, const shared_ptr&lt;Interaction&gt;&amp; interaction)
+{
+	BodyMacroParameters* sdec1 = static_cast&lt;BodyMacroParameters*&gt;(b1.get());
+	BodyMacroParameters* sdec2 = static_cast&lt;BodyMacroParameters*&gt;(b2.get());
+	SpheresContactGeometry* interactionGeometry = static_cast&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+	
+	if(interactionGeometry) // so it is SpheresContactGeometry  - NON PERMANENT LINK
+	{
+
+/* OLD VERSION  this is a LinearContactModel, different class, model different that MicroMacroElasticRelationships
+another would be HerzMindlinContactModel
+
+		shared_ptr&lt;ElasticContactInteraction&gt; contactPhysics;
+		
+		if ( interaction-&gt;isNew)
+		{
+			interaction-&gt;interactionPhysics = shared_ptr&lt;ElasticContactInteraction&gt;(new ElasticContactInteraction());
+			contactPhysics = dynamic_pointer_cast&lt;ElasticContactInteraction&gt;(interaction-&gt;interactionPhysics);
+			
+			contactPhysics-&gt;initialKn			= 2*(sdec1-&gt;kn*sdec2-&gt;kn)/(sdec1-&gt;kn+sdec2-&gt;kn);
+			contactPhysics-&gt;initialKs			= 2*(sdec1-&gt;ks*sdec2-&gt;ks)/(sdec1-&gt;ks+sdec2-&gt;ks);
+			contactPhysics-&gt;prevNormal 			= interactionGeometry-&gt;normal;
+			contactPhysics-&gt;initialEquilibriumDistance	= interactionGeometry-&gt;radius1+interactionGeometry-&gt;radius2;
+		}
+		else
+			contactPhysics = dynamic_pointer_cast&lt;ElasticContactInteraction&gt;(interaction-&gt;interactionPhysics);
+		
+		contactPhysics-&gt;kn = contactPhysics-&gt;initialKn;
+		contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
+		contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
+*/
+		if( interaction-&gt;isNew)
+		{
+			interaction-&gt;interactionPhysics = shared_ptr&lt;CapillaryParameters&gt;(new CapillaryParameters());
+			CapillaryParameters* contactPhysics = static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+
+			Real Ea 	= sdec1-&gt;young;
+			Real Eb 	= sdec2-&gt;young;
+			Real Va 	= sdec1-&gt;poisson;
+			Real Vb 	= sdec2-&gt;poisson;
+			Real Da 	= interactionGeometry-&gt;radius1; // FIXME - multiply by factor of sphere interaction distance (so sphere intaracts at bigger range that its geometrical size)
+			Real Db 	= interactionGeometry-&gt;radius2; // FIXME - as above
+			Real fa 	= sdec1-&gt;frictionAngle;
+			Real fb 	= sdec2-&gt;frictionAngle;
+
+			Real Eab	= 2*Ea*Eb/(Ea+Eb);
+			Real Vab	= 2*Va*Vb/(Va+Vb);
+
+			Real Dinit 	= Da+Db; 			// FIXME - is it just a sum?
+			Real Sinit 	= Mathr::PI * std::pow( std::min(Da,Db) , 2);
+
+			//Real Kn						= (Eab*Sinit/Dinit)*( (1+alpha)/(beta*(1+Vab) + gamma*(1-alpha*Vab) ) );
+			Real ksOnkn = 0.5;
+			Real Kn = 4*Ea*Da*Eb*Db/(2*(Ea*Da+Eb*Db));//harmonic average of two stiffnesses
+//cerr &lt;&lt; &quot;Kn: &quot; &lt;&lt; Kn &lt;&lt; endl;
+			contactPhysics-&gt;initialKn			= Kn;
+			//contactPhysics-&gt;initialKs			= Kn*(1-alpha*Vab)/(1+Vab);
+			contactPhysics-&gt;initialKs			= Kn*ksOnkn;
+//cerr &lt;&lt; &quot;Ks: &quot; &lt;&lt;       contactPhysics-&gt;initialKs			&lt;&lt; endl;
+			//contactPhysics-&gt;frictionAngle			= (fa+fb)*0.5; // FIXME - this is actually a waste of memory space, just like initialKs and initialKn
+			contactPhysics-&gt;frictionAngle			= std::min(fa,fb);
+			contactPhysics-&gt;tangensOfFrictionAngle		= std::tan(contactPhysics-&gt;frictionAngle); 
+
+			contactPhysics-&gt;prevNormal 			= interactionGeometry-&gt;normal;
+			contactPhysics-&gt;initialEquilibriumDistance	= Dinit;			
+
+			contactPhysics-&gt;kn = contactPhysics-&gt;initialKn;
+			contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
+			contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
+
+		}
+		else
+		{	// FIXME - are those lines necessary ???? what they are doing in fact ???
+			CapillaryParameters* contactPhysics = static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+
+			contactPhysics-&gt;kn = contactPhysics-&gt;initialKn;
+			contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
+			contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
+		}	
+		
+	}
+	else   // this is PERMANENT LINK because previous static_cast failed, dispatcher should do this job
+	{
+		SDECLinkGeometry* sdecLinkGeometry =  static_cast&lt;SDECLinkGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+		if (sdecLinkGeometry)
+		{		
+			SDECLinkPhysics* linkPhysics = static_cast&lt;SDECLinkPhysics*&gt;(interaction-&gt;interactionPhysics.get());
+	//		linkPhysics-&gt;frictionAngle 		= ?? //FIXME - uninitialized 
+			linkPhysics-&gt;kn 			= linkPhysics-&gt;initialKn;
+			linkPhysics-&gt;ks 			= linkPhysics-&gt;initialKs;
+			linkPhysics-&gt;equilibriumDistance 	= linkPhysics-&gt;initialEquilibriumDistance;
+		}
+	}
+};


Property changes on: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.hpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,37 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef SDECLINEARCONTACTMODEL_HPP
+#define SDECLINEARCONTACTMODEL_HPP
+
+#include &lt;yade/pkg-common/InteractionPhysicsEngineUnit.hpp&gt;
+
+class MacroMicroElasticRelationshipsWater : public InteractionPhysicsEngineUnit
+{
+	public :
+		Real		 alpha
+				,beta
+				,gamma;
+
+		MacroMicroElasticRelationshipsWater();
+
+		virtual void go(	const shared_ptr&lt;PhysicalParameters&gt;&amp; b1,
+					const shared_ptr&lt;PhysicalParameters&gt;&amp; b2,
+					const shared_ptr&lt;Interaction&gt;&amp; interaction);
+
+	protected :
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(MacroMicroElasticRelationshipsWater);
+	REGISTER_BASE_CLASS_NAME(InteractionPhysicsEngineUnit);
+
+};
+
+REGISTER_SERIALIZABLE(MacroMicroElasticRelationshipsWater,false);
+
+#endif // __SDECLINEARCONTACTMODEL_HPP__
+


Property changes on: trunk/pkg/dem/Engine/EngineUnit/MacroMicroElasticRelationshipsWater.hpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,522 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;CapillaryCohesiveLaw.hpp&quot;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+#include &lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+
+#include &lt;yade/pkg-dem/CapillaryParameters.hpp&gt;
+#include &lt;yade/core/Omega.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;yade/pkg-common/Force.hpp&gt;
+#include &lt;yade/pkg-common/Momentum.hpp&gt;
+#include &lt;yade/core/PhysicalAction.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include &lt;yade/lib-base/yadeWm3.hpp&gt;
+
+#include &lt;yade/core/GeometricalModel.hpp&gt;
+
+
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+using namespace std;
+
+//int compteur1 = 0;
+//int compteur2 = 0;
+
+CapillaryCohesiveLaw::CapillaryCohesiveLaw() : InteractionSolver() , actionForce(new Force) , actionMomentum(new Momentum)
+{
+        sdecGroupMask=1;
+
+        capillary = shared_ptr&lt;capillarylaw&gt;(new capillarylaw); // ????????
+
+        //importFilename 		= &quot;../data&quot;; // chemin vers M(r=...)
+
+        capillary-&gt;fill(&quot;M(r=1)&quot;);
+        capillary-&gt;fill(&quot;M(r=1.1)&quot;);
+        capillary-&gt;fill(&quot;M(r=1.25)&quot;);
+        capillary-&gt;fill(&quot;M(r=1.5)&quot;);
+        capillary-&gt;fill(&quot;M(r=1.75)&quot;);
+        capillary-&gt;fill(&quot;M(r=2)&quot;);
+        capillary-&gt;fill(&quot;M(r=3)&quot;);
+        capillary-&gt;fill(&quot;M(r=4)&quot;);
+        capillary-&gt;fill(&quot;M(r=5)&quot;);
+        capillary-&gt;fill(&quot;M(r=10)&quot;);
+
+        CapillaryPressure=0;
+
+}
+
+
+void CapillaryCohesiveLaw::registerAttributes()
+{
+        InteractionSolver::registerAttributes();
+        REGISTER_ATTRIBUTE(sdecGroupMask);
+        REGISTER_ATTRIBUTE(CapillaryPressure);
+
+}
+
+Parameters::Parameters()
+{
+        V = 0;
+        F = 0;
+        delta1 = 0;
+        delta2 = 0;
+};
+
+Parameters::Parameters(const Parameters &amp;source)
+{
+        V = source.V;
+        F = source.F;
+        delta1 = source.delta1;
+        delta2 = source.delta2;
+}
+
+Parameters::~Parameters()
+{}
+;
+
+//FIXME : remove bool first !!!!!
+void CapillaryCohesiveLaw::action(Body* body)
+{
+
+//compteur1 = 0;
+//compteur2 = 0;
+        // 	cerr &lt;&lt; &quot;CapillaryCohesiveLaw::action&quot; &lt;&lt; endl;
+
+        MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+        shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+
+
+        /// Non Permanents Links ///
+
+        //InteractionContainer::iterator ii    = ncb-&gt;persistentInteractions-&gt;begin();
+        InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
+        //InteractionContainer::iterator iiEnd = ncb-&gt;persistentInteractions-&gt;end();
+        InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
+
+        /// initialisation du volume avant calcul
+        //Real Vtotal = 0;
+
+        for(  ; ii!=iiEnd ; ++ii ) {
+
+                if ((*ii)-&gt;isReal) {
+
+                        const shared_ptr&lt;Interaction&gt;&amp; interaction = *ii;
+                        unsigned int id1 = interaction-&gt;getId1();
+                        unsigned int id2 = interaction-&gt;getId2();
+
+                        if( !( (*bodies)[id1]-&gt;getGroupMask() &amp; (*bodies)[id2]-&gt;getGroupMask() &amp; sdecGroupMask)  )
+                                continue; // skip other groups, BTW: this is example of a good usage of 'continue' keyword
+
+                        /// interaction geometry search
+
+                        int geometryIndex1 = (*bodies)[id1]-&gt;geometricalModel-&gt;getClassIndex(); // !!!
+                        //cerr &lt;&lt; &quot;geo1 =&quot; &lt;&lt; geometryIndex1 &lt;&lt; endl;
+                        int geometryIndex2 = (*bodies)[id2]-&gt;geometricalModel-&gt;getClassIndex();
+                        //cerr &lt;&lt; &quot;geo2 =&quot; &lt;&lt; geometryIndex2 &lt;&lt; endl;
+
+                        if (!(geometryIndex1 == geometryIndex2))
+                                continue;
+
+                        /// definition of interacting objects (not in contact)
+
+                        BodyMacroParameters* de1 		=
+                                static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id1]-&gt;physicalParameters.get());
+                        BodyMacroParameters* de2 		=
+                                static_cast&lt;BodyMacroParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
+
+                        SpheresContactGeometry* currentContactGeometry 	=
+                                static_cast&lt;SpheresContactGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+
+                        //SDECLinkGeometry* currentContactGeometry	= static_cast&lt;SDECLinkGeometry*&gt;(interaction-&gt;interactionGeometry.get());
+
+                        CapillaryParameters* currentContactPhysics 	=
+                                static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+
+                        //SDECLinkPhysics* currentContactPhysics	= static_cast&lt;SDECLinkPhysics*&gt;(interaction-&gt;interactionPhysics.get());
+
+                        //                         CapillaryParameters* meniscusParameters
+                        // = static_cast&lt;CapillaryParameters*&gt;(interaction-&gt;interactionPhysics.get());
+
+                        /// Capillary components definition:
+
+                        Real liquidTension = 0.073; 	// superficial
+                        //tension of water N/m (20&#65533;C)
+
+                        //Real teta = 0;		// mouillage parfait (eau pure/billes de verre)
+
+                        /// Interacting Grains:
+                        // d&#65533;finition du rapport tailleR&#65533;elle/TailleYADE
+                        Real alpha=1; // OK si pas de gravit&#65533;!!!
+
+                        Real R1 = 0;
+                        R1=alpha*std::min(currentContactGeometry-&gt;radius2,currentContactGeometry-&gt;
+                                          radius1 ) ;
+                        Real R2 = 0;
+                        R2=alpha*std::max(currentContactGeometry-&gt;radius2,currentContactGeometry-&gt;
+                                          radius1 ) ;
+                        //cerr &lt;&lt; &quot;R1 = &quot; &lt;&lt; R1 &lt;&lt; &quot; R2 = &quot;&lt;&lt; R2 &lt;&lt; endl;
+
+                        /// intergranular distance
+
+                        Real intergranularDistance =
+                                currentContactGeometry-&gt;penetrationDepth;
+
+                        Real D =
+                                alpha*(de2-&gt;se3.position-de1-&gt;se3.position).Length()-alpha*(
+                                        currentContactGeometry-&gt;radius1+ currentContactGeometry-&gt;radius2);
+                     
+
+                        if
+                        ((currentContactGeometry-&gt;penetrationDepth&gt;=0)||(D&lt;=0)||CapillaryPressure&lt;=300||
+                                        (Omega::instance().getCurrentIteration() &lt; 2) ) {
+                                //                         			cerr &lt;&lt; &quot;if (currentContactGeometry-&gt;penetrationDepth &gt;= 0)&quot; &lt;&lt; endl ;
+                                D = 0;	// defin Fcap when spheres interpenetrate
+                                currentContactPhysics-&gt;meniscus=true;
+                                //meniscusParameters-&gt;meniscus=true;
+                                //                         				cerr &lt;&lt; &quot;END ## if (currentContactGeometry-&gt;penetrationDepth &gt;= 0)&quot; &lt;&lt; endl ;
+                        }
+                        //                         cerr &lt;&lt; &quot;D = &quot; &lt;&lt; D &lt;&lt; &quot; | Depth = &quot; &lt;&lt;
+                        // currentContactGeometry-&gt;penetrationDepth &lt;&lt; endl;
+                        //
+                        //                       	cerr &lt;&lt; &quot;meniscus = &quot; &lt;&lt;
+                        // 			currentContactPhysics-&gt;meniscus &lt;&lt; endl;
+
+                        Real Dinterpol = D/R2;
+
+                        /// Suction (Capillary pressure):
+
+                        Real Pinterpol =CapillaryPressure*(R2/liquidTension);
+                        //cerr &lt;&lt; &quot;CapillaryPressure LAW = &quot;&lt;&lt;
+                        //CapillaryPressure&lt;&lt; endl;
+                        //meniscusParameters-&gt;CapillaryPressure = CapillaryPressure;
+                        currentContactPhysics-&gt;CapillaryPressure = CapillaryPressure;
+
+                        Real r = R2/R1;
+
+                        //cerr &lt;&lt; &quot;r = &quot;&lt;&lt; R2/R1 &lt;&lt; endl ;
+                        //cerr &lt;&lt; &quot;Dinterpol = &quot; &lt;&lt; Dinterpol &lt;&lt; endl;
+
+                        /// Capillary solution finder:
+
+                        //cerr &lt;&lt; &quot;solution finder &quot; &lt;&lt; endl;
+
+                        if ((Pinterpol&gt;=0) &amp;&amp; (currentContactPhysics-&gt;meniscus==true))
+                                //if (Pinterpol&gt;=0)
+
+                        {	//cerr &lt;&lt; &quot;Pinterpol = &quot;&lt;&lt; Pinterpol &lt;&lt; endl;
+
+                                Parameters
+                                solution(capillary-&gt;Interpolate(R1,R2,
+                                                                Dinterpol, Pinterpol, currentContactPhysics-&gt;currentIndexes));
+
+                                /// capillary adhesion force
+
+                                Real Finterpol = solution.F;
+                                Vector3r Fcap =
+                                        Finterpol*(2*Mathr::PI*(R2/alpha)*liquidTension)*currentContactGeometry-&gt;
+                                        normal; /// unit&#65533;s !!!
+
+                                currentContactPhysics-&gt;Fcap = Fcap;
+
+                                // 				cerr &lt;&lt; &quot;CapillaryPressure = &quot;&lt;&lt; CapillaryPressure &lt;&lt; endl;
+
+                                //cerr &lt;&lt; &quot;Finterpol = &quot; &lt;&lt; Finterpol &lt;&lt; endl ;
+
+                                /// meniscus volume
+
+                                Real Vinterpol = solution.V;
+                                currentContactPhysics-&gt;Vmeniscus =
+                                        Vinterpol*(R2*R2*R2)/(alpha*alpha*alpha);
+                                //meniscusParameters-&gt;Vmeniscus = Vinterpol*(R2*R2*R2);
+
+                                //Vtotal = (Vtotal+meniscusParameters-&gt;Vmeniscus);
+
+                                //                                 if (meniscusParameters-&gt;Vmeniscus != 0) {
+                                //                                         meniscusParameters-&gt;meniscus = true;
+                                //                                 } else {
+                                //                                         meniscusParameters-&gt;meniscus = false;
+                                //                                 }
+                                //
+                                //                                 cerr &lt;&lt; &quot; | meniscus = &quot;&lt;&lt; meniscusParameters-&gt;meniscus &lt;&lt; &quot; | V = &quot; &lt;&lt; meniscusParameters-&gt;Vmeniscus &lt;&lt; endl ;
+                                //
+                                //                                 /// wetting angles
+                                //                                 meniscusParameters-&gt;Delta1 = max(solution.delta1,solution.delta2);
+                                //                                 meniscusParameters-&gt;Delta2 = min(solution.delta1,solution.delta2);
+                                //
+                                //                                 cerr &lt;&lt; &quot;delta1 = &quot; &lt;&lt; meniscusParameters-&gt;Delta1 &lt;&lt; &quot;| delta2 = &quot; &lt;&lt; meniscusParameters-&gt;Delta2 &lt;&lt; endl;
+
+                                if (currentContactPhysics-&gt;Vmeniscus != 0)
+                                {
+                                        currentContactPhysics-&gt;meniscus = true;
+                                } else
+                                {
+                                        currentContactPhysics-&gt;meniscus = false;
+                                }
+
+                                //                                 cerr &lt;&lt; &quot; | meniscus = &quot;&lt;&lt;
+                                // 				currentContactPhysics-&gt;meniscus &lt;&lt; &quot; | V = &quot; &lt;&lt;
+                                // 				currentContactPhysics-&gt;Vmeniscus &lt;&lt; endl ;
+
+                                /// wetting angles
+                                currentContactPhysics-&gt;Delta1 = max(solution.delta1,solution.delta2);
+                                currentContactPhysics-&gt;Delta2 = min(solution.delta1,solution.delta2);
+
+                                //cerr &lt;&lt; &quot;delta1 = &quot; &lt;&lt; currentContactPhysics-&gt;Delta1 &lt;&lt; &quot;| delta2 = &quot; &lt;&lt; currentContactPhysics-&gt;Delta2 &lt;&lt; endl;
+
+                                static_cast&lt;Force*&gt;   (ncb-&gt;physicalActions-&gt;find( id1 , actionForce  -&gt;getClassIndex()).get())-&gt;force    += Fcap;
+                                static_cast&lt;Force*&gt;   (ncb-&gt;physicalActions-&gt;find( id2 , actionForce  -&gt;getClassIndex()).get())-&gt;force    -= Fcap;
+
+                                currentContactPhysics-&gt;prevNormal = currentContactGeometry-&gt;normal;
+
+                        }
+                }
+        }
+//cerr &lt;&lt; &quot;compteur1=&quot; &lt;&lt; compteur1 &lt;&lt; &quot;; compteur2=&quot; &lt;&lt; compteur2 &lt;&lt; endl;
+}
+
+capillarylaw::capillarylaw()
+{}
+
+void capillarylaw::fill(const char* filename)
+
+{
+        data_complete.push_back(Tableau(filename));
+
+}
+
+Parameters capillarylaw::Interpolate(Real R1, Real R2, Real D, Real P, int* index)
+
+{	//cerr &lt;&lt; &quot;interpolate&quot; &lt;&lt; endl;
+        if (R1 &gt; R2) {
+                Real R3 = R1;
+                R1 = R2;
+                R2 = R3;
+        }
+
+        Real R = R2/R1;
+        //cerr &lt;&lt; &quot;R = &quot; &lt;&lt; R &lt;&lt; endl;
+
+        Parameters result_inf;
+        Parameters result_sup;
+        Parameters result;
+        int i = 0;
+
+        for ( i; i &lt; (NB_R_VALUES); i++)
+        {
+                Real data_R = data_complete[i].R;
+                //cerr &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
+
+                if (data_R &gt; R)	// Attention &#65533; l'ordre ds lequel
+                        //vont &#65533;tre rang&#65533;s les tableau R (croissant)
+
+                {
+                        Tableau&amp; tab_inf=data_complete[i-1];
+                        Tableau&amp; tab_sup=data_complete[i];
+
+                        Real r=(R-tab_inf.R)/(tab_sup.R-tab_inf.R);
+
+                        result_inf = tab_inf.Interpolate2(D,P,index[0], index[1]);
+                        result_sup = tab_sup.Interpolate2(D,P,index[2], index[3]);
+
+                        result.V = result_inf.V*(1-r) + r*result_sup.V;
+                        result.F = result_inf.F*(1-r) + r*result_sup.F;
+                        result.delta1 = result_inf.delta1*(1-r) + r*result_sup.delta1;
+                        result.delta2 = result_inf.delta2*(1-r) + r*result_sup.delta2;
+
+                        i=NB_R_VALUES;
+                        //cerr &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
+
+                }
+                else if (data_complete[i].R == R)
+                {
+                        result = data_complete[i].Interpolate2(D,P, index[0], index[1]);
+                        i=NB_R_VALUES;
+                        //cerr &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; endl;
+                }
+        }
+        return result;
+}
+
+Tableau::Tableau()
+{}
+
+Tableau::Tableau(const char* filename)
+
+{
+        ifstream file (filename);
+        file &gt;&gt; R;
+        //cerr &lt;&lt; &quot;r = &quot; &lt;&lt; R &lt;&lt; endl;
+        int n_D;	//number of D values
+        file &gt;&gt; n_D;
+
+        if (!file.is_open())
+                cout &lt;&lt; &quot;problem opening file for capillary law&quot; &lt;&lt; endl;
+        for (int i=0; i&lt;n_D; i++)
+                full_data.push_back(TableauD(file));
+        file.close();
+        //cerr &lt;&lt; *this;	// exemple d'utilisation de la fonction d'&#65533;criture (this est le pointeur vers l'objet courant)
+}
+
+Tableau::~Tableau()
+{}
+
+Parameters Tableau::Interpolate2(Real D, Real P, int&amp; index1, int&amp; index2)
+
+{	//cerr &lt;&lt; &quot;interpolate2&quot; &lt;&lt; endl;
+        Parameters result;
+        Parameters result_inf;
+        Parameters result_sup;
+
+        for ( int i=0; i &lt; full_data.size(); ++i)
+        {
+                if (full_data[i].D &gt; D )	// ok si D rang&#65533;s ds l'ordre croissant
+
+                {
+                        Real rD = (D-full_data[i-1].D)/(full_data[i].D-full_data[i-1].D);
+
+                        result_inf = full_data[i-1].Interpolate3(P, index1);
+                        result_sup = full_data[i].Interpolate3(P, index2);
+
+                        result.V = result_inf.V*(1-rD) + rD*result_sup.V;
+                        result.F = result_inf.F*(1-rD) + rD*result_sup.F;
+                        result.delta1 = result_inf.delta1*(1-rD) + rD*result_sup.delta1;
+                        result.delta2 = result_inf.delta2*(1-rD) + rD*result_sup.delta2;
+
+                        i = full_data.size();
+                }
+                else if (full_data[i].D == D)
+                {
+                        result=full_data[i].Interpolate3(P, index1);
+
+                        i=full_data.size();
+                }
+
+        }
+        return result;
+}
+
+TableauD::TableauD()
+{} // ?? constructeur
+
+TableauD::TableauD(ifstream&amp; file)
+
+{
+        int i=0;
+        Real x;
+        int n_lines;	//pb: n_lines is real!!!
+        file &gt;&gt; n_lines;
+        //cout &lt;&lt; n_lines &lt;&lt; endl;
+
+        file.ignore(200, '\n'); // saute les caract&#65533;res (200 au maximum) jusque au caract&#65533;re \n (fin de ligne)*_
+
+        if (n_lines!=0)
+                for (i; i&lt;n_lines; ++i) {
+                        data.push_back(vector&lt;Real&gt; ());
+                        for (int j=0; j &lt; 6; ++j)	// [D,P,V,F,delta1,delta2]
+                        {
+                                file &gt;&gt; x;
+                                data[i].push_back(x);
+                        }
+                }
+        D = data[i-1][0];
+}
+
+Parameters TableauD::Interpolate3(Real P, int&amp; index)
+
+{	//cerr &lt;&lt; &quot;interpolate3&quot; &lt;&lt; endl;
+        Parameters result;
+        int dataSize = data.size();
+        
+        if (index &lt; dataSize &amp;&amp; index&gt;0)
+        {
+        	if (data[index][1] &gt;= P &amp;&amp; data[index-1][1] &lt; P)
+        	{
+        		//compteur1+=1;	
+        		Real Pinf=data[index-1][1];
+                        Real Finf=data[index-1][3];
+                        Real Vinf=data[index-1][2];
+                        Real Delta1inf=data[index-1][4];
+                        Real Delta2inf=data[index-1][5];
+
+                        Real Psup=data[index][1];
+                        Real Fsup=data[index][3];
+                        Real Vsup=data[index][2];
+                        Real Delta1sup=data[index][4];
+                        Real Delta2sup=data[index][5];
+
+                        result.V = Vinf+((Vsup-Vinf)/(Psup-Pinf))*(P-Pinf);
+                        result.F = Finf+((Fsup-Finf)/(Psup-Pinf))*(P-Pinf);
+                        result.delta1 = Delta1inf+((Delta1sup-Delta1inf)/(Psup-Pinf))*(P-Pinf);
+                        result.delta2 = Delta2inf+((Delta2sup-Delta2inf)/(Psup-Pinf))*(P-Pinf);
+                        return result;
+        		
+        	}
+        }
+	//compteur2+=1;	
+        for (int k=1; k &lt; dataSize; ++k) 	// Length(data) ??
+
+        {	//cerr &lt;&lt; &quot;k = &quot; &lt;&lt; k &lt;&lt; endl;
+                if ( data[k][1] &gt; P) 	// OK si P rang&#233;s ds l'ordre croissant
+
+                {	//cerr &lt;&lt; &quot;if&quot; &lt;&lt; endl;
+                        Real Pinf=data[k-1][1];
+                        Real Finf=data[k-1][3];
+                        Real Vinf=data[k-1][2];
+                        Real Delta1inf=data[k-1][4];
+                        Real Delta2inf=data[k-1][5];
+
+                        Real Psup=data[k][1];
+                        Real Fsup=data[k][3];
+                        Real Vsup=data[k][2];
+                        Real Delta1sup=data[k][4];
+                        Real Delta2sup=data[k][5];
+
+                        result.V = Vinf+((Vsup-Vinf)/(Psup-Pinf))*(P-Pinf);
+                        result.F = Finf+((Fsup-Finf)/(Psup-Pinf))*(P-Pinf);
+                        result.delta1 = Delta1inf+((Delta1sup-Delta1inf)/(Psup-Pinf))*(P-Pinf);
+                        result.delta2 = Delta2inf+((Delta2sup-Delta2inf)/(Psup-Pinf))*(P-Pinf);
+                        index = k;
+
+                        k=dataSize;
+                }
+                else if (data[k][1] == P)
+
+                {	//cerr &lt;&lt; &quot;elseif&quot; &lt;&lt; endl;
+                        result.V = data[k][2];
+                        result.F = data[k][3];
+                        result.delta1 = data[k][4];
+                        result.delta2 = data[k][5];
+                        index = k;
+
+                        k=dataSize;
+                }
+
+        }
+        return result;
+}
+
+TableauD::~TableauD()
+{} // ?? destructeur
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Tableau&amp; T)
+{
+        os &lt;&lt; &quot;Tableau : R=&quot; &lt;&lt; T.R &lt;&lt; endl;
+        for (int i=0; i&lt;T.full_data.size(); i++) {
+                os &lt;&lt; &quot;TableauD : D=&quot; &lt;&lt; T.full_data[i].D &lt;&lt; endl;
+                for (int j=0; j&lt;T.full_data[i].data.size();j++) {
+                        for (int k=0; k&lt;T.full_data[i].data[j].size(); k++)
+                                os &lt;&lt; T.full_data[i].data[j][k] &lt;&lt; &quot; &quot;;
+                        os &lt;&lt; endl;
+                }
+        }
+        os &lt;&lt; endl;
+        return os;
+}


Property changes on: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,113 @@
+//
+// C++ Interface: CapillaryCohesiveLaw
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef CAPILLARY_COHESIVE_LAW_HPP
+#define CAPILLARY_COHESIVE_LAW_HPP
+
+#include &lt;yade/core/InteractionSolver.hpp&gt;
+#include &lt;set&gt;
+#include &lt;boost/tuple/tuple.hpp&gt;
+
+// ajouts
+#include &lt;vector&gt;
+#include &lt;utility&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;string&gt;
+
+using namespace std;
+
+class Parameters
+
+{ 
+  public :
+  Real V;
+  Real F;
+  Real delta1;
+  Real delta2;
+  int index1;
+  int index2;
+
+  Parameters();
+  Parameters(const Parameters &amp;source); // construction par recopie
+  ~Parameters();
+} ;
+
+
+const int NB_R_VALUES = 10;
+
+class PhysicalAction;
+class capillarylaw; // fait appel &#65533; la classe def plus bas
+
+class CapillaryCohesiveLaw : public InteractionSolver
+{
+	private :
+		shared_ptr&lt;PhysicalAction&gt; actionForce;
+		shared_ptr&lt;PhysicalAction&gt; actionMomentum;
+		
+	public :
+		int sdecGroupMask;
+		Real CapillaryPressure;
+		shared_ptr&lt;capillarylaw&gt; capillary;
+						
+		CapillaryCohesiveLaw();
+		void action(Body* body);
+
+	protected : 
+		void registerAttributes();
+	REGISTER_CLASS_NAME(CapillaryCohesiveLaw);
+	REGISTER_BASE_CLASS_NAME(InteractionSolver);
+
+};
+
+class TableauD
+{
+	public:
+		Real D;
+		std::vector&lt;std::vector&lt;Real&gt; &gt; data;
+		Parameters Interpolate3(Real P, int&amp; index);
+		
+  		TableauD();
+  		TableauD(std::ifstream&amp; file);
+  		~TableauD();
+};
+
+// Fonction d'&#65533;criture de tableau, utilis&#65533;e dans le constructeur pour test 
+class Tableau;
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Tableau&amp; T);
+
+class Tableau
+{	
+	public: 
+		Real R;
+		std::vector&lt;TableauD&gt; full_data;
+		Parameters Interpolate2(Real D, Real P, int&amp; index1, int&amp; index2);
+		
+		std::ifstream&amp; operator&lt;&lt; (std::ifstream&amp; file);
+		
+		Tableau();
+    		Tableau(const char* filename);
+    		~Tableau();
+};
+
+class capillarylaw
+{
+	public:
+		capillarylaw();
+		std::vector&lt;Tableau&gt; data_complete;
+		Parameters Interpolate(Real R1, Real R2, Real D, Real P, int* index);
+		
+		void fill (const char* filename);
+};
+
+REGISTER_SERIALIZABLE(CapillaryCohesiveLaw,false);
+
+#endif // CAPILLARY_COHESIVE_LAW_HPP
+


Property changes on: trunk/pkg/dem/Engine/StandAloneEngine/CapillaryCohesiveLaw.hpp
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticContactLaw.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -6,7 +6,8 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;ElasticContactLaw.hpp&quot;
+#include &lt;yade/pkg-dem/ElasticContactLaw.hpp&gt;
+
 #include&lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
 #include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
 #include&lt;yade/pkg-dem/SDECLinkGeometry.hpp&gt;
@@ -68,7 +69,7 @@
 				shearForce			= Vector3r(0,0,0);
 					
 			Real un 				= currentContactGeometry-&gt;penetrationDepth;
-			currentContactPhysics-&gt;normalForce	= currentContactPhysics-&gt;kn*un*currentContactGeometry-&gt;normal;
+			currentContactPhysics-&gt;normalForce	= currentContactPhysics-&gt;kn*std::max(un,(Real) 0)*currentContactGeometry-&gt;normal;
 	
 			Vector3r axis;
 			Real angle;

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -63,6 +63,9 @@
                         int id1 = contact-&gt;getId1();
                         int id2 = contact-&gt;getId2();
 
+			//if body_getId1.isClumpMember() Id1 = ball from clump Idc
+			// Id1 = Body::clumpId
+
                         //if( !( (*bodies)[id1]-&gt;getGroupMask() &amp; (*bodies)[id2]-&gt;getGroupMask() &amp; sdecGroupMask)  )
                         //continue; // skip other groups, BTW: this is example of a good usage of 'continue' keyword
 

Added: trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,748 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;TriaxialTestWater.hpp&quot;
+
+#include &lt;yade/pkg-dem/ElasticContactLaw.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryCohesiveLaw.hpp&gt;
+
+#include &lt;yade/pkg-dem/MacroMicroElasticRelationships.hpp&gt;
+#include &lt;yade/pkg-dem/BodyMacroParameters.hpp&gt;
+
+#include &lt;yade/pkg-dem/GlobalStiffnessCounter.hpp&gt;
+#include &lt;yade/pkg-dem/GlobalStiffnessTimeStepper.hpp&gt;
+
+#include &lt;yade/pkg-dem/AveragePositionRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/ForceRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/VelocityRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/WallStressRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/CapillaryStressRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/ContactStressRecorder.hpp&gt;
+#include &lt;yade/pkg-dem/TriaxialStressController.hpp&gt;
+#include &lt;yade/pkg-dem/TriaxialCompressionEngine.hpp&gt;
+
+#include &lt;yade/pkg-common/Box.hpp&gt;
+#include &lt;yade/pkg-common/AABB.hpp&gt;
+#include &lt;yade/pkg-common/Sphere.hpp&gt;
+#include &lt;yade/core/MetaBody.hpp&gt;
+#include &lt;yade/pkg-common/SAPCollider.hpp&gt;
+#include &lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
+#include &lt;yade/lib-serialization/IOFormatManager.hpp&gt;
+#include &lt;yade/core/Interaction.hpp&gt;
+#include &lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
+#include &lt;yade/pkg-common/MetaInteractingGeometry2AABB.hpp&gt;
+#include &lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
+
+#include &lt;yade/pkg-common/GravityEngine.hpp&gt;
+#include &lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
+#include &lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
+#include &lt;yade/pkg-common/CundallNonViscousForceDamping.hpp&gt;
+#include &lt;yade/pkg-common/CundallNonViscousMomentumDamping.hpp&gt;
+
+#include &lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
+#include &lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
+#include &lt;yade/core/Body.hpp&gt;
+#include &lt;yade/pkg-common/InteractingBox.hpp&gt;
+#include &lt;yade/pkg-common/InteractingSphere.hpp&gt;
+
+#include &lt;yade/pkg-common/PhysicalActionContainerReseter.hpp&gt;
+#include &lt;yade/pkg-common/PhysicalActionContainerInitializer.hpp&gt;
+
+#include &lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
+
+#include &lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
+#include &lt;yade/pkg-common/InteractionVecSet.hpp&gt;
+#include &lt;yade/pkg-common/InteractionHashMap.hpp&gt;
+#include &lt;yade/pkg-common/PhysicalActionVectorVector.hpp&gt;
+
+#include &lt;boost/filesystem/convenience.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+#include &lt;boost/numeric/conversion/bounds.hpp&gt;
+#include &lt;boost/limits.hpp&gt;
+
+// random
+#include &lt;boost/random/linear_congruential.hpp&gt;
+#include &lt;boost/random/uniform_real.hpp&gt;
+#include &lt;boost/random/variate_generator.hpp&gt;
+#include &lt;boost/random/normal_distribution.hpp&gt;
+
+
+
+using namespace boost;
+using namespace std;
+
+
+typedef pair&lt;Vector3r, Real&gt; BasicSphere;
+//! make a list of spheres non-overlapping sphere
+string GenerateCloud(vector&lt;BasicSphere&gt;&amp; sphere_list, Vector3r lowerCorner, Vector3r upperCorner, long number, Real rad_std_dev, Real porosity);
+
+
+TriaxialTestWater::TriaxialTestWater () : FileGenerator()
+{
+	lowerCorner 		= Vector3r(0,0,0);
+	upperCorner 		= Vector3r(0.0065,0.0065,0.0065);
+	thickness 		= 0.00001;
+	importFilename 		= &quot;../data/small.sdec.xyz&quot;;
+	outputFileName 		= &quot;../data/TriaxialTestWater.xml&quot;;
+	//nlayers = 1;
+	wall_top 		= true;
+	wall_bottom 		= true;
+	wall_1			= true;
+	wall_2			= true;
+	wall_3			= true;
+	wall_4			= true;
+	wall_top_wire 		= true;
+	wall_bottom_wire	= true;
+	wall_1_wire		= true;
+	wall_2_wire		= true;
+	wall_3_wire		= true;
+	wall_4_wire		= true;
+	spheresColor		= Vector3r(0.8,0.3,0.3);
+	spheresRandomColor	= false;
+	recordBottomForce	= true;
+	forceRecordFile		= &quot;../data/force&quot;;
+	recordAveragePositions	= true;
+	positionRecordFile	= &quot;../data/position&quot;;
+	recordIntervalIter	= 100;
+	velocityRecordFile 	= &quot;../data/velocities&quot;;
+	wallStressRecordFile	= &quot;../data/wallStress&quot;;
+	capillaryStressRecordFile	= &quot;../data/capillaryStress&quot;;
+	contactStressRecordFile	= &quot;../data/contactStress&quot;;
+	rotationBlocked = false;
+	
+//	boxWalls 		= false;
+	boxWalls 		= true;
+	internalCompaction	=false;
+
+//	bigBall 		= true;
+	bigBall 		= false;
+	bigBallRadius		= 0.075;
+	bigBallPoissonRatio 	= 0.3;
+	bigBallYoungModulus 	= 10000000.0;
+	bigBallFrictDeg 	= 60;
+	bigBallDensity		= 7800;
+	bigBallDropTimeSeconds	= 30;
+	bigBallDropHeight 	= 3.04776;
+	
+	dampingForce = 0.2;
+	dampingMomentum = 0.2;
+	
+	defaultDt = 0.000001;
+	timeStepUpdateInterval = 50;
+	timeStepOutputInterval = 50;
+	wallStiffnessUpdateInterval = 1;
+	numberOfGrains = 1000;
+	max_vel = 0.00001;
+	strainRate = 0.1;
+	StabilityCriterion = 0.01;
+	autoCompressionActivation = true;
+	maxMultiplier = 1.001;
+	finalMaxMultiplier = 1.00001;
+	
+	sphereYoungModulus  = 150000000.0;
+	spherePoissonRatio  = 0.2;
+	sphereFrictionDeg   = 18.0;
+	density		    = 2600;
+	Rdispersion 	    = 1.4;
+	
+	boxYoungModulus   = 150000000.0;
+	boxPoissonRatio  = 0.2;
+	boxFrictionDeg   = 0;
+	gravity 	= Vector3r(0,-9.81,0);
+	
+	sigma_iso = 50000;
+	water = true;
+	CapillaryPressure = 0;
+	
+}
+
+
+TriaxialTestWater::~TriaxialTestWater ()
+{
+
+}
+
+
+void TriaxialTestWater::registerAttributes()
+{
+	REGISTER_ATTRIBUTE(lowerCorner);
+	REGISTER_ATTRIBUTE(upperCorner);
+	REGISTER_ATTRIBUTE(thickness);
+	REGISTER_ATTRIBUTE(importFilename);
+	REGISTER_ATTRIBUTE(internalCompaction);
+	REGISTER_ATTRIBUTE(maxMultiplier);
+	REGISTER_ATTRIBUTE(finalMaxMultiplier);
+
+	REGISTER_ATTRIBUTE(sphereYoungModulus);
+	REGISTER_ATTRIBUTE(spherePoissonRatio);
+	REGISTER_ATTRIBUTE(sphereFrictionDeg);
+
+	REGISTER_ATTRIBUTE(boxYoungModulus);
+	REGISTER_ATTRIBUTE(boxPoissonRatio);
+	REGISTER_ATTRIBUTE(boxFrictionDeg);
+
+	REGISTER_ATTRIBUTE(density);
+	REGISTER_ATTRIBUTE(Rdispersion);
+	REGISTER_ATTRIBUTE(dampingForce);
+	REGISTER_ATTRIBUTE(dampingMomentum);
+	REGISTER_ATTRIBUTE(rotationBlocked);
+	REGISTER_ATTRIBUTE(defaultDt);
+	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
+	REGISTER_ATTRIBUTE(timeStepOutputInterval);
+	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
+	REGISTER_ATTRIBUTE(numberOfGrains);
+	REGISTER_ATTRIBUTE(max_vel)
+	
+	REGISTER_ATTRIBUTE(strainRate);
+	REGISTER_ATTRIBUTE(StabilityCriterion);
+	REGISTER_ATTRIBUTE(autoCompressionActivation);
+
+	REGISTER_ATTRIBUTE(recordBottomForce);
+	REGISTER_ATTRIBUTE(forceRecordFile);
+// 	REGISTER_ATTRIBUTE(recordAveragePositions);
+	REGISTER_ATTRIBUTE(positionRecordFile);
+	REGISTER_ATTRIBUTE(velocityRecordFile)
+	REGISTER_ATTRIBUTE(recordIntervalIter);
+	REGISTER_ATTRIBUTE(wallStressRecordFile);
+	REGISTER_ATTRIBUTE(capillaryStressRecordFile);
+	REGISTER_ATTRIBUTE(contactStressRecordFile);
+
+	REGISTER_ATTRIBUTE(sigma_iso);
+	REGISTER_ATTRIBUTE(water);
+	REGISTER_ATTRIBUTE(CapillaryPressure);
+
+}
+
+
+string TriaxialTestWater::generate()
+{
+	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2
+	
+	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
+	createActors(rootBody);
+	positionRootBody(rootBody);
+
+	rootBody-&gt;persistentInteractions = 
+	shared_ptr&lt;InteractionContainer&gt;(new InteractionHashMap);
+	rootBody-&gt;transientInteractions		=
+	shared_ptr&lt;InteractionContainer&gt;(new InteractionHashMap);
+	rootBody-&gt;physicalActions		= shared_ptr&lt;PhysicalActionContainer&gt;(new PhysicalActionVectorVector);
+	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
+
+	shared_ptr&lt;Body&gt; body;
+	
+	vector&lt;BasicSphere&gt; sphere_list;
+	string output = GenerateCloud(sphere_list, lowerCorner, upperCorner,
+	numberOfGrains, Rdispersion, 0.75);
+	
+	vector&lt;BasicSphere&gt;::iterator it = sphere_list.begin();
+	vector&lt;BasicSphere&gt;::iterator it_end = sphere_list.end();
+			
+	for (;it!=it_end; ++it)
+	{
+		cerr &lt;&lt; &quot;sphere (&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
+		createSphere(body,it-&gt;first,it-&gt;second,false,true);
+		rootBody-&gt;bodies-&gt;insert(body);
+	}
+	
+
+//	forcerec-&gt;bigBallReleaseTime = 0;
+
+	if(boxWalls)
+	{
+	// bottom box
+	 	Vector3r center		= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						lowerCorner[1]-thickness/2.0,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+	 	Vector3r halfSize	= Vector3r(
+	 						fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+							thickness/2.0,
+	 						fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	
+		createBox(body,center,halfSize,wall_bottom_wire);
+	 	if(wall_bottom) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_bottom_id
+			= body-&gt;getId();
+			forcerec-&gt;startId = body-&gt;getId();
+			forcerec-&gt;endId   = body-&gt;getId();
+			wallStressRecorder-&gt;wall_bottom_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_bottom_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_bottom_id = body-&gt;getId();
+			}
+			
+	// top box
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						upperCorner[1]+thickness/2.0,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+	 	halfSize		= Vector3r(
+	 						fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						thickness/2.0,
+	 						fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	
+		createBox(body,center,halfSize,wall_top_wire);
+	 	if(wall_top) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_top_id = body-&gt;getId();
+			wallStressRecorder-&gt;wall_top_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_top_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_top_id = body-&gt;getId();
+			}
+	// box 1
+	
+	 	center			= Vector3r(
+	 						lowerCorner[0]-thickness/2.0,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+		halfSize		= Vector3r(
+							thickness/2.0,
+	 						fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+		createBox(body,center,halfSize,wall_1_wire);
+	 	if(wall_1) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_left_id = body-&gt;getId();
+			wallStressRecorder-&gt;wall_left_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_left_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_left_id = body-&gt;getId();
+			}
+	// box 2
+	 	center			= Vector3r(
+	 						upperCorner[0]+thickness/2.0,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+							(lowerCorner[2]+upperCorner[2])/2);
+	 	halfSize		= Vector3r(
+	 						thickness/2.0,
+	 						fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	 	
+		createBox(body,center,halfSize,wall_2_wire);
+	 	if(wall_2) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_right_id = body-&gt;getId();
+			wallStressRecorder-&gt;wall_right_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_right_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_right_id = body-&gt;getId();
+			}
+	// box 3
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						lowerCorner[2]-thickness/2.0);
+	 	halfSize		= Vector3r(
+	 						fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						thickness/2.0);
+		createBox(body,center,halfSize,wall_3_wire);
+	 	if(wall_3) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_back_id = body-&gt;getId();
+			wallStressRecorder-&gt;wall_back_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_back_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_back_id = body-&gt;getId();
+			}
+	
+	// box 4
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						upperCorner[2]+thickness/2.0);
+	 	halfSize		= Vector3r(
+	 						fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						thickness/2.0);
+		createBox(body,center,halfSize,wall_3_wire);
+	 	if(wall_4) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_front_id = body-&gt;getId();
+			wallStressRecorder-&gt;wall_front_id = body-&gt;getId();
+			capillaryStressRecorder-&gt;wall_front_id = body-&gt;getId();
+			contactStressRecorder-&gt;wall_front_id = body-&gt;getId();
+			}
+			 
+	}
+	
+	return output;
+//  	return &quot;Generated a sample inside box of dimensions: (&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[0]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[1]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[2]) + &quot;) and (&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[0]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[1]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[2]) + &quot;).&quot;;
+
+}
+
+
+void TriaxialTestWater::createSphere(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Real radius, bool big, bool dynamic )
+{
+	body = shared_ptr&lt;Body&gt;(new Body(0,2));
+	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
+	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
+	
+	Quaternionr q;
+	q.FromAxisAngle( Vector3r(0,0,1),0);
+	
+	body-&gt;isDynamic			= dynamic;
+	
+	physics-&gt;angularVelocity	= Vector3r(0,0,0);
+	physics-&gt;velocity		= Vector3r(0,0,0);
+	physics-&gt;mass			= 4.0/3.0*Mathr::PI*radius*radius*radius*(big ? bigBallDensity : density);
+	
+	physics-&gt;inertia		= Vector3r( 	2.0/5.0*physics-&gt;mass*radius*radius,
+							2.0/5.0*physics-&gt;mass*radius*radius,
+							2.0/5.0*physics-&gt;mass*radius*radius);
+	physics-&gt;se3			= Se3r(position,q);
+	physics-&gt;young			= big ? bigBallYoungModulus : sphereYoungModulus;
+	physics-&gt;poisson		= big ? bigBallPoissonRatio : spherePoissonRatio;
+	physics-&gt;frictionAngle		= (big ? bigBallFrictDeg : sphereFrictionDeg ) * Mathr::PI/180.0;
+
+	if((!big) &amp;&amp; (!dynamic) &amp;&amp; (!boxWalls))
+	{
+		physics-&gt;young			= boxYoungModulus;
+		physics-&gt;poisson		= boxPoissonRatio;
+		physics-&gt;frictionAngle		= boxFrictionDeg * Mathr::PI/180.0;
+	}
+	
+	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
+
+
+	gSphere-&gt;radius			= radius;
+	gSphere-&gt;diffuseColor		= spheresColor;
+	gSphere-&gt;wire			= false;
+	gSphere-&gt;visible		= true;
+	gSphere-&gt;shadowCaster		= true;
+	
+	iSphere-&gt;radius			= radius;
+	iSphere-&gt;diffuseColor		= Vector3r(Mathf::UnitRandom(),Mathf::UnitRandom(),Mathf::UnitRandom());
+
+	body-&gt;interactingGeometry	= iSphere;
+	body-&gt;geometricalModel		= gSphere;
+	body-&gt;boundingVolume		= aabb;
+	body-&gt;physicalParameters	= physics;
+}
+
+
+void TriaxialTestWater::createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents, bool wire)
+{
+	body = shared_ptr&lt;Body&gt;(new Body(0,2));
+	shared_ptr&lt;BodyMacroParameters&gt; physics(new BodyMacroParameters);
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	shared_ptr&lt;Box&gt; gBox(new Box);
+	shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox);
+	
+	Quaternionr q;
+	q.FromAxisAngle( Vector3r(0,0,1),0);
+
+	body-&gt;isDynamic			= false;
+	
+	physics-&gt;angularVelocity	= Vector3r(0,0,0);
+	physics-&gt;velocity		= Vector3r(0,0,0);
+	physics-&gt;mass			= 0; 
+	//physics-&gt;mass			= extents[0]*extents[1]*extents[2]*density*2; 
+	physics-&gt;inertia		= Vector3r(
+							  physics-&gt;mass*(extents[1]*extents[1]+extents[2]*extents[2])/3
+							, physics-&gt;mass*(extents[0]*extents[0]+extents[2]*extents[2])/3
+							, physics-&gt;mass*(extents[1]*extents[1]+extents[0]*extents[0])/3
+						);
+//	physics-&gt;mass			= 0;
+//	physics-&gt;inertia		= Vector3r(0,0,0);
+	physics-&gt;se3			= Se3r(position,q);
+
+	physics-&gt;young			= boxYoungModulus;
+	physics-&gt;poisson		= boxPoissonRatio;
+	physics-&gt;frictionAngle		= boxFrictionDeg * Mathr::PI/180.0;
+
+	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
+
+	gBox-&gt;extents			= extents;
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
+	gBox-&gt;wire			= wire;
+	gBox-&gt;visible			= true;
+	gBox-&gt;shadowCaster		= false;
+	
+	iBox-&gt;extents			= extents;
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
+
+	body-&gt;boundingVolume		= aabb;
+	body-&gt;interactingGeometry	= iBox;
+	body-&gt;geometricalModel		= gBox;
+	body-&gt;physicalParameters	= physics;
+}
+
+void TriaxialTestWater::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
+{
+// recording average positions
+	averagePositionRecorder = shared_ptr&lt;AveragePositionRecorder&gt;(new AveragePositionRecorder);
+	averagePositionRecorder -&gt; outputFile 		= positionRecordFile;
+	averagePositionRecorder -&gt; interval 		= recordIntervalIter;
+// recording forces
+	forcerec = shared_ptr&lt;ForceRecorder&gt;(new ForceRecorder);
+	forcerec -&gt; outputFile 	= forceRecordFile;
+	forcerec -&gt; interval 	= recordIntervalIter;
+// recording velocities
+	velocityRecorder = shared_ptr&lt;VelocityRecorder&gt;(new VelocityRecorder);
+	velocityRecorder-&gt; outputFile 	= velocityRecordFile;
+	velocityRecorder-&gt; interval 	= recordIntervalIter;
+
+// recording global stress
+	wallStressRecorder = shared_ptr&lt;WallStressRecorder&gt;(new
+	WallStressRecorder);
+	wallStressRecorder-&gt; outputFile 	= wallStressRecordFile;
+	wallStressRecorder-&gt; interval 		= recordIntervalIter;
+	wallStressRecorder-&gt; thickness 		= thickness;
+	
+// recording capillary stress
+	capillaryStressRecorder = shared_ptr&lt;CapillaryStressRecorder&gt;(new
+	CapillaryStressRecorder);
+	capillaryStressRecorder -&gt; outputFile 	= capillaryStressRecordFile;
+ 	capillaryStressRecorder -&gt; interval 	= recordIntervalIter;
+ 	capillaryStressRecorder-&gt; thickness 	= thickness;
+//  	capillaryStressRecorder-&gt; upperCorner 	= upperCorner;
+//  	capillaryStressRecorder-&gt; lowerCorner 	= lowerCorner;
+
+//recording contact stress
+	contactStressRecorder = shared_ptr&lt;ContactStressRecorder&gt;(new
+	ContactStressRecorder);
+	contactStressRecorder -&gt; outputFile 	= contactStressRecordFile;
+ 	contactStressRecorder -&gt; interval 	= recordIntervalIter;
+ 	contactStressRecorder-&gt; thickness 	= thickness;
+ 	contactStressRecorder-&gt; upperCorner 	= upperCorner;
+ 	contactStressRecorder-&gt; lowerCorner 	= lowerCorner;
+
+	shared_ptr&lt;PhysicalActionContainerInitializer&gt; physicalActionInitializer(new PhysicalActionContainerInitializer);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Force&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Momentum&quot;);
+	//physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;StiffnessMatrix&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;GlobalStiffness&quot;);
+	
+	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
+	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,
+&quot;InteractingSphere&quot;,
+&quot;InteractingSphere2InteractingSphere4SpheresContactGeometryWater&quot;);
+	interactionGeometryDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;InteractingBox&quot;,&quot;InteractingBox2InteractingSphere4SpheresContactGeometry&quot;);
+
+	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; interactionPhysicsDispatcher(new InteractionPhysicsMetaEngine);
+	interactionPhysicsDispatcher-&gt;add(&quot;BodyMacroParameters&quot;,
+&quot;BodyMacroParameters&quot;,&quot;MacroMicroElasticRelationshipsWater&quot;);
+		
+	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingSphere&quot;,&quot;AABB&quot;,
+&quot;InteractingSphere2AABBwater&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingBox&quot;,&quot;AABB&quot;,&quot;InteractingBox2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;MetaInteractingGeometry&quot;,&quot;AABB&quot;,&quot;MetaInteractingGeometry2AABB&quot;);
+
+	
+
+		
+	shared_ptr&lt;GravityEngine&gt; gravityCondition(new GravityEngine);
+	gravityCondition-&gt;gravity = gravity;
+	
+	shared_ptr&lt;CundallNonViscousForceDamping&gt; actionForceDamping(new CundallNonViscousForceDamping);
+	actionForceDamping-&gt;damping = dampingForce;
+	shared_ptr&lt;CundallNonViscousMomentumDamping&gt; actionMomentumDamping(new CundallNonViscousMomentumDamping);
+	actionMomentumDamping-&gt;damping = dampingMomentum;
+	shared_ptr&lt;PhysicalActionDamper&gt; actionDampingDispatcher(new PhysicalActionDamper);
+	actionDampingDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;CundallNonViscousForceDamping&quot;,actionForceDamping);
+	actionDampingDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;CundallNonViscousMomentumDamping&quot;,actionMomentumDamping);
+	
+	shared_ptr&lt;PhysicalActionApplier&gt; applyActionDispatcher(new PhysicalActionApplier);
+	applyActionDispatcher-&gt;add(&quot;Force&quot;,&quot;ParticleParameters&quot;,&quot;NewtonsForceLaw&quot;);
+	applyActionDispatcher-&gt;add(&quot;Momentum&quot;,&quot;RigidBodyParameters&quot;,&quot;NewtonsMomentumLaw&quot;);
+		
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; positionIntegrator(new PhysicalParametersMetaEngine);
+	positionIntegrator-&gt;add(&quot;ParticleParameters&quot;,&quot;LeapFrogPositionIntegrator&quot;);
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
+	orientationIntegrator-&gt;add(&quot;RigidBodyParameters&quot;,&quot;LeapFrogOrientationIntegrator&quot;);
+
+
+	shared_ptr&lt;GlobalStiffnessTimeStepper&gt; globalStiffnessTimeStepper(new
+	GlobalStiffnessTimeStepper);
+	globalStiffnessTimeStepper-&gt;sdecGroupMask = 2;
+	globalStiffnessTimeStepper-&gt;defaultDt = defaultDt;
+	globalStiffnessTimeStepper-&gt;timeStepUpdateInterval = timeStepUpdateInterval;
+	
+	shared_ptr&lt;ElasticContactLaw&gt; elasticContactLaw(new ElasticContactLaw);
+	elasticContactLaw-&gt;sdecGroupMask = 2;
+	
+	// capillary
+	shared_ptr&lt;CapillaryCohesiveLaw&gt; capillaryCohesiveLaw(new
+	CapillaryCohesiveLaw); 
+	capillaryCohesiveLaw-&gt;sdecGroupMask = 2;	
+	capillaryCohesiveLaw-&gt;CapillaryPressure = CapillaryPressure;
+	
+	shared_ptr&lt;GlobalStiffnessCounter&gt; globalStiffnessCounter(new
+	GlobalStiffnessCounter);
+	globalStiffnessCounter-&gt;sdecGroupMask = 2;
+	globalStiffnessCounter-&gt;interval = timeStepUpdateInterval;
+	
+	// moving walls to regulate the stress applied
+	cerr &lt;&lt; &quot;triaxialstressController = shared_ptr&quot; &lt;&lt; std::endl;
+	triaxialstressController = shared_ptr&lt;TriaxialStressController&gt; (new
+	TriaxialStressController);
+	triaxialstressController-&gt;interval = 1;// = recordIntervalIter
+	triaxialstressController-&gt;sigma_iso = sigma_iso;
+	triaxialstressController-&gt;maxMultiplier = maxMultiplier;
+	triaxialstressController-&gt;finalMaxMultiplier = finalMaxMultiplier;
+	triaxialstressController-&gt;max_vel = max_vel;
+	triaxialstressController-&gt;thickness = thickness;
+// 	triaxialstressController-&gt;wall_bottom_activated = false;
+// 	triaxialstressController-&gt;wall_top_activated = false;	
+	cerr &lt;&lt;&quot;fin section triaxialstressController = shared_ptr&quot;&lt;&lt; std::endl;
+	
+	// moving walls to regulate the stress applied + compress when the
+	//packing is dense an stable
+	cerr &lt;&lt; &quot;triaxialcompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (new TriaxialCompressionEngine);&quot; &lt;&lt; std::endl;
+	triaxialcompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (new TriaxialCompressionEngine);
+	triaxialcompressionEngine-&gt; interval = wallStiffnessUpdateInterval;// = stiffness update interval
+	triaxialcompressionEngine-&gt;sigma_iso = sigma_iso;
+	triaxialcompressionEngine-&gt;max_vel = max_vel;
+	triaxialcompressionEngine-&gt;thickness = thickness;
+	triaxialcompressionEngine-&gt;strainRate = strainRate;
+	triaxialcompressionEngine-&gt;StabilityCriterion = StabilityCriterion;
+	triaxialcompressionEngine-&gt;autoCompressionActivation = autoCompressionActivation;
+	triaxialcompressionEngine-&gt;internalCompaction = internalCompaction;
+	triaxialcompressionEngine-&gt;maxMultiplier = maxMultiplier;
+	triaxialcompressionEngine-&gt;finalMaxMultiplier = finalMaxMultiplier;
+	cerr &lt;&lt;&quot;fin section triaxialcompressionEngine = shared_ptr&quot;&lt;&lt; std::endl;
+	
+	
+	rootBody-&gt;engines.clear();
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new
+	PhysicalActionContainerReseter));
+	rootBody-&gt;engines.push_back(boundingVolumeDispatcher);
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new
+	PersistentSAPCollider));
+	rootBody-&gt;engines.push_back(interactionGeometryDispatcher);
+	rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
+	rootBody-&gt;engines.push_back(elasticContactLaw);
+	
+	// capillary
+	if(water)
+	{
+		rootBody-&gt;engines.push_back(capillaryCohesiveLaw);
+		rootBody-&gt;engines.push_back(capillaryStressRecorder);
+	}
+	
+	rootBody-&gt;engines.push_back(globalStiffnessCounter);
+	rootBody-&gt;engines.push_back(globalStiffnessTimeStepper);
+	//rootBody-&gt;engines.push_back(triaxialstressController);
+	rootBody-&gt;engines.push_back(triaxialcompressionEngine);
+	rootBody-&gt;engines.push_back(forcerec);	
+	rootBody-&gt;engines.push_back(wallStressRecorder);
+	rootBody-&gt;engines.push_back(contactStressRecorder);
+	rootBody-&gt;engines.push_back(actionDampingDispatcher);
+	rootBody-&gt;engines.push_back(applyActionDispatcher);
+	rootBody-&gt;engines.push_back(positionIntegrator);
+	if(!rotationBlocked)
+		rootBody-&gt;engines.push_back(orientationIntegrator);
+		
+	//rootBody-&gt;engines.push_back(triaxialcompressionEngine);
+		
+	rootBody-&gt;engines.push_back(averagePositionRecorder);
+	rootBody-&gt;engines.push_back(velocityRecorder);
+	//rootBody-&gt;engines.push_back(forcerec);
+	
+	//rootBody-&gt;engines.push_back(wallStressRecorder);
+	//rootBody-&gt;engines.push_back(contactStressRecorder);
+	
+	rootBody-&gt;initializers.clear();
+	rootBody-&gt;initializers.push_back(physicalActionInitializer);
+	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
+	
+}
+
+
+void TriaxialTestWater::positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
+{
+	rootBody-&gt;isDynamic		= false;
+
+	Quaternionr q;
+	q.FromAxisAngle( Vector3r(0,0,1),0);
+	shared_ptr&lt;ParticleParameters&gt; physics(new ParticleParameters); // FIXME : fix indexable class PhysicalParameters
+	physics-&gt;se3			= Se3r(Vector3r(0,0,0),q);
+	physics-&gt;mass			= 0;
+	physics-&gt;velocity		= Vector3r::ZERO;
+	physics-&gt;acceleration		= Vector3r::ZERO;
+	
+	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
+	
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
+
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	aabb-&gt;diffuseColor		= Vector3r(0,0,1);
+	
+	rootBody-&gt;interactingGeometry	= dynamic_pointer_cast&lt;InteractingGeometry&gt;(set);	
+	rootBody-&gt;boundingVolume	= dynamic_pointer_cast&lt;BoundingVolume&gt;(aabb);
+	rootBody-&gt;physicalParameters 	= physics;
+	
+}
+
+
+
+string GenerateCloud(vector&lt;BasicSphere&gt;&amp; sphere_list, Vector3r lowerCorner, Vector3r upperCorner, long number, Real rad_std_dev, Real porosity)
+{
+	typedef boost::minstd_rand StdGenerator;
+	static StdGenerator generator;
+	static boost::variate_generator&lt;StdGenerator&amp;, boost::uniform_real&lt;&gt; &gt;
+			random1(generator, boost::uniform_real&lt;&gt;(0,1));
+        //         static boost::variate_generator&lt;StdGenerator&amp;, boost::normal_distribution&lt;&gt; &gt;
+        //         randomN(generator, boost::normal_distribution&lt;&gt;(aggregateMeanRadius,aggregateSigmaRadius));
+
+	sphere_list.clear();
+	long tries = 1000; //nb of tries for positionning the next sphere
+	Vector3r dimensions = upperCorner - lowerCorner;
+		
+	Real mean_radius = std::pow(dimensions.X()*dimensions.Y()*dimensions.Z()*(1-porosity)/(3.1416*1.3333*number),0.333333);
+        //cerr &lt;&lt; mean_radius;
+        Real Rmin=mean_radius, Rmax=mean_radius;
+
+	std::cerr &lt;&lt; &quot;generating aggregates ... &quot;;
+	
+	long t, i;
+	for (i=0; i&lt;number; ++i) {
+		BasicSphere s;
+		for (t=0; t&lt;tries; ++t) {
+			s.second = (random1()-0.5)*rad_std_dev*mean_radius+mean_radius;
+			s.first.X() = lowerCorner.X()+s.second+(dimensions.X()-2*s.second)*random1();
+			s.first.Y() = lowerCorner.Y()+s.second+(dimensions.Y()-2*s.second)*random1();
+			s.first.Z() = lowerCorner.Z()+s.second+(dimensions.Z()-2*s.second)*random1();
+			bool overlap=false;
+			for (long j=0; (j&lt;i &amp;&amp; !overlap); j++)
+				if ( pow(sphere_list[j].second+s.second, 2) &gt; (sphere_list[j].first-s.first).SquaredLength()) overlap=true;
+			if (!overlap)
+			{
+				sphere_list.push_back(s);
+				break;
+			}	
+			
+			Rmin = std::min(Rmin,s.second);
+			Rmax = std::max(Rmax,s.second);
+				
+		}
+		if (t==tries) return &quot;More than &quot; + lexical_cast&lt;string&gt;(tries) +
+					&quot; tries while generating sphere number &quot; +
+					lexical_cast&lt;string&gt;(i+1) + &quot;/&quot; + lexical_cast&lt;string&gt;(number) + &quot;.&quot;;
+	}
+	return &quot;Generated a sample with &quot; + lexical_cast&lt;string&gt;(number) + &quot;spheres inside box of dimensions: (&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[0]) + &quot;,&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[1]) + &quot;,&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[2]) + &quot;).&quot;
+			+ &quot;  mean radius=&quot; + lexical_cast&lt;string&gt;(mean_radius) +
+			+ &quot;  Rmin =&quot; + lexical_cast&lt;string&gt;(Rmin) +
+			+ &quot;  Rmax =&quot; + lexical_cast&lt;string&gt;(Rmax) + &quot;.&quot;;
+}
+
+
+


Property changes on: trunk/pkg/dem/PreProcessor/TriaxialTestWater.cpp
___________________________________________________________________
Name: svn:executable
   + *

Added: trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp	2007-05-31 18:22:06 UTC (rev 1182)
@@ -0,0 +1,138 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef SDECIMPORT3_HPP
+#define SDECIMPORT3_HPP
+
+#include &lt;yade/core/FileGenerator.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include &lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class ForceRecorder;
+class AveragePositionRecorder;
+class VelocityRecorder;
+class TriaxialStressController;
+class TriaxialCompressionEngine;
+class WallStressRecorder;
+class CapillaryStressRecorder;
+class ContactStressRecorder;
+
+/*! \brief Isotropic compression + uniaxial compression test
+
+	detailed description...
+ */
+
+class TriaxialTestWater : public FileGenerator
+{
+	private	:
+		Vector3r	 gravity
+				,lowerCorner
+				,upperCorner;
+
+		Vector3r	 spheresColor;
+
+		Real		 thickness
+				,sphereYoungModulus
+				,spherePoissonRatio
+				,sphereFrictionDeg
+				,boxYoungModulus
+				,boxPoissonRatio
+				,boxFrictionDeg
+				,density
+				,Rdispersion
+				,dampingForce
+				,dampingMomentum
+
+				,bigBallRadius
+				,bigBallDensity
+				,bigBallDropTimeSeconds
+				,bigBallPoissonRatio
+				,bigBallYoungModulus
+				,bigBallFrictDeg
+				,bigBallDropHeight
+				
+				,sigma_iso
+				,CapillaryPressure
+				,defaultDt
+				,max_vel
+				,strainRate
+				,StabilityCriterion
+				,autoCompressionActivation
+				,finalMaxMultiplier
+				,maxMultiplier; ///max multiplier of diameters during internal compaction
+
+		bool		water
+				,wall_top
+				,wall_bottom
+				,wall_1
+				,wall_2
+				,wall_3
+				,wall_4
+				,wall_top_wire
+				,wall_bottom_wire
+				,wall_1_wire
+				,wall_2_wire
+				,wall_3_wire
+				,wall_4_wire
+				,bigBall
+				,rotationBlocked
+				,spheresRandomColor
+				,recordBottomForce
+				,recordAveragePositions
+				,boxWalls
+				,internalCompaction;
+
+		int		 recordIntervalIter
+				,timeStepUpdateInterval
+				,timeStepOutputInterval
+				,wallStiffnessUpdateInterval
+				,numberOfGrains;
+				/*,wall_top_id
+				,wall_bottom_id
+				,wall_left_id
+				,all_right_id
+				,wall_front_id
+				,wall_back_id;*/
+		
+		string		 forceRecordFile
+				,positionRecordFile
+				,velocityRecordFile
+				,wallStressRecordFile
+				,capillaryStressRecordFile
+				,contactStressRecordFile
+				,importFilename;
+	
+		shared_ptr&lt;ForceRecorder&gt; forcerec;
+		shared_ptr&lt;VelocityRecorder&gt; velocityRecorder;
+		shared_ptr&lt;AveragePositionRecorder&gt; averagePositionRecorder;
+		shared_ptr&lt;WallStressRecorder&gt; wallStressRecorder;
+		shared_ptr&lt;CapillaryStressRecorder&gt; capillaryStressRecorder;
+		shared_ptr&lt;ContactStressRecorder&gt; contactStressRecorder;
+		shared_ptr&lt;TriaxialCompressionEngine&gt; triaxialcompressionEngine;
+		shared_ptr&lt;TriaxialStressController&gt; triaxialstressController;
+			
+		void createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents,bool wire);
+		void createSphere(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Real radius,bool big,bool dynamic);
+		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
+		void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
+	
+	public : 
+		TriaxialTestWater ();
+		~TriaxialTestWater ();
+		string generate();
+	
+	protected :
+		void registerAttributes();
+	REGISTER_CLASS_NAME(TriaxialTestWater);
+	REGISTER_BASE_CLASS_NAME(FileGenerator);
+};
+
+REGISTER_SERIALIZABLE(TriaxialTestWater,false);
+
+#endif // SDECIMPORT3_HPP
+


Property changes on: trunk/pkg/dem/PreProcessor/TriaxialTestWater.hpp
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/pkg/dem/SConscript
===================================================================
--- trunk/pkg/dem/SConscript	2007-05-30 20:29:39 UTC (rev 1181)
+++ trunk/pkg/dem/SConscript	2007-05-31 18:22:06 UTC (rev 1182)
@@ -536,5 +536,139 @@
 			'yade-multimethods',
 			'boost_filesystem',
 			'TranslationEngine']),
+
+env.SharedLibrary('WallStressRecorder',
+		['Engine/DeusExMachina/WallStressRecorder.cpp'],
+		LIBS=env['LIBS']+['ParticleParameters',
+			'ElasticContactInteraction',
+			'SpheresContactGeometry',
+			'BodyMacroParameters',
+			'Force',
+			'TriaxialStressController',
+			'TriaxialCompressionEngine',
+			'Sphere',
+			'ElasticContactLaw']),
+
+env.SharedLibrary('CapillaryPressureEngine',
+		['Engine/DeusExMachina/CapillaryPressureEngine.cpp'],
+		LIBS=env['LIBS']+['CapillaryCohesiveLaw']),
+
+
+env.SharedLibrary('CapillaryStressRecorder',
+		['Engine/DeusExMachina/CapillaryStressRecorder.cpp'],
+		LIBS=env['LIBS']+['ParticleParameters',
+			'ElasticContactInteraction',
+			'CapillaryParameters',
+			'Force',
+			'CapillaryCohesiveLaw']),
+
+env.SharedLibrary('TriaxialTestWater',
+		['PreProcessor/TriaxialTestWater.cpp'],
+		LIBS=env['LIBS']+Split('''SDECLinkGeometry
+        ElasticContactLaw
+        CapillaryCohesiveLaw
+        AveragePositionRecorder
+        VelocityRecorder
+        ForceRecorder
+        WallStressRecorder
+        CapillaryStressRecorder
+        ContactStressRecorder
+        MacroMicroElasticRelationships
+        ElasticCriterionTimeStepper
+        PhysicalActionVectorVector
+        InteractionVecSet
+	InteractionHashMap
+        BodyRedirectionVector
+        InteractingSphere
+        InteractingBox
+        CundallNonViscousMomentumDamping
+        CundallNonViscousForceDamping
+        MetaInteractingGeometry
+        GravityEngine
+        yade-serialization
+        PhysicalActionContainerInitializer
+        PhysicalActionContainerReseter
+        InteractionGeometryMetaEngine
+        InteractionPhysicsMetaEngine
+        PhysicalActionApplier
+        PhysicalParametersMetaEngine
+        BoundingVolumeMetaEngine
+        yade-multimethods
+        Box
+        Sphere
+        AABB
+        PersistentSAPCollider
+        SAPCollider
+        MetaInteractingGeometry2AABB
+	GlobalStiffness
+	GlobalStiffnessCounter
+	ResultantForceEngine
+	TriaxialStressController
+	TriaxialCompressionEngine
+	GlobalStiffnessTimeStepper''')),
+
+
+
+
+env.SharedLibrary('ContactStressRecorder',
+		['Engine/DeusExMachina/ContactStressRecorder.cpp'],
+		LIBS=env['LIBS']+['ParticleParameters',
+			'ElasticContactInteraction',
+			'SpheresContactGeometry',
+			'BodyMacroParameters',
+			'Force',
+			'TriaxialStressController',
+			'TriaxialCompressionEngine',
+			'Sphere',
+			'ElasticContactLaw',
+			'CapillaryCohesiveLaw']),
+
+env.SharedLibrary('CapillaryCohesiveLaw',
+		['Engine/StandAloneEngine/CapillaryCohesiveLaw.cpp'],
+		LIBS=env['LIBS']+['CapillaryParameters',
+			'ElasticContactInteraction',
+			'SpheresContactGeometry',
+			'BodyMacroParameters',
+			'Force',
+			'Momentum',
+			'RigidBodyParameters',
+			'Sphere',
+			'ElasticContactLaw']),
+
+env.SharedLibrary('CapillaryParameters',
+		['DataClass/InteractionPhysics/CapillaryParameters.cpp'],
+		LIBS=env['LIBS']+['ElasticContactInteraction']),
+
+env.SharedLibrary('InteractingSphere2InteractingSphere4SpheresContactGeometryWater',
+		['Engine/EngineUnit/InteractingSphere2InteractingSphere4SpheresContactGeometryWater.cpp'],
+		LIBS=env['LIBS']+['SpheresContactGeometry',
+			'InteractionGeometryMetaEngine',
+			'InteractingSphere' ]),
+
+env.SharedLibrary('InteractingBox2InteractingSphere4SpheresContactGeometryWater',
+		['Engine/EngineUnit/InteractingBox2InteractingSphere4SpheresContactGeometryWater.cpp'],
+		LIBS=env['LIBS']+['SpheresContactGeometry',
+			'InteractionGeometryMetaEngine',
+			'InteractingSphere',
+			'InteractingBox' ]),
+
+env.SharedLibrary('MacroMicroElasticRelationshipsWater',
+		['Engine/EngineUnit/MacroMicroElasticRelationshipsWater.cpp'],
+		LIBS=env['LIBS']+['SDECLinkPhysics',
+			'SDECLinkGeometry',
+			'ElasticContactInteraction',
+			'SpheresContactGeometry',
+			'BodyMacroParameters',
+			'RigidBodyParameters',
+			'ParticleParameters',
+			'InteractionPhysicsMetaEngine',
+			'CapillaryParameters']),
+
+env.SharedLibrary('InteractingSphere2AABBwater',
+		['Engine/EngineUnit/InteractingSphere2AABBwater.cpp'],
+		LIBS=env['LIBS']+['InteractingSphere', 'AABB', 'BoundingVolumeMetaEngine']),
+
+
+
+
 ])
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000146.html">[Yade-commits] r1181 - in trunk: core extra/clump extra/tetra	gui/qt3 pkg/common/Container pkg/common/Engine/StandAloneEngine	pkg/common/RenderingEngine/OpenGLRenderingEngine	pkg/dem/Engine/StandAloneEngine pkg/dem/PreProcessor	pkg/fem/Engine/EngineUnit pkg/lattice/PreProcessor	pkg/lattice/RenderingEngine/GLDrawLatticeInteractingGeometry	pkg/mass-spring/PreProcessor pkg/realtime-rigidbody/PreProcessor
</A></li>
	<LI>Next message: <A HREF="000148.html">[Yade-commits] r1183 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#147">[ date ]</a>
              <a href="thread.html#147">[ thread ]</a>
              <a href="subject.html#147">[ subject ]</a>
              <a href="author.html#147">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
