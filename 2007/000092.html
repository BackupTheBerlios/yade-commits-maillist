<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1127 - in branches/scons-layout: . core extra gui	lib lib/miniWm3 pkg/common pkg/dem pkg/fem pkg/lattice	pkg/mass-spring pkg/realtime-rigidbody
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1127%20-%20in%20branches/scons-layout%3A%20.%20core%20extra%20gui%0A%09lib%20lib/miniWm3%20pkg/common%20pkg/dem%20pkg/fem%20pkg/lattice%0A%09pkg/mass-spring%20pkg/realtime-rigidbody&In-Reply-To=%3C200703100931.l2A9VoTf013524%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000091.html">
   <LINK REL="Next"  HREF="000093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1127 - in branches/scons-layout: . core extra gui	lib lib/miniWm3 pkg/common pkg/dem pkg/fem pkg/lattice	pkg/mass-spring pkg/realtime-rigidbody</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1127%20-%20in%20branches/scons-layout%3A%20.%20core%20extra%20gui%0A%09lib%20lib/miniWm3%20pkg/common%20pkg/dem%20pkg/fem%20pkg/lattice%0A%09pkg/mass-spring%20pkg/realtime-rigidbody&In-Reply-To=%3C200703100931.l2A9VoTf013524%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1127 - in branches/scons-layout: . core extra gui	lib lib/miniWm3 pkg/common pkg/dem pkg/fem pkg/lattice	pkg/mass-spring pkg/realtime-rigidbody">eudoxos at mail.berlios.de
       </A><BR>
    <I>Sat Mar 10 10:31:50 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000091.html">[Yade-commits] r1126 - branches/scons-layout
</A></li>
        <LI>Next message: <A HREF="000093.html">[Yade-commits] r1128 - branches/scons-layout
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2007-03-10 10:31:44 +0100 (Sat, 10 Mar 2007)
New Revision: 1127

Added:
   branches/scons-layout/lib/miniWm3/
   branches/scons-layout/lib/miniWm3/README
   branches/scons-layout/lib/miniWm3/Wm3FoundationLIB.h
   branches/scons-layout/lib/miniWm3/Wm3FoundationPCH.h
   branches/scons-layout/lib/miniWm3/Wm3Math.cpp
   branches/scons-layout/lib/miniWm3/Wm3Math.h
   branches/scons-layout/lib/miniWm3/Wm3Math.inl
   branches/scons-layout/lib/miniWm3/Wm3Math.mcr
   branches/scons-layout/lib/miniWm3/Wm3Matrix2.cpp
   branches/scons-layout/lib/miniWm3/Wm3Matrix2.h
   branches/scons-layout/lib/miniWm3/Wm3Matrix2.inl
   branches/scons-layout/lib/miniWm3/Wm3Matrix3.cpp
   branches/scons-layout/lib/miniWm3/Wm3Matrix3.h
   branches/scons-layout/lib/miniWm3/Wm3Matrix3.inl
   branches/scons-layout/lib/miniWm3/Wm3Matrix4.cpp
   branches/scons-layout/lib/miniWm3/Wm3Matrix4.h
   branches/scons-layout/lib/miniWm3/Wm3Matrix4.inl
   branches/scons-layout/lib/miniWm3/Wm3Memory.cpp
   branches/scons-layout/lib/miniWm3/Wm3Memory.h
   branches/scons-layout/lib/miniWm3/Wm3Memory.inl
   branches/scons-layout/lib/miniWm3/Wm3Plane3.h
   branches/scons-layout/lib/miniWm3/Wm3Plane3.inl
   branches/scons-layout/lib/miniWm3/Wm3Platforms.h
   branches/scons-layout/lib/miniWm3/Wm3Quaternion.cpp
   branches/scons-layout/lib/miniWm3/Wm3Quaternion.h
   branches/scons-layout/lib/miniWm3/Wm3Quaternion.inl
   branches/scons-layout/lib/miniWm3/Wm3String.cpp
   branches/scons-layout/lib/miniWm3/Wm3String.h
   branches/scons-layout/lib/miniWm3/Wm3String.inl
   branches/scons-layout/lib/miniWm3/Wm3System.cpp
   branches/scons-layout/lib/miniWm3/Wm3System.h
   branches/scons-layout/lib/miniWm3/Wm3System.inl
   branches/scons-layout/lib/miniWm3/Wm3TArray.h
   branches/scons-layout/lib/miniWm3/Wm3TArray.inl
   branches/scons-layout/lib/miniWm3/Wm3THashSet.h
   branches/scons-layout/lib/miniWm3/Wm3THashSet.inl
   branches/scons-layout/lib/miniWm3/Wm3THashTable.h
   branches/scons-layout/lib/miniWm3/Wm3THashTable.inl
   branches/scons-layout/lib/miniWm3/Wm3TList.h
   branches/scons-layout/lib/miniWm3/Wm3TList.inl
   branches/scons-layout/lib/miniWm3/Wm3TSet.h
   branches/scons-layout/lib/miniWm3/Wm3TSet.inl
   branches/scons-layout/lib/miniWm3/Wm3TStack.h
   branches/scons-layout/lib/miniWm3/Wm3TStack.inl
   branches/scons-layout/lib/miniWm3/Wm3TTuple.h
   branches/scons-layout/lib/miniWm3/Wm3TTuple.inl
   branches/scons-layout/lib/miniWm3/Wm3Vector2.cpp
   branches/scons-layout/lib/miniWm3/Wm3Vector2.h
   branches/scons-layout/lib/miniWm3/Wm3Vector2.inl
   branches/scons-layout/lib/miniWm3/Wm3Vector3.cpp
   branches/scons-layout/lib/miniWm3/Wm3Vector3.h
   branches/scons-layout/lib/miniWm3/Wm3Vector3.inl
   branches/scons-layout/lib/miniWm3/Wm3Vector4.cpp
   branches/scons-layout/lib/miniWm3/Wm3Vector4.h
   branches/scons-layout/lib/miniWm3/Wm3Vector4.inl
Modified:
   branches/scons-layout/SConstruct
   branches/scons-layout/core/SConscript
   branches/scons-layout/core/yade.cpp
   branches/scons-layout/extra/SConscript
   branches/scons-layout/gui/SConscript
   branches/scons-layout/lib/SConscript
   branches/scons-layout/pkg/common/SConscript
   branches/scons-layout/pkg/dem/SConscript
   branches/scons-layout/pkg/fem/SConscript
   branches/scons-layout/pkg/lattice/SConscript
   branches/scons-layout/pkg/mass-spring/SConscript
   branches/scons-layout/pkg/realtime-rigidbody/SConscript
Log:
OK, I finally added part of wm3 to the tree, since it is very difficult to build on AMD64 as whole. This way, it will work just fine.
We no longer link agains wm3 explicitly for each target, all targets link to it implicitly. If we decide to switch back to Wm3Foundation instead of miniWm3, it is just matter of a few lines in SConstruct.



Modified: branches/scons-layout/SConstruct
===================================================================
--- branches/scons-layout/SConstruct	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/SConstruct	2007-03-10 09:31:44 UTC (rev 1127)
@@ -54,7 +54,7 @@
 	('extraModules', 'Extra directories with their own SConscript files (must be in-tree) (whitespace separated)',None,None,Split),
 	('buildPrefix','Where to create build-[version][variant] directory for intermediary files','..'),
 	('version','Yade version (if not specified, guess will be attempted)',None),
-	('CPPPATH', 'Additional paths for the C preprocessor (whitespace separated)',['/usr/include/wm3'],None,Split),
+	('CPPPATH', 'Additional paths for the C preprocessor (whitespace separated)',None,None,Split),
 	('LIBPATH','Additional paths for the linker (whitespace separated)',None,None,Split),
 	('QTDIR','Directories where to look for qt3',['/usr/share/qt3','/usr/lib/qt'],None,Split),
 	('CXX','The c++ compiler','g++'),
@@ -92,8 +92,9 @@
 buildDir=os.path.join(env['buildPrefix'],env.subst('build$SUFFIX'))
 print &quot;All intermediary files will be in `%s'.&quot;%buildDir
 # these MUST be first so that builddir's headers are read before any locally installed ones
-if os.path.isabs(buildDir): env.Append(CPPPATH=[os.path.join(buildDir,'include','yade-$version')])
-else: env.Append(CPPPATH=[os.path.join('#',buildDir,'include','yade-$version')])
+buildInc=buildDir+'/include/yade-$version'
+if not os.path.isabs(buildDir): buildInc='#/'+buildInc
+env.Append(CPPPATH=[buildInc,buildInc+'/yade/lib-miniWm3'])
 ### OLD: older scons only
 if not os.path.exists(buildDir): os.makedirs(buildDir)
 
@@ -103,6 +104,7 @@
 ############# CONFIGURATION ##############################################################
 ##########################################################################################
 
+# ensure non-None
 env.Append(CPPPATH='',LIBPATH='',LIBS='')
 
 def CheckQt(context, qtdirs):
@@ -164,26 +166,28 @@
 	if not ok:
 			print &quot;\nYour compiler is broken, no point in continuing. See `config.log' for what went wrong and use the CXX parameter to change your compiler.&quot;
 			Exit(1)
-	# essential libs
+	# check essential libs
 	ok&amp;=conf.CheckLibWithHeader('pthread','pthread.h','c','pthread_exit(NULL);')
 	ok&amp;=conf.CheckLibWithHeader('glut','GL/glut.h','c','glutGetModifiers();')
 	ok&amp;=conf.CheckLibWithHeader('boost_date_time','boost/date_time/posix_time/posix_time.hpp','c++','boost::posix_time::time_duration::time_duration();')
 	ok&amp;=conf.CheckLibWithHeader('boost_thread','boost/thread/thread.hpp','c++','boost::thread::thread();')
 	ok&amp;=conf.CheckLibWithHeader('boost_filesystem','boost/filesystem/path.hpp','c++','boost::filesystem::path();')
-	ok&amp;=conf.CheckLibWithHeader('Wm3Foundation','Wm3Math.h','c++','Wm3::Math&lt;double&gt;::PI;')
+	#ok&amp;=conf.CheckLibWithHeader('Wm3Foundation','Wm3Math.h','c++','Wm3::Math&lt;double&gt;::PI;')
 	ok&amp;=conf.CheckQt(env['QTDIR'])
 	env.Tool('qt'); env.Replace(QT_LIB='qt-mt')
 	ok&amp;=conf.CheckLibWithHeader('3dviewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);')
 	if not ok:
 		print &quot;\nOne of the essential libraries above was not found, unable to continue.\n\nCheck config.log for possible causes, note that there are options that you may need to customize:\n\n&quot;+opts.GenerateHelpText(env)
 		Exit(1)
-	env.Append(LIBS=['glut','boost_date_time','boost_filesystem','boost_thread','pthread','Wm3Foundation'])
 
-	#optional libs
+	# check optional libs
 	if conf.CheckLibWithHeader('log4cxx','log4cxx/logger.h','c++','log4cxx::Logger::getLogger(&quot;foo&quot;);'):
 		env.Append(LIBS='log4cxx',CPPDEFINES=['LOG4CXX'])
 	if conf.CheckPython() and conf.CheckScientificPython(): env.Append(CPPDEFINES=['EMBED_PYTHON'])
 
+	# append essential libs		
+	env.Append(LIBS=['glut','boost_date_time','boost_filesystem','boost_thread','pthread','miniWm3']) #'Wm3Foundation'
+
 	env=conf.Finish()
 
 
@@ -300,7 +304,7 @@
 			except ValueError: pass
 		if not re.match(r'\.[/\\](core|lib|pkg|gui|extra)[/\\]?.*',root): continue
 		for f in files:
-			if f.split('.')[-1] in ('hpp','inl','ipp','tpp','h'):
+			if f.split('.')[-1] in ('hpp','inl','ipp','tpp','h','mcr'):
 				#m=re.match('^\./([^/]*)/.*$',root)
 				m=re.match('^.*?'+sep+'((extra|core)|((gui|lib|pkg)'+sep+'.*?))(|'+sep+'.*)$',root)
 				subInc=join(yadeInc,m.group(1).replace(sep,'-')) # replace pkg/lattice by pkg-lattice

Modified: branches/scons-layout/core/SConscript
===================================================================
--- branches/scons-layout/core/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/core/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -26,11 +26,11 @@
 			'yade.cpp',
 			'yadeExceptions.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-loki',
 			'yade-multimethods',
 			'glut',

Modified: branches/scons-layout/core/yade.cpp
===================================================================
--- branches/scons-layout/core/yade.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/core/yade.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -47,7 +47,7 @@
 		}
 	#endif
 	#ifdef YADE_DEBUG
-		else if(sig==SIGABRT || sig==SIGSEGV){
+		if(sig==SIGABRT || sig==SIGSEGV){
 			signal(SIGSEGV,SIG_DFL); signal(SIGABRT,SIG_DFL); // prevent loops - default handlers
 			cerr&lt;&lt;&quot;SIGSEGV/SIGABRT handler&quot;;
 			system((string(&quot;gdb -x &quot;)+gdbCrashBatch).c_str());

Modified: branches/scons-layout/extra/SConscript
===================================================================
--- branches/scons-layout/extra/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/extra/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -5,7 +5,7 @@
 		['spherical-dem-simulator/PersistentAloneSAPCollider.cpp',
 			'spherical-dem-simulator/SphericalDEMSimulator.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'MacroMicroElasticRelationships',
 			'BodyMacroParameters',
 			'CundallNonViscousMomentumDamping',
@@ -18,7 +18,7 @@
 			'yade-factory',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['spherical-dem-simulator/src/SphericalDEMSimulator', '$PREFIX/include']),
 
 	env.SharedLibrary('Clump',
@@ -27,7 +27,7 @@
 		LIBPATH=env['LIBPATH']),
 	env.SharedLibrary('PythonRecorder',['clump/PythonRecorder.cpp']),
 	env.SharedLibrary('_pyade',['clump/pyade.cpp'],SHLIBPREFIX='',
-		LIBS=env['LIBS']+['yade-base','Wm3Foundation','ParticleParameters','RigidBodyParameters'],
+		LIBS=env['LIBS']+['yade-base','ParticleParameters','RigidBodyParameters'],
 	),
 	env.File('clump/pyade.py'),
 	env.SharedLibrary('Shop',
@@ -48,7 +48,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',

Modified: branches/scons-layout/gui/SConscript
===================================================================
--- branches/scons-layout/gui/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/gui/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -30,9 +30,9 @@
 			'qt/YadeQtGeneratedMainWindow.ui',
 			'qt/YadeQtMainWindow.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-factory',
 			'yade-opengl',

Modified: branches/scons-layout/lib/SConscript
===================================================================
--- branches/scons-layout/lib/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -3,16 +3,34 @@
 
 	env.SharedLibrary('yade-base',
 		['base/yadeWm3Extra.cpp'],
-		LIBS=env['LIBS']+['Wm3Foundation'],
+		LIBS=env['LIBS'],
 		CPPPATH=env['CPPPATH']+['yade-base']),
 
+	env.StaticLibrary('miniWm3',
+		['miniWm3/Wm3Math.cpp',
+			'miniWm3/Wm3Matrix3.cpp',
+			'miniWm3/Wm3Quaternion.cpp',
+			'miniWm3/Wm3Vector3.cpp',
+			'miniWm3/Wm3Matrix2.cpp',
+			'miniWm3/Wm3Matrix4.cpp',
+			'miniWm3/Wm3Vector2.cpp',
+			'miniWm3/Wm3Vector4.cpp',
+			'miniWm3/Wm3Memory.cpp',
+			'miniWm3/Wm3String.cpp',
+			'miniWm3/Wm3System.cpp'],
+		# miniWm3 cannot link with itself, filter it out.
+		LIBS=filter(lambda l: l!='miniWm3',env['LIBS']),
+		CPPPATH=env['CPPPATH']+['miniWm3'],
+		# miniWm3 will be always optimized and withoutdebugging info, even in debug builds.
+		CXXFLAGS=env['CXXFLAGS']+['-O2','-g0']),
+
 	env.SharedLibrary('yade-computational-geometry',
 		['computational-geometry/Distances2D.cpp',
 			'computational-geometry/Distances3D.cpp',
 			'computational-geometry/Intersections2D.cpp',
 			'computational-geometry/Intersections3D.cpp',
 			'computational-geometry/MarchingCube.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['computational-geometry']),
 
 	env.SharedLibrary('yade-factory',
@@ -44,13 +62,13 @@
 
 	env.SharedLibrary('yade-serialization-qt',
 		['serialization-qt/QtGUIGenerator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'XMLFormatManager'],
+		LIBS=env['LIBS']+['yade-base',  'XMLFormatManager'],
 		CPPPATH=env['CPPPATH']+['serialization-qt']),
 
 	env.SharedLibrary('XMLFormatManager',
 		['serialization-xml/XMLFormatManager.cpp',
 			'serialization-xml/XMLSaxParser.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['serialization-xml']),
 
 	env.SharedLibrary('yade-serialization',

Added: branches/scons-layout/lib/miniWm3/README
===================================================================
--- branches/scons-layout/lib/miniWm3/README	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/README	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,5 @@
+This directory contains direct copy of a part of WildMagick3p11 (<A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>). The only file that altered is Wm3FoundationPCH.h, which is just empty here.
+
+Due to building issues, its non-availability as debian packages and considerable size of the original library, of which yade uses only a fraction, we decided to ship and build a local copy.
+
+Upstream source licence is LGPL.

Added: branches/scons-layout/lib/miniWm3/Wm3FoundationLIB.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3FoundationLIB.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3FoundationLIB.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,30 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3FOUNDATIONLIB_H
+#define WM3FOUNDATIONLIB_H
+
+// For the DLL library.
+#ifdef WM3_DLL_EXPORT
+#define WM3_ITEM __declspec(dllexport)
+
+// For a client of the DLL library.
+#else
+#ifdef WM3_DLL_IMPORT
+#define WM3_ITEM __declspec(dllimport)
+
+// For the static library.
+#else
+#define WM3_ITEM
+
+#endif
+#endif
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3FoundationPCH.h
===================================================================

Added: branches/scons-layout/lib/miniWm3/Wm3Math.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Math.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Math.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,67 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Math.h&quot;
+
+namespace Wm3
+{
+
+template&lt;&gt; const float Math&lt;float&gt;::EPSILON = FLT_EPSILON;
+template&lt;&gt; const float Math&lt;float&gt;::ZERO_TOLERANCE = 1e-06f;
+template&lt;&gt; const float Math&lt;float&gt;::MAX_REAL = FLT_MAX;
+template&lt;&gt; const float Math&lt;float&gt;::PI = (float)(4.0*atan(1.0));
+template&lt;&gt; const float Math&lt;float&gt;::TWO_PI = 2.0f*Math&lt;float&gt;::PI;
+template&lt;&gt; const float Math&lt;float&gt;::HALF_PI = 0.5f*Math&lt;float&gt;::PI;
+template&lt;&gt; const float Math&lt;float&gt;::INV_PI = 1.0f/Math&lt;float&gt;::PI;
+template&lt;&gt; const float Math&lt;float&gt;::INV_TWO_PI = 1.0f/Math&lt;float&gt;::TWO_PI;
+template&lt;&gt; const float Math&lt;float&gt;::DEG_TO_RAD = Math&lt;float&gt;::PI/180.0f;
+template&lt;&gt; const float Math&lt;float&gt;::RAD_TO_DEG = 180.0f/Math&lt;float&gt;::PI;
+
+template&lt;&gt; const double Math&lt;double&gt;::EPSILON = DBL_EPSILON;
+template&lt;&gt; const double Math&lt;double&gt;::ZERO_TOLERANCE = 1e-08;
+template&lt;&gt; const double Math&lt;double&gt;::MAX_REAL = DBL_MAX;
+template&lt;&gt; const double Math&lt;double&gt;::PI = 4.0*atan(1.0);
+template&lt;&gt; const double Math&lt;double&gt;::TWO_PI = 2.0*Math&lt;double&gt;::PI;
+template&lt;&gt; const double Math&lt;double&gt;::HALF_PI = 0.5*Math&lt;double&gt;::PI;
+template&lt;&gt; const double Math&lt;double&gt;::INV_PI = 1.0/Math&lt;double&gt;::PI;
+template&lt;&gt; const double Math&lt;double&gt;::INV_TWO_PI = 1.0/Math&lt;double&gt;::TWO_PI;
+template&lt;&gt; const double Math&lt;double&gt;::DEG_TO_RAD = Math&lt;double&gt;::PI/180.0;
+template&lt;&gt; const double Math&lt;double&gt;::RAD_TO_DEG = 180.0/Math&lt;double&gt;::PI;
+
+//----------------------------------------------------------------------------
+template &lt;&gt;
+float Math&lt;float&gt;::FastInvSqrt (float fValue)
+{
+    float fHalf = 0.5f*fValue;
+    int i  = *(int*)&fValue;
+    i = 0x5f3759df - (i &gt;&gt; 1);
+    fValue = *(float*)&i;
+    fValue = fValue*(1.5f - fHalf*fValue*fValue);
+    return fValue;
+}
+//----------------------------------------------------------------------------
+template &lt;&gt;
+double Math&lt;double&gt;::FastInvSqrt (double dValue)
+{
+    double dHalf = 0.5*dValue;
+    Integer64 i  = *(Integer64*)&dValue;
+#if defined(WM3_USING_VC70) || defined(WM3_USING_VC6)
+    i = 0x5fe6ec85e7de30da - (i &gt;&gt; 1);
+#else
+    i = 0x5fe6ec85e7de30daLL - (i &gt;&gt; 1);
+#endif
+    dValue = *(double*)&i;
+    dValue = dValue*(1.5 - dHalf*dValue*dValue);
+    return dValue;
+}
+//----------------------------------------------------------------------------
+
+}

Added: branches/scons-layout/lib/miniWm3/Wm3Math.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Math.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Math.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,131 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3MATH_H
+#define WM3MATH_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3System.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Math
+{
+public:
+    // Wrappers to hide implementations of functions.  The ACos and ASin
+    // functions clamp the input argument to [-1,1] to avoid NaN issues
+    // when the input is slightly larger than 1 or slightly smaller than -1.
+    // Other functions have the potential for using a fast and approximate
+    // algorithm rather than calling the standard math library functions.
+    static Real ACos (Real fValue);
+    static Real ASin (Real fValue);
+    static Real ATan (Real fValue);
+    static Real ATan2 (Real fY, Real fX);
+    static Real Ceil (Real fValue);
+    static Real Cos (Real fValue);
+    static Real Exp (Real fValue);
+    static Real FAbs (Real fValue);
+    static Real Floor (Real fValue);
+    static Real FMod (Real fX, Real fY);
+    static Real InvSqrt (Real fValue);
+    static Real Log (Real fValue);
+    static Real Pow (Real fBase, Real fExponent);
+    static Real Sin (Real fValue);
+    static Real Sqr (Real fValue);
+    static Real Sqrt (Real fValue);
+    static Real Tan (Real fValue);
+
+    // Return -1 if the input is negative, 0 if the input is zero, and +1
+    // if the input is positive.
+    static int Sign (int iValue);
+    static Real Sign (Real fValue);
+
+    // Generate a random number in [0,1).  The random number generator may
+    // be seeded by a first call to UnitRandom with a positive seed.
+    static Real UnitRandom (unsigned int uiSeed = 0);
+
+    // Generate a random number in [-1,1).  The random number generator may
+    // be seeded by a first call to SymmetricRandom with a positive seed.
+    static Real SymmetricRandom (unsigned int uiSeed = 0);
+
+    // Generate a random number in [min,max).  The random number generator may
+    // be seeded by a first call to IntervalRandom with a positive seed.
+    static Real IntervalRandom (Real fMin, Real fMax,
+        unsigned int uiSeed = 0);
+
+    // Fast evaluation of trigonometric and inverse trigonometric functions
+    // using polynomial approximations.  The speed ups were measured on an
+    // AMD 2800 (2.08 GHz) processor using Visual Studion .NET 2003 with a
+    // release build.
+
+    // The input must be in [0,pi/2].
+    // max error sin0 = 1.7e-04, speed up = 4.0
+    // max error sin1 = 1.9e-08, speed up = 2.8
+    static Real FastSin0 (Real fAngle);
+    static Real FastSin1 (Real fAngle);
+
+    // The input must be in [0,pi/2]
+    // max error cos0 = 1.2e-03, speed up = 4.5
+    // max error cos1 = 6.5e-09, speed up = 2.8
+    static Real FastCos0 (Real fAngle);
+    static Real FastCos1 (Real fAngle);
+
+    // The input must be in [0,pi/4].
+    // max error tan0 = 8.1e-04, speed up = 5.6
+    // max error tan1 = 1.9e-08, speed up = 3.4
+    static Real FastTan0 (Real fAngle);
+    static Real FastTan1 (Real fAngle);
+
+    // The input must be in [0,1].
+    // max error invsin0 = 6.8e-05, speed up = 7.5
+    // max error invsin1 = 1.4e-07, speed up = 5.5
+    static Real FastInvSin0 (Real fValue);
+    static Real FastInvSin1 (Real fValue);
+
+    // The input must be in [0,1].
+    // max error invcos0 = 6.8e-05, speed up = 7.5
+    // max error invcos1 = 1.4e-07, speed up = 5.7
+    static Real FastInvCos0 (Real fValue);
+    static Real FastInvCos1 (Real fValue);
+
+    // The input must be in [-1,1]. 
+    // max error invtan0 = 1.2e-05, speed up = 2.8
+    // max error invtan1 = 2.3e-08, speed up = 1.8
+    static Real FastInvTan0 (Real fValue);
+    static Real FastInvTan1 (Real fValue);
+
+    // A fast approximation to 1/sqrt.
+    static Real FastInvSqrt (Real fValue);
+
+    // common constants
+    WM3_ITEM static const Real EPSILON;
+    WM3_ITEM static const Real ZERO_TOLERANCE;
+    WM3_ITEM static const Real MAX_REAL;
+    WM3_ITEM static const Real PI;
+    WM3_ITEM static const Real TWO_PI;
+    WM3_ITEM static const Real HALF_PI;
+    WM3_ITEM static const Real INV_PI;
+    WM3_ITEM static const Real INV_TWO_PI;
+    WM3_ITEM static const Real DEG_TO_RAD;
+    WM3_ITEM static const Real RAD_TO_DEG;
+};
+
+#include &quot;Wm3Math.inl&quot;
+#include &quot;Wm3Math.mcr&quot;
+
+typedef Math&lt;float&gt; Mathf;
+typedef Math&lt;double&gt; Mathd;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Math.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Math.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Math.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,402 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::ACos (Real fValue)
+{
+    if ( -(Real)1.0 &lt; fValue )
+    {
+        if ( fValue &lt; (Real)1.0 )
+            return (Real)acos((double)fValue);
+        else
+            return (Real)0.0;
+    }
+    else
+    {
+        return PI;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::ASin (Real fValue)
+{
+    if ( -(Real)1.0 &lt; fValue )
+    {
+        if ( fValue &lt; (Real)1.0 )
+            return (Real)asin((double)fValue);
+        else
+            return HALF_PI;
+    }
+    else
+    {
+        return -HALF_PI;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::ATan (Real fValue)
+{
+    return (Real)atan((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::ATan2 (Real fY, Real fX)
+{
+    return (Real)atan2((double)fY,(double)fX);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Ceil (Real fValue)
+{
+    return (Real)ceil((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Cos (Real fValue)
+{
+    return (Real)cos((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Exp (Real fValue)
+{
+    return (Real)exp((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FAbs (Real fValue)
+{
+    return (Real)fabs((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Floor (Real fValue)
+{
+    return (Real)floor((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FMod (Real fX, Real fY)
+{
+    return (Real)fmod((double)fX,(double)fY);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::InvSqrt (Real fValue)
+{
+    return (Real)(1.0/sqrt((double)fValue));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Log (Real fValue)
+{
+    return (Real)log((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Pow (Real fBase, Real fExponent)
+{
+    return (Real)pow((double)fBase,(double)fExponent);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Sin (Real fValue)
+{
+    return (Real)sin((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Sqr (Real fValue)
+{
+    return fValue*fValue;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Sqrt (Real fValue)
+{
+    return (Real)sqrt((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Tan (Real fValue)
+{
+    return (Real)tan((double)fValue);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Math&lt;Real&gt;::Sign (int iValue)
+{
+    if ( iValue &gt; 0 )
+        return 1;
+
+    if ( iValue &lt; 0 )
+        return -1;
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::Sign (Real fValue)
+{
+    if ( fValue &gt; (Real)0.0 )
+        return (Real)1.0;
+
+    if ( fValue &lt; (Real)0.0 )
+        return -(Real)1.0;
+
+    return (Real)0.0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::UnitRandom (unsigned int uiSeed )
+{
+    if ( uiSeed &gt; 0 )
+        srand(uiSeed);
+
+    double dRatio = ((double)rand())/((double)(RAND_MAX));
+    return (Real)dRatio;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::SymmetricRandom (unsigned int uiSeed)
+{
+    if ( uiSeed &gt; 0.0 )
+        srand(uiSeed);
+
+    double dRatio = ((double)rand())/((double)(RAND_MAX));
+    return (Real)(2.0*dRatio - 1.0);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::IntervalRandom (Real fMin, Real fMax, unsigned int uiSeed)
+{
+    if ( uiSeed &gt; 0 )
+        srand(uiSeed);
+
+    double dRatio = ((double)rand())/((double)(RAND_MAX));
+    return fMin+(fMax-fMin)*((Real)dRatio);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastSin0 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = (Real)7.61e-03;
+    fResult *= fASqr;
+    fResult -= (Real)1.6605e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    fResult *= fAngle;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastSin1 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = -(Real)2.39e-08;
+    fResult *= fASqr;
+    fResult += (Real)2.7526e-06;
+    fResult *= fASqr;
+    fResult -= (Real)1.98409e-04;
+    fResult *= fASqr;
+    fResult += (Real)8.3333315e-03;
+    fResult *= fASqr;
+    fResult -= (Real)1.666666664e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    fResult *= fAngle;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastCos0 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = (Real)3.705e-02;
+    fResult *= fASqr;
+    fResult -= (Real)4.967e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastCos1 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = -(Real)2.605e-07;
+    fResult *= fASqr;
+    fResult += (Real)2.47609e-05;
+    fResult *= fASqr;
+    fResult -= (Real)1.3888397e-03;
+    fResult *= fASqr;
+    fResult += (Real)4.16666418e-02;
+    fResult *= fASqr;
+    fResult -= (Real)4.999999963e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastTan0 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = (Real)2.033e-01;
+    fResult *= fASqr;
+    fResult += (Real)3.1755e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    fResult *= fAngle;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastTan1 (Real fAngle)
+{
+    Real fASqr = fAngle*fAngle;
+    Real fResult = (Real)9.5168091e-03;
+    fResult *= fASqr;
+    fResult += (Real)2.900525e-03;
+    fResult *= fASqr;
+    fResult += (Real)2.45650893e-02;
+    fResult *= fASqr;
+    fResult += (Real)5.33740603e-02;
+    fResult *= fASqr;
+    fResult += (Real)1.333923995e-01;
+    fResult *= fASqr;
+    fResult += (Real)3.333314036e-01;
+    fResult *= fASqr;
+    fResult += (Real)1.0;
+    fResult *= fAngle;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvSin0 (Real fValue)
+{
+    Real fRoot = Math&lt;Real&gt;::Sqrt(((Real)1.0)-fValue);
+    Real fResult = -(Real)0.0187293;
+    fResult *= fValue;
+    fResult += (Real)0.0742610;
+    fResult *= fValue;
+    fResult -= (Real)0.2121144;
+    fResult *= fValue;
+    fResult += (Real)1.5707288;
+    fResult = HALF_PI - fRoot*fResult;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvSin1 (Real fValue)
+{
+    Real fRoot = Math&lt;Real&gt;::Sqrt(FAbs(((Real)1.0)-fValue));
+    Real fResult = -(Real)0.0012624911;
+    fResult *= fValue;
+    fResult += (Real)0.0066700901;
+    fResult *= fValue;
+    fResult -= (Real)0.0170881256;
+    fResult *= fValue;
+    fResult += (Real)0.0308918810;
+    fResult *= fValue;
+    fResult -= (Real)0.0501743046;
+    fResult *= fValue;
+    fResult += (Real)0.0889789874;
+    fResult *= fValue;
+    fResult -= (Real)0.2145988016;
+    fResult *= fValue;
+    fResult += (Real)1.5707963050;
+    fResult = HALF_PI - fRoot*fResult;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvCos0 (Real fValue)
+{
+    Real fRoot = Math&lt;Real&gt;::Sqrt(((Real)1.0)-fValue);
+    Real fResult = -(Real)0.0187293;
+    fResult *= fValue;
+    fResult += (Real)0.0742610;
+    fResult *= fValue;
+    fResult -= (Real)0.2121144;
+    fResult *= fValue;
+    fResult += (Real)1.5707288;
+    fResult *= fRoot;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvCos1 (Real fValue)
+{
+    Real fRoot = Math&lt;Real&gt;::Sqrt(FAbs(((Real)1.0)-fValue));
+    Real fResult = -(Real)0.0012624911;
+    fResult *= fValue;
+    fResult += (Real)0.0066700901;
+    fResult *= fValue;
+    fResult -= (Real)0.0170881256;
+    fResult *= fValue;
+    fResult += (Real)0.0308918810;
+    fResult *= fValue;
+    fResult -= (Real)0.0501743046;
+    fResult *= fValue;
+    fResult += (Real)0.0889789874;
+    fResult *= fValue;
+    fResult -= (Real)0.2145988016;
+    fResult *= fValue;
+    fResult += (Real)1.5707963050;
+    fResult *= fRoot;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvTan0 (Real fValue)
+{
+    Real fVSqr = fValue*fValue;
+    Real fResult = (Real)0.0208351;
+    fResult *= fVSqr;
+    fResult -= (Real)0.085133;
+    fResult *= fVSqr;
+    fResult += (Real)0.180141;
+    fResult *= fVSqr;
+    fResult -= (Real)0.3302995;
+    fResult *= fVSqr;
+    fResult += (Real)0.999866;
+    fResult *= fValue;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Math&lt;Real&gt;::FastInvTan1 (Real fValue)
+{
+    Real fVSqr = fValue*fValue;
+    Real fResult = (Real)0.0028662257;
+    fResult *= fVSqr;
+    fResult -= (Real)0.0161657367;
+    fResult *= fVSqr;
+    fResult += (Real)0.0429096138;
+    fResult *= fVSqr;
+    fResult -= (Real)0.0752896400;
+    fResult *= fVSqr;
+    fResult += (Real)0.1065626393;
+    fResult *= fVSqr;
+    fResult -= (Real)0.1420889944;
+    fResult *= fVSqr;
+    fResult += (Real)0.1999355085;
+    fResult *= fVSqr;
+    fResult -= (Real)0.3333314528;
+    fResult *= fVSqr;
+    fResult += (Real)1.0;
+    fResult *= fValue;
+    return fResult;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Math.mcr
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Math.mcr	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Math.mcr	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,39 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+
+// Fast conversion from a IEEE 32-bit floating point number F in [0,1] to a
+// a 32-bit integer I in [0,2^L-1].
+//
+//   fFloat = F
+//   iLog = L
+//   iInt = I
+
+#define WM3_SCALED_FLOAT_TO_INT(fFloat,iLog,iInt)\
+{ \
+    int iShift = 150 - iLog - ((*(int*)(&amp;fFloat) &gt;&gt; 23) &amp; 0xFF); \
+    if (iShift &lt; 24) \
+    { \
+        iInt = ((*(int*)(&amp;fFloat) &amp; 0x007FFFFF) | \
+            0x00800000) &gt;&gt; iShift; \
+        if (iInt == (1 &lt;&lt; iLog)) \
+        { \
+            iInt--; \
+        } \
+    } \
+    else \
+    { \
+        iInt = 0; \
+    } \
+}
+
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix2.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix2.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix2.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,28 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Matrix2.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Matrix2&lt;float&gt; Matrix2&lt;float&gt;::ZERO(
+    0.0f,0.0f,
+    0.0f,0.0f);
+template&lt;&gt; const Matrix2&lt;float&gt; Matrix2&lt;float&gt;::IDENTITY(
+    1.0f,0.0f,
+    0.0f,1.0f);
+
+template&lt;&gt; const Matrix2&lt;double&gt; Matrix2&lt;double&gt;::ZERO(
+    0.0,0.0,
+    0.0,0.0);
+template&lt;&gt; const Matrix2&lt;double&gt; Matrix2&lt;double&gt;::IDENTITY(
+    1.0,0.0,
+    0.0,1.0);
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix2.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix2.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix2.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,183 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3MATRIX2_H
+#define WM3MATRIX2_H
+
+// Matrix operations are applied on the left.  For example, given a matrix M
+// and a vector V, matrix-times-vector is M*V.  That is, V is treated as a
+// column vector.  Some graphics APIs use V*M where V is treated as a row
+// vector.  In this context the &quot;M&quot; matrix is really a transpose of the M as
+// represented in Wild Magic.  Similarly, to apply two matrix operations M0
+// and M1, in that order, you compute M1*M0 so that the transform of a vector
+// is (M1*M0)*V = M1*(M0*V).  Some graphics APIs use M0*M1, but again these
+// matrices are the transpose of those as represented in Wild Magic.  You
+// must therefore be careful about how you interface the transformation code
+// with graphics APIS.
+//
+// For memory organization it might seem natural to chose Real[N][N] for the
+// matrix storage, but this can be a problem on a platform/console that
+// chooses to store the data in column-major rather than row-major format.
+// To avoid potential portability problems, the matrix is stored as Real[N*N]
+// and organized in row-major order.  That is, the entry of the matrix in row
+// r (0 &lt;= r &lt; N) and column c (0 &lt;= c &lt; N) is stored at index i = c+N*r
+// (0 &lt;= i &lt; N*N).
+
+// Rotation matrices are of the form
+//   R = cos(t) -sin(t)
+//       sin(t)  cos(t)
+// where t &gt; 0 indicates a counterclockwise rotation in the xy-plane.
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Vector2.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Matrix2
+{
+public:
+    // If bZero is true, create the zero matrix.  Otherwise, create the
+    // identity matrix.
+    Matrix2 (bool bZero = true);
+
+    // copy constructor
+    Matrix2 (const Matrix2&amp; rkM);
+
+    // input Mrc is in row r, column c.
+    Matrix2 (Real fM00, Real fM01, Real fM10, Real fM11);
+
+    // Create a matrix from an array of numbers.  The input array is
+    // interpreted based on the Boolean input as
+    //   true:  entry[0..3] = {m00,m01,m10,m11}  [row major]
+    //   false: entry[0..3] = {m00,m10,m01,m11}  [column major]
+    Matrix2 (const Real afEntry[4], bool bRowMajor);
+
+    // Create matrices based on vector input.  The Boolean is interpreted as
+    //   true: vectors are columns of the matrix
+    //   false: vectors are rows of the matrix
+    Matrix2 (const Vector2&lt;Real&gt;&amp; rkU, const Vector2&lt;Real&gt;&amp; rkV,
+        bool bColumns);
+    Matrix2 (const Vector2&lt;Real&gt;* akV, bool bColumns);
+
+    // create a diagonal matrix
+    Matrix2 (Real fM00, Real fM11);
+
+    // create a rotation matrix (positive angle - counterclockwise)
+    Matrix2 (Real fAngle);
+
+    // create a tensor product U*V^T
+    Matrix2 (const Vector2&lt;Real&gt;&amp; rkU, const Vector2&lt;Real&gt;&amp; rkV);
+
+    // create various matrices
+    void MakeZero ();
+    void MakeIdentity ();
+    void MakeDiagonal (Real fM00, Real fM11);
+    void FromAngle (Real fAngle);
+    void MakeTensorProduct (const Vector2&lt;Real&gt;&amp; rkU,
+        const Vector2&lt;Real&gt;&amp; rkV);
+
+    // member access
+    operator const Real* () const;
+    operator Real* ();
+    const Real* operator[] (int iRow) const;
+    Real* operator[] (int iRow);
+    Real operator() (int iRow, int iCol) const;
+    Real&amp; operator() (int iRow, int iCol);
+    void SetRow (int iRow, const Vector2&lt;Real&gt;&amp; rkV);
+    Vector2&lt;Real&gt; GetRow (int iRow) const;
+    void SetColumn (int iCol, const Vector2&lt;Real&gt;&amp; rkV);
+    Vector2&lt;Real&gt; GetColumn (int iCol) const;
+    void GetColumnMajor (Real* afCMajor) const;
+
+    // assignment
+    Matrix2&amp; operator= (const Matrix2&amp; rkM);
+
+    // comparison
+    bool operator== (const Matrix2&amp; rkM) const;
+    bool operator!= (const Matrix2&amp; rkM) const;
+    bool operator&lt;  (const Matrix2&amp; rkM) const;
+    bool operator&lt;= (const Matrix2&amp; rkM) const;
+    bool operator&gt;  (const Matrix2&amp; rkM) const;
+    bool operator&gt;= (const Matrix2&amp; rkM) const;
+
+    // arithmetic operations
+    Matrix2 operator+ (const Matrix2&amp; rkM) const;
+    Matrix2 operator- (const Matrix2&amp; rkM) const;
+    Matrix2 operator* (const Matrix2&amp; rkM) const;
+    Matrix2 operator* (Real fScalar) const;
+    Matrix2 operator/ (Real fScalar) const;
+    Matrix2 operator- () const;
+
+    // arithmetic updates
+    Matrix2&amp; operator+= (const Matrix2&amp; rkM);
+    Matrix2&amp; operator-= (const Matrix2&amp; rkM);
+    Matrix2&amp; operator*= (Real fScalar);
+    Matrix2&amp; operator/= (Real fScalar);
+
+    // matrix times vector
+    Vector2&lt;Real&gt; operator* (const Vector2&lt;Real&gt;&amp; rkV) const;  // M * v
+
+    // other operations
+    Matrix2 Transpose () const;  // M^T
+    Matrix2 TransposeTimes (const Matrix2&amp; rkM) const;  // this^T * M
+    Matrix2 TimesTranspose (const Matrix2&amp; rkM) const;  // this * M^T
+    Matrix2 Inverse () const;
+    Matrix2 Adjoint () const;
+    Real Determinant () const;
+    Real QForm (const Vector2&lt;Real&gt;&amp; rkU,
+        const Vector2&lt;Real&gt;&amp; rkV) const;  // u^T*M*v
+
+    // The matrix must be a rotation for these functions to be valid.  The
+    // last function uses Gram-Schmidt orthonormalization applied to the
+    // columns of the rotation matrix.  The angle must be in radians, not
+    // degrees.
+    void ToAngle (Real&amp; rfAngle) const;
+    void Orthonormalize ();
+
+    // The matrix must be symmetric.  Factor M = R * D * R^T where
+    // R = [u0|u1] is a rotation matrix with columns u0 and u1 and
+    // D = diag(d0,d1) is a diagonal matrix whose diagonal entries are d0 and
+    // d1.  The eigenvector u[i] corresponds to eigenvector d[i].  The
+    // eigenvalues are ordered as d0 &lt;= d1.
+    void EigenDecomposition (Matrix2&amp; rkRot, Matrix2&amp; rkDiag) const;
+
+    WM3_ITEM static const Matrix2 ZERO;
+    WM3_ITEM static const Matrix2 IDENTITY;
+
+private:
+    // for indexing into the 1D array of the matrix, iCol+N*iRow
+    static int I (int iRow, int iCol);
+
+    // support for comparisons
+    int CompareArrays (const Matrix2&amp; rkM) const;
+
+    // matrix stored in row-major order
+    Real m_afEntry[4];
+};
+
+// c * M
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; operator* (Real fScalar, const Matrix2&lt;Real&gt;&amp; rkM);
+
+// v^T * M
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; operator* (const Vector2&lt;Real&gt;&amp; rkV, const Matrix2&lt;Real&gt;&amp; rkM);
+
+#include &quot;Wm3Matrix2.inl&quot;
+
+typedef Matrix2&lt;float&gt; Matrix2f;
+typedef Matrix2&lt;double&gt; Matrix2d;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix2.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix2.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix2.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,648 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (bool bZero)
+{
+    if (bZero)
+    {
+        MakeZero();
+    }
+    else
+    {
+        MakeIdentity();
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (const Matrix2&amp; rkM)
+{
+    size_t uiSize = 4*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (Real fM00, Real fM01, Real fM10, Real fM11)
+{
+    m_afEntry[0] = fM00;
+    m_afEntry[1] = fM01;
+    m_afEntry[2] = fM10;
+    m_afEntry[3] = fM11;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (const Real afEntry[4], bool bRowMajor)
+{
+    if (bRowMajor)
+    {
+        size_t uiSize = 4*sizeof(Real);
+        System::Memcpy(m_afEntry,uiSize,afEntry,uiSize);
+    }
+    else
+    {
+        m_afEntry[0] = afEntry[0];
+        m_afEntry[1] = afEntry[2];
+        m_afEntry[2] = afEntry[1];
+        m_afEntry[3] = afEntry[3];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (const Vector2&lt;Real&gt;&amp; rkU, const Vector2&lt;Real&gt;&amp; rkV,
+    bool bColumns)
+{
+    if (bColumns)
+    {
+        m_afEntry[0] = rkU[0];
+        m_afEntry[1] = rkV[0];
+        m_afEntry[2] = rkU[1];
+        m_afEntry[3] = rkV[1];
+    }
+    else
+    {
+        m_afEntry[0] = rkU[0];
+        m_afEntry[1] = rkU[1];
+        m_afEntry[2] = rkV[0];
+        m_afEntry[3] = rkV[1];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (const Vector2&lt;Real&gt;* akV, bool bColumns)
+{
+    if (bColumns)
+    {
+        m_afEntry[0] = akV[0][0];
+        m_afEntry[1] = akV[1][0];
+        m_afEntry[2] = akV[0][1];
+        m_afEntry[3] = akV[1][1];
+    }
+    else
+    {
+        m_afEntry[0] = akV[0][0];
+        m_afEntry[1] = akV[0][1];
+        m_afEntry[2] = akV[1][0];
+        m_afEntry[3] = akV[1][1];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (Real fM00, Real fM11)
+{
+    MakeDiagonal(fM00,fM11);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (Real fAngle)
+{
+    FromAngle(fAngle);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::Matrix2 (const Vector2&lt;Real&gt;&amp; rkU, const Vector2&lt;Real&gt;&amp; rkV)
+{
+    MakeTensorProduct(rkU,rkV);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::operator const Real* () const
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;::operator Real* ()
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+const Real* Matrix2&lt;Real&gt;::operator[] (int iRow) const
+{
+    return &amp;m_afEntry[2*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real* Matrix2&lt;Real&gt;::operator[] (int iRow)
+{
+    return &amp;m_afEntry[2*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix2&lt;Real&gt;::operator() (int iRow, int iCol) const
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Matrix2&lt;Real&gt;::operator() (int iRow, int iCol)
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix2&lt;Real&gt;::I (int iRow, int iCol)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 2 &amp;&amp; 0 &lt;= iCol &amp;&amp; iCol &lt; 2);
+    return iCol + 2*iRow;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::MakeZero ()
+{
+    memset(m_afEntry,0,4*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::MakeIdentity ()
+{
+    m_afEntry[0] = (Real)1.0;
+    m_afEntry[1] = (Real)0.0;
+    m_afEntry[2] = (Real)0.0;
+    m_afEntry[3] = (Real)1.0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::MakeDiagonal (Real fM00, Real fM11)
+{
+    m_afEntry[0] = fM00;
+    m_afEntry[1] = (Real)0.0;
+    m_afEntry[2] = (Real)0.0;
+    m_afEntry[3] = fM11;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::FromAngle (Real fAngle)
+{
+    m_afEntry[0] = Math&lt;Real&gt;::Cos(fAngle);
+    m_afEntry[2] = Math&lt;Real&gt;::Sin(fAngle);
+    m_afEntry[1] = -m_afEntry[2];
+    m_afEntry[3] =  m_afEntry[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::MakeTensorProduct (const Vector2&lt;Real&gt;&amp; rkU,
+    const Vector2&lt;Real&gt;&amp; rkV)
+{
+    m_afEntry[0] = rkU[0]*rkV[0];
+    m_afEntry[1] = rkU[0]*rkV[1];
+    m_afEntry[2] = rkU[1]*rkV[0];
+    m_afEntry[3] = rkU[1]*rkV[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::SetRow (int iRow, const Vector2&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 2);
+    for (int iCol = 0, i = 2*iRow; iCol &lt; 2; iCol++, i++)
+    {
+        m_afEntry[i] = rkV[iCol];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Matrix2&lt;Real&gt;::GetRow (int iRow) const
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 2);
+    Vector2&lt;Real&gt; kV;
+    for (int iCol = 0, i = 2*iRow; iCol &lt; 2; iCol++, i++)
+    {
+        kV[iCol] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::SetColumn (int iCol, const Vector2&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 2);
+    for (int iRow = 0, i = iCol; iRow &lt; 2; iRow++, i += 2)
+    {
+        m_afEntry[i] = rkV[iRow];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Matrix2&lt;Real&gt;::GetColumn (int iCol) const
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 2);
+    Vector2&lt;Real&gt; kV;
+    for (int iRow = 0, i = iCol; iRow &lt; 2; iRow++, i += 2)
+    {
+        kV[iRow] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::GetColumnMajor (Real* afCMajor) const
+{
+    for (int iRow = 0, i = 0; iRow &lt; 2; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            afCMajor[i++] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;&amp; Matrix2&lt;Real&gt;::operator= (const Matrix2&amp; rkM)
+{
+    size_t uiSize = 4*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix2&lt;Real&gt;::CompareArrays (const Matrix2&amp; rkM) const
+{
+    return memcmp(m_afEntry,rkM.m_afEntry,4*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator== (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator!= (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator&lt;  (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator&lt;= (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator&gt;  (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix2&lt;Real&gt;::operator&gt;= (const Matrix2&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator+ (const Matrix2&amp; rkM) const
+{
+    Matrix2 kSum;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kSum.m_afEntry[i] = m_afEntry[i] + rkM.m_afEntry[i];
+    }
+    return kSum;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator- (const Matrix2&amp; rkM) const
+{
+    Matrix2 kDiff;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kDiff.m_afEntry[i] = m_afEntry[i] - rkM.m_afEntry[i];
+    }
+    return kDiff;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator* (const Matrix2&amp; rkM) const
+{
+    Matrix2 kProd;
+    for (int iRow = 0; iRow &lt; 2; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 2; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator* (Real fScalar) const
+{
+    Matrix2 kProd;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kProd.m_afEntry[i] = fScalar*m_afEntry[i];
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Matrix2 kQuot;
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 4; i++)
+        {
+            kQuot.m_afEntry[i] = fInvScalar*m_afEntry[i];
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 4; i++)
+        {
+            kQuot.m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::operator- () const
+{
+    Matrix2 kNeg;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kNeg.m_afEntry[i] = -m_afEntry[i];
+    }
+    return kNeg;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;&amp; Matrix2&lt;Real&gt;::operator+= (const Matrix2&amp; rkM)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afEntry[i] += rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;&amp; Matrix2&lt;Real&gt;::operator-= (const Matrix2&amp; rkM)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afEntry[i] -= rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;&amp; Matrix2&lt;Real&gt;::operator*= (Real fScalar)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afEntry[i] *= fScalar;
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt;&amp; Matrix2&lt;Real&gt;::operator/= (Real fScalar)
+{
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afEntry[i] *= fInvScalar;
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Matrix2&lt;Real&gt;::operator* (const Vector2&lt;Real&gt;&amp; rkV) const
+{
+    Vector2&lt;Real&gt; kProd;
+    for (int iRow = 0; iRow &lt; 2; iRow++)
+    {
+        kProd[iRow] = (Real)0.0;
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            kProd[iRow] += m_afEntry[I(iRow,iCol)]*rkV[iCol];
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::Transpose () const
+{
+    Matrix2 kTranspose;
+    for (int iRow = 0; iRow &lt; 2; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            kTranspose.m_afEntry[I(iRow,iCol)] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+    return kTranspose;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::TransposeTimes (const Matrix2&amp; rkM) const
+{
+    // P = A^T*B, P[r][c] = sum_m A[m][r]*B[m][c]
+    Matrix2 kProd;
+    for (int iRow = 0; iRow &lt; 2; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 2; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iMid,iRow)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::TimesTranspose (const Matrix2&amp; rkM) const
+{
+    // P = A*B^T, P[r][c] = sum_m A[r][m]*B[c][m]
+    Matrix2 kProd;
+    for (int iRow = 0; iRow &lt; 2; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 2; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 2; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iCol,iMid)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::Inverse () const
+{
+    Matrix2 kInverse;
+
+    Real fDet = m_afEntry[0]*m_afEntry[3] - m_afEntry[1]*m_afEntry[2];
+    if (Math&lt;Real&gt;::FAbs(fDet) &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvDet = ((Real)1.0)/fDet;
+        kInverse[0][0] =  m_afEntry[3]*fInvDet;
+        kInverse[0][1] = -m_afEntry[1]*fInvDet;
+        kInverse[1][0] = -m_afEntry[2]*fInvDet;
+        kInverse[1][1] =  m_afEntry[0]*fInvDet;
+    }
+    else
+    {
+        kInverse.MakeZero();
+    }
+
+    return kInverse;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; Matrix2&lt;Real&gt;::Adjoint () const
+{
+    return Matrix2(
+         m_afEntry[3],-m_afEntry[1],
+        -m_afEntry[2], m_afEntry[0]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix2&lt;Real&gt;::Determinant () const
+{
+    return m_afEntry[0]*m_afEntry[3] - m_afEntry[1]*m_afEntry[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix2&lt;Real&gt;::QForm (const Vector2&lt;Real&gt;&amp; rkU,
+    const Vector2&lt;Real&gt;&amp; rkV) const
+{
+    return rkU.Dot((*this)*rkV);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::ToAngle (Real&amp; rfAngle) const
+{
+    // assert:  matrix is a rotation
+    rfAngle = Math&lt;Real&gt;::ATan2(m_afEntry[2],m_afEntry[0]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::Orthonormalize ()
+{
+    // Algorithm uses Gram-Schmidt orthogonalization.  If 'this' matrix is
+    // M = [m0|m1], then orthonormal output matrix is Q = [q0|q1],
+    //
+    //   q0 = m0/|m0|
+    //   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|
+    //
+    // where |V| indicates length of vector V and A*B indicates dot
+    // product of vectors A and B.
+
+    // compute q0
+    Real fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[0]*m_afEntry[0] +
+        m_afEntry[2]*m_afEntry[2]);
+
+    m_afEntry[0] *= fInvLength;
+    m_afEntry[2] *= fInvLength;
+
+    // compute q1
+    Real fDot0 = m_afEntry[0]*m_afEntry[1] + m_afEntry[2]*m_afEntry[3];
+    m_afEntry[1] -= fDot0*m_afEntry[0];
+    m_afEntry[3] -= fDot0*m_afEntry[2];
+
+    fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[1]*m_afEntry[1] +
+        m_afEntry[3]*m_afEntry[3]);
+
+    m_afEntry[1] *= fInvLength;
+    m_afEntry[3] *= fInvLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix2&lt;Real&gt;::EigenDecomposition (Matrix2&amp; rkRot, Matrix2&amp; rkDiag) const
+{
+    Real fTrace = m_afEntry[0] + m_afEntry[3];
+    Real fDiff = m_afEntry[0] - m_afEntry[3];
+    Real fDiscr = Math&lt;Real&gt;::Sqrt(fDiff*fDiff +
+        ((Real)4.0)*m_afEntry[1]*m_afEntry[1]);
+    Real fEVal0 = ((Real)0.5)*(fTrace-fDiscr);
+    Real fEVal1 = ((Real)0.5)*(fTrace+fDiscr);
+    rkDiag.MakeDiagonal(fEVal0,fEVal1);
+
+    Real fCos, fSin;
+    if (fDiff &gt;= (Real)0.0)
+    {
+        fCos = m_afEntry[1];
+        fSin = fEVal0 - m_afEntry[0];
+    }
+    else
+    {
+        fCos = fEVal0 - m_afEntry[3];
+        fSin = m_afEntry[1];
+    }
+    Real fTmp = Math&lt;Real&gt;::InvSqrt(fCos*fCos + fSin*fSin);
+    fCos *= fTmp;
+    fSin *= fTmp;
+
+    rkRot.m_afEntry[0] = fCos;
+    rkRot.m_afEntry[1] = -fSin;
+    rkRot.m_afEntry[2] = fSin;
+    rkRot.m_afEntry[3] = fCos;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix2&lt;Real&gt; operator* (Real fScalar, const Matrix2&lt;Real&gt;&amp; rkM)
+{
+    return rkM*fScalar;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; operator* (const Vector2&lt;Real&gt;&amp; rkV, const Matrix2&lt;Real&gt;&amp; rkM)
+{
+    return Vector2&lt;Real&gt;(
+        rkV[0]*rkM[0][0] + rkV[1]*rkM[1][0],
+        rkV[0]*rkM[0][1] + rkV[1]*rkM[1][1]);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix3.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix3.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix3.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,32 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Matrix3.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Matrix3&lt;float&gt; Matrix3&lt;float&gt;::ZERO(
+    0.0f,0.0f,0.0f,
+    0.0f,0.0f,0.0f,
+    0.0f,0.0f,0.0f);
+template&lt;&gt; const Matrix3&lt;float&gt; Matrix3&lt;float&gt;::IDENTITY(
+    1.0f,0.0f,0.0f,
+    0.0f,1.0f,0.0f,
+    0.0f,0.0f,1.0f);
+
+template&lt;&gt; const Matrix3&lt;double&gt; Matrix3&lt;double&gt;::ZERO(
+    0.0,0.0,0.0,
+    0.0,0.0,0.0,
+    0.0,0.0,0.0);
+template&lt;&gt; const Matrix3&lt;double&gt; Matrix3&lt;double&gt;::IDENTITY(
+    1.0,0.0,0.0,
+    0.0,1.0,0.0,
+    0.0,0.0,1.0);
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix3.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix3.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix3.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,250 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3MATRIX3_H
+#define WM3MATRIX3_H
+
+// Matrix operations are applied on the left.  For example, given a matrix M
+// and a vector V, matrix-times-vector is M*V.  That is, V is treated as a
+// column vector.  Some graphics APIs use V*M where V is treated as a row
+// vector.  In this context the &quot;M&quot; matrix is really a transpose of the M as
+// represented in Wild Magic.  Similarly, to apply two matrix operations M0
+// and M1, in that order, you compute M1*M0 so that the transform of a vector
+// is (M1*M0)*V = M1*(M0*V).  Some graphics APIs use M0*M1, but again these
+// matrices are the transpose of those as represented in Wild Magic.  You
+// must therefore be careful about how you interface the transformation code
+// with graphics APIS.
+//
+// For memory organization it might seem natural to chose Real[N][N] for the
+// matrix storage, but this can be a problem on a platform/console that
+// chooses to store the data in column-major rather than row-major format.
+// To avoid potential portability problems, the matrix is stored as Real[N*N]
+// and organized in row-major order.  That is, the entry of the matrix in row
+// r (0 &lt;= r &lt; N) and column c (0 &lt;= c &lt; N) is stored at index i = c+N*r
+// (0 &lt;= i &lt; N*N).
+
+// The (x,y,z) coordinate system is assumed to be right-handed.  Coordinate
+// axis rotation matrices are of the form
+//   RX =    1       0       0
+//           0     cos(t) -sin(t)
+//           0     sin(t)  cos(t)
+// where t &gt; 0 indicates a counterclockwise rotation in the yz-plane
+//   RY =  cos(t)    0     sin(t)
+//           0       1       0
+//        -sin(t)    0     cos(t)
+// where t &gt; 0 indicates a counterclockwise rotation in the zx-plane
+//   RZ =  cos(t) -sin(t)    0
+//         sin(t)  cos(t)    0
+//           0       0       1
+// where t &gt; 0 indicates a counterclockwise rotation in the xy-plane.
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Vector3.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Matrix3
+{
+public:
+    // If bZero is true, create the zero matrix.  Otherwise, create the
+    // identity matrix.
+    Matrix3 (bool bZero = true);
+
+    // copy constructor
+    Matrix3 (const Matrix3&amp; rkM);
+
+    // input Mrc is in row r, column c.
+    Matrix3 (Real fM00, Real fM01, Real fM02,
+             Real fM10, Real fM11, Real fM12,
+             Real fM20, Real fM21, Real fM22);
+
+    // Create a matrix from an array of numbers.  The input array is
+    // interpreted based on the Boolean input as
+    //   true:  entry[0..8]={m00,m01,m02,m10,m11,m12,m20,m21,m22} [row major]
+    //   false: entry[0..8]={m00,m10,m20,m01,m11,m21,m02,m12,m22} [col major]
+    Matrix3 (const Real afEntry[9], bool bRowMajor);
+
+    // Create matrices based on vector input.  The Boolean is interpreted as
+    //   true: vectors are columns of the matrix
+    //   false: vectors are rows of the matrix
+    Matrix3 (const Vector3&lt;Real&gt;&amp; rkU, const Vector3&lt;Real&gt;&amp; rkV,
+        const Vector3&lt;Real&gt;&amp; rkW, bool bColumns);
+    Matrix3 (const Vector3&lt;Real&gt;* akV, bool bColumns);
+
+    // create a diagonal matrix
+    Matrix3 (Real fM00, Real fM11, Real fM22);
+
+    // Create rotation matrices (positive angle - counterclockwise).  The
+    // angle must be in radians, not degrees.
+    Matrix3 (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle);
+
+    // create a tensor product U*V^T
+    Matrix3 (const Vector3&lt;Real&gt;&amp; rkU, const Vector3&lt;Real&gt;&amp; rkV);
+
+    // create various matrices
+    Matrix3&amp; MakeZero ();
+    Matrix3&amp; MakeIdentity ();
+    Matrix3&amp; MakeDiagonal (Real fM00, Real fM11, Real fM22);
+    Matrix3&amp; FromAxisAngle (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle);
+    Matrix3&amp; MakeTensorProduct (const Vector3&lt;Real&gt;&amp; rkU,
+        const Vector3&lt;Real&gt;&amp; rkV);
+
+    // member access
+    operator const Real* () const;
+    operator Real* ();
+    const Real* operator[] (int iRow) const;
+    Real* operator[] (int iRow);
+    Real operator() (int iRow, int iCol) const;
+    Real&amp; operator() (int iRow, int iCol);
+    void SetRow (int iRow, const Vector3&lt;Real&gt;&amp; rkV);
+    Vector3&lt;Real&gt; GetRow (int iRow) const;
+    void SetColumn (int iCol, const Vector3&lt;Real&gt;&amp; rkV);
+    Vector3&lt;Real&gt; GetColumn (int iCol) const;
+    void GetColumnMajor (Real* afCMajor) const;
+
+    // assignment
+    Matrix3&amp; operator= (const Matrix3&amp; rkM);
+
+    // comparison
+    bool operator== (const Matrix3&amp; rkM) const;
+    bool operator!= (const Matrix3&amp; rkM) const;
+    bool operator&lt;  (const Matrix3&amp; rkM) const;
+    bool operator&lt;= (const Matrix3&amp; rkM) const;
+    bool operator&gt;  (const Matrix3&amp; rkM) const;
+    bool operator&gt;= (const Matrix3&amp; rkM) const;
+
+    // arithmetic operations
+    Matrix3 operator+ (const Matrix3&amp; rkM) const;
+    Matrix3 operator- (const Matrix3&amp; rkM) const;
+    Matrix3 operator* (const Matrix3&amp; rkM) const;
+    Matrix3 operator* (Real fScalar) const;
+    Matrix3 operator/ (Real fScalar) const;
+    Matrix3 operator- () const;
+
+    // arithmetic updates
+    Matrix3&amp; operator+= (const Matrix3&amp; rkM);
+    Matrix3&amp; operator-= (const Matrix3&amp; rkM);
+    Matrix3&amp; operator*= (Real fScalar);
+    Matrix3&amp; operator/= (Real fScalar);
+
+    // matrix times vector
+    Vector3&lt;Real&gt; operator* (const Vector3&lt;Real&gt;&amp; rkV) const;  // M * v
+
+    // other operations
+    Matrix3 Transpose () const;  // M^T
+    Matrix3 TransposeTimes (const Matrix3&amp; rkM) const;  // this^T * M
+    Matrix3 TimesTranspose (const Matrix3&amp; rkM) const;  // this * M^T
+    Matrix3 Inverse () const;
+    Matrix3 Adjoint () const;
+    Real Determinant () const;
+    Real QForm (const Vector3&lt;Real&gt;&amp; rkU,
+        const Vector3&lt;Real&gt;&amp; rkV) const;  // u^T*M*v
+    Matrix3 TimesDiagonal (const Vector3&lt;Real&gt;&amp; rkDiag) const;  // M*D
+    Matrix3 DiagonalTimes (const Vector3&lt;Real&gt;&amp; rkDiag) const;  // D*M
+
+    // The matrix must be a rotation for these functions to be valid.  The
+    // last function uses Gram-Schmidt orthonormalization applied to the
+    // columns of the rotation matrix.  The angle must be in radians, not
+    // degrees.
+    void ToAxisAngle (Vector3&lt;Real&gt;&amp; rkAxis, Real&amp; rfAngle) const;
+    void Orthonormalize ();
+
+    // The matrix must be symmetric.  Factor M = R * D * R^T where
+    // R = [u0|u1|u2] is a rotation matrix with columns u0, u1, and u2 and
+    // D = diag(d0,d1,d2) is a diagonal matrix whose diagonal entries are d0,
+    // d1, and d2.  The eigenvector u[i] corresponds to eigenvector d[i].
+    // The eigenvalues are ordered as d0 &lt;= d1 &lt;= d2.
+    void EigenDecomposition (Matrix3&amp; rkRot, Matrix3&amp; rkDiag) const;
+
+    // The matrix must be orthonormal.  The decomposition is yaw*pitch*roll
+    // where yaw is rotation about the Up vector, pitch is rotation about the
+    // Right axis, and roll is rotation about the Direction axis.
+    Matrix3&amp; FromEulerAnglesXYZ (Real fYAngle, Real fPAngle, Real fRAngle);
+    Matrix3&amp; FromEulerAnglesXZY (Real fYAngle, Real fPAngle, Real fRAngle);
+    Matrix3&amp; FromEulerAnglesYXZ (Real fYAngle, Real fPAngle, Real fRAngle);
+    Matrix3&amp; FromEulerAnglesYZX (Real fYAngle, Real fPAngle, Real fRAngle);
+    Matrix3&amp; FromEulerAnglesZXY (Real fYAngle, Real fPAngle, Real fRAngle);
+    Matrix3&amp; FromEulerAnglesZYX (Real fYAngle, Real fPAngle, Real fRAngle);
+    bool ToEulerAnglesXYZ (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+    bool ToEulerAnglesXZY (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+    bool ToEulerAnglesYXZ (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+    bool ToEulerAnglesYZX (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+    bool ToEulerAnglesZXY (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+    bool ToEulerAnglesZYX (Real&amp; rfYAngle, Real&amp; rfPAngle,
+        Real&amp; rfRAngle) const;
+
+    // SLERP (spherical linear interpolation) without quaternions.  Computes
+    // R(t) = R0*(Transpose(R0)*R1)^t.  If Q is a rotation matrix with
+    // unit-length axis U and angle A, then Q^t is a rotation matrix with
+    // unit-length axis U and rotation angle t*A.
+    static Matrix3 Slerp (Real fT, const Matrix3&amp; rkR0,
+        const Matrix3&amp; rkR1);
+
+    // Singular value decomposition, M = L*S*R, where L and R are orthogonal
+    // and S is a diagonal matrix whose diagonal entries are nonnegative.
+    void SingularValueDecomposition (Matrix3&amp; rkL, Matrix3&amp; rkS,
+        Matrix3&amp; rkR) const;
+    void SingularValueComposition (const Matrix3&amp; rkL, const Matrix3&amp; rkS,
+        const Matrix3&amp; rkR);
+
+    // factor M = Q*D*U with orthogonal Q, diagonal D, upper triangular U
+    void QDUDecomposition (Matrix3&amp; rkQ, Matrix3&amp; rkD, Matrix3&amp; rkU) const;
+
+    // special matrices
+    WM3_ITEM static const Matrix3 ZERO;
+    WM3_ITEM static const Matrix3 IDENTITY;
+
+private:
+    // Support for eigendecomposition.  The Tridiagonalize function applies
+    // a Householder transformation to the matrix.  If that transformation
+    // is the identity (the matrix is already tridiagonal), then the return
+    // value is 'false'.  Otherwise, the transformation is a reflection and
+    // the return value is 'true'.  The QLAlgorithm returns 'true' iff the
+    // QL iteration scheme converged.
+    bool Tridiagonalize (Real afDiag[3], Real afSubd[2]);
+    bool QLAlgorithm (Real afDiag[3], Real afSubd[2]);
+
+    // support for singular value decomposition
+    static void Bidiagonalize (Matrix3&amp; rkA, Matrix3&amp; rkL, Matrix3&amp; rkR);
+    static void GolubKahanStep (Matrix3&amp; rkA, Matrix3&amp; rkL, Matrix3&amp; rkR);
+
+    // for indexing into the 1D array of the matrix, iCol+N*iRow
+    static int I (int iRow, int iCol);
+
+    // support for comparisons
+    int CompareArrays (const Matrix3&amp; rkM) const;
+
+    Real m_afEntry[9];
+};
+
+// c * M
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; operator* (Real fScalar, const Matrix3&lt;Real&gt;&amp; rkM);
+
+// v^T * M
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; operator* (const Vector3&lt;Real&gt;&amp; rkV, const Matrix3&lt;Real&gt;&amp; rkM);
+
+#include &quot;Wm3Matrix3.inl&quot;
+
+typedef Matrix3&lt;float&gt; Matrix3f;
+typedef Matrix3&lt;double&gt; Matrix3d;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix3.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix3.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix3.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,2082 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (bool bZero)
+{
+    if (bZero)
+    {
+        MakeZero();
+    }
+    else
+    {
+        MakeIdentity();
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Matrix3&amp; rkM)
+{
+    size_t uiSize = 9*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (Real fM00, Real fM01, Real fM02, Real fM10, Real fM11,
+    Real fM12, Real fM20, Real fM21, Real fM22)
+{
+    m_afEntry[0] = fM00;
+    m_afEntry[1] = fM01;
+    m_afEntry[2] = fM02;
+    m_afEntry[3] = fM10;
+    m_afEntry[4] = fM11;
+    m_afEntry[5] = fM12;
+    m_afEntry[6] = fM20;
+    m_afEntry[7] = fM21;
+    m_afEntry[8] = fM22;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Real afEntry[9], bool bRowMajor)
+{
+    if (bRowMajor)
+    {
+        size_t uiSize = 9*sizeof(Real);
+        System::Memcpy(m_afEntry,uiSize,afEntry,uiSize);
+    }
+    else
+    {
+        m_afEntry[0] = afEntry[0];
+        m_afEntry[1] = afEntry[3];
+        m_afEntry[2] = afEntry[6];
+        m_afEntry[3] = afEntry[1];
+        m_afEntry[4] = afEntry[4];
+        m_afEntry[5] = afEntry[7];
+        m_afEntry[6] = afEntry[2];
+        m_afEntry[7] = afEntry[5];
+        m_afEntry[8] = afEntry[8];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Vector3&lt;Real&gt;&amp; rkU, const Vector3&lt;Real&gt;&amp; rkV,
+    const Vector3&lt;Real&gt;&amp; rkW, bool bColumns)
+{
+    if (bColumns)
+    {
+        m_afEntry[0] = rkU[0];
+        m_afEntry[1] = rkV[0];
+        m_afEntry[2] = rkW[0];
+        m_afEntry[3] = rkU[1];
+        m_afEntry[4] = rkV[1];
+        m_afEntry[5] = rkW[1];
+        m_afEntry[6] = rkU[2];
+        m_afEntry[7] = rkV[2];
+        m_afEntry[8] = rkW[2];
+    }
+    else
+    {
+        m_afEntry[0] = rkU[0];
+        m_afEntry[1] = rkU[1];
+        m_afEntry[2] = rkU[2];
+        m_afEntry[3] = rkV[0];
+        m_afEntry[4] = rkV[1];
+        m_afEntry[5] = rkV[2];
+        m_afEntry[6] = rkW[0];
+        m_afEntry[7] = rkW[1];
+        m_afEntry[8] = rkW[2];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Vector3&lt;Real&gt;* akV, bool bColumns)
+{
+    if (bColumns)
+    {
+        m_afEntry[0] = akV[0][0];
+        m_afEntry[1] = akV[1][0];
+        m_afEntry[2] = akV[2][0];
+        m_afEntry[3] = akV[0][1];
+        m_afEntry[4] = akV[1][1];
+        m_afEntry[5] = akV[2][1];
+        m_afEntry[6] = akV[0][2];
+        m_afEntry[7] = akV[1][2];
+        m_afEntry[8] = akV[2][2];
+    }
+    else
+    {
+        m_afEntry[0] = akV[0][0];
+        m_afEntry[1] = akV[0][1];
+        m_afEntry[2] = akV[0][2];
+        m_afEntry[3] = akV[1][0];
+        m_afEntry[4] = akV[1][1];
+        m_afEntry[5] = akV[1][2];
+        m_afEntry[6] = akV[2][0];
+        m_afEntry[7] = akV[2][1];
+        m_afEntry[8] = akV[2][2];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (Real fM00, Real fM11, Real fM22)
+{
+    MakeDiagonal(fM00,fM11,fM22);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle)
+{
+    FromAxisAngle(rkAxis,fAngle);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::Matrix3 (const Vector3&lt;Real&gt;&amp; rkU, const Vector3&lt;Real&gt;&amp; rkV)
+{
+    MakeTensorProduct(rkU,rkV);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::operator const Real* () const
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;::operator Real* ()
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+const Real* Matrix3&lt;Real&gt;::operator[] (int iRow) const
+{
+    return &amp;m_afEntry[3*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real* Matrix3&lt;Real&gt;::operator[] (int iRow)
+{
+    return &amp;m_afEntry[3*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix3&lt;Real&gt;::operator() (int iRow, int iCol) const
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Matrix3&lt;Real&gt;::operator() (int iRow, int iCol)
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix3&lt;Real&gt;::I (int iRow, int iCol)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 3 &amp;&amp; 0 &lt;= iCol &amp;&amp; iCol &lt; 3);
+    return iCol + 3*iRow;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::MakeZero ()
+{
+    memset(m_afEntry,0,9*sizeof(Real));
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::MakeIdentity ()
+{
+    m_afEntry[0] = (Real)1.0;
+    m_afEntry[1] = (Real)0.0;
+    m_afEntry[2] = (Real)0.0;
+    m_afEntry[3] = (Real)0.0;
+    m_afEntry[4] = (Real)1.0;
+    m_afEntry[5] = (Real)0.0;
+    m_afEntry[6] = (Real)0.0;
+    m_afEntry[7] = (Real)0.0;
+    m_afEntry[8] = (Real)1.0;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::MakeDiagonal (Real fM00, Real fM11, Real fM22)
+{
+    m_afEntry[0] = fM00;
+    m_afEntry[1] = (Real)0.0;
+    m_afEntry[2] = (Real)0.0;
+    m_afEntry[3] = (Real)0.0;
+    m_afEntry[4] = fM11;
+    m_afEntry[5] = (Real)0.0;
+    m_afEntry[6] = (Real)0.0;
+    m_afEntry[7] = (Real)0.0;
+    m_afEntry[8] = fM22;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromAxisAngle (const Vector3&lt;Real&gt;&amp; rkAxis,
+    Real fAngle)
+{
+    Real fCos = Math&lt;Real&gt;::Cos(fAngle);
+    Real fSin = Math&lt;Real&gt;::Sin(fAngle);
+    Real fOneMinusCos = ((Real)1.0)-fCos;
+    Real fX2 = rkAxis[0]*rkAxis[0];
+    Real fY2 = rkAxis[1]*rkAxis[1];
+    Real fZ2 = rkAxis[2]*rkAxis[2];
+    Real fXYM = rkAxis[0]*rkAxis[1]*fOneMinusCos;
+    Real fXZM = rkAxis[0]*rkAxis[2]*fOneMinusCos;
+    Real fYZM = rkAxis[1]*rkAxis[2]*fOneMinusCos;
+    Real fXSin = rkAxis[0]*fSin;
+    Real fYSin = rkAxis[1]*fSin;
+    Real fZSin = rkAxis[2]*fSin;
+    
+    m_afEntry[0] = fX2*fOneMinusCos+fCos;
+    m_afEntry[1] = fXYM-fZSin;
+    m_afEntry[2] = fXZM+fYSin;
+    m_afEntry[3] = fXYM+fZSin;
+    m_afEntry[4] = fY2*fOneMinusCos+fCos;
+    m_afEntry[5] = fYZM-fXSin;
+    m_afEntry[6] = fXZM-fYSin;
+    m_afEntry[7] = fYZM+fXSin;
+    m_afEntry[8] = fZ2*fOneMinusCos+fCos;
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::MakeTensorProduct (const Vector3&lt;Real&gt;&amp; rkU,
+    const Vector3&lt;Real&gt;&amp; rkV)
+{
+    m_afEntry[0] = rkU[0]*rkV[0];
+    m_afEntry[1] = rkU[0]*rkV[1];
+    m_afEntry[2] = rkU[0]*rkV[2];
+    m_afEntry[3] = rkU[1]*rkV[0];
+    m_afEntry[4] = rkU[1]*rkV[1];
+    m_afEntry[5] = rkU[1]*rkV[2];
+    m_afEntry[6] = rkU[2]*rkV[0];
+    m_afEntry[7] = rkU[2]*rkV[1];
+    m_afEntry[8] = rkU[2]*rkV[2];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::SetRow (int iRow, const Vector3&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 3);
+    for (int iCol = 0, i = 3*iRow; iCol &lt; 3; iCol++, i++)
+    {
+        m_afEntry[i] = rkV[iCol];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Matrix3&lt;Real&gt;::GetRow (int iRow) const
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 3);
+    Vector3&lt;Real&gt; kV;
+    for (int iCol = 0, i = 3*iRow; iCol &lt; 3; iCol++, i++)
+    {
+        kV[iCol] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::SetColumn (int iCol, const Vector3&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 3);
+    for (int iRow = 0, i = iCol; iRow &lt; 3; iRow++, i += 3)
+    {
+        m_afEntry[i] = rkV[iRow];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Matrix3&lt;Real&gt;::GetColumn (int iCol) const
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 3);
+    Vector3&lt;Real&gt; kV;
+    for (int iRow = 0, i = iCol; iRow &lt; 3; iRow++, i += 3)
+    {
+        kV[iRow] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::GetColumnMajor (Real* afCMajor) const
+{
+    for (int iRow = 0, i = 0; iRow &lt; 3; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            afCMajor[i++] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::operator= (const Matrix3&amp; rkM)
+{
+    size_t uiSize = 9*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix3&lt;Real&gt;::CompareArrays (const Matrix3&amp; rkM) const
+{
+    return memcmp(m_afEntry,rkM.m_afEntry,9*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator== (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator!= (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator&lt;  (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator&lt;= (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator&gt;  (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::operator&gt;= (const Matrix3&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator+ (const Matrix3&amp; rkM) const
+{
+    Matrix3 kSum;
+    for (int i = 0; i &lt; 9; i++)
+    {
+        kSum.m_afEntry[i] = m_afEntry[i] + rkM.m_afEntry[i];
+    }
+    return kSum;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator- (const Matrix3&amp; rkM) const
+{
+    Matrix3 kDiff;
+    for (int i = 0; i &lt; 9; i++)
+    {
+        kDiff.m_afEntry[i] = m_afEntry[i] - rkM.m_afEntry[i];
+    }
+    return kDiff;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator* (const Matrix3&amp; rkM) const
+{
+    Matrix3 kProd;
+    for (int iRow = 0; iRow &lt; 3; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 3; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator* (Real fScalar) const
+{
+    Matrix3 kProd;
+    for (int i = 0; i &lt; 9; i++)
+    {
+        kProd.m_afEntry[i] = fScalar*m_afEntry[i];
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Matrix3 kQuot;
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 9; i++)
+        {
+            kQuot.m_afEntry[i] = fInvScalar*m_afEntry[i];
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 9; i++)
+        {
+            kQuot.m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::operator- () const
+{
+    Matrix3 kNeg;
+    for (int i = 0; i &lt; 9; i++)
+    {
+        kNeg.m_afEntry[i] = -m_afEntry[i];
+    }
+    return kNeg;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::operator+= (const Matrix3&amp; rkM)
+{
+    for (int i = 0; i &lt; 9; i++)
+    {
+        m_afEntry[i] += rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::operator-= (const Matrix3&amp; rkM)
+{
+    for (int i = 0; i &lt; 9; i++)
+    {
+        m_afEntry[i] -= rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::operator*= (Real fScalar)
+{
+    for (int i = 0; i &lt; 9; i++)
+    {
+        m_afEntry[i] *= fScalar;
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::operator/= (Real fScalar)
+{
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 9; i++)
+        {
+            m_afEntry[i] *= fInvScalar;
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 9; i++)
+        {
+            m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Matrix3&lt;Real&gt;::operator* (const Vector3&lt;Real&gt;&amp; rkV) const
+{
+    Vector3&lt;Real&gt; kProd;
+    for (int iRow = 0; iRow &lt; 3; iRow++)
+    {
+        kProd[iRow] = 0.0f;
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            kProd[iRow] += m_afEntry[I(iRow,iCol)]*rkV[iCol];
+        }
+            
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::Transpose () const
+{
+    Matrix3 kTranspose;
+    for (int iRow = 0; iRow &lt; 3; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            kTranspose.m_afEntry[I(iRow,iCol)] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+    return kTranspose;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::TransposeTimes (const Matrix3&amp; rkM) const
+{
+    // P = A^T*B, P[r][c] = sum_m A[m][r]*B[m][c]
+    Matrix3 kProd;
+    for (int iRow = 0; iRow &lt; 3; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 3; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iMid,iRow)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::TimesTranspose (const Matrix3&amp; rkM) const
+{
+    // P = A*B^T, P[r][c] = sum_m A[r][m]*B[c][m]
+    Matrix3 kProd;
+    for (int iRow = 0; iRow &lt; 3; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 3; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 3; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iCol,iMid)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::Inverse () const
+{
+    // Invert a 3x3 using cofactors.  This is faster than using a generic
+    // Gaussian elimination because of the loop overhead of such a method.
+
+    Matrix3 kInverse;
+
+    kInverse[0][0] = m_afEntry[4]*m_afEntry[8] - m_afEntry[5]*m_afEntry[7];
+    kInverse[0][1] = m_afEntry[2]*m_afEntry[7] - m_afEntry[1]*m_afEntry[8];
+    kInverse[0][2] = m_afEntry[1]*m_afEntry[5] - m_afEntry[2]*m_afEntry[4];
+    kInverse[1][0] = m_afEntry[5]*m_afEntry[6] - m_afEntry[3]*m_afEntry[8];
+    kInverse[1][1] = m_afEntry[0]*m_afEntry[8] - m_afEntry[2]*m_afEntry[6];
+    kInverse[1][2] = m_afEntry[2]*m_afEntry[3] - m_afEntry[0]*m_afEntry[5];
+    kInverse[2][0] = m_afEntry[3]*m_afEntry[7] - m_afEntry[4]*m_afEntry[6];
+    kInverse[2][1] = m_afEntry[1]*m_afEntry[6] - m_afEntry[0]*m_afEntry[7];
+    kInverse[2][2] = m_afEntry[0]*m_afEntry[4] - m_afEntry[1]*m_afEntry[3];
+
+    Real fDet = m_afEntry[0]*kInverse[0][0] + m_afEntry[1]*kInverse[1][0]+
+        m_afEntry[2]*kInverse[2][0];
+
+    if (Math&lt;Real&gt;::FAbs(fDet) &lt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        return ZERO;
+    }
+
+    kInverse /= fDet;
+    return kInverse;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::Adjoint () const
+{
+    Matrix3 kAdjoint;
+
+    kAdjoint[0][0] = m_afEntry[4]*m_afEntry[8] - m_afEntry[5]*m_afEntry[7];
+    kAdjoint[0][1] = m_afEntry[2]*m_afEntry[7] - m_afEntry[1]*m_afEntry[8];
+    kAdjoint[0][2] = m_afEntry[1]*m_afEntry[5] - m_afEntry[2]*m_afEntry[4];
+    kAdjoint[1][0] = m_afEntry[5]*m_afEntry[6] - m_afEntry[3]*m_afEntry[8];
+    kAdjoint[1][1] = m_afEntry[0]*m_afEntry[8] - m_afEntry[2]*m_afEntry[6];
+    kAdjoint[1][2] = m_afEntry[2]*m_afEntry[3] - m_afEntry[0]*m_afEntry[5];
+    kAdjoint[2][0] = m_afEntry[3]*m_afEntry[7] - m_afEntry[4]*m_afEntry[6];
+    kAdjoint[2][1] = m_afEntry[1]*m_afEntry[6] - m_afEntry[0]*m_afEntry[7];
+    kAdjoint[2][2] = m_afEntry[0]*m_afEntry[4] - m_afEntry[1]*m_afEntry[3];
+
+    return kAdjoint;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix3&lt;Real&gt;::Determinant () const
+{
+    Real fCo00 = m_afEntry[4]*m_afEntry[8] - m_afEntry[5]*m_afEntry[7];
+    Real fCo10 = m_afEntry[5]*m_afEntry[6] - m_afEntry[3]*m_afEntry[8];
+    Real fCo20 = m_afEntry[3]*m_afEntry[7] - m_afEntry[4]*m_afEntry[6];
+    Real fDet = m_afEntry[0]*fCo00 + m_afEntry[1]*fCo10 + m_afEntry[2]*fCo20;
+    return fDet;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix3&lt;Real&gt;::QForm (const Vector3&lt;Real&gt;&amp; rkU, const Vector3&lt;Real&gt;&amp; rkV)
+    const
+{
+    return rkU.Dot((*this)*rkV);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::TimesDiagonal (const Vector3&lt;Real&gt;&amp; rkDiag) const
+{
+    return Matrix3(
+        m_afEntry[0]*rkDiag[0],m_afEntry[1]*rkDiag[1],m_afEntry[2]*rkDiag[2],
+        m_afEntry[3]*rkDiag[0],m_afEntry[4]*rkDiag[1],m_afEntry[5]*rkDiag[2],
+        m_afEntry[6]*rkDiag[0],m_afEntry[7]*rkDiag[1],m_afEntry[8]*rkDiag[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::DiagonalTimes (const Vector3&lt;Real&gt;&amp; rkDiag) const
+{
+    return Matrix3(
+        rkDiag[0]*m_afEntry[0],rkDiag[0]*m_afEntry[1],rkDiag[0]*m_afEntry[2],
+        rkDiag[1]*m_afEntry[3],rkDiag[1]*m_afEntry[4],rkDiag[1]*m_afEntry[5],
+        rkDiag[2]*m_afEntry[6],rkDiag[2]*m_afEntry[7],rkDiag[2]*m_afEntry[8]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::ToAxisAngle (Vector3&lt;Real&gt;&amp; rkAxis, Real&amp; rfAngle) const
+{
+    // Let (x,y,z) be the unit-length axis and let A be an angle of rotation.
+    // The rotation matrix is R = I + sin(A)*P + (1-cos(A))*P^2 where
+    // I is the identity and
+    //
+    //       +-        -+
+    //   P = |  0 -z +y |
+    //       | +z  0 -x |
+    //       | -y +x  0 |
+    //       +-        -+
+    //
+    // If A &gt; 0, R represents a counterclockwise rotation about the axis in
+    // the sense of looking from the tip of the axis vector towards the
+    // origin.  Some algebra will show that
+    //
+    //   cos(A) = (trace(R)-1)/2  and  R - R^t = 2*sin(A)*P
+    //
+    // In the event that A = pi, R-R^t = 0 which prevents us from extracting
+    // the axis through P.  Instead note that R = I+2*P^2 when A = pi, so
+    // P^2 = (R-I)/2.  The diagonal entries of P^2 are x^2-1, y^2-1, and
+    // z^2-1.  We can solve these for axis (x,y,z).  Because the angle is pi,
+    // it does not matter which sign you choose on the square roots.
+
+    Real fTrace = m_afEntry[0] + m_afEntry[4] + m_afEntry[8];
+    Real fCos = ((Real)0.5)*(fTrace-(Real)1.0);
+    rfAngle = Math&lt;Real&gt;::ACos(fCos);  // in [0,PI]
+
+    if (rfAngle &gt; (Real)0.0)
+    {
+        if (rfAngle &lt; Math&lt;Real&gt;::PI)
+        {
+            rkAxis[0] = m_afEntry[7]-m_afEntry[5];
+            rkAxis[1] = m_afEntry[2]-m_afEntry[6];
+            rkAxis[2] = m_afEntry[3]-m_afEntry[1];
+            rkAxis.Normalize();
+        }
+        else
+        {
+            // angle is PI
+            Real fHalfInverse;
+            if (m_afEntry[0] &gt;= m_afEntry[4])
+            {
+                // r00 &gt;= r11
+                if (m_afEntry[0] &gt;= m_afEntry[8])
+                {
+                    // r00 is maximum diagonal term
+                    rkAxis[0] = ((Real)0.5)*Math&lt;Real&gt;::Sqrt(m_afEntry[0] -
+                        m_afEntry[4] - m_afEntry[8] + (Real)1.0);
+                    fHalfInverse = ((Real)0.5)/rkAxis[0];
+                    rkAxis[1] = fHalfInverse*m_afEntry[1];
+                    rkAxis[2] = fHalfInverse*m_afEntry[2];
+                }
+                else
+                {
+                    // r22 is maximum diagonal term
+                    rkAxis[2] = ((Real)0.5)*Math&lt;Real&gt;::Sqrt(m_afEntry[8] -
+                        m_afEntry[0] - m_afEntry[4] + (Real)1.0);
+                    fHalfInverse = ((Real)0.5)/rkAxis[2];
+                    rkAxis[0] = fHalfInverse*m_afEntry[2];
+                    rkAxis[1] = fHalfInverse*m_afEntry[5];
+                }
+            }
+            else
+            {
+                // r11 &gt; r00
+                if (m_afEntry[4] &gt;= m_afEntry[8])
+                {
+                    // r11 is maximum diagonal term
+                    rkAxis[1] = ((Real)0.5)*Math&lt;Real&gt;::Sqrt(m_afEntry[4] -
+                        m_afEntry[0] - m_afEntry[8] + (Real)1.0);
+                    fHalfInverse  = ((Real)0.5)/rkAxis[1];
+                    rkAxis[0] = fHalfInverse*m_afEntry[1];
+                    rkAxis[2] = fHalfInverse*m_afEntry[5];
+                }
+                else
+                {
+                    // r22 is maximum diagonal term
+                    rkAxis[2] = ((Real)0.5)*Math&lt;Real&gt;::Sqrt(m_afEntry[8] -
+                        m_afEntry[0] - m_afEntry[4] + (Real)1.0);
+                    fHalfInverse = ((Real)0.5)/rkAxis[2];
+                    rkAxis[0] = fHalfInverse*m_afEntry[2];
+                    rkAxis[1] = fHalfInverse*m_afEntry[5];
+                }
+            }
+        }
+    }
+    else
+    {
+        // The angle is 0 and the matrix is the identity.  Any axis will
+        // work, so just use the x-axis.
+        rkAxis[0] = (Real)1.0;
+        rkAxis[1] = (Real)0.0;
+        rkAxis[2] = (Real)0.0;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::Orthonormalize ()
+{
+    // Algorithm uses Gram-Schmidt orthogonalization.  If 'this' matrix is
+    // M = [m0|m1|m2], then orthonormal output matrix is Q = [q0|q1|q2],
+    //
+    //   q0 = m0/|m0|
+    //   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|
+    //   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|
+    //
+    // where |V| indicates length of vector V and A*B indicates dot
+    // product of vectors A and B.
+
+    // compute q0
+    Real fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[0]*m_afEntry[0] +
+        m_afEntry[3]*m_afEntry[3] + m_afEntry[6]*m_afEntry[6]);
+
+    m_afEntry[0] *= fInvLength;
+    m_afEntry[3] *= fInvLength;
+    m_afEntry[6] *= fInvLength;
+
+    // compute q1
+    Real fDot0 = m_afEntry[0]*m_afEntry[1] + m_afEntry[3]*m_afEntry[4] +
+        m_afEntry[6]*m_afEntry[7];
+
+    m_afEntry[1] -= fDot0*m_afEntry[0];
+    m_afEntry[4] -= fDot0*m_afEntry[3];
+    m_afEntry[7] -= fDot0*m_afEntry[6];
+
+    fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[1]*m_afEntry[1] +
+        m_afEntry[4]*m_afEntry[4] + m_afEntry[7]*m_afEntry[7]);
+
+    m_afEntry[1] *= fInvLength;
+    m_afEntry[4] *= fInvLength;
+    m_afEntry[7] *= fInvLength;
+
+    // compute q2
+    Real fDot1 = m_afEntry[1]*m_afEntry[2] + m_afEntry[4]*m_afEntry[5] +
+        m_afEntry[7]*m_afEntry[8];
+
+    fDot0 = m_afEntry[0]*m_afEntry[2] + m_afEntry[3]*m_afEntry[5] +
+        m_afEntry[6]*m_afEntry[8];
+
+    m_afEntry[2] -= fDot0*m_afEntry[0] + fDot1*m_afEntry[1];
+    m_afEntry[5] -= fDot0*m_afEntry[3] + fDot1*m_afEntry[4];
+    m_afEntry[8] -= fDot0*m_afEntry[6] + fDot1*m_afEntry[7];
+
+    fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[2]*m_afEntry[2] +
+        m_afEntry[5]*m_afEntry[5] + m_afEntry[8]*m_afEntry[8]);
+
+    m_afEntry[2] *= fInvLength;
+    m_afEntry[5] *= fInvLength;
+    m_afEntry[8] *= fInvLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::EigenDecomposition (Matrix3&amp; rkRot, Matrix3&amp; rkDiag) const
+{
+    // Factor M = R*D*R^T.  The columns of R are the eigenvectors.  The
+    // diagonal entries of D are the corresponding eigenvalues.
+    Real afDiag[3], afSubd[2];
+    rkRot = *this;
+    bool bReflection = rkRot.Tridiagonalize(afDiag,afSubd);
+    bool bConverged = rkRot.QLAlgorithm(afDiag,afSubd);
+    assert(bConverged);
+
+    // (insertion) sort eigenvalues in increasing order, d0 &lt;= d1 &lt;= d2
+    int i;
+    Real fSave;
+
+    if (afDiag[1] &lt; afDiag[0])
+    {
+        // swap d0 and d1
+        fSave = afDiag[0];
+        afDiag[0] = afDiag[1];
+        afDiag[1] = fSave;
+
+        // swap V0 and V1
+        for (i = 0; i &lt; 3; i++)
+        {
+            fSave = rkRot[i][0];
+            rkRot[i][0] = rkRot[i][1];
+            rkRot[i][1] = fSave;
+        }
+        bReflection = !bReflection;
+    }
+
+    if (afDiag[2] &lt; afDiag[1])
+    {
+        // swap d1 and d2
+        fSave = afDiag[1];
+        afDiag[1] = afDiag[2];
+        afDiag[2] = fSave;
+
+        // swap V1 and V2
+        for (i = 0; i &lt; 3; i++)
+        {
+            fSave = rkRot[i][1];
+            rkRot[i][1] = rkRot[i][2];
+            rkRot[i][2] = fSave;
+        }
+        bReflection = !bReflection;
+    }
+
+    if (afDiag[1] &lt; afDiag[0])
+    {
+        // swap d0 and d1
+        fSave = afDiag[0];
+        afDiag[0] = afDiag[1];
+        afDiag[1] = fSave;
+
+        // swap V0 and V1
+        for (i = 0; i &lt; 3; i++)
+        {
+            fSave = rkRot[i][0];
+            rkRot[i][0] = rkRot[i][1];
+            rkRot[i][1] = fSave;
+        }
+        bReflection = !bReflection;
+    }
+
+    rkDiag.MakeDiagonal(afDiag[0],afDiag[1],afDiag[2]);
+
+    if (bReflection)
+    {
+        // The orthogonal transformation that diagonalizes M is a reflection.
+        // Make the eigenvectors a right--handed system by changing sign on
+        // the last column.
+        rkRot[0][2] = -rkRot[0][2];
+        rkRot[1][2] = -rkRot[1][2];
+        rkRot[2][2] = -rkRot[2][2];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesXYZ (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    *this = kXMat*(kYMat*kZMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesXZY (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    *this = kXMat*(kZMat*kYMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesYXZ (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    *this = kYMat*(kXMat*kZMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesYZX (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    *this = kYMat*(kZMat*kXMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesZXY (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    *this = kZMat*(kXMat*kYMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt;&amp; Matrix3&lt;Real&gt;::FromEulerAnglesZYX (Real fYAngle, Real fPAngle,
+    Real fRAngle)
+{
+    Real fCos, fSin;
+
+    fCos = Math&lt;Real&gt;::Cos(fYAngle);
+    fSin = Math&lt;Real&gt;::Sin(fYAngle);
+    Matrix3 kZMat(
+        fCos,-fSin,(Real)0.0,
+        fSin,fCos,(Real)0.0,
+        (Real)0.0,(Real)0.0,(Real)1.0);
+
+    fCos = Math&lt;Real&gt;::Cos(fPAngle);
+    fSin = Math&lt;Real&gt;::Sin(fPAngle);
+    Matrix3 kYMat(
+        fCos,(Real)0.0,fSin,
+        (Real)0.0,(Real)1.0,(Real)0.0,
+        -fSin,(Real)0.0,fCos);
+
+    fCos = Math&lt;Real&gt;::Cos(fRAngle);
+    fSin = Math&lt;Real&gt;::Sin(fRAngle);
+    Matrix3 kXMat(
+        (Real)1.0,(Real)0.0,(Real)0.0,
+        (Real)0.0,fCos,-fSin,
+        (Real)0.0,fSin,fCos);
+
+    *this = kZMat*(kYMat*kXMat);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesXYZ (Real&amp; rfXAngle, Real&amp; rfYAngle,
+    Real&amp; rfZAngle) const
+{
+    // rot =  cy*cz          -cy*sz           sy
+    //        cz*sx*sy+cx*sz  cx*cz-sx*sy*sz -cy*sx
+    //       -cx*cz*sy+sx*sz  cz*sx+cx*sy*sz  cx*cy
+
+    if (m_afEntry[2] &lt; (Real)1.0)
+    {
+        if (m_afEntry[2] &gt; -(Real)1.0)
+        {
+            rfXAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[5],m_afEntry[8]);
+            rfYAngle = (Real)asin((double)m_afEntry[2]);
+            rfZAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[1],m_afEntry[0]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  XA - ZA = -atan2(r10,r11)
+            rfXAngle = -Math&lt;Real&gt;::ATan2(m_afEntry[3],m_afEntry[4]);
+            rfYAngle = -Math&lt;Real&gt;::HALF_PI;
+            rfZAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  XAngle + ZAngle = atan2(r10,r11)
+        rfXAngle = Math&lt;Real&gt;::ATan2(m_afEntry[3],m_afEntry[4]);
+        rfYAngle = Math&lt;Real&gt;::HALF_PI;
+        rfZAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesXZY (Real&amp; rfXAngle, Real&amp; rfZAngle,
+    Real&amp; rfYAngle) const
+{
+    // rot =  cy*cz          -sz              cz*sy
+    //        sx*sy+cx*cy*sz  cx*cz          -cy*sx+cx*sy*sz
+    //       -cx*sy+cy*sx*sz  cz*sx           cx*cy+sx*sy*sz
+
+    if (m_afEntry[1] &lt; (Real)1.0)
+    {
+        if (m_afEntry[1] &gt; -(Real)1.0)
+        {
+            rfXAngle = Math&lt;Real&gt;::ATan2(m_afEntry[7],m_afEntry[4]);
+            rfZAngle = (Real)asin(-(double)m_afEntry[1]);
+            rfYAngle = Math&lt;Real&gt;::ATan2(m_afEntry[2],m_afEntry[0]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  XA - YA = atan2(r20,r22)
+            rfXAngle = Math&lt;Real&gt;::ATan2(m_afEntry[6],m_afEntry[8]);
+            rfZAngle = Math&lt;Real&gt;::HALF_PI;
+            rfYAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  XA + YA = atan2(-r20,r22)
+        rfXAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[6],m_afEntry[8]);
+        rfZAngle = -Math&lt;Real&gt;::HALF_PI;
+        rfYAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesYXZ (Real&amp; rfYAngle, Real&amp; rfXAngle,
+    Real&amp; rfZAngle) const
+{
+    // rot =  cy*cz+sx*sy*sz  cz*sx*sy-cy*sz  cx*sy
+    //        cx*sz           cx*cz          -sx
+    //       -cz*sy+cy*sx*sz  cy*cz*sx+sy*sz  cx*cy
+
+    if (m_afEntry[5] &lt; (Real)1.0)
+    {
+        if (m_afEntry[5] &gt; -(Real)1.0)
+        {
+            rfYAngle = Math&lt;Real&gt;::ATan2(m_afEntry[2],m_afEntry[8]);
+            rfXAngle = (Real)asin(-(double)m_afEntry[5]);
+            rfZAngle = Math&lt;Real&gt;::ATan2(m_afEntry[3],m_afEntry[4]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  YA - ZA = atan2(r01,r00)
+            rfYAngle = Math&lt;Real&gt;::ATan2(m_afEntry[1],m_afEntry[0]);
+            rfXAngle = Math&lt;Real&gt;::HALF_PI;
+            rfZAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  YA + ZA = atan2(-r01,r00)
+        rfYAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[1],m_afEntry[0]);
+        rfXAngle = -Math&lt;Real&gt;::HALF_PI;
+        rfZAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesYZX (Real&amp; rfYAngle, Real&amp; rfZAngle,
+    Real&amp; rfXAngle) const
+{
+    // rot =  cy*cz           sx*sy-cx*cy*sz  cx*sy+cy*sx*sz
+    //        sz              cx*cz          -cz*sx
+    //       -cz*sy           cy*sx+cx*sy*sz  cx*cy-sx*sy*sz
+
+    if (m_afEntry[3] &lt; (Real)1.0)
+    {
+        if (m_afEntry[3] &gt; -(Real)1.0)
+        {
+            rfYAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[6],m_afEntry[0]);
+            rfZAngle = (Real)asin((double)m_afEntry[3]);
+            rfXAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[5],m_afEntry[4]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  YA - XA = -atan2(r21,r22);
+            rfYAngle = -Math&lt;Real&gt;::ATan2(m_afEntry[7],m_afEntry[8]);
+            rfZAngle = -Math&lt;Real&gt;::HALF_PI;
+            rfXAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  YA + XA = atan2(r21,r22)
+        rfYAngle = Math&lt;Real&gt;::ATan2(m_afEntry[7],m_afEntry[8]);
+        rfZAngle = Math&lt;Real&gt;::HALF_PI;
+        rfXAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesZXY (Real&amp; rfZAngle, Real&amp; rfXAngle,
+    Real&amp; rfYAngle) const
+{
+    // rot =  cy*cz-sx*sy*sz -cx*sz           cz*sy+cy*sx*sz
+    //        cz*sx*sy+cy*sz  cx*cz          -cy*cz*sx+sy*sz
+    //       -cx*sy           sx              cx*cy
+
+    if (m_afEntry[7] &lt; (Real)1.0)
+    {
+        if (m_afEntry[7] &gt; -(Real)1.0)
+        {
+            rfZAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[1],m_afEntry[4]);
+            rfXAngle = (Real)asin((double)m_afEntry[7]);
+            rfYAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[6],m_afEntry[8]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  ZA - YA = -atan(r02,r00)
+            rfZAngle = -Math&lt;Real&gt;::ATan2(m_afEntry[2],m_afEntry[0]);
+            rfXAngle = -Math&lt;Real&gt;::HALF_PI;
+            rfYAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  ZA + YA = atan2(r02,r00)
+        rfZAngle = Math&lt;Real&gt;::ATan2(m_afEntry[2],m_afEntry[0]);
+        rfXAngle = Math&lt;Real&gt;::HALF_PI;
+        rfYAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::ToEulerAnglesZYX (Real&amp; rfZAngle, Real&amp; rfYAngle,
+    Real&amp; rfXAngle) const
+{
+    // rot =  cy*cz           cz*sx*sy-cx*sz  cx*cz*sy+sx*sz
+    //        cy*sz           cx*cz+sx*sy*sz -cz*sx+cx*sy*sz
+    //       -sy              cy*sx           cx*cy
+
+    if (m_afEntry[6] &lt; (Real)1.0)
+    {
+        if (m_afEntry[6] &gt; -(Real)1.0)
+        {
+            rfZAngle = Math&lt;Real&gt;::ATan2(m_afEntry[3],m_afEntry[0]);
+            rfYAngle = (Real)asin(-(double)m_afEntry[6]);
+            rfXAngle = Math&lt;Real&gt;::ATan2(m_afEntry[7],m_afEntry[8]);
+            return true;
+        }
+        else
+        {
+            // WARNING.  Not unique.  ZA - XA = -atan2(r01,r02)
+            rfZAngle = -Math&lt;Real&gt;::ATan2(m_afEntry[1],m_afEntry[2]);
+            rfYAngle = Math&lt;Real&gt;::HALF_PI;
+            rfXAngle = (Real)0.0;
+            return false;
+        }
+    }
+    else
+    {
+        // WARNING.  Not unique.  ZA + XA = atan2(-r01,-r02)
+        rfZAngle = Math&lt;Real&gt;::ATan2(-m_afEntry[1],-m_afEntry[2]);
+        rfYAngle = -Math&lt;Real&gt;::HALF_PI;
+        rfXAngle = (Real)0.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; Matrix3&lt;Real&gt;::Slerp (Real fT, const Matrix3&amp; rkR0,
+    const Matrix3&amp; rkR1)
+{
+    Vector3&lt;Real&gt; kAxis;
+    Real fAngle;
+    Matrix3 kProd = rkR0.TransposeTimes(rkR1);
+    kProd.ToAxisAngle(kAxis,fAngle);
+    return Matrix3(kAxis,fT*fAngle);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::Tridiagonalize (Real afDiag[3], Real afSubd[2])
+{
+    // Householder reduction T = Q^t M Q
+    //   Input:   
+    //     mat, symmetric 3x3 matrix M
+    //   Output:  
+    //     mat, orthogonal matrix Q (a reflection)
+    //     diag, diagonal entries of T
+    //     subd, subdiagonal entries of T (T is symmetric)
+
+    Real fM00 = m_afEntry[0];
+    Real fM01 = m_afEntry[1];
+    Real fM02 = m_afEntry[2];
+    Real fM11 = m_afEntry[4];
+    Real fM12 = m_afEntry[5];
+    Real fM22 = m_afEntry[8];
+
+    afDiag[0] = fM00;
+    if (Math&lt;Real&gt;::FAbs(fM02) &gt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        afSubd[0] = Math&lt;Real&gt;::Sqrt(fM01*fM01+fM02*fM02);
+        Real fInvLength = ((Real)1.0)/afSubd[0];
+        fM01 *= fInvLength;
+        fM02 *= fInvLength;
+        Real fTmp = ((Real)2.0)*fM01*fM12+fM02*(fM22-fM11);
+        afDiag[1] = fM11+fM02*fTmp;
+        afDiag[2] = fM22-fM02*fTmp;
+        afSubd[1] = fM12-fM01*fTmp;
+
+        m_afEntry[0] = (Real)1.0;
+        m_afEntry[1] = (Real)0.0;
+        m_afEntry[2] = (Real)0.0;
+        m_afEntry[3] = (Real)0.0;
+        m_afEntry[4] = fM01;
+        m_afEntry[5] = fM02;
+        m_afEntry[6] = (Real)0.0;
+        m_afEntry[7] = fM02;
+        m_afEntry[8] = -fM01;
+        return true;
+    }
+    else
+    {
+        afDiag[1] = fM11;
+        afDiag[2] = fM22;
+        afSubd[0] = fM01;
+        afSubd[1] = fM12;
+
+        m_afEntry[0] = (Real)1.0;
+        m_afEntry[1] = (Real)0.0;
+        m_afEntry[2] = (Real)0.0;
+        m_afEntry[3] = (Real)0.0;
+        m_afEntry[4] = (Real)1.0;
+        m_afEntry[5] = (Real)0.0;
+        m_afEntry[6] = (Real)0.0;
+        m_afEntry[7] = (Real)0.0;
+        m_afEntry[8] = (Real)1.0;
+        return false;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix3&lt;Real&gt;::QLAlgorithm (Real afDiag[3], Real afSubd[2])
+{
+    // This is an implementation of the symmetric QR algorithm from the book
+    // &quot;Matrix Computations&quot; by Gene H. Golub and Charles F. Van Loan, second
+    // edition.  The algorithm is 8.2.3.  The implementation has a slight
+    // variation to actually make it a QL algorithm, and it traps the case
+    // when either of the subdiagonal terms s0 or s1 is zero and reduces the
+    // 2-by-2 subblock directly.
+
+    const int iMax = 32;
+    for (int i = 0; i &lt; iMax; i++)
+    {
+        Real fSum, fDiff, fDiscr, fEValue0, fEValue1, fCos, fSin, fTmp;
+        int iRow;
+
+        fSum = Math&lt;Real&gt;::FAbs(afDiag[0]) + Math&lt;Real&gt;::FAbs(afDiag[1]);
+        if (Math&lt;Real&gt;::FAbs(afSubd[0]) + fSum == fSum)
+        {
+            // The matrix is effectively
+            //       +-        -+
+            //   M = | d0  0  0 |
+            //       | 0  d1 s1 |
+            //       | 0  s1 d2 |
+            //       +-        -+
+
+            // Compute the eigenvalues as roots of a quadratic equation.
+            fSum = afDiag[1] + afDiag[2];
+            fDiff = afDiag[1] - afDiag[2];
+            fDiscr = Math&lt;Real&gt;::Sqrt(fDiff*fDiff +
+                ((Real)4.0)*afSubd[1]*afSubd[1]);
+            fEValue0 = ((Real)0.5)*(fSum - fDiscr);
+            fEValue1 = ((Real)0.5)*(fSum + fDiscr);
+
+            // Compute the Givens rotation.
+            if (fDiff &gt;= (Real)0.0)
+            {
+                fCos = afSubd[1];
+                fSin = afDiag[1] - fEValue0;
+            }
+            else
+            {
+                fCos = afDiag[2] - fEValue0;
+                fSin = afSubd[1];
+            }
+            fTmp = Math&lt;Real&gt;::InvSqrt(fCos*fCos + fSin*fSin);
+            fCos *= fTmp;
+            fSin *= fTmp;
+
+            // Postmultiply the current orthogonal matrix with the Givens
+            // rotation.
+            for (iRow = 0; iRow &lt; 3; iRow++)
+            {
+                fTmp = m_afEntry[I(iRow,2)];
+                m_afEntry[I(iRow,2)] = fSin*m_afEntry[I(iRow,1)] + fCos*fTmp;
+                m_afEntry[I(iRow,1)] = fCos*m_afEntry[I(iRow,1)] - fSin*fTmp;
+            }
+
+            // Update the tridiagonal matrix.
+            afDiag[1] = fEValue0;
+            afDiag[2] = fEValue1;
+            afSubd[0] = (Real)0.0;
+            afSubd[1] = (Real)0.0;
+            return true;
+        }
+
+        fSum = Math&lt;Real&gt;::FAbs(afDiag[1]) + Math&lt;Real&gt;::FAbs(afDiag[2]);
+        if (Math&lt;Real&gt;::FAbs(afSubd[1]) + fSum == fSum)
+        {
+            // The matrix is effectively
+            //       +-         -+
+            //   M = | d0  s0  0 |
+            //       | s0  d1  0 |
+            //       | 0   0  d2 |
+            //       +-         -+
+
+            // Compute the eigenvalues as roots of a quadratic equation.
+            fSum = afDiag[0] + afDiag[1];
+            fDiff = afDiag[0] - afDiag[1];
+            fDiscr = Math&lt;Real&gt;::Sqrt(fDiff*fDiff +
+                ((Real)4.0)*afSubd[0]*afSubd[0]);
+            fEValue0 = ((Real)0.5)*(fSum - fDiscr);
+            fEValue1 = ((Real)0.5)*(fSum + fDiscr);
+
+            // Compute the Givens rotation.
+            if (fDiff &gt;= (Real)0.0)
+            {
+                fCos = afSubd[0];
+                fSin = afDiag[0] - fEValue0;
+            }
+            else
+            {
+                fCos = afDiag[1] - fEValue0;
+                fSin = afSubd[0];
+            }
+            fTmp = Math&lt;Real&gt;::InvSqrt(fCos*fCos + fSin*fSin);
+            fCos *= fTmp;
+            fSin *= fTmp;
+
+            // Postmultiply the current orthogonal matrix with the Givens
+            // rotation.
+            for (iRow = 0; iRow &lt; 3; iRow++)
+            {
+                fTmp = m_afEntry[I(iRow,1)];
+                m_afEntry[I(iRow,1)] = fSin*m_afEntry[I(iRow,0)] + fCos*fTmp;
+                m_afEntry[I(iRow,0)] = fCos*m_afEntry[I(iRow,0)] - fSin*fTmp;
+            }
+
+            // Update the tridiagonal matrix.
+            afDiag[0] = fEValue0;
+            afDiag[1] = fEValue1;
+            afSubd[0] = (Real)0.0;
+            afSubd[1] = (Real)0.0;
+            return true;
+        }
+
+        // The matrix is
+        //       +-        -+
+        //   M = | d0 s0  0 |
+        //       | s0 d1 s1 |
+        //       | 0  s1 d2 |
+        //       +-        -+
+
+        // Set up the parameters for the first pass of the QL step.  The
+        // value for A is the difference between diagonal term D[2] and the
+        // implicit shift suggested by Wilkinson.
+        Real fRatio = (afDiag[1]-afDiag[0])/(((Real)2.0f)*afSubd[0]);
+        Real fRoot = Math&lt;Real&gt;::Sqrt((Real)1.0 + fRatio*fRatio);
+        Real fB = afSubd[1];
+        Real fA = afDiag[2] - afDiag[0];
+        if (fRatio &gt;= (Real)0.0)
+        {
+            fA += afSubd[0]/(fRatio + fRoot);
+        }
+        else
+        {
+            fA += afSubd[0]/(fRatio - fRoot);
+        }
+
+        // Compute the Givens rotation for the first pass.
+        if (Math&lt;Real&gt;::FAbs(fB) &gt;= Math&lt;Real&gt;::FAbs(fA))
+        {
+            fRatio = fA/fB;
+            fSin = Math&lt;Real&gt;::InvSqrt((Real)1.0 + fRatio*fRatio);
+            fCos = fRatio*fSin;
+        }
+        else
+        {
+            fRatio = fB/fA;
+            fCos = Math&lt;Real&gt;::InvSqrt((Real)1.0 + fRatio*fRatio);
+            fSin = fRatio*fCos;
+        }
+
+        // Postmultiply the current orthogonal matrix with the Givens
+        // rotation.
+        for (iRow = 0; iRow &lt; 3; iRow++)
+        {
+            fTmp = m_afEntry[I(iRow,2)];
+            m_afEntry[I(iRow,2)] = fSin*m_afEntry[I(iRow,1)]+fCos*fTmp;
+            m_afEntry[I(iRow,1)] = fCos*m_afEntry[I(iRow,1)]-fSin*fTmp;
+        }
+
+        // Set up the parameters for the second pass of the QL step.  The
+        // values tmp0 and tmp1 are required to fully update the tridiagonal
+        // matrix at the end of the second pass.
+        Real fTmp0 = (afDiag[1] - afDiag[2])*fSin +
+            ((Real)2.0)*afSubd[1]*fCos;
+        Real fTmp1 = fCos*afSubd[0];
+        fB = fSin*afSubd[0];
+        fA = fCos*fTmp0 - afSubd[1];
+        fTmp0 *= fSin;
+
+        // Compute the Givens rotation for the second pass.  The subdiagonal
+        // term S[1] in the tridiagonal matrix is updated at this time.
+        if (Math&lt;Real&gt;::FAbs(fB) &gt;= Math&lt;Real&gt;::FAbs(fA))
+        {
+            fRatio = fA/fB;
+            fRoot = Math&lt;Real&gt;::Sqrt((Real)1.0 + fRatio*fRatio);
+            afSubd[1] = fB*fRoot;
+            fSin = ((Real)1.0)/fRoot;
+            fCos = fRatio*fSin;
+        }
+        else
+        {
+            fRatio = fB/fA;
+            fRoot = Math&lt;Real&gt;::Sqrt((Real)1.0 + fRatio*fRatio);
+            afSubd[1] = fA*fRoot;
+            fCos = ((Real)1.0)/fRoot;
+            fSin = fRatio*fCos;
+        }
+
+        // Postmultiply the current orthogonal matrix with the Givens
+        // rotation.
+        for (iRow = 0; iRow &lt; 3; iRow++)
+        {
+            fTmp = m_afEntry[I(iRow,1)];
+            m_afEntry[I(iRow,1)] = fSin*m_afEntry[I(iRow,0)]+fCos*fTmp;
+            m_afEntry[I(iRow,0)] = fCos*m_afEntry[I(iRow,0)]-fSin*fTmp;
+        }
+
+        // Complete the update of the tridiagonal matrix.
+        Real fTmp2 = afDiag[1] - fTmp0;
+        afDiag[2] += fTmp0;
+        fTmp0 = (afDiag[0] - fTmp2)*fSin + ((Real)2.0)*fTmp1*fCos;
+        afSubd[0] = fCos*fTmp0 - fTmp1;
+        fTmp0 *= fSin;
+        afDiag[1] = fTmp2 + fTmp0;
+        afDiag[0] -= fTmp0;
+    }
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::Bidiagonalize (Matrix3&amp; rkA, Matrix3&amp; rkL, Matrix3&amp; rkR)
+{
+    Real afV[3], afW[3];
+    Real fLength, fSign, fT1, fInvT1, fT2;
+    bool bIdentity;
+
+    // map first column to (*,0,0)
+    fLength = Math&lt;Real&gt;::Sqrt(rkA[0][0]*rkA[0][0] + rkA[1][0]*rkA[1][0] +
+        rkA[2][0]*rkA[2][0]);
+    if (fLength &gt; (Real)0.0)
+    {
+        fSign = (rkA[0][0] &gt; (Real)0.0 ? (Real)1.0 : -(Real)1.0);
+        fT1 = rkA[0][0] + fSign*fLength;
+        fInvT1 = ((Real)1.0)/fT1;
+        afV[1] = rkA[1][0]*fInvT1;
+        afV[2] = rkA[2][0]*fInvT1;
+
+        fT2 = -((Real)2.0)/(((Real)1.0)+afV[1]*afV[1]+afV[2]*afV[2]);
+        afW[0] = fT2*(rkA[0][0]+rkA[1][0]*afV[1]+rkA[2][0]*afV[2]);
+        afW[1] = fT2*(rkA[0][1]+rkA[1][1]*afV[1]+rkA[2][1]*afV[2]);
+        afW[2] = fT2*(rkA[0][2]+rkA[1][2]*afV[1]+rkA[2][2]*afV[2]);
+        rkA[0][0] += afW[0];
+        rkA[0][1] += afW[1];
+        rkA[0][2] += afW[2];
+        rkA[1][1] += afV[1]*afW[1];
+        rkA[1][2] += afV[1]*afW[2];
+        rkA[2][1] += afV[2]*afW[1];
+        rkA[2][2] += afV[2]*afW[2];
+
+        rkL[0][0] = ((Real)1.0)+fT2;
+        rkL[0][1] = fT2*afV[1];
+        rkL[1][0] = rkL[0][1];
+        rkL[0][2] = fT2*afV[2];
+        rkL[2][0] = rkL[0][2];
+        rkL[1][1] = ((Real)1.0)+fT2*afV[1]*afV[1];
+        rkL[1][2] = fT2*afV[1]*afV[2];
+        rkL[2][1] = rkL[1][2];
+        rkL[2][2] = ((Real)1.0)+fT2*afV[2]*afV[2];
+        bIdentity = false;
+    }
+    else
+    {
+        rkL = Matrix3::IDENTITY;
+        bIdentity = true;
+    }
+
+    // map first row to (*,*,0)
+    fLength = Math&lt;Real&gt;::Sqrt(rkA[0][1]*rkA[0][1]+rkA[0][2]*rkA[0][2]);
+    if (fLength &gt; (Real)0.0)
+    {
+        fSign = (rkA[0][1] &gt; (Real)0.0 ? (Real)1.0 : -(Real)1.0);
+        fT1 = rkA[0][1] + fSign*fLength;
+        afV[2] = rkA[0][2]/fT1;
+
+        fT2 = -((Real)2.0)/(((Real)1.0)+afV[2]*afV[2]);
+        afW[0] = fT2*(rkA[0][1]+rkA[0][2]*afV[2]);
+        afW[1] = fT2*(rkA[1][1]+rkA[1][2]*afV[2]);
+        afW[2] = fT2*(rkA[2][1]+rkA[2][2]*afV[2]);
+        rkA[0][1] += afW[0];
+        rkA[1][1] += afW[1];
+        rkA[1][2] += afW[1]*afV[2];
+        rkA[2][1] += afW[2];
+        rkA[2][2] += afW[2]*afV[2];
+        
+        rkR[0][0] = (Real)1.0;
+        rkR[0][1] = (Real)0.0;
+        rkR[1][0] = (Real)0.0;
+        rkR[0][2] = (Real)0.0;
+        rkR[2][0] = (Real)0.0;
+        rkR[1][1] = ((Real)1.0)+fT2;
+        rkR[1][2] = fT2*afV[2];
+        rkR[2][1] = rkR[1][2];
+        rkR[2][2] = ((Real)1.0)+fT2*afV[2]*afV[2];
+    }
+    else
+    {
+        rkR = Matrix3::IDENTITY;
+    }
+
+    // map second column to (*,*,0)
+    fLength = Math&lt;Real&gt;::Sqrt(rkA[1][1]*rkA[1][1]+rkA[2][1]*rkA[2][1]);
+    if (fLength &gt; (Real)0.0)
+    {
+        fSign = (rkA[1][1] &gt; (Real)0.0 ? (Real)1.0 : -(Real)1.0);
+        fT1 = rkA[1][1] + fSign*fLength;
+        afV[2] = rkA[2][1]/fT1;
+
+        fT2 = -((Real)2.0)/(((Real)1.0)+afV[2]*afV[2]);
+        afW[1] = fT2*(rkA[1][1]+rkA[2][1]*afV[2]);
+        afW[2] = fT2*(rkA[1][2]+rkA[2][2]*afV[2]);
+        rkA[1][1] += afW[1];
+        rkA[1][2] += afW[2];
+        rkA[2][2] += afV[2]*afW[2];
+
+        Real fA = ((Real)1.0)+fT2;
+        Real fB = fT2*afV[2];
+        Real fC = ((Real)1.0)+fB*afV[2];
+
+        if (bIdentity)
+        {
+            rkL[0][0] = (Real)1.0;
+            rkL[0][1] = (Real)0.0;
+            rkL[1][0] = (Real)0.0;
+            rkL[0][2] = (Real)0.0;
+            rkL[2][0] = (Real)0.0;
+            rkL[1][1] = fA;
+            rkL[1][2] = fB;
+            rkL[2][1] = fB;
+            rkL[2][2] = fC;
+        }
+        else
+        {
+            for (int iRow = 0; iRow &lt; 3; iRow++)
+            {
+                Real fTmp0 = rkL[iRow][1];
+                Real fTmp1 = rkL[iRow][2];
+                rkL[iRow][1] = fA*fTmp0+fB*fTmp1;
+                rkL[iRow][2] = fB*fTmp0+fC*fTmp1;
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::GolubKahanStep (Matrix3&amp; rkA, Matrix3&amp; rkL, Matrix3&amp; rkR)
+{
+    Real fT11 = rkA[0][1]*rkA[0][1]+rkA[1][1]*rkA[1][1];
+    Real fT22 = rkA[1][2]*rkA[1][2]+rkA[2][2]*rkA[2][2];
+    Real fT12 = rkA[1][1]*rkA[1][2];
+    Real fTrace = fT11+fT22;
+    Real fDiff = fT11-fT22;
+    Real fDiscr = Math&lt;Real&gt;::Sqrt(fDiff*fDiff+((Real)4.0)*fT12*fT12);
+    Real fRoot1 = ((Real)0.5)*(fTrace+fDiscr);
+    Real fRoot2 = ((Real)0.5)*(fTrace-fDiscr);
+
+    // adjust right
+    Real fY = rkA[0][0] - (Math&lt;Real&gt;::FAbs(fRoot1-fT22) &lt;=
+        Math&lt;Real&gt;::FAbs(fRoot2-fT22) ? fRoot1 : fRoot2);
+    Real fZ = rkA[0][1];
+    Real fInvLength = Math&lt;Real&gt;::InvSqrt(fY*fY+fZ*fZ);
+    Real fSin = fZ*fInvLength;
+    Real fCos = -fY*fInvLength;
+
+    Real fTmp0 = rkA[0][0];
+    Real fTmp1 = rkA[0][1];
+    rkA[0][0] = fCos*fTmp0-fSin*fTmp1;
+    rkA[0][1] = fSin*fTmp0+fCos*fTmp1;
+    rkA[1][0] = -fSin*rkA[1][1];
+    rkA[1][1] *= fCos;
+
+    int iRow;
+    for (iRow = 0; iRow &lt; 3; iRow++)
+    {
+        fTmp0 = rkR[0][iRow];
+        fTmp1 = rkR[1][iRow];
+        rkR[0][iRow] = fCos*fTmp0-fSin*fTmp1;
+        rkR[1][iRow] = fSin*fTmp0+fCos*fTmp1;
+    }
+
+    // adjust left
+    fY = rkA[0][0];
+    fZ = rkA[1][0];
+    fInvLength = Math&lt;Real&gt;::InvSqrt(fY*fY+fZ*fZ);
+    fSin = fZ*fInvLength;
+    fCos = -fY*fInvLength;
+
+    rkA[0][0] = fCos*rkA[0][0]-fSin*rkA[1][0];
+    fTmp0 = rkA[0][1];
+    fTmp1 = rkA[1][1];
+    rkA[0][1] = fCos*fTmp0-fSin*fTmp1;
+    rkA[1][1] = fSin*fTmp0+fCos*fTmp1;
+    rkA[0][2] = -fSin*rkA[1][2];
+    rkA[1][2] *= fCos;
+
+    int iCol;
+    for (iCol = 0; iCol &lt; 3; iCol++)
+    {
+        fTmp0 = rkL[iCol][0];
+        fTmp1 = rkL[iCol][1];
+        rkL[iCol][0] = fCos*fTmp0-fSin*fTmp1;
+        rkL[iCol][1] = fSin*fTmp0+fCos*fTmp1;
+    }
+
+    // adjust right
+    fY = rkA[0][1];
+    fZ = rkA[0][2];
+    fInvLength = Math&lt;Real&gt;::InvSqrt(fY*fY+fZ*fZ);
+    fSin = fZ*fInvLength;
+    fCos = -fY*fInvLength;
+
+    rkA[0][1] = fCos*rkA[0][1]-fSin*rkA[0][2];
+    fTmp0 = rkA[1][1];
+    fTmp1 = rkA[1][2];
+    rkA[1][1] = fCos*fTmp0-fSin*fTmp1;
+    rkA[1][2] = fSin*fTmp0+fCos*fTmp1;
+    rkA[2][1] = -fSin*rkA[2][2];
+    rkA[2][2] *= fCos;
+
+    for (iRow = 0; iRow &lt; 3; iRow++)
+    {
+        fTmp0 = rkR[1][iRow];
+        fTmp1 = rkR[2][iRow];
+        rkR[1][iRow] = fCos*fTmp0-fSin*fTmp1;
+        rkR[2][iRow] = fSin*fTmp0+fCos*fTmp1;
+    }
+
+    // adjust left
+    fY = rkA[1][1];
+    fZ = rkA[2][1];
+    fInvLength = Math&lt;Real&gt;::InvSqrt(fY*fY+fZ*fZ);
+    fSin = fZ*fInvLength;
+    fCos = -fY*fInvLength;
+
+    rkA[1][1] = fCos*rkA[1][1]-fSin*rkA[2][1];
+    fTmp0 = rkA[1][2];
+    fTmp1 = rkA[2][2];
+    rkA[1][2] = fCos*fTmp0-fSin*fTmp1;
+    rkA[2][2] = fSin*fTmp0+fCos*fTmp1;
+
+    for (iCol = 0; iCol &lt; 3; iCol++)
+    {
+        fTmp0 = rkL[iCol][1];
+        fTmp1 = rkL[iCol][2];
+        rkL[iCol][1] = fCos*fTmp0-fSin*fTmp1;
+        rkL[iCol][2] = fSin*fTmp0+fCos*fTmp1;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::SingularValueDecomposition (Matrix3&amp; rkL, Matrix3&amp; rkS,
+    Matrix3&amp; rkR) const
+{
+    int iRow, iCol;
+
+    Matrix3 kA = *this;
+    Bidiagonalize(kA,rkL,rkR);
+    rkS.MakeZero();
+
+    const int iMax = 32;
+    const Real fEpsilon = (Real)1e-04;
+    for (int i = 0; i &lt; iMax; i++)
+    {
+        Real fTmp, fTmp0, fTmp1;
+        Real fSin0, fCos0, fTan0;
+        Real fSin1, fCos1, fTan1;
+
+        bool bTest1 = (Math&lt;Real&gt;::FAbs(kA[0][1]) &lt;=
+            fEpsilon*(Math&lt;Real&gt;::FAbs(kA[0][0]) +
+            Math&lt;Real&gt;::FAbs(kA[1][1])));
+        bool bTest2 = (Math&lt;Real&gt;::FAbs(kA[1][2]) &lt;=
+            fEpsilon*(Math&lt;Real&gt;::FAbs(kA[1][1]) +
+            Math&lt;Real&gt;::FAbs(kA[2][2])));
+        if (bTest1)
+        {
+            if (bTest2)
+            {
+                rkS[0][0] = kA[0][0];
+                rkS[1][1] = kA[1][1];
+                rkS[2][2] = kA[2][2];
+                break;
+            }
+            else
+            {
+                // 2x2 closed form factorization
+                fTmp = (kA[1][1]*kA[1][1] - kA[2][2]*kA[2][2] +
+                    kA[1][2]*kA[1][2])/(kA[1][2]*kA[2][2]);
+                fTan0 = ((Real)0.5)*(fTmp + Math&lt;Real&gt;::Sqrt(fTmp*fTmp +
+                    ((Real)4.0)));
+                fCos0 = Math&lt;Real&gt;::InvSqrt(((Real)1.0)+fTan0*fTan0);
+                fSin0 = fTan0*fCos0;
+
+                for (iCol = 0; iCol &lt; 3; iCol++)
+                {
+                    fTmp0 = rkL[iCol][1];
+                    fTmp1 = rkL[iCol][2];
+                    rkL[iCol][1] = fCos0*fTmp0-fSin0*fTmp1;
+                    rkL[iCol][2] = fSin0*fTmp0+fCos0*fTmp1;
+                }
+                
+                fTan1 = (kA[1][2]-kA[2][2]*fTan0)/kA[1][1];
+                fCos1 = Math&lt;Real&gt;::InvSqrt(((Real)1.0)+fTan1*fTan1);
+                fSin1 = -fTan1*fCos1;
+
+                for (iRow = 0; iRow &lt; 3; iRow++)
+                {
+                    fTmp0 = rkR[1][iRow];
+                    fTmp1 = rkR[2][iRow];
+                    rkR[1][iRow] = fCos1*fTmp0-fSin1*fTmp1;
+                    rkR[2][iRow] = fSin1*fTmp0+fCos1*fTmp1;
+                }
+
+                rkS[0][0] = kA[0][0];
+                rkS[1][1] = fCos0*fCos1*kA[1][1] -
+                    fSin1*(fCos0*kA[1][2]-fSin0*kA[2][2]);
+                rkS[2][2] = fSin0*fSin1*kA[1][1] +
+                    fCos1*(fSin0*kA[1][2]+fCos0*kA[2][2]);
+                break;
+            }
+        }
+        else 
+        {
+            if (bTest2)
+            {
+                // 2x2 closed form factorization 
+                fTmp = (kA[0][0]*kA[0][0] + kA[1][1]*kA[1][1] -
+                    kA[0][1]*kA[0][1])/(kA[0][1]*kA[1][1]);
+                fTan0 = ((Real)0.5)*(-fTmp + Math&lt;Real&gt;::Sqrt(fTmp*fTmp +
+                    ((Real)4.0)));
+                fCos0 = Math&lt;Real&gt;::InvSqrt(((Real)1.0)+fTan0*fTan0);
+                fSin0 = fTan0*fCos0;
+
+                for (iCol = 0; iCol &lt; 3; iCol++)
+                {
+                    fTmp0 = rkL[iCol][0];
+                    fTmp1 = rkL[iCol][1];
+                    rkL[iCol][0] = fCos0*fTmp0-fSin0*fTmp1;
+                    rkL[iCol][1] = fSin0*fTmp0+fCos0*fTmp1;
+                }
+                
+                fTan1 = (kA[0][1]-kA[1][1]*fTan0)/kA[0][0];
+                fCos1 = Math&lt;Real&gt;::InvSqrt(((Real)1.0)+fTan1*fTan1);
+                fSin1 = -fTan1*fCos1;
+
+                for (iRow = 0; iRow &lt; 3; iRow++)
+                {
+                    fTmp0 = rkR[0][iRow];
+                    fTmp1 = rkR[1][iRow];
+                    rkR[0][iRow] = fCos1*fTmp0-fSin1*fTmp1;
+                    rkR[1][iRow] = fSin1*fTmp0+fCos1*fTmp1;
+                }
+
+                rkS[0][0] = fCos0*fCos1*kA[0][0] -
+                    fSin1*(fCos0*kA[0][1]-fSin0*kA[1][1]);
+                rkS[1][1] = fSin0*fSin1*kA[0][0] +
+                    fCos1*(fSin0*kA[0][1]+fCos0*kA[1][1]);
+                rkS[2][2] = kA[2][2];
+                break;
+            }
+            else
+            {
+                GolubKahanStep(kA,rkL,rkR);
+            }
+        }
+    }
+
+    // positize diagonal
+    for (iRow = 0; iRow &lt; 3; iRow++)
+    {
+        if ( rkS[iRow][iRow] &lt; (Real)0.0 )
+        {
+            rkS[iRow][iRow] = -rkS[iRow][iRow];
+            for (iCol = 0; iCol &lt; 3; iCol++)
+            {
+                rkR[iRow][iCol] = -rkR[iRow][iCol];
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::SingularValueComposition (const Matrix3&amp; rkL,
+    const Matrix3&amp; rkS, const Matrix3&amp; rkR)
+{
+    *this = rkL*(rkS*rkR);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix3&lt;Real&gt;::QDUDecomposition (Matrix3&amp; rkQ, Matrix3&amp; rkD,
+    Matrix3&amp; rkU) const
+{
+    // Factor M = QR = QDU where Q is orthogonal (rotation), D is diagonal
+    // (scaling),  and U is upper triangular with ones on its diagonal
+    // (shear).  Algorithm uses Gram-Schmidt orthogonalization (the QR
+    // algorithm).
+    //
+    // If M = [ m0 | m1 | m2 ] and Q = [ q0 | q1 | q2 ], then
+    //
+    //   q0 = m0/|m0|
+    //   q1 = (m1-(q0*m1)q0)/|m1-(q0*m1)q0|
+    //   q2 = (m2-(q0*m2)q0-(q1*m2)q1)/|m2-(q0*m2)q0-(q1*m2)q1|
+    //
+    // where |V| indicates length of vector V and A*B indicates dot
+    // product of vectors A and B.  The matrix R has entries
+    //
+    //   r00 = q0*m0  r01 = q0*m1  r02 = q0*m2
+    //   r10 = 0      r11 = q1*m1  r12 = q1*m2
+    //   r20 = 0      r21 = 0      r22 = q2*m2
+    //
+    // so D = diag(r00,r11,r22) and U has entries u01 = r01/r00,
+    // u02 = r02/r00, and u12 = r12/r11.
+
+    // build orthogonal matrix Q
+    Real fInvLength = Math&lt;Real&gt;::InvSqrt(m_afEntry[0]*m_afEntry[0] +
+        m_afEntry[3]*m_afEntry[3] + m_afEntry[6]*m_afEntry[6]);
+    rkQ[0][0] = m_afEntry[0]*fInvLength;
+    rkQ[1][0] = m_afEntry[3]*fInvLength;
+    rkQ[2][0] = m_afEntry[6]*fInvLength;
+
+    Real fDot = rkQ[0][0]*m_afEntry[1] + rkQ[1][0]*m_afEntry[4] +
+        rkQ[2][0]*m_afEntry[7];
+    rkQ[0][1] = m_afEntry[1]-fDot*rkQ[0][0];
+    rkQ[1][1] = m_afEntry[4]-fDot*rkQ[1][0];
+    rkQ[2][1] = m_afEntry[7]-fDot*rkQ[2][0];
+    fInvLength = Math&lt;Real&gt;::InvSqrt(rkQ[0][1]*rkQ[0][1] +
+        rkQ[1][1]*rkQ[1][1] + rkQ[2][1]*rkQ[2][1]);
+    rkQ[0][1] *= fInvLength;
+    rkQ[1][1] *= fInvLength;
+    rkQ[2][1] *= fInvLength;
+
+    fDot = rkQ[0][0]*m_afEntry[2] + rkQ[1][0]*m_afEntry[5] +
+        rkQ[2][0]*m_afEntry[8];
+    rkQ[0][2] = m_afEntry[2]-fDot*rkQ[0][0];
+    rkQ[1][2] = m_afEntry[5]-fDot*rkQ[1][0];
+    rkQ[2][2] = m_afEntry[8]-fDot*rkQ[2][0];
+    fDot = rkQ[0][1]*m_afEntry[2] + rkQ[1][1]*m_afEntry[5] +
+        rkQ[2][1]*m_afEntry[8];
+    rkQ[0][2] -= fDot*rkQ[0][1];
+    rkQ[1][2] -= fDot*rkQ[1][1];
+    rkQ[2][2] -= fDot*rkQ[2][1];
+    fInvLength = Math&lt;Real&gt;::InvSqrt(rkQ[0][2]*rkQ[0][2] +
+        rkQ[1][2]*rkQ[1][2] + rkQ[2][2]*rkQ[2][2]);
+    rkQ[0][2] *= fInvLength;
+    rkQ[1][2] *= fInvLength;
+    rkQ[2][2] *= fInvLength;
+
+    // guarantee that orthogonal matrix has determinant 1 (no reflections)
+    Real fDet = rkQ[0][0]*rkQ[1][1]*rkQ[2][2] + rkQ[0][1]*rkQ[1][2]*rkQ[2][0]
+        +  rkQ[0][2]*rkQ[1][0]*rkQ[2][1] - rkQ[0][2]*rkQ[1][1]*rkQ[2][0]
+        -  rkQ[0][1]*rkQ[1][0]*rkQ[2][2] - rkQ[0][0]*rkQ[1][2]*rkQ[2][1];
+
+    if (fDet &lt; (Real)0.0)
+    {
+        for (int iRow = 0; iRow &lt; 3; iRow++)
+        {
+            for (int iCol = 0; iCol &lt; 3; iCol++)
+            {
+                rkQ[iRow][iCol] = -rkQ[iRow][iCol];
+            }
+        }
+    }
+
+    // build &quot;right&quot; matrix R
+    Matrix3 kR;
+    kR[0][0] = rkQ[0][0]*m_afEntry[0] + rkQ[1][0]*m_afEntry[3] +
+        rkQ[2][0]*m_afEntry[6];
+    kR[0][1] = rkQ[0][0]*m_afEntry[1] + rkQ[1][0]*m_afEntry[4] +
+        rkQ[2][0]*m_afEntry[7];
+    kR[1][1] = rkQ[0][1]*m_afEntry[1] + rkQ[1][1]*m_afEntry[4] +
+        rkQ[2][1]*m_afEntry[7];
+    kR[0][2] = rkQ[0][0]*m_afEntry[2] + rkQ[1][0]*m_afEntry[5] +
+        rkQ[2][0]*m_afEntry[8];
+    kR[1][2] = rkQ[0][1]*m_afEntry[2] + rkQ[1][1]*m_afEntry[5] +
+        rkQ[2][1]*m_afEntry[8];
+    kR[2][2] = rkQ[0][2]*m_afEntry[2] + rkQ[1][2]*m_afEntry[5] +
+        rkQ[2][2]*m_afEntry[8];
+
+    // the scaling component
+    rkD.MakeDiagonal(kR[0][0],kR[1][1],kR[2][2]);
+
+    // the shear component
+    Real fInvD0 = ((Real)1.0)/rkD[0][0];
+    rkU[0][0] = (Real)1.0;
+    rkU[0][1] = kR[0][1]*fInvD0;
+    rkU[0][2] = kR[0][2]*fInvD0;
+    rkU[1][0] = (Real)0.0;
+    rkU[1][1] = (Real)1.0;
+    rkU[1][2] = kR[1][2]/rkD[1][1];
+    rkU[2][0] = (Real)0.0;
+    rkU[2][1] = (Real)0.0;
+    rkU[2][2] = (Real)1.0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix3&lt;Real&gt; operator* (Real fScalar, const Matrix3&lt;Real&gt;&amp; rkM)
+{
+    return rkM*fScalar;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; operator* (const Vector3&lt;Real&gt;&amp; rkV, const Matrix3&lt;Real&gt;&amp; rkM)
+{
+    return Vector3&lt;Real&gt;(
+        rkV[0]*rkM[0][0] + rkV[1]*rkM[1][0] + rkV[2]*rkM[2][0],
+        rkV[0]*rkM[0][1] + rkV[1]*rkM[1][1] + rkV[2]*rkM[2][1],
+        rkV[0]*rkM[0][2] + rkV[1]*rkM[1][2] + rkV[2]*rkM[2][2]);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix4.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix4.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix4.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,36 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Matrix4.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Matrix4&lt;float&gt; Matrix4&lt;float&gt;::ZERO(
+    0.0f,0.0f,0.0f,0.0f,
+    0.0f,0.0f,0.0f,0.0f,
+    0.0f,0.0f,0.0f,0.0f,
+    0.0f,0.0f,0.0f,0.0f);
+template&lt;&gt; const Matrix4&lt;float&gt; Matrix4&lt;float&gt;::IDENTITY(
+    1.0f,0.0f,0.0f,0.0f,
+    0.0f,1.0f,0.0f,0.0f,
+    0.0f,0.0f,1.0f,0.0f,
+    0.0f,0.0f,0.0f,1.0f);
+
+template&lt;&gt; const Matrix4&lt;double&gt; Matrix4&lt;double&gt;::ZERO(
+    0.0,0.0,0.0,0.0,
+    0.0,0.0,0.0,0.0,
+    0.0,0.0,0.0,0.0,
+    0.0,0.0,0.0,0.0);
+template&lt;&gt; const Matrix4&lt;double&gt; Matrix4&lt;double&gt;::IDENTITY(
+    1.0,0.0,0.0,0.0,
+    0.0,1.0,0.0,0.0,
+    0.0,0.0,1.0,0.0,
+    0.0,0.0,0.0,1.0);
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix4.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix4.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix4.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,159 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3MATRIX4_H
+#define WM3MATRIX4_H
+
+// Matrix operations are applied on the left.  For example, given a matrix M
+// and a vector V, matrix-times-vector is M*V.  That is, V is treated as a
+// column vector.  Some graphics APIs use V*M where V is treated as a row
+// vector.  In this context the &quot;M&quot; matrix is really a transpose of the M as
+// represented in Wild Magic.  Similarly, to apply two matrix operations M0
+// and M1, in that order, you compute M1*M0 so that the transform of a vector
+// is (M1*M0)*V = M1*(M0*V).  Some graphics APIs use M0*M1, but again these
+// matrices are the transpose of those as represented in Wild Magic.  You
+// must therefore be careful about how you interface the transformation code
+// with graphics APIS.
+//
+// For memory organization it might seem natural to chose Real[N][N] for the
+// matrix storage, but this can be a problem on a platform/console that
+// chooses to store the data in column-major rather than row-major format.
+// To avoid potential portability problems, the matrix is stored as Real[N*N]
+// and organized in row-major order.  That is, the entry of the matrix in row
+// r (0 &lt;= r &lt; N) and column c (0 &lt;= c &lt; N) is stored at index i = c+N*r
+// (0 &lt;= i &lt; N*N).
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Plane3.h&quot;
+#include &quot;Wm3Vector4.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Matrix4
+{
+public:
+    // If bZero is true, create the zero matrix.  Otherwise, create the
+    // identity matrix.
+    Matrix4 (bool bZero = true);
+
+    // copy constructor
+    Matrix4 (const Matrix4&amp; rkM);
+
+    // input Mrc is in row r, column c.
+    Matrix4 (Real fM00, Real fM01, Real fM02, Real fM03,
+             Real fM10, Real fM11, Real fM12, Real fM13,
+             Real fM20, Real fM21, Real fM22, Real fM23,
+             Real fM30, Real fM31, Real fM32, Real fM33);
+
+    // Create a matrix from an array of numbers.  The input array is
+    // interpreted based on the Boolean input as
+    //   true:  entry[0..15]={m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,
+    //                        m23,m30,m31,m32,m33} [row major]
+    //   false: entry[0..15]={m00,m10,m20,m30,m01,m11,m21,m31,m02,m12,m22,
+    //                        m32,m03,m13,m23,m33} [col major]
+    Matrix4 (const Real afEntry[16], bool bRowMajor);
+
+    void MakeZero ();
+    void MakeIdentity ();
+
+    // member access
+    operator const Real* () const;
+    operator Real* ();
+    const Real* operator[] (int iRow) const;
+    Real* operator[] (int iRow);
+    Real operator() (int iRow, int iCol) const;
+    Real&amp; operator() (int iRow, int iCol);
+    void SetRow (int iRow, const Vector4&lt;Real&gt;&amp; rkV);
+    Vector4&lt;Real&gt; GetRow (int iRow) const;
+    void SetColumn (int iCol, const Vector4&lt;Real&gt;&amp; rkV);
+    Vector4&lt;Real&gt; GetColumn (int iCol) const;
+    void GetColumnMajor (Real* afCMajor) const;
+
+    // assignment
+    Matrix4&amp; operator= (const Matrix4&amp; rkM);
+
+    // comparison
+    bool operator== (const Matrix4&amp; rkM) const;
+    bool operator!= (const Matrix4&amp; rkM) const;
+    bool operator&lt;  (const Matrix4&amp; rkM) const;
+    bool operator&lt;= (const Matrix4&amp; rkM) const;
+    bool operator&gt;  (const Matrix4&amp; rkM) const;
+    bool operator&gt;= (const Matrix4&amp; rkM) const;
+
+    // arithmetic operations
+    Matrix4 operator+ (const Matrix4&amp; rkM) const;
+    Matrix4 operator- (const Matrix4&amp; rkM) const;
+    Matrix4 operator* (const Matrix4&amp; rkM) const;
+    Matrix4 operator* (Real fScalar) const;
+    Matrix4 operator/ (Real fScalar) const;
+    Matrix4 operator- () const;
+
+    // arithmetic updates
+    Matrix4&amp; operator+= (const Matrix4&amp; rkM);
+    Matrix4&amp; operator-= (const Matrix4&amp; rkM);
+    Matrix4&amp; operator*= (Real fScalar);
+    Matrix4&amp; operator/= (Real fScalar);
+
+    // matrix times vector
+    Vector4&lt;Real&gt; operator* (const Vector4&lt;Real&gt;&amp; rkV) const;  // M * v
+
+    // other operations
+    Matrix4 Transpose () const;  // M^T
+    Matrix4 TransposeTimes (const Matrix4&amp; rkM) const;  // this^T * M
+    Matrix4 TimesTranspose (const Matrix4&amp; rkM) const;  // this * M^T
+    Matrix4 Inverse () const;
+    Matrix4 Adjoint () const;
+    Real Determinant () const;
+    Real QForm (const Vector4&lt;Real&gt;&amp; rkU,
+        const Vector4&lt;Real&gt;&amp; rkV) const;  // u^T*M*v
+
+    // projection matrices onto a specified plane
+    void MakeObliqueProjection (const Vector3&lt;Real&gt;&amp; rkNormal,
+        const Vector3&lt;Real&gt;&amp; rkPoint, const Vector3&lt;Real&gt;&amp; rkDirection);
+    void MakePerspectiveProjection (const Vector3&lt;Real&gt;&amp; rkNormal,
+        const Vector3&lt;Real&gt;&amp; rkPoint, const Vector3&lt;Real&gt;&amp; rkEye);
+
+    // reflection matrix through a specified plane
+    void MakeReflection (const Vector3&lt;Real&gt;&amp; rkNormal,
+        const Vector3&lt;Real&gt;&amp; rkPoint);
+
+    // special matrices
+    WM3_ITEM static const Matrix4 ZERO;
+    WM3_ITEM static const Matrix4 IDENTITY;
+
+private:
+    // for indexing into the 1D array of the matrix, iCol+N*iRow
+    static int I (int iRow, int iCol);
+
+    // support for comparisons
+    int CompareArrays (const Matrix4&amp; rkM) const;
+
+    Real m_afEntry[16];
+};
+
+// c * M
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; operator* (Real fScalar, const Matrix4&lt;Real&gt;&amp; rkM);
+
+// v^T * M
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; operator* (const Vector4&lt;Real&gt;&amp; rkV, const Matrix4&lt;Real&gt;&amp; rkM);
+
+#include &quot;Wm3Matrix4.inl&quot;
+
+typedef Matrix4&lt;float&gt; Matrix4f;
+typedef Matrix4&lt;double&gt; Matrix4d;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Matrix4.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Matrix4.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Matrix4.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,716 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::Matrix4 (bool bZero)
+{
+    if (bZero)
+    {
+        MakeZero();
+    }
+    else
+    {
+        MakeIdentity();
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::Matrix4 (const Matrix4&amp; rkM)
+{
+    size_t uiSize = 16*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::Matrix4 (Real fM00, Real fM01, Real fM02, Real fM03,
+    Real fM10, Real fM11, Real fM12, Real fM13, Real fM20, Real fM21,
+    Real fM22, Real fM23, Real fM30, Real fM31, Real fM32, Real fM33)
+{
+    m_afEntry[ 0] = fM00;
+    m_afEntry[ 1] = fM01;
+    m_afEntry[ 2] = fM02;
+    m_afEntry[ 3] = fM03;
+    m_afEntry[ 4] = fM10;
+    m_afEntry[ 5] = fM11;
+    m_afEntry[ 6] = fM12;
+    m_afEntry[ 7] = fM13;
+    m_afEntry[ 8] = fM20;
+    m_afEntry[ 9] = fM21;
+    m_afEntry[10] = fM22;
+    m_afEntry[11] = fM23;
+    m_afEntry[12] = fM30;
+    m_afEntry[13] = fM31;
+    m_afEntry[14] = fM32;
+    m_afEntry[15] = fM33;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::Matrix4 (const Real afEntry[16], bool bRowMajor)
+{
+    if (bRowMajor)
+    {
+        size_t uiSize = 16*sizeof(Real);
+        System::Memcpy(m_afEntry,uiSize,afEntry,uiSize);
+    }
+    else
+    {
+        m_afEntry[ 0] = afEntry[ 0];
+        m_afEntry[ 1] = afEntry[ 4];
+        m_afEntry[ 2] = afEntry[ 8];
+        m_afEntry[ 3] = afEntry[12];
+        m_afEntry[ 4] = afEntry[ 1];
+        m_afEntry[ 5] = afEntry[ 5];
+        m_afEntry[ 6] = afEntry[ 9];
+        m_afEntry[ 7] = afEntry[13];
+        m_afEntry[ 8] = afEntry[ 2];
+        m_afEntry[ 9] = afEntry[ 6];
+        m_afEntry[10] = afEntry[10];
+        m_afEntry[11] = afEntry[14];
+        m_afEntry[12] = afEntry[ 3];
+        m_afEntry[13] = afEntry[ 7];
+        m_afEntry[14] = afEntry[11];
+        m_afEntry[15] = afEntry[15];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::operator const Real* () const
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;::operator Real* ()
+{
+    return m_afEntry;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+const Real* Matrix4&lt;Real&gt;::operator[] (int iRow) const
+{
+    return &amp;m_afEntry[4*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real* Matrix4&lt;Real&gt;::operator[] (int iRow)
+{
+    return &amp;m_afEntry[4*iRow];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix4&lt;Real&gt;::operator() (int iRow, int iCol) const
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Matrix4&lt;Real&gt;::operator() (int iRow, int iCol)
+{
+    return m_afEntry[I(iRow,iCol)];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix4&lt;Real&gt;::I (int iRow, int iCol)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 4 &amp;&amp; 0 &lt;= iCol &amp;&amp; iCol &lt; 4);
+    return iCol + 4*iRow;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::MakeZero ()
+{
+    memset(m_afEntry,0,16*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::MakeIdentity ()
+{
+    m_afEntry[ 0] = (Real)1.0;
+    m_afEntry[ 1] = (Real)0.0;
+    m_afEntry[ 2] = (Real)0.0;
+    m_afEntry[ 3] = (Real)0.0;
+    m_afEntry[ 4] = (Real)0.0;
+    m_afEntry[ 5] = (Real)1.0;
+    m_afEntry[ 6] = (Real)0.0;
+    m_afEntry[ 7] = (Real)0.0;
+    m_afEntry[ 8] = (Real)0.0;
+    m_afEntry[ 9] = (Real)0.0;
+    m_afEntry[10] = (Real)1.0;
+    m_afEntry[11] = (Real)0.0;
+    m_afEntry[12] = (Real)0.0;
+    m_afEntry[13] = (Real)0.0;
+    m_afEntry[14] = (Real)0.0;
+    m_afEntry[15] = (Real)1.0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::SetRow (int iRow, const Vector4&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 4);
+    for (int iCol = 0, i = 4*iRow; iCol &lt; 4; iCol++, i++)
+    {
+        m_afEntry[i] = rkV[iCol];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Matrix4&lt;Real&gt;::GetRow (int iRow) const
+{
+    assert(0 &lt;= iRow &amp;&amp; iRow &lt; 4);
+    Vector4&lt;Real&gt; kV;
+    for (int iCol = 0, i = 4*iRow; iCol &lt; 4; iCol++, i++)
+    {
+        kV[iCol] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::SetColumn (int iCol, const Vector4&lt;Real&gt;&amp; rkV)
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 4);
+    for (int iRow = 0, i = iCol; iRow &lt; 4; iRow++, i += 4)
+    {
+        m_afEntry[i] = rkV[iRow];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Matrix4&lt;Real&gt;::GetColumn (int iCol) const
+{
+    assert(0 &lt;= iCol &amp;&amp; iCol &lt; 4);
+    Vector4&lt;Real&gt; kV;
+    for (int iRow = 0, i = iCol; iRow &lt; 4; iRow++, i += 4)
+    {
+        kV[iRow] = m_afEntry[i];
+    }
+    return kV;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::GetColumnMajor (Real* afCMajor) const
+{
+    for (int iRow = 0, i = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            afCMajor[i++] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;&amp; Matrix4&lt;Real&gt;::operator= (const Matrix4&amp; rkM)
+{
+    size_t uiSize = 16*sizeof(Real);
+    System::Memcpy(m_afEntry,uiSize,rkM.m_afEntry,uiSize);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Matrix4&lt;Real&gt;::CompareArrays (const Matrix4&amp; rkM) const
+{
+    return memcmp(m_afEntry,rkM.m_afEntry,16*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator== (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator!= (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator&lt;  (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator&lt;= (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator&gt;  (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Matrix4&lt;Real&gt;::operator&gt;= (const Matrix4&amp; rkM) const
+{
+    return CompareArrays(rkM) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator+ (const Matrix4&amp; rkM) const
+{
+    Matrix4 kSum;
+    for (int i = 0; i &lt; 16; i++)
+    {
+        kSum.m_afEntry[i] = m_afEntry[i] + rkM.m_afEntry[i];
+    }
+    return kSum;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator- (const Matrix4&amp; rkM) const
+{
+    Matrix4 kDiff;
+    for (int i = 0; i &lt; 16; i++)
+    {
+        kDiff.m_afEntry[i] = m_afEntry[i] - rkM.m_afEntry[i];
+    }
+    return kDiff;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator* (const Matrix4&amp; rkM) const
+{
+    Matrix4 kProd;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 4; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator* (Real fScalar) const
+{
+    Matrix4 kProd;
+    for (int i = 0; i &lt; 16; i++)
+    {
+        kProd.m_afEntry[i] = fScalar*m_afEntry[i];
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Matrix4 kQuot;
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 16; i++)
+        {
+            kQuot.m_afEntry[i] = fInvScalar*m_afEntry[i];
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 16; i++)
+        {
+            kQuot.m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::operator- () const
+{
+    Matrix4 kNeg;
+    for (int i = 0; i &lt; 16; i++)
+    {
+        kNeg.m_afEntry[i] = -m_afEntry[i];
+    }
+    return kNeg;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;&amp; Matrix4&lt;Real&gt;::operator+= (const Matrix4&amp; rkM)
+{
+    for (int i = 0; i &lt; 16; i++)
+    {
+        m_afEntry[i] += rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;&amp; Matrix4&lt;Real&gt;::operator-= (const Matrix4&amp; rkM)
+{
+    for (int i = 0; i &lt; 16; i++)
+    {
+        m_afEntry[i] -= rkM.m_afEntry[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;&amp; Matrix4&lt;Real&gt;::operator*= (Real fScalar)
+{
+    for (int i = 0; i &lt; 16; i++)
+    {
+        m_afEntry[i] *= fScalar;
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt;&amp; Matrix4&lt;Real&gt;::operator/= (Real fScalar)
+{
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 16; i++)
+        {
+            m_afEntry[i] *= fInvScalar;
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 16; i++)
+        {
+            m_afEntry[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Matrix4&lt;Real&gt;::operator* (const Vector4&lt;Real&gt;&amp; rkV) const
+{
+    Vector4&lt;Real&gt; kProd;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        kProd[iRow] = (Real)0.0;
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            kProd[iRow] += m_afEntry[I(iRow,iCol)]*rkV[iCol];
+        }
+            
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::Transpose () const
+{
+    Matrix4 kTranspose;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            kTranspose.m_afEntry[I(iRow,iCol)] = m_afEntry[I(iCol,iRow)];
+        }
+    }
+    return kTranspose;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::TransposeTimes (const Matrix4&amp; rkM) const
+{
+    // P = A^T*B, P[r][c] = sum_m A[m][r]*B[m][c]
+    Matrix4 kProd;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 4; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iMid,iRow)]*rkM.m_afEntry[I(iMid,iCol)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::TimesTranspose (const Matrix4&amp; rkM) const
+{
+    // P = A*B^T, P[r][c] = sum_m A[r][m]*B[c][m]
+    Matrix4 kProd;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            int i = I(iRow,iCol);
+            kProd.m_afEntry[i] = (Real)0.0;
+            for (int iMid = 0; iMid &lt; 4; iMid++)
+            {
+                kProd.m_afEntry[i] +=
+                    m_afEntry[I(iRow,iMid)]*rkM.m_afEntry[I(iCol,iMid)];
+            }
+        }
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::Inverse () const
+{
+    Real fA0 = m_afEntry[ 0]*m_afEntry[ 5] - m_afEntry[ 1]*m_afEntry[ 4];
+    Real fA1 = m_afEntry[ 0]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 4];
+    Real fA2 = m_afEntry[ 0]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 4];
+    Real fA3 = m_afEntry[ 1]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 5];
+    Real fA4 = m_afEntry[ 1]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 5];
+    Real fA5 = m_afEntry[ 2]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 6];
+    Real fB0 = m_afEntry[ 8]*m_afEntry[13] - m_afEntry[ 9]*m_afEntry[12];
+    Real fB1 = m_afEntry[ 8]*m_afEntry[14] - m_afEntry[10]*m_afEntry[12];
+    Real fB2 = m_afEntry[ 8]*m_afEntry[15] - m_afEntry[11]*m_afEntry[12];
+    Real fB3 = m_afEntry[ 9]*m_afEntry[14] - m_afEntry[10]*m_afEntry[13];
+    Real fB4 = m_afEntry[ 9]*m_afEntry[15] - m_afEntry[11]*m_afEntry[13];
+    Real fB5 = m_afEntry[10]*m_afEntry[15] - m_afEntry[11]*m_afEntry[14];
+
+    Real fDet = fA0*fB5-fA1*fB4+fA2*fB3+fA3*fB2-fA4*fB1+fA5*fB0;
+    if (Math&lt;Real&gt;::FAbs(fDet) &lt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        return Matrix4&lt;Real&gt;::ZERO;
+    }
+
+    Matrix4 kInv;
+    kInv[0][0] = + m_afEntry[ 5]*fB5 - m_afEntry[ 6]*fB4 + m_afEntry[ 7]*fB3;
+    kInv[1][0] = - m_afEntry[ 4]*fB5 + m_afEntry[ 6]*fB2 - m_afEntry[ 7]*fB1;
+    kInv[2][0] = + m_afEntry[ 4]*fB4 - m_afEntry[ 5]*fB2 + m_afEntry[ 7]*fB0;
+    kInv[3][0] = - m_afEntry[ 4]*fB3 + m_afEntry[ 5]*fB1 - m_afEntry[ 6]*fB0;
+    kInv[0][1] = - m_afEntry[ 1]*fB5 + m_afEntry[ 2]*fB4 - m_afEntry[ 3]*fB3;
+    kInv[1][1] = + m_afEntry[ 0]*fB5 - m_afEntry[ 2]*fB2 + m_afEntry[ 3]*fB1;
+    kInv[2][1] = - m_afEntry[ 0]*fB4 + m_afEntry[ 1]*fB2 - m_afEntry[ 3]*fB0;
+    kInv[3][1] = + m_afEntry[ 0]*fB3 - m_afEntry[ 1]*fB1 + m_afEntry[ 2]*fB0;
+    kInv[0][2] = + m_afEntry[13]*fA5 - m_afEntry[14]*fA4 + m_afEntry[15]*fA3;
+    kInv[1][2] = - m_afEntry[12]*fA5 + m_afEntry[14]*fA2 - m_afEntry[15]*fA1;
+    kInv[2][2] = + m_afEntry[12]*fA4 - m_afEntry[13]*fA2 + m_afEntry[15]*fA0;
+    kInv[3][2] = - m_afEntry[12]*fA3 + m_afEntry[13]*fA1 - m_afEntry[14]*fA0;
+    kInv[0][3] = - m_afEntry[ 9]*fA5 + m_afEntry[10]*fA4 - m_afEntry[11]*fA3;
+    kInv[1][3] = + m_afEntry[ 8]*fA5 - m_afEntry[10]*fA2 + m_afEntry[11]*fA1;
+    kInv[2][3] = - m_afEntry[ 8]*fA4 + m_afEntry[ 9]*fA2 - m_afEntry[11]*fA0;
+    kInv[3][3] = + m_afEntry[ 8]*fA3 - m_afEntry[ 9]*fA1 + m_afEntry[10]*fA0;
+
+    Real fInvDet = ((Real)1.0)/fDet;
+    for (int iRow = 0; iRow &lt; 4; iRow++)
+    {
+        for (int iCol = 0; iCol &lt; 4; iCol++)
+        {
+            kInv[iRow][iCol] *= fInvDet;
+        }
+    }
+
+    return kInv;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; Matrix4&lt;Real&gt;::Adjoint () const
+{
+    Real fA0 = m_afEntry[ 0]*m_afEntry[ 5] - m_afEntry[ 1]*m_afEntry[ 4];
+    Real fA1 = m_afEntry[ 0]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 4];
+    Real fA2 = m_afEntry[ 0]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 4];
+    Real fA3 = m_afEntry[ 1]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 5];
+    Real fA4 = m_afEntry[ 1]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 5];
+    Real fA5 = m_afEntry[ 2]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 6];
+    Real fB0 = m_afEntry[ 8]*m_afEntry[13] - m_afEntry[ 9]*m_afEntry[12];
+    Real fB1 = m_afEntry[ 8]*m_afEntry[14] - m_afEntry[10]*m_afEntry[12];
+    Real fB2 = m_afEntry[ 8]*m_afEntry[15] - m_afEntry[11]*m_afEntry[12];
+    Real fB3 = m_afEntry[ 9]*m_afEntry[14] - m_afEntry[10]*m_afEntry[13];
+    Real fB4 = m_afEntry[ 9]*m_afEntry[15] - m_afEntry[11]*m_afEntry[13];
+    Real fB5 = m_afEntry[10]*m_afEntry[15] - m_afEntry[11]*m_afEntry[14];
+
+    Matrix4 kAdj;
+    kAdj[0][0] = + m_afEntry[ 5]*fB5 - m_afEntry[ 6]*fB4 + m_afEntry[ 7]*fB3;
+    kAdj[1][0] = - m_afEntry[ 4]*fB5 + m_afEntry[ 6]*fB2 - m_afEntry[ 7]*fB1;
+    kAdj[2][0] = + m_afEntry[ 4]*fB4 - m_afEntry[ 5]*fB2 + m_afEntry[ 7]*fB0;
+    kAdj[3][0] = - m_afEntry[ 4]*fB3 + m_afEntry[ 5]*fB1 - m_afEntry[ 6]*fB0;
+    kAdj[0][1] = - m_afEntry[ 1]*fB5 + m_afEntry[ 2]*fB4 - m_afEntry[ 3]*fB3;
+    kAdj[1][1] = + m_afEntry[ 0]*fB5 - m_afEntry[ 2]*fB2 + m_afEntry[ 3]*fB1;
+    kAdj[2][1] = - m_afEntry[ 0]*fB4 + m_afEntry[ 1]*fB2 - m_afEntry[ 3]*fB0;
+    kAdj[3][1] = + m_afEntry[ 0]*fB3 - m_afEntry[ 1]*fB1 + m_afEntry[ 2]*fB0;
+    kAdj[0][2] = + m_afEntry[13]*fA5 - m_afEntry[14]*fA4 + m_afEntry[15]*fA3;
+    kAdj[1][2] = - m_afEntry[12]*fA5 + m_afEntry[14]*fA2 - m_afEntry[15]*fA1;
+    kAdj[2][2] = + m_afEntry[12]*fA4 - m_afEntry[13]*fA2 + m_afEntry[15]*fA0;
+    kAdj[3][2] = - m_afEntry[12]*fA3 + m_afEntry[13]*fA1 - m_afEntry[14]*fA0;
+    kAdj[0][3] = - m_afEntry[ 9]*fA5 + m_afEntry[10]*fA4 - m_afEntry[11]*fA3;
+    kAdj[1][3] = + m_afEntry[ 8]*fA5 - m_afEntry[10]*fA2 + m_afEntry[11]*fA1;
+    kAdj[2][3] = - m_afEntry[ 8]*fA4 + m_afEntry[ 9]*fA2 - m_afEntry[11]*fA0;
+    kAdj[3][3] = + m_afEntry[ 8]*fA3 - m_afEntry[ 9]*fA1 + m_afEntry[10]*fA0;
+
+    return kAdj;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix4&lt;Real&gt;::Determinant () const
+{
+    Real fA0 = m_afEntry[ 0]*m_afEntry[ 5] - m_afEntry[ 1]*m_afEntry[ 4];
+    Real fA1 = m_afEntry[ 0]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 4];
+    Real fA2 = m_afEntry[ 0]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 4];
+    Real fA3 = m_afEntry[ 1]*m_afEntry[ 6] - m_afEntry[ 2]*m_afEntry[ 5];
+    Real fA4 = m_afEntry[ 1]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 5];
+    Real fA5 = m_afEntry[ 2]*m_afEntry[ 7] - m_afEntry[ 3]*m_afEntry[ 6];
+    Real fB0 = m_afEntry[ 8]*m_afEntry[13] - m_afEntry[ 9]*m_afEntry[12];
+    Real fB1 = m_afEntry[ 8]*m_afEntry[14] - m_afEntry[10]*m_afEntry[12];
+    Real fB2 = m_afEntry[ 8]*m_afEntry[15] - m_afEntry[11]*m_afEntry[12];
+    Real fB3 = m_afEntry[ 9]*m_afEntry[14] - m_afEntry[10]*m_afEntry[13];
+    Real fB4 = m_afEntry[ 9]*m_afEntry[15] - m_afEntry[11]*m_afEntry[13];
+    Real fB5 = m_afEntry[10]*m_afEntry[15] - m_afEntry[11]*m_afEntry[14];
+    Real fDet = fA0*fB5-fA1*fB4+fA2*fB3+fA3*fB2-fA4*fB1+fA5*fB0;
+    return fDet;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Matrix4&lt;Real&gt;::QForm (const Vector4&lt;Real&gt;&amp; rkU,
+    const Vector4&lt;Real&gt;&amp; rkV) const
+{
+    return rkU.Dot((*this)*rkV);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::MakeObliqueProjection (const Vector3&lt;Real&gt;&amp; rkNormal,
+    const Vector3&lt;Real&gt;&amp; rkPoint, const Vector3&lt;Real&gt;&amp; rkDirection)
+{
+    // The projection plane is Dot(N,X-P) = 0 where N is a 3-by-1 unit-length
+    // normal vector and P is a 3-by-1 point on the plane.  The projection
+    // is oblique to the plane, in the direction of the 3-by-1 vector D.
+    // Necessarily Dot(N,D) is not zero for this projection to make sense.
+    // Given a 3-by-1 point U, compute the intersection of the line U+t*D
+    // with the plane to obtain t = -Dot(N,U-P)/Dot(N,D).  Then
+    //
+    //   projection(U) = P + [I - D*N^T/Dot(N,D)]*(U-P)
+    //
+    // A 4-by-4 homogeneous transformation representing the projection is
+    //
+    //       +-                               -+
+    //   M = | D*N^T - Dot(N,D)*I   -Dot(N,P)D |
+    //       |          0^T          -Dot(N,D) |
+    //       +-                               -+
+    //
+    // where M applies to [U^T 1]^T by M*[U^T 1]^T.  The matrix is chosen so
+    // that M[3][3] &gt; 0 whenever Dot(N,D) &lt; 0 (projection is onto the
+    // &quot;positive side&quot; of the plane).
+
+    Real fNdD = rkNormal.Dot(rkDirection);
+    Real fNdP = rkNormal.Dot(rkPoint);
+    m_afEntry[ 0] = rkDirection[0]*rkNormal[0] - fNdD;
+    m_afEntry[ 1] = rkDirection[0]*rkNormal[1];
+    m_afEntry[ 2] = rkDirection[0]*rkNormal[2];
+    m_afEntry[ 3] = -fNdP*rkDirection[0];
+    m_afEntry[ 4] = rkDirection[1]*rkNormal[0];
+    m_afEntry[ 5] = rkDirection[1]*rkNormal[1] - fNdD;
+    m_afEntry[ 6] = rkDirection[1]*rkNormal[2];
+    m_afEntry[ 7] = -fNdP*rkDirection[1];
+    m_afEntry[ 8] = rkDirection[2]*rkNormal[0];
+    m_afEntry[ 9] = rkDirection[2]*rkNormal[1];
+    m_afEntry[10] = rkDirection[2]*rkNormal[2] - fNdD;
+    m_afEntry[11] = -fNdP*rkDirection[2];
+    m_afEntry[12] = 0.0f;
+    m_afEntry[13] = 0.0f;
+    m_afEntry[14] = 0.0f;
+    m_afEntry[15] = -fNdD;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::MakePerspectiveProjection (const Vector3&lt;Real&gt;&amp; rkNormal,
+    const Vector3&lt;Real&gt;&amp; rkPoint, const Vector3&lt;Real&gt;&amp; rkEye)
+{
+    //     +-                                                 -+
+    // M = | Dot(N,E-P)*I - E*N^T    -(Dot(N,E-P)*I - E*N^T)*E |
+    //     |        -N^t                      Dot(N,E)         |
+    //     +-                                                 -+
+    //
+    // where E is the eye point, P is a point on the plane, and N is a
+    // unit-length plane normal.
+
+    Real fNdEmP = rkNormal.Dot(rkEye-rkPoint);
+
+    m_afEntry[ 0] = fNdEmP - rkEye[0]*rkNormal[0];
+    m_afEntry[ 1] = -rkEye[0]*rkNormal[1];
+    m_afEntry[ 2] = -rkEye[0]*rkNormal[2];
+    m_afEntry[ 3] = -(m_afEntry[0]*rkEye[0] + m_afEntry[1]*rkEye[1] +
+        m_afEntry[2]*rkEye[2]);
+    m_afEntry[ 4] = -rkEye[1]*rkNormal[0];
+    m_afEntry[ 5] = fNdEmP - rkEye[1]*rkNormal[1];
+    m_afEntry[ 6] = -rkEye[1]*rkNormal[2];
+    m_afEntry[ 7] = -(m_afEntry[4]*rkEye[0] + m_afEntry[5]*rkEye[1] +
+        m_afEntry[6]*rkEye[2]);
+    m_afEntry[ 8] = -rkEye[2]*rkNormal[0];
+    m_afEntry[ 9] = -rkEye[2]*rkNormal[1];
+    m_afEntry[10] = fNdEmP- rkEye[2]*rkNormal[2];
+    m_afEntry[11] = -(m_afEntry[8]*rkEye[0] + m_afEntry[9]*rkEye[1] +
+        m_afEntry[10]*rkEye[2]);
+    m_afEntry[12] = -rkNormal[0];
+    m_afEntry[13] = -rkNormal[1];
+    m_afEntry[14] = -rkNormal[2];
+    m_afEntry[15] = rkNormal.Dot(rkEye);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Matrix4&lt;Real&gt;::MakeReflection (const Vector3&lt;Real&gt;&amp; rkNormal,
+    const Vector3&lt;Real&gt;&amp; rkPoint)
+{
+    //     +-                         -+
+    // M = | I-2*N*N^T    2*Dot(N,P)*N |
+    //     |     0^T            1      |
+    //     +-                         -+
+    //
+    // where P is a point on the plane and N is a unit-length plane normal.
+
+    Real fTwoNdP = ((Real)2.0)*(rkNormal.Dot(rkPoint));
+
+    m_afEntry[ 0] = (Real)1.0 - ((Real)2.0)*rkNormal[0]*rkNormal[0];
+    m_afEntry[ 1] = -((Real)2.0)*rkNormal[0]*rkNormal[1];
+    m_afEntry[ 2] = -((Real)2.0)*rkNormal[0]*rkNormal[2];
+    m_afEntry[ 3] = fTwoNdP*rkNormal[0];
+    m_afEntry[ 4] = -((Real)2.0)*rkNormal[1]*rkNormal[0];
+    m_afEntry[ 5] = (Real)1.0 - ((Real)2.0)*rkNormal[1]*rkNormal[1];
+    m_afEntry[ 6] = -((Real)2.0)*rkNormal[1]*rkNormal[2];
+    m_afEntry[ 7] = fTwoNdP*rkNormal[1];
+    m_afEntry[ 8] = -((Real)2.0)*rkNormal[2]*rkNormal[0];
+    m_afEntry[ 9] = -((Real)2.0)*rkNormal[2]*rkNormal[1];
+    m_afEntry[10] = (Real)1.0 - ((Real)2.0)*rkNormal[2]*rkNormal[2];
+    m_afEntry[11] = fTwoNdP*rkNormal[2];
+    m_afEntry[12] = (Real)0.0;
+    m_afEntry[13] = (Real)0.0;
+    m_afEntry[14] = (Real)0.0;
+    m_afEntry[15] = (Real)1.0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Matrix4&lt;Real&gt; operator* (Real fScalar, const Matrix4&lt;Real&gt;&amp; rkM)
+{
+    return rkM*fScalar;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; operator* (const Vector4&lt;Real&gt;&amp; rkV, const Matrix4&lt;Real&gt;&amp; rkM)
+{
+    return Vector4&lt;Real&gt;(
+        rkV[0]*rkM[0][0]+rkV[1]*rkM[1][0]+rkV[2]*rkM[2][0]+rkV[3]*rkM[3][0],
+        rkV[0]*rkM[0][1]+rkV[1]*rkM[1][1]+rkV[2]*rkM[2][1]+rkV[3]*rkM[3][1],
+        rkV[0]*rkM[0][2]+rkV[1]*rkM[1][2]+rkV[2]*rkM[2][2]+rkV[3]*rkM[3][2],
+        rkV[0]*rkM[0][3]+rkV[1]*rkM[1][3]+rkV[2]*rkM[2][3]+rkV[3]*rkM[3][3]);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Memory.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Memory.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Memory.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,310 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+
+#ifdef WM3_MEMORY_MANAGER
+
+#include &lt;cassert&gt;
+#include &lt;cstdlib&gt;
+#include &lt;fstream&gt;
+#include &quot;Wm3Memory.h&quot;
+using namespace Wm3;
+
+size_t Memory::ms_uiNumNewCalls = 0;
+size_t Memory::ms_uiNumDeleteCalls = 0;
+size_t Memory::ms_uiMaxAllowedBytes = 0;
+size_t Memory::ms_uiNumBlocks = 0;
+size_t Memory::ms_uiNumBytes = 0;
+Memory::Block* Memory::ms_pkHead = 0;
+Memory::Block* Memory::ms_pkTail = 0;
+bool Memory::ms_bTrackSizes = false;
+size_t Memory::ms_uiMaxAllocatedBytes = 0;
+size_t Memory::ms_uiMaxBlockSize = 0;
+size_t Memory::ms_auiHistogram[32] =
+{
+    0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0
+};
+
+//----------------------------------------------------------------------------
+void* Memory::Allocate (size_t uiSize, char* acFile, unsigned int uiLine,
+    bool bIsArray)
+{
+    ms_uiNumNewCalls++;
+
+    // The 'assert' used to be enabled to trap attempts to allocate zero
+    // bytes.  However, the DirectX function D3DXCheckNewDelete may pass in
+    // a value of zero.
+    // assert(uiSize &gt; 0);
+
+    // Allocate additional storage for the block header information.
+    size_t uiExtendedSize = sizeof(Block) + uiSize;
+    char* pcAddr = (char*)malloc(uiExtendedSize);
+
+    // Save the allocation information.
+    Block* pkBlock = (Block*)pcAddr;
+    pkBlock-&gt;Size = uiSize;
+    pkBlock-&gt;File = acFile;
+    pkBlock-&gt;Line = uiLine;
+    pkBlock-&gt;IsArray = bIsArray;
+    InsertBlock(pkBlock);
+
+    // Move the pointer to the start of what the user expects from 'new'.
+    pcAddr += sizeof(Block);
+
+    // Keep track of number of allocated blocks and bytes.
+    ms_uiNumBlocks++;
+    ms_uiNumBytes += uiSize;
+
+    if (ms_uiMaxAllowedBytes &gt; 0 &amp;&amp; ms_uiNumBytes &gt; ms_uiMaxAllowedBytes)
+    {
+        // The allocation has exceeded the maximum number of bytes.
+        assert(false);
+    }
+
+    // Keep track of the maximum number of bytes allocated.
+    if (ms_uiNumBytes &gt; ms_uiMaxAllocatedBytes)
+    {
+        ms_uiMaxAllocatedBytes = ms_uiNumBytes;
+    }
+
+    // Keep track of the distribution of sizes for allocations.
+    if (ms_bTrackSizes)
+    {
+        // Keep track of the largest block ever allocated.
+        if (uiSize &gt; ms_uiMaxBlockSize)
+        {
+            ms_uiMaxBlockSize = uiSize;
+        }
+
+        unsigned int uiTwoPowerI = 1;
+        int i;
+        for (i = 0; i &lt;= 30; i++, uiTwoPowerI &lt;&lt;= 1)
+        {
+            if (uiSize &lt;= uiTwoPowerI)
+            {
+                ms_auiHistogram[i]++;
+                break;
+            }
+        }
+        if (i == 31)
+        {
+            ms_auiHistogram[i]++;
+        }
+    }
+
+    return (void*)pcAddr;
+}
+//----------------------------------------------------------------------------
+void Memory::Deallocate (char* pcAddr, bool bIsArray)
+{
+    ms_uiNumDeleteCalls++;
+
+    if (!pcAddr)
+    {
+        return;
+    }
+
+    // Move the pointer to the start of the actual allocated block.
+    pcAddr -= sizeof(Block);
+
+    // Get the allocation information and remove the block.  The removal
+    // only modifies the Prev and Next pointers, so the block information is
+    // accessible after the call.
+    Block* pkBlock = (Block*)pcAddr;
+    RemoveBlock(pkBlock);
+
+    // Check for correct pairing of new/delete or new[]/delete[].
+    assert(pkBlock-&gt;IsArray == bIsArray);
+
+    // Keep track of number of allocated blocks and bytes.  If the number of
+    // blocks is zero at this time, a delete has been called twice on the
+    // same pointer.  If the number of bytes is too small at this time, some
+    // internal problem has occurred within this class and needs to be
+    // diagnosed.
+    assert(ms_uiNumBlocks &gt; 0 &amp;&amp; ms_uiNumBytes &gt;= pkBlock-&gt;Size);
+    ms_uiNumBlocks--;
+    ms_uiNumBytes -= pkBlock-&gt;Size;
+
+    // Deallocate the memory block.
+    free(pcAddr);
+}
+//----------------------------------------------------------------------------
+void Memory::InsertBlock (Block* pkBlock)
+{
+    // New blocks are inserted at the tail of the doubly linked list.
+    if (ms_pkTail)
+    {
+        pkBlock-&gt;Prev = ms_pkTail;
+        pkBlock-&gt;Next = 0;
+        ms_pkTail-&gt;Next = pkBlock;
+        ms_pkTail = pkBlock;
+    }
+    else
+    {
+        pkBlock-&gt;Prev = 0;
+        pkBlock-&gt;Next = 0;
+        ms_pkHead = pkBlock;
+        ms_pkTail = pkBlock;
+    }
+}
+//----------------------------------------------------------------------------
+void Memory::RemoveBlock (Block* pkBlock)
+{
+    if (pkBlock-&gt;Prev)
+    {
+        pkBlock-&gt;Prev-&gt;Next = pkBlock-&gt;Next;
+    }
+    else
+    {
+        ms_pkHead = pkBlock-&gt;Next;
+    }
+    
+    if (pkBlock-&gt;Next)
+    {
+        pkBlock-&gt;Next-&gt;Prev = pkBlock-&gt;Prev;
+    }
+    else
+    {
+        ms_pkTail = pkBlock-&gt;Prev;
+    }
+}
+//----------------------------------------------------------------------------
+void Memory::GenerateReport (const char* acFilename)
+{
+    std::ofstream kOStr(acFilename);
+    assert(kOStr);
+    if (!kOStr)
+    {
+        return;
+    }
+
+    // Total calls.
+    kOStr &lt;&lt; &quot;Total number of 'new' calls = &quot;
+        &lt;&lt; (unsigned int)ms_uiNumNewCalls &lt;&lt; std::endl;
+    kOStr &lt;&lt; &quot;Total number of 'delete' calls = &quot;
+        &lt;&lt; (unsigned int)ms_uiNumDeleteCalls &lt;&lt; std::endl;
+    kOStr &lt;&lt; &quot;Maximum number of allocated bytes = &quot;
+        &lt;&lt; (unsigned int)ms_uiMaxAllocatedBytes &lt;&lt; std::endl &lt;&lt; std::endl;
+
+    // Remaining counts.
+    kOStr &lt;&lt; &quot;Remaining number of blocks = &quot;
+        &lt;&lt; (unsigned int)ms_uiNumBlocks &lt;&lt; std::endl;
+    kOStr &lt;&lt; &quot;Remaining number of bytes  = &quot;
+        &lt;&lt; (unsigned int)ms_uiNumBytes &lt;&lt; std::endl &lt;&lt; std::endl;
+
+    // Count the blocks and bytes from known and unknown sources.
+    size_t uiNumKnownBlocks = 0;
+    size_t uiNumKnownBytes = 0;
+    size_t uiNumUnknownBlocks = 0;
+    size_t uiNumUnknownBytes = 0;
+    Block* pkBlock = ms_pkHead;
+    while (pkBlock)
+    {
+        if (pkBlock-&gt;File)
+        {
+            uiNumKnownBlocks++;
+            uiNumKnownBytes += pkBlock-&gt;Size;
+        }
+        else
+        {
+            uiNumUnknownBlocks++;
+            uiNumUnknownBytes += pkBlock-&gt;Size;
+        }
+        pkBlock = pkBlock-&gt;Next;
+    }
+
+    // consistency check
+    assert(uiNumKnownBlocks + uiNumUnknownBlocks == ms_uiNumBlocks);
+    assert(uiNumKnownBytes + uiNumUnknownBytes == ms_uiNumBytes);
+
+    kOStr &lt;&lt; &quot;Remaining number of known blocks = &quot;
+        &lt;&lt; (unsigned int)uiNumKnownBlocks &lt;&lt; std::endl;
+    kOStr &lt;&lt; &quot;Remaining number of known bytes  = &quot;
+        &lt;&lt; (unsigned int)uiNumKnownBytes &lt;&lt; std::endl &lt;&lt; std::endl;
+
+    kOStr &lt;&lt; &quot;Remaining number of unknown blocks = &quot;
+        &lt;&lt; (unsigned int)uiNumUnknownBlocks &lt;&lt; std::endl;
+    kOStr &lt;&lt; &quot;Remaining number of unknown bytes  = &quot;
+        &lt;&lt; (unsigned int)uiNumUnknownBytes &lt;&lt; std::endl &lt;&lt; std::endl;
+
+    // Report the information for each block.
+    pkBlock = ms_pkHead;
+    size_t uiIndex = 0;
+    while (pkBlock)
+    {
+        kOStr &lt;&lt; &quot;block = &quot; &lt;&lt; (unsigned int)uiIndex &lt;&lt; std::endl;
+        kOStr &lt;&lt; &quot;size  = &quot; &lt;&lt; (unsigned int)pkBlock-&gt;Size &lt;&lt; std::endl;
+        if (pkBlock-&gt;File)
+        {
+            kOStr &lt;&lt; &quot;file  = &quot; &lt;&lt; pkBlock-&gt;File &lt;&lt; std::endl;
+            kOStr &lt;&lt; &quot;line  = &quot; &lt;&lt; pkBlock-&gt;Line &lt;&lt; std::endl;
+        }
+        else
+        {
+            kOStr &lt;&lt; &quot;file  = unknown&quot; &lt;&lt; std::endl;
+            kOStr &lt;&lt; &quot;line  = unknown&quot; &lt;&lt; std::endl;
+        }
+        kOStr &lt;&lt; &quot;array = &quot; &lt;&lt; pkBlock-&gt;IsArray &lt;&lt; std::endl &lt;&lt; std::endl;
+        pkBlock = pkBlock-&gt;Next;
+        uiIndex++;
+    }
+    kOStr.close();
+
+    // consistency check
+    assert(uiIndex == ms_uiNumBlocks);
+}
+//----------------------------------------------------------------------------
+void* operator new (size_t uiSize)
+{
+    return Memory::Allocate(uiSize,0,0,false);
+}
+//----------------------------------------------------------------------------
+void* operator new[](size_t uiSize)
+{
+    return Memory::Allocate(uiSize,0,0,true);
+}
+//----------------------------------------------------------------------------
+void* operator new (size_t uiSize, char* acFile, unsigned int uiLine)
+{
+    return Memory::Allocate(uiSize,acFile,uiLine,false);
+}
+//----------------------------------------------------------------------------
+void* operator new[] (size_t uiSize, char* acFile, unsigned int uiLine)
+{
+    return Memory::Allocate(uiSize,acFile,uiLine,true);
+}
+//----------------------------------------------------------------------------
+void operator delete (void* pvAddr)
+{
+    Memory::Deallocate((char*)pvAddr,false);
+}
+//----------------------------------------------------------------------------
+void operator delete[] (void* pvAddr)
+{
+    Memory::Deallocate((char*)pvAddr,true);
+}
+//----------------------------------------------------------------------------
+void operator delete (void* pvAddr, char*, unsigned int)
+{
+    Memory::Deallocate((char*)pvAddr,false);
+}
+//----------------------------------------------------------------------------
+void operator delete[] (void* pvAddr, char*, unsigned int)
+{
+    Memory::Deallocate((char*)pvAddr,true);
+}
+//----------------------------------------------------------------------------
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Memory.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Memory.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Memory.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,134 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3MEMORY_H
+#define WM3MEMORY_H
+
+#ifndef WM3_MEMORY_MANAGER
+
+// Use the default memory manager.
+#define WM3_NEW new
+#define WM3_DELETE delete
+
+#else
+
+// Overrides of the global new and delete operators.  These enhance the
+// default memory manager by keeping track of information about allocations
+// and deallocations.
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Platforms.h&quot;
+
+namespace Wm3
+{
+
+class WM3_ITEM Memory
+{
+public:
+    // The memory chunks have information prepended of the following data
+    // type.  The blocks are inserted and removed from a doubly linked list.
+    struct Block
+    {
+        size_t Size;
+        const char* File;
+        unsigned int Line;
+        bool IsArray;
+        Block* Prev;
+        Block* Next;
+    };
+
+    // read-write members
+    static size_t&amp; MaxAllowedBytes ();
+    static bool&amp; TrackSizes ();
+
+    // read-only members
+    static size_t GetNumNewCalls ();
+    static size_t GetNumDeleteCalls ();
+    static size_t GetNumBlocks ();
+    static size_t GetNumBytes ();
+    static size_t GetMaxAllocatedBytes ();
+    static size_t GetMaxBlockSize ();
+    static size_t GetHistogram (int i);
+
+    // For iteration over the current list of memory blocks.
+    static const Block* GetHead ();
+    static const Block* GetTail ();
+
+    // Generate a report about the current list memory blocks.
+    static void GenerateReport (const char* acFilename);
+
+private:
+    // Count the number of times the memory allocation/deallocation system
+    // has been entered.
+    static size_t ms_uiNumNewCalls;
+    static size_t ms_uiNumDeleteCalls;
+
+    // Set this value in your application if you want to know when NumBytes
+    // exceeds a maximum allowed number of bytes.  An 'assert' will be
+    // triggered in Allocate when this happens.  The default value is 0, in
+    // which case no comparison is made between NumBytes and MaxAllowedBytes.
+    static size_t ms_uiMaxAllowedBytes;
+
+    // The current number of allocated memory blocks.
+    static size_t ms_uiNumBlocks;
+
+    // The current number of allocated bytes.
+    static size_t ms_uiNumBytes;
+
+    // Doubly linked list of headers for the memory blocks.
+    static Block* ms_pkHead;
+    static Block* ms_pkTail;
+
+    // Set this variable to 'true' if you want the ms_uiMaxBlockSize and
+    // ms_auiHistogram[] elements to be computed.  The default is 'false'.
+    static bool ms_bTrackSizes;
+
+    // The maximum number of bytes allocated by the application.
+    static size_t ms_uiMaxAllocatedBytes;
+
+    // The size of the largest memory block allocated by the application.
+    static size_t ms_uiMaxBlockSize;
+
+    // Keep track of the number of allocated blocks of various sizes.  The
+    // element Histogram[0] stores the number of allocated blocks of size 1.
+    // The element Histogram[31] stores the number of allocated blocks of
+    // size larger than pow(2,30).  For 1 &lt;= i &lt;= 30, the element Histogram[i]
+    // stores the number of allocated blocks of size N, where
+    // pow(2,i-1) &lt; N &lt;= pow(2,i).
+    static size_t ms_auiHistogram[32];
+
+// internal use
+public:
+    static void* Allocate (size_t uiSize, char* acFile, unsigned int uiLine,
+        bool bIsArray);
+    static void Deallocate (char* pcAddr, bool bIsArray);
+    static void InsertBlock (Block* pkBlock);
+    static void RemoveBlock (Block* pkBlock);
+};
+
+#include &quot;Wm3Memory.inl&quot;
+
+}
+
+#define WM3_NEW new(__FILE__,__LINE__)
+#define WM3_DELETE delete
+
+void* operator new (size_t uiSize);
+void* operator new[](size_t uiSize);
+void* operator new (size_t uiSize, char* acFile, unsigned int uiLine);
+void* operator new[] (size_t uiSize, char* acFile, unsigned int uiLine);
+void operator delete (void* pvAddr);
+void operator delete[] (void* pvAddr);
+void operator delete (void* pvAddr, char* acFile, unsigned int uiLine);
+void operator delete[] (void* pvAddr, char* acFile, unsigned int uiLine);
+
+#endif
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Memory.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Memory.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Memory.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,72 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+inline size_t&amp; Memory::MaxAllowedBytes ()
+{
+    return ms_uiMaxAllowedBytes;
+}
+//----------------------------------------------------------------------------
+inline bool&amp; Memory::TrackSizes ()
+{
+    return ms_bTrackSizes;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetNumNewCalls ()
+{
+    return ms_uiNumNewCalls;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetNumDeleteCalls ()
+{
+    return ms_uiNumDeleteCalls;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetNumBlocks ()
+{
+    return ms_uiNumBlocks;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetNumBytes ()
+{
+    return ms_uiNumBytes;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetMaxAllocatedBytes ()
+{
+    return ms_uiMaxAllocatedBytes;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetMaxBlockSize ()
+{
+    return ms_uiMaxBlockSize;
+}
+//----------------------------------------------------------------------------
+inline size_t Memory::GetHistogram (int i)
+{
+    if (0 &lt;= i &amp;&amp; i &lt;= 31)
+    {
+        return ms_auiHistogram[i];
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+inline const Memory::Block* Memory::GetHead ()
+{
+    return ms_pkHead;
+}
+//----------------------------------------------------------------------------
+inline const Memory::Block* Memory::GetTail ()
+{
+    return ms_pkTail;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Plane3.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Plane3.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Plane3.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,71 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3PLANE3_H
+#define WM3PLANE3_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Vector3.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Plane3
+{
+public:
+    // The plane is represented as Dot(N,X) = c where N is a unit-length
+    // normal vector, c is the plane constant, and X is any point on the
+    // plane.  The user must ensure that the normal vector satisfies this
+    // condition.
+
+    Plane3 ();  // uninitialized
+    Plane3 (const Plane3&amp; rkPlane);
+
+    // specify N and c directly
+    Plane3 (const Vector3&lt;Real&gt;&amp; rkNormal, Real fConstant);
+
+    // N is specified, c = Dot(N,P) where P is on the plane
+    Plane3 (const Vector3&lt;Real&gt;&amp; rkNormal, const Vector3&lt;Real&gt;&amp; rkP);
+
+    // N = Cross(P1-P0,P2-P0)/Length(Cross(P1-P0,P2-P0)), c = Dot(N,P0) where
+    // P0, P1, P2 are points on the plane.
+    Plane3 (const Vector3&lt;Real&gt;&amp; rkP0, const Vector3&lt;Real&gt;&amp; rkP1,
+        const Vector3&lt;Real&gt;&amp; rkP2);
+
+    // assignment
+    Plane3&amp; operator= (const Plane3&amp; rkPlane);
+
+    // The &quot;positive side&quot; of the plane is the half space to which the plane
+    // normal points.  The &quot;negative side&quot; is the other half space.  The
+    // function returns +1 for the positive side, -1 for the negative side,
+    // and 0 for the point being on the plane.
+    int WhichSide (const Vector3&lt;Real&gt;&amp; rkP) const;
+
+    // Compute d = Dot(N,Q)-c where N is the plane normal and c is the plane
+    // constant.  This is a signed distance.  The sign of the return value is
+    // positive if the point is on the positive side of the plane, negative if
+    // the point is on the negative side, and zero if the point is on the
+    // plane.
+    Real DistanceTo (const Vector3&lt;Real&gt;&amp; rkQ) const;
+
+    Vector3&lt;Real&gt; Normal;
+    Real Constant;
+};
+
+#include &quot;Wm3Plane3.inl&quot;
+
+typedef Plane3&lt;float&gt; Plane3f;
+typedef Plane3&lt;double&gt; Plane3d;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Plane3.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Plane3.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Plane3.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,84 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;::Plane3 ()
+{
+    // uninitialized
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;::Plane3 (const Plane3&amp; rkPlane)
+    :
+    Normal(rkPlane.Normal)
+{
+    Constant = rkPlane.Constant;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;::Plane3 (const Vector3&lt;Real&gt;&amp; rkNormal, Real fConstant)
+    :
+    Normal(rkNormal)
+{
+    Constant = fConstant;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;::Plane3 (const Vector3&lt;Real&gt;&amp; rkNormal, const Vector3&lt;Real&gt;&amp; rkP)
+    :
+    Normal(rkNormal)
+{
+    Constant = rkNormal.Dot(rkP);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;::Plane3 (const Vector3&lt;Real&gt;&amp; rkP0, const Vector3&lt;Real&gt;&amp; rkP1,
+    const Vector3&lt;Real&gt;&amp; rkP2)
+{
+    Vector3&lt;Real&gt; kEdge1 = rkP1 - rkP0;
+    Vector3&lt;Real&gt; kEdge2 = rkP2 - rkP0;
+    Normal = kEdge1.UnitCross(kEdge2);
+    Constant = Normal.Dot(rkP0);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Plane3&lt;Real&gt;&amp; Plane3&lt;Real&gt;::operator= (const Plane3&amp; rkPlane)
+{
+    Normal = rkPlane.Normal;
+    Constant = rkPlane.Constant;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Plane3&lt;Real&gt;::DistanceTo (const Vector3&lt;Real&gt;&amp; rkP) const
+{
+    return Normal.Dot(rkP) - Constant;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Plane3&lt;Real&gt;::WhichSide (const Vector3&lt;Real&gt;&amp; rkQ) const
+{
+    Real fDistance = DistanceTo(rkQ);
+
+    if (fDistance &lt; (Real)0.0)
+    {
+        return -1;
+    }
+
+    if (fDistance &gt; (Real)0.0)
+    {
+        return +1;
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Platforms.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Platforms.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Platforms.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,140 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3PLATFORMS_H
+#define WM3PLATFORMS_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// Platform-specific information goes in this header file.  The defines to
+// control which platform is included are:
+//
+// MINGW      :  Minimalist GNU for Windows
+// _WIN32     :  Microsoft Windows 2000/XP
+// __APPLE__  :  Macintosh OS X (10.2.3 or higher required)
+// __sgi      :  Silicon Graphics Irix
+// __sun      :  Sun Solaris
+// &lt;none&gt;     :  Linux
+//
+// Add others as needed.
+
+//----------------------------------------------------------------------------
+// Minimalist GNU for Windows
+//----------------------------------------------------------------------------
+#if defined(MINGW)
+
+typedef long long Integer64;
+
+//----------------------------------------------------------------------------
+// Microsoft Windows 2000/XP platform
+//----------------------------------------------------------------------------
+#elif defined(_WIN32)
+
+#if defined(_MSC_VER)
+
+// Microsoft Visual C++ specific pragmas.  MSVC6 is version 12.00, MSVC7.0 is
+// version 13.00, and MSVC7.1 is version 13.10.  MSVC8.0 is version 14.00.
+#if _MSC_VER &lt; 1300
+#define WM3_USING_VC6
+#elif _MSC_VER &lt; 1310
+#define WM3_USING_VC70
+#elif _MSC_VER &lt; 1400
+#define WM3_USING_VC71
+#else
+#define WM3_USING_VC80
+#endif
+
+#if defined(WM3_USING_VC6)
+
+// Disable the warning &quot;non dll-interface class FOO used as base for
+// dll-interface class BAR.&quot;  These occur in the derivations
+// class Binary2D : public ImageInt2D; class Binary3D : public ImageInt3D;
+#pragma warning( disable : 4275 )
+
+// Disable the warning about truncating the debug names to 255 characters.
+// This warning shows up often with STL code in MSVC6, but not MSVC7.
+#pragma warning( disable : 4786 )
+
+// This warning is disabled because MSVC6 warns about not finding
+// implementations for the pure virtual functions that occur in the template
+// classes 'template &lt;class Real&gt;' when explicitly instantiating the classes.
+// NOTE:  If you create your own template classes that will be explicitly
+// instantiated, you should re-enable the warning to make sure that in fact
+// all your member data and functions have been defined and implemented.
+#pragma warning( disable : 4661 )
+
+#endif
+
+// The use of WM3_ITEM to export an entire class generates warnings when
+// member data and functions involving templates or inlines occur.  To avoid
+// the warning, WM3_ITEM can be applied only to those items that really need
+// to be exported.  I do not want to go to that effort.
+#pragma warning( disable : 4251 ) 
+
+// Enable the warning: &quot;loop control variable declared in the for-loop is
+// used outside the for-loop scope.  The default level 3 warnings do not
+// enable this (level 4 does), but should since allowing the outside scope
+// is a Microsoft extension.
+// #pragma warning( error : 4289 )
+
+typedef __int64 Integer64;
+
+#endif
+
+// Specialized instantiation of static members in template classes before or
+// after the class itself is instantiated is not a problem with Visual Studio
+// .NET 2003 (VC 7.1), but VC 6 likes the specialized instantiation to occur
+// after the class instantiation.
+// #define WM3_INSTANTIATE_BEFORE
+//----------------------------------------------------------------------------
+
+//----------------------------------------------------------------------------
+// Macintosh OS X platform
+//----------------------------------------------------------------------------
+#elif defined(__APPLE__)
+
+#if defined(__BIG_ENDIAN__)
+#define WM3_BIG_ENDIAN
+#else
+#define WM3_LITTLE_ENDIAN
+#endif
+
+#include &lt;stdint.h&gt;
+typedef int64_t Integer64;
+
+// g++ wants specialized template instantiations to occur after the explicit
+// class instantiations.  CodeWarrior wants them to occur before.
+#ifdef __MWERKS__
+#define WM3_INSTANTIATE_BEFORE
+#endif
+//----------------------------------------------------------------------------
+
+//----------------------------------------------------------------------------
+// Linux platform
+//----------------------------------------------------------------------------
+#else
+
+#include &lt;stdint.h&gt;
+typedef int64_t Integer64;
+
+// Linux on a PC. Red Hat 8.x g++ has problems with specialized instantiation
+// of static members in template classes *before* the class itself is
+// explicitly instantiated.  The problem is not consistent; for example, Math
+// Vector*, and Matrix* classes compile fine, but not Integrate1 or
+// BSplineRectangle.  So the following macro is *not* defined for this
+// platform.  If you have a Linux system that does appear to require the
+// instantiation before, then enable this macro.
+// #define WML_INSTANTIATE_BEFORE
+
+#endif
+//----------------------------------------------------------------------------
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Quaternion.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Quaternion.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Quaternion.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,26 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Quaternion.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Quaternion&lt;float&gt;
+    Quaternion&lt;float&gt;::IDENTITY(1.0f,0.0f,0.0f,0.0f);
+template&lt;&gt; const Quaternion&lt;float&gt;
+    Quaternion&lt;float&gt;::ZERO(0.0f,0.0f,0.0f,0.0f);
+template&lt;&gt; int Quaternion&lt;float&gt;::ms_iNext[3] = { 1, 2, 0 };
+
+template&lt;&gt; const Quaternion&lt;double&gt;
+    Quaternion&lt;double&gt;::IDENTITY(1.0,0.0,0.0,0.0);
+template&lt;&gt; const Quaternion&lt;double&gt;
+    Quaternion&lt;double&gt;::ZERO(0.0,0.0,0.0,0.0);
+template&lt;&gt; int Quaternion&lt;double&gt;::ms_iNext[3] = { 1, 2, 0 };
+

Added: branches/scons-layout/lib/miniWm3/Wm3Quaternion.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Quaternion.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Quaternion.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,162 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3QUATERNION_H
+#define WM3QUATERNION_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Matrix3.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Quaternion
+{
+public:
+    // A quaternion is q = w + x*i + y*j + z*k where (w,x,y,z) is not
+    // necessarily a unit length vector in 4D.
+
+    // construction
+    Quaternion ();  // uninitialized
+    Quaternion (Real fW, Real fX, Real fY, Real fZ);
+    Quaternion (const Quaternion&amp; rkQ);
+
+    // quaternion for the input rotation matrix
+    Quaternion (const Matrix3&lt;Real&gt;&amp; rkRot);
+
+    // quaternion for the rotation of the axis-angle pair
+    Quaternion (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle);
+
+    // quaternion for the rotation matrix with specified columns
+    Quaternion (const Vector3&lt;Real&gt; akRotColumn[3]);
+
+    // member access:  0 = w, 1 = x, 2 = y, 3 = z
+    operator const Real* () const;
+    operator Real* ();
+    Real operator[] (int i) const;
+    Real&amp; operator[] (int i);
+    Real W () const;
+    Real&amp; W ();
+    Real X () const;
+    Real&amp; X ();
+    Real Y () const;
+    Real&amp; Y ();
+    Real Z () const;
+    Real&amp; Z ();
+
+    // assignment
+    Quaternion&amp; operator= (const Quaternion&amp; rkQ);
+
+    // comparison
+    bool operator== (const Quaternion&amp; rkQ) const;
+    bool operator!= (const Quaternion&amp; rkQ) const;
+    bool operator&lt;  (const Quaternion&amp; rkQ) const;
+    bool operator&lt;= (const Quaternion&amp; rkQ) const;
+    bool operator&gt;  (const Quaternion&amp; rkQ) const;
+    bool operator&gt;= (const Quaternion&amp; rkQ) const;
+
+    // arithmetic operations
+    Quaternion operator+ (const Quaternion&amp; rkQ) const;
+    Quaternion operator- (const Quaternion&amp; rkQ) const;
+    Quaternion operator* (const Quaternion&amp; rkQ) const;
+    Quaternion operator* (Real fScalar) const;
+    Quaternion operator/ (Real fScalar) const;
+    Quaternion operator- () const;
+
+    // arithmetic updates
+    Quaternion&amp; operator+= (const Quaternion&amp; rkQ);
+    Quaternion&amp; operator-= (const Quaternion&amp; rkQ);
+    Quaternion&amp; operator*= (Real fScalar);
+    Quaternion&amp; operator/= (Real fScalar);
+
+    // conversion between quaternions, matrices, and axis-angle
+    Quaternion&amp; FromRotationMatrix (const Matrix3&lt;Real&gt;&amp; rkRot);
+    void ToRotationMatrix (Matrix3&lt;Real&gt;&amp; rkRot) const;
+    Quaternion&amp; FromRotationMatrix (const Vector3&lt;Real&gt; akRotColumn[3]);
+    void ToRotationMatrix (Vector3&lt;Real&gt; akRotColumn[3]) const;
+    Quaternion&amp; FromAxisAngle (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle);
+    void ToAxisAngle (Vector3&lt;Real&gt;&amp; rkAxis, Real&amp; rfAngle) const;
+
+    // functions of a quaternion
+    Real Length () const;  // length of 4-tuple
+    Real SquaredLength () const;  // squared length of 4-tuple
+    Real Dot (const Quaternion&amp; rkQ) const;  // dot product of 4-tuples
+    Real Normalize ();  // make the 4-tuple unit length
+    Quaternion Inverse () const;  // apply to non-zero quaternion
+    Quaternion Conjugate () const;
+    Quaternion Exp () const;  // apply to quaternion with w = 0
+    Quaternion Log () const;  // apply to unit-length quaternion
+
+    // rotation of a vector by a quaternion
+    Vector3&lt;Real&gt; Rotate (const Vector3&lt;Real&gt;&amp; rkVector) const;
+
+    // spherical linear interpolation
+    Quaternion&amp; Slerp (Real fT, const Quaternion&amp; rkP, const Quaternion&amp; rkQ);
+
+    Quaternion&amp; SlerpExtraSpins (Real fT, const Quaternion&amp; rkP,
+        const Quaternion&amp; rkQ, int iExtraSpins);
+
+    // intermediate terms for spherical quadratic interpolation
+    Quaternion&amp; Intermediate (const Quaternion&amp; rkQ0,
+        const Quaternion&amp; rkQ1, const Quaternion&amp; rkQ2);
+
+    // spherical quadratic interpolation
+    Quaternion&amp; Squad (Real fT, const Quaternion&amp; rkQ0,
+        const Quaternion&amp; rkA0, const Quaternion&amp; rkA1,
+        const Quaternion&amp; rkQ1);
+
+    // Compute a quaternion that rotates unit-length vector V1 to unit-length
+    // vector V2.  The rotation is about the axis perpendicular to both V1 and
+    // V2, with angle of that between V1 and V2.  If V1 and V2 are parallel,
+    // any axis of rotation will do, such as the permutation (z2,x2,y2), where
+    // V2 = (x2,y2,z2).
+    Quaternion&amp; Align (const Vector3&lt;Real&gt;&amp; rkV1, const Vector3&lt;Real&gt;&amp; rkV2);
+
+    // Decompose a quaternion into q = q_twist * q_swing, where q is 'this'
+    // quaternion.  If V1 is the input axis and V2 is the rotation of V1 by
+    // q, q_swing represents the rotation about the axis perpendicular to
+    // V1 and V2 (see Quaternion::Align), and q_twist is a rotation about V1.
+    void DecomposeTwistTimesSwing (const Vector3&lt;Real&gt;&amp; rkV1,
+        Quaternion&amp; rkTwist, Quaternion&amp; rkSwing);
+
+    // Decompose a quaternion into q = q_swing * q_twist, where q is 'this'
+    // quaternion.  If V1 is the input axis and V2 is the rotation of V1 by
+    // q, q_swing represents the rotation about the axis perpendicular to
+    // V1 and V2 (see Quaternion::Align), and q_twist is a rotation about V1.
+    void DecomposeSwingTimesTwist (const Vector3&lt;Real&gt;&amp; rkV1,
+        Quaternion&amp; rkSwing, Quaternion&amp; rkTwist);
+
+    // special values
+    WM3_ITEM static const Quaternion IDENTITY;  // the identity rotation
+    WM3_ITEM static const Quaternion ZERO;
+
+private:
+    // support for comparisons
+    int CompareArrays (const Quaternion&amp; rkQ) const;
+
+    // support for FromRotationMatrix
+    static int ms_iNext[3];
+
+    Real m_afTuple[4];
+};
+
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; operator* (Real fScalar, const Quaternion&lt;Real&gt;&amp; rkQ);
+
+#include &quot;Wm3Quaternion.inl&quot;
+
+typedef Quaternion&lt;float&gt; Quaternionf;
+typedef Quaternion&lt;double&gt; Quaterniond;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3Quaternion.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Quaternion.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Quaternion.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,843 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion ()
+{
+    // uninitialized for performance in array construction
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion (Real fW, Real fX, Real fY, Real fZ)
+{
+    m_afTuple[0] = fW;
+    m_afTuple[1] = fX;
+    m_afTuple[2] = fY;
+    m_afTuple[3] = fZ;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion (const Quaternion&amp; rkQ)
+{
+    size_t uiSize = 4*sizeof(Real);
+    System::Memcpy(m_afTuple,uiSize,rkQ.m_afTuple,uiSize);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion (const Matrix3&lt;Real&gt;&amp; rkRot)
+{
+    FromRotationMatrix(rkRot);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion (const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle)
+{
+    FromAxisAngle(rkAxis,fAngle);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::Quaternion (const Vector3&lt;Real&gt; akRotColumn[3])
+{
+    FromRotationMatrix(akRotColumn);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::operator const Real* () const
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;::operator Real* ()
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 3);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Quaternion&lt;Real&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 3);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::W () const
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Quaternion&lt;Real&gt;::W ()
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::X () const
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Quaternion&lt;Real&gt;::X ()
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::Y () const
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Quaternion&lt;Real&gt;::Y ()
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::Z () const
+{
+    return m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Quaternion&lt;Real&gt;::Z ()
+{
+    return m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::operator= (const Quaternion&amp; rkQ)
+{
+    size_t uiSize = 4*sizeof(Real);
+    System::Memcpy(m_afTuple,uiSize,rkQ.m_afTuple,uiSize);
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Quaternion&lt;Real&gt;::CompareArrays (const Quaternion&amp; rkQ) const
+{
+    return memcmp(m_afTuple,rkQ.m_afTuple,4*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator== (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator!= (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator&lt; (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator&lt;= (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator&gt; (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Quaternion&lt;Real&gt;::operator&gt;= (const Quaternion&amp; rkQ) const
+{
+    return CompareArrays(rkQ) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator+ (const Quaternion&amp; rkQ) const
+{
+    Quaternion kSum;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kSum.m_afTuple[i] = m_afTuple[i] + rkQ.m_afTuple[i];
+    }
+    return kSum;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator- (const Quaternion&amp; rkQ) const
+{
+    Quaternion kDiff;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kDiff.m_afTuple[i] = m_afTuple[i] - rkQ.m_afTuple[i];
+    }
+    return kDiff;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator* (const Quaternion&amp; rkQ) const
+{
+    // NOTE:  Multiplication is not generally commutative, so in most
+    // cases p*q != q*p.
+
+    Quaternion kProd;
+
+    kProd.m_afTuple[0] =
+        m_afTuple[0]*rkQ.m_afTuple[0] -
+        m_afTuple[1]*rkQ.m_afTuple[1] -
+        m_afTuple[2]*rkQ.m_afTuple[2] -
+        m_afTuple[3]*rkQ.m_afTuple[3];
+
+    kProd.m_afTuple[1] =
+        m_afTuple[0]*rkQ.m_afTuple[1] +
+        m_afTuple[1]*rkQ.m_afTuple[0] +
+        m_afTuple[2]*rkQ.m_afTuple[3] -
+        m_afTuple[3]*rkQ.m_afTuple[2];
+
+    kProd.m_afTuple[2] =
+        m_afTuple[0]*rkQ.m_afTuple[2] +
+        m_afTuple[2]*rkQ.m_afTuple[0] +
+        m_afTuple[3]*rkQ.m_afTuple[1] -
+        m_afTuple[1]*rkQ.m_afTuple[3];
+
+    kProd.m_afTuple[3] =
+        m_afTuple[0]*rkQ.m_afTuple[3] +
+        m_afTuple[3]*rkQ.m_afTuple[0] +
+        m_afTuple[1]*rkQ.m_afTuple[2] -
+        m_afTuple[2]*rkQ.m_afTuple[1];
+
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator* (Real fScalar) const
+{
+    Quaternion kProd;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kProd.m_afTuple[i] = fScalar*m_afTuple[i];
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Quaternion kQuot;
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 4; i++)
+        {
+            kQuot.m_afTuple[i] = fInvScalar*m_afTuple[i];
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 4; i++)
+        {
+            kQuot.m_afTuple[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::operator- () const
+{
+    Quaternion kNeg;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kNeg.m_afTuple[i] = -m_afTuple[i];
+    }
+    return kNeg;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; operator* (Real fScalar, const Quaternion&lt;Real&gt;&amp; rkQ)
+{
+    Quaternion&lt;Real&gt; kProd;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        kProd[i] = fScalar*rkQ[i];
+    }
+    return kProd;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::operator+= (const Quaternion&amp; rkQ)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afTuple[i] += rkQ.m_afTuple[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::operator-= (const Quaternion&amp; rkQ)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afTuple[i] -= rkQ.m_afTuple[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::operator*= (Real fScalar)
+{
+    for (int i = 0; i &lt; 4; i++)
+    {
+        m_afTuple[i] *= fScalar;
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::operator/= (Real fScalar)
+{
+    int i;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afTuple[i] *= fInvScalar;
+        }
+    }
+    else
+    {
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afTuple[i] = Math&lt;Real&gt;::MAX_REAL;
+        }
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::FromRotationMatrix (
+    const Matrix3&lt;Real&gt;&amp; rkRot)
+{
+    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
+    // article &quot;Quaternion Calculus and Fast Animation&quot;.
+
+    Real fTrace = rkRot(0,0) + rkRot(1,1) + rkRot(2,2);
+    Real fRoot;
+
+    if (fTrace &gt; (Real)0.0)
+    {
+        // |w| &gt; 1/2, may as well choose w &gt; 1/2
+        fRoot = Math&lt;Real&gt;::Sqrt(fTrace + (Real)1.0);  // 2w
+        m_afTuple[0] = ((Real)0.5)*fRoot;
+        fRoot = ((Real)0.5)/fRoot;  // 1/(4w)
+        m_afTuple[1] = (rkRot(2,1)-rkRot(1,2))*fRoot;
+        m_afTuple[2] = (rkRot(0,2)-rkRot(2,0))*fRoot;
+        m_afTuple[3] = (rkRot(1,0)-rkRot(0,1))*fRoot;
+    }
+    else
+    {
+        // |w| &lt;= 1/2
+        int i = 0;
+        if (rkRot(1,1) &gt; rkRot(0,0))
+        {
+            i = 1;
+        }
+        if (rkRot(2,2) &gt; rkRot(i,i))
+        {
+            i = 2;
+        }
+        int j = ms_iNext[i];
+        int k = ms_iNext[j];
+
+        fRoot = Math&lt;Real&gt;::Sqrt(rkRot(i,i)-rkRot(j,j)-rkRot(k,k)+(Real)1.0);
+        Real* apfQuat[3] = { &amp;m_afTuple[1], &amp;m_afTuple[2], &amp;m_afTuple[3] };
+        *apfQuat[i] = ((Real)0.5)*fRoot;
+        fRoot = ((Real)0.5)/fRoot;
+        m_afTuple[0] = (rkRot(k,j)-rkRot(j,k))*fRoot;
+        *apfQuat[j] = (rkRot(j,i)+rkRot(i,j))*fRoot;
+        *apfQuat[k] = (rkRot(k,i)+rkRot(i,k))*fRoot;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Quaternion&lt;Real&gt;::ToRotationMatrix (Matrix3&lt;Real&gt;&amp; rkRot) const
+{
+    Real fTx  = ((Real)2.0)*m_afTuple[1];
+    Real fTy  = ((Real)2.0)*m_afTuple[2];
+    Real fTz  = ((Real)2.0)*m_afTuple[3];
+    Real fTwx = fTx*m_afTuple[0];
+    Real fTwy = fTy*m_afTuple[0];
+    Real fTwz = fTz*m_afTuple[0];
+    Real fTxx = fTx*m_afTuple[1];
+    Real fTxy = fTy*m_afTuple[1];
+    Real fTxz = fTz*m_afTuple[1];
+    Real fTyy = fTy*m_afTuple[2];
+    Real fTyz = fTz*m_afTuple[2];
+    Real fTzz = fTz*m_afTuple[3];
+
+    rkRot(0,0) = (Real)1.0-(fTyy+fTzz);
+    rkRot(0,1) = fTxy-fTwz;
+    rkRot(0,2) = fTxz+fTwy;
+    rkRot(1,0) = fTxy+fTwz;
+    rkRot(1,1) = (Real)1.0-(fTxx+fTzz);
+    rkRot(1,2) = fTyz-fTwx;
+    rkRot(2,0) = fTxz-fTwy;
+    rkRot(2,1) = fTyz+fTwx;
+    rkRot(2,2) = (Real)1.0-(fTxx+fTyy);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::FromRotationMatrix (
+    const Vector3&lt;Real&gt; akRotColumn[3])
+{
+    Matrix3&lt;Real&gt; kRot;
+    for (int iCol = 0; iCol &lt; 3; iCol++)
+    {
+        kRot(0,iCol) = akRotColumn[iCol][0];
+        kRot(1,iCol) = akRotColumn[iCol][1];
+        kRot(2,iCol) = akRotColumn[iCol][2];
+    }
+    return FromRotationMatrix(kRot);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Quaternion&lt;Real&gt;::ToRotationMatrix (Vector3&lt;Real&gt; akRotColumn[3]) const
+{
+    Matrix3&lt;Real&gt; kRot;
+    ToRotationMatrix(kRot);
+    for (int iCol = 0; iCol &lt; 3; iCol++)
+    {
+        akRotColumn[iCol][0] = kRot(0,iCol);
+        akRotColumn[iCol][1] = kRot(1,iCol);
+        akRotColumn[iCol][2] = kRot(2,iCol);
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::FromAxisAngle (
+    const Vector3&lt;Real&gt;&amp; rkAxis, Real fAngle)
+{
+    // assert:  axis[] is unit length
+    //
+    // The quaternion representing the rotation is
+    //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
+
+    Real fHalfAngle = ((Real)0.5)*fAngle;
+    Real fSin = Math&lt;Real&gt;::Sin(fHalfAngle);
+    m_afTuple[0] = Math&lt;Real&gt;::Cos(fHalfAngle);
+    m_afTuple[1] = fSin*rkAxis[0];
+    m_afTuple[2] = fSin*rkAxis[1];
+    m_afTuple[3] = fSin*rkAxis[2];
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Quaternion&lt;Real&gt;::ToAxisAngle (Vector3&lt;Real&gt;&amp; rkAxis, Real&amp; rfAngle)
+    const
+{
+    // The quaternion representing the rotation is
+    //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
+
+    Real fSqrLength = m_afTuple[1]*m_afTuple[1] + m_afTuple[2]*m_afTuple[2]
+        + m_afTuple[3]*m_afTuple[3];
+    if (fSqrLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        rfAngle = ((Real)2.0)*Math&lt;Real&gt;::ACos(m_afTuple[0]);
+        Real fInvLength = Math&lt;Real&gt;::InvSqrt(fSqrLength);
+        rkAxis[0] = m_afTuple[1]*fInvLength;
+        rkAxis[1] = m_afTuple[2]*fInvLength;
+        rkAxis[2] = m_afTuple[3]*fInvLength;
+    }
+    else
+    {
+        // angle is 0 (mod 2*pi), so any axis will do
+        rfAngle = (Real)0.0;
+        rkAxis[0] = (Real)1.0;
+        rkAxis[1] = (Real)0.0;
+        rkAxis[2] = (Real)0.0;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::Length () const
+{
+    return Math&lt;Real&gt;::Sqrt(
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2] +
+        m_afTuple[3]*m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::SquaredLength () const
+{
+    return
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2] +
+        m_afTuple[3]*m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::Dot (const Quaternion&amp; rkQ) const
+{
+    Real fDot = (Real)0.0;
+    for (int i = 0; i &lt; 4; i++)
+    {
+        fDot += m_afTuple[i]*rkQ.m_afTuple[i];
+    }
+    return fDot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Quaternion&lt;Real&gt;::Normalize ()
+{
+    Real fLength = Length();
+    int i;
+
+    if (fLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvLength = ((Real)1.0)/fLength;
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afTuple[i] *= fInvLength;
+        }
+    }
+    else
+    {
+        fLength = (Real)0.0;
+        for (i = 0; i &lt; 4; i++)
+        {
+            m_afTuple[i] = (Real)0.0;
+        }
+    }
+
+    return fLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::Inverse () const
+{
+    Quaternion kInverse;
+
+    Real fNorm = (Real)0.0;
+    int i;
+    for (i = 0; i &lt; 4; i++)
+    {
+        fNorm += m_afTuple[i]*m_afTuple[i];
+    }
+
+    if (fNorm &gt; (Real)0.0)
+    {
+        Real fInvNorm = ((Real)1.0)/fNorm;
+        kInverse.m_afTuple[0] = m_afTuple[0]*fInvNorm;
+        kInverse.m_afTuple[1] = -m_afTuple[1]*fInvNorm;
+        kInverse.m_afTuple[2] = -m_afTuple[2]*fInvNorm;
+        kInverse.m_afTuple[3] = -m_afTuple[3]*fInvNorm;
+    }
+    else
+    {
+        // return an invalid result to flag the error
+        for (i = 0; i &lt; 4; i++)
+        {
+            kInverse.m_afTuple[i] = (Real)0.0;
+        }
+    }
+
+    return kInverse;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::Conjugate () const
+{
+    return Quaternion(m_afTuple[0],-m_afTuple[1],-m_afTuple[2],
+        -m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::Exp () const
+{
+    // If q = A*(x*i+y*j+z*k) where (x,y,z) is unit length, then
+    // exp(q) = cos(A)+sin(A)*(x*i+y*j+z*k).  If sin(A) is near zero,
+    // use exp(q) = cos(A)+A*(x*i+y*j+z*k) since A/sin(A) has limit 1.
+
+    Quaternion kResult;
+
+    Real fAngle = Math&lt;Real&gt;::Sqrt(m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2] + m_afTuple[3]*m_afTuple[3]);
+
+    Real fSin = Math&lt;Real&gt;::Sin(fAngle);
+    kResult.m_afTuple[0] = Math&lt;Real&gt;::Cos(fAngle);
+
+    int i;
+
+    if (Math&lt;Real&gt;::FAbs(fSin) &gt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fCoeff = fSin/fAngle;
+        for (i = 1; i &lt;= 3; i++)
+        {
+            kResult.m_afTuple[i] = fCoeff*m_afTuple[i];
+        }
+    }
+    else
+    {
+        for (i = 1; i &lt;= 3; i++)
+        {
+            kResult.m_afTuple[i] = m_afTuple[i];
+        }
+    }
+
+    return kResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt; Quaternion&lt;Real&gt;::Log () const
+{
+    // If q = cos(A)+sin(A)*(x*i+y*j+z*k) where (x,y,z) is unit length, then
+    // log(q) = A*(x*i+y*j+z*k).  If sin(A) is near zero, use log(q) =
+    // sin(A)*(x*i+y*j+z*k) since sin(A)/A has limit 1.
+
+    Quaternion kResult;
+    kResult.m_afTuple[0] = (Real)0.0;
+
+    int i;
+
+    if (Math&lt;Real&gt;::FAbs(m_afTuple[0]) &lt; (Real)1.0)
+    {
+        Real fAngle = Math&lt;Real&gt;::ACos(m_afTuple[0]);
+        Real fSin = Math&lt;Real&gt;::Sin(fAngle);
+        if (Math&lt;Real&gt;::FAbs(fSin) &gt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+        {
+            Real fCoeff = fAngle/fSin;
+            for (i = 1; i &lt;= 3; i++)
+            {
+                kResult.m_afTuple[i] = fCoeff*m_afTuple[i];
+            }
+            return kResult;
+        }
+    }
+
+    for (i = 1; i &lt;= 3; i++)
+    {
+        kResult.m_afTuple[i] = m_afTuple[i];
+    }
+    return kResult;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Quaternion&lt;Real&gt;::Rotate (const Vector3&lt;Real&gt;&amp; rkVector) const
+{
+    // Given a vector u = (x0,y0,z0) and a unit length quaternion
+    // q = &lt;w,x,y,z&gt;, the vector v = (x1,y1,z1) which represents the
+    // rotation of u by q is v = q*u*q^{-1} where * indicates quaternion
+    // multiplication and where u is treated as the quaternion &lt;0,x0,y0,z0&gt;.
+    // Note that q^{-1} = &lt;w,-x,-y,-z&gt;, so no real work is required to
+    // invert q.  Now
+    //
+    //   q*u*q^{-1} = q*&lt;0,x0,y0,z0&gt;*q^{-1}
+    //     = q*(x0*i+y0*j+z0*k)*q^{-1}
+    //     = x0*(q*i*q^{-1})+y0*(q*j*q^{-1})+z0*(q*k*q^{-1})
+    //
+    // As 3-vectors, q*i*q^{-1}, q*j*q^{-1}, and 2*k*q^{-1} are the columns
+    // of the rotation matrix computed in Quaternion&lt;Real&gt;::ToRotationMatrix.
+    // The vector v is obtained as the product of that rotation matrix with
+    // vector u.  As such, the quaternion representation of a rotation
+    // matrix requires less space than the matrix and more time to compute
+    // the rotated vector.  Typical space-time tradeoff...
+
+    Matrix3&lt;Real&gt; kRot;
+    ToRotationMatrix(kRot);
+    return kRot*rkVector;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::Slerp (Real fT, const Quaternion&amp; rkP,
+    const Quaternion&amp; rkQ)
+{
+    Real fCos = rkP.Dot(rkQ);
+    Real fAngle = Math&lt;Real&gt;::ACos(fCos);
+
+    if (Math&lt;Real&gt;::FAbs(fAngle) &gt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fSin = Math&lt;Real&gt;::Sin(fAngle);
+        Real fInvSin = ((Real)1.0)/fSin;
+        Real fCoeff0 = Math&lt;Real&gt;::Sin(((Real)1.0-fT)*fAngle)*fInvSin;
+        Real fCoeff1 = Math&lt;Real&gt;::Sin(fT*fAngle)*fInvSin;
+        *this = fCoeff0*rkP + fCoeff1*rkQ;
+    }
+    else
+    {
+        *this = rkP;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::SlerpExtraSpins (Real fT,
+    const Quaternion&amp; rkP, const Quaternion&amp; rkQ, int iExtraSpins)
+{
+    Real fCos = rkP.Dot(rkQ);
+    Real fAngle = Math&lt;Real&gt;::ACos(fCos);
+
+    if (Math&lt;Real&gt;::FAbs(fAngle) &gt;= Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fSin = Math&lt;Real&gt;::Sin(fAngle);
+        Real fPhase = Math&lt;Real&gt;::PI*iExtraSpins*fT;
+        Real fInvSin = ((Real)1.0)/fSin;
+        Real fCoeff0 = Math&lt;Real&gt;::Sin(((Real)1.0-fT)*fAngle-fPhase)*fInvSin;
+        Real fCoeff1 = Math&lt;Real&gt;::Sin(fT*fAngle + fPhase)*fInvSin;
+        *this = fCoeff0*rkP + fCoeff1*rkQ;
+    }
+    else
+    {
+        *this = rkP;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::Intermediate (const Quaternion&amp; rkQ0,
+    const Quaternion&amp; rkQ1, const Quaternion&amp; rkQ2)
+{
+    // assert:  Q0, Q1, Q2 all unit-length
+    Quaternion kQ1Inv = rkQ1.Conjugate();
+    Quaternion kP0 = kQ1Inv*rkQ0;
+    Quaternion kP2 = kQ1Inv*rkQ2;
+    Quaternion kArg = -((Real)0.25)*(kP0.Log()+kP2.Log());
+    Quaternion kA = rkQ1*kArg.Exp();
+    *this = kA;
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::Squad (Real fT, const Quaternion&amp; rkQ0,
+    const Quaternion&amp; rkA0, const Quaternion&amp; rkA1, const Quaternion&amp; rkQ1)
+{
+    Real fSlerpT = ((Real)2.0)*fT*((Real)1.0-fT);
+    Quaternion kSlerpP = Slerp(fT,rkQ0,rkQ1);
+    Quaternion kSlerpQ = Slerp(fT,rkA0,rkA1);
+    return Slerp(fSlerpT,kSlerpP,kSlerpQ);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Quaternion&lt;Real&gt;&amp; Quaternion&lt;Real&gt;::Align (const Vector3&lt;Real&gt;&amp; rkV1,
+    const Vector3&lt;Real&gt;&amp; rkV2)
+{
+    // If V1 and V2 are not parallel, the axis of rotation is the unit-length
+    // vector U = Cross(V1,V2)/Length(Cross(V1,V2)).  The angle of rotation,
+    // A, is the angle between V1 and V2.  The quaternion for the rotation is
+    // q = cos(A/2) + sin(A/2)*(ux*i+uy*j+uz*k) where U = (ux,uy,uz).
+    //
+    // (1) Rather than extract A = acos(Dot(V1,V2)), multiply by 1/2, then
+    //     compute sin(A/2) and cos(A/2), we reduce the computational costs by
+    //     computing the bisector B = (V1+V2)/Length(V1+V2), so cos(A/2) =
+    //     Dot(V1,B).
+    //
+    // (2) The rotation axis is U = Cross(V1,B)/Length(Cross(V1,B)), but
+    //     Length(Cross(V1,B)) = Length(V1)*Length(B)*sin(A/2) = sin(A/2), in
+    //     which case sin(A/2)*(ux*i+uy*j+uz*k) = (cx*i+cy*j+cz*k) where
+    //     C = Cross(V1,B).
+    //
+    // If V1 = V2, then B = V1, cos(A/2) = 1, and U = (0,0,0).  If V1 = -V2,
+    // then B = 0.  This can happen even if V1 is approximately -V2 using
+    // floating point arithmetic, since Vector3::Normalize checks for
+    // closeness to zero and returns the zero vector accordingly.  The test
+    // for exactly zero is usually not recommend for floating point
+    // arithmetic, but the implementation of Vector3::Normalize guarantees
+    // the comparison is robust.  In this case, the A = pi and any axis
+    // perpendicular to V1 may be used as the rotation axis.
+
+    Vector3&lt;Real&gt; kBisector = rkV1 + rkV2;
+    kBisector.Normalize();
+
+    Real fCosHalfAngle = rkV1.Dot(kBisector);
+    Vector3&lt;Real&gt; kCross;
+
+    m_afTuple[0] = fCosHalfAngle;
+
+    if (fCosHalfAngle != (Real)0.0)
+    {
+        kCross = rkV1.Cross(kBisector);
+        m_afTuple[1] = kCross.X();
+        m_afTuple[2] = kCross.Y();
+        m_afTuple[3] = kCross.Z();
+    }
+    else
+    {
+        Real fInvLength;
+        if (Math&lt;Real&gt;::FAbs(rkV1[0]) &gt;= Math&lt;Real&gt;::FAbs(rkV1[1]))
+        {
+            // V1.x or V1.z is the largest magnitude component
+            fInvLength = Math&lt;Real&gt;::InvSqrt(rkV1[0]*rkV1[0] +
+                rkV1[2]*rkV1[2]);
+            m_afTuple[1] = -rkV1[2]*fInvLength;
+            m_afTuple[2] = (Real)0.0;
+            m_afTuple[3] = +rkV1[0]*fInvLength;
+        }
+        else
+        {
+            // V1.y or V1.z is the largest magnitude component
+            fInvLength = Math&lt;Real&gt;::InvSqrt(rkV1[1]*rkV1[1] +
+                rkV1[2]*rkV1[2]);
+            m_afTuple[1] = (Real)0.0;
+            m_afTuple[2] = +rkV1[2]*fInvLength;
+            m_afTuple[3] = -rkV1[1]*fInvLength;
+        }
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Quaternion&lt;Real&gt;::DecomposeTwistTimesSwing (
+    const Vector3&lt;Real&gt;&amp; rkV1, Quaternion&amp; rkTwist, Quaternion&amp; rkSwing)
+{
+    Vector3&lt;Real&gt; kV2 = Rotate(rkV1);
+    rkSwing = Align(rkV1,kV2);
+    rkTwist = (*this)*rkSwing.Conjugate();
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Quaternion&lt;Real&gt;::DecomposeSwingTimesTwist (
+    const Vector3&lt;Real&gt;&amp; rkV1, Quaternion&amp; rkSwing, Quaternion&amp; rkTwist)
+{
+    Vector3&lt;Real&gt; kV2 = Rotate(rkV1);
+    rkSwing = Align(rkV1,kV2);
+    rkTwist = rkSwing.Conjugate()*(*this);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3String.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3String.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3String.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,159 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3String.h&quot;
+using namespace Wm3;
+
+//----------------------------------------------------------------------------
+String::String (const char* acText)
+{
+    if (acText)
+    {
+        m_iLength = (int)strlen(acText);
+        m_acText = WM3_NEW char[m_iLength+1];
+        const size_t uiSize = (size_t)(m_iLength + 1);
+        System::Strcpy(m_acText,uiSize,acText);
+    }
+    else
+    {
+        m_iLength = 0;
+        m_acText = WM3_NEW char[1];
+        m_acText[0] = 0;
+    }
+}
+//----------------------------------------------------------------------------
+String::String (int iLength, const char* acText)
+{
+    if (iLength &lt; 0 || (iLength &gt; 0 &amp;&amp; !acText))
+    {
+        assert(false);
+        iLength = 0;
+    }
+
+#ifdef _DEBUG
+    // make sure acText has as many non-null characters as specified
+    if (iLength &gt; 0)
+    {
+        int i;
+        for (i = 0; i &lt; iLength; i++)
+        {
+            if (acText[i] == 0)
+            {
+                break;
+            }
+        }
+        assert(i == iLength);
+    }
+#endif
+
+    m_iLength = iLength;
+    if (m_iLength &gt; 0)
+    {
+        const size_t uiSrcSize = (size_t)m_iLength;
+        const size_t uiDstSize = (size_t)(m_iLength + 1);
+        m_acText = WM3_NEW char[uiDstSize];
+        System::Strncpy(m_acText,uiDstSize,acText,uiSrcSize);
+        m_acText[m_iLength] = 0;
+    }
+    else
+    {
+        m_acText = WM3_NEW char[1];
+        m_acText[0] = 0;
+    }
+}
+//----------------------------------------------------------------------------
+String::String (const String&amp; rkString)
+{
+    m_acText = 0;
+    *this = rkString;
+}
+//----------------------------------------------------------------------------
+String::~String ()
+{
+    WM3_DELETE[] m_acText;
+}
+//----------------------------------------------------------------------------
+String&amp; String::operator= (const String&amp; rkString)
+{
+    m_iLength = rkString.m_iLength;
+    WM3_DELETE[] m_acText;
+    const size_t uiSize = (size_t)(m_iLength + 1);
+    m_acText = WM3_NEW char[uiSize];
+    System::Strcpy(m_acText,uiSize,rkString.m_acText);
+    return *this;
+}
+//----------------------------------------------------------------------------
+String&amp; String::operator+= (const String&amp; rkString)
+{
+    m_iLength += rkString.m_iLength;
+    const size_t uiSize = (size_t)(m_iLength + 1);
+    char* acNew = WM3_NEW char[uiSize];
+    System::Strcpy(acNew,uiSize,m_acText);
+    WM3_DELETE[] m_acText;
+    m_acText = System::Strcat(acNew,uiSize,rkString.m_acText);   
+    return *this;
+}
+//----------------------------------------------------------------------------
+String String::operator+ (const String&amp; rkString)
+{
+    int iLength = m_iLength + rkString.m_iLength;
+    const size_t uiSize = (size_t)(iLength + 1);
+    char* acNew = WM3_NEW char[uiSize];
+    System::Strcpy(acNew,uiSize,m_acText);
+    System::Strcat(acNew,uiSize,rkString.m_acText);
+    String kAppended(iLength,acNew);
+    WM3_DELETE[] acNew;
+    return kAppended;
+}
+//----------------------------------------------------------------------------
+bool String::operator== (const String&amp; rkString) const
+{
+    return m_iLength == rkString.m_iLength
+        &amp;&amp; memcmp(m_acText,rkString.m_acText,m_iLength) == 0;
+}
+//----------------------------------------------------------------------------
+bool String::operator!= (const String&amp; rkString) const
+{
+    return m_iLength != rkString.m_iLength
+        || memcmp(m_acText,rkString.m_acText,m_iLength) != 0;
+}
+//----------------------------------------------------------------------------
+String::operator unsigned int () const
+{
+    unsigned int uiKey = 0;
+    for (int i = 0; i &lt; m_iLength; i++)
+    {
+        uiKey += (uiKey &lt;&lt; 5) + m_acText[i];
+    }
+    return uiKey;
+}
+//----------------------------------------------------------------------------
+String String::ToUpper () const
+{
+    String kCopy(*this);
+    for (int i = 0; i &lt; m_iLength; i++)
+    {
+        kCopy.m_acText[i] = toupper(m_acText[i]);
+    }
+    return kCopy;
+}
+//----------------------------------------------------------------------------
+String String::ToLower () const
+{
+    String kCopy(*this);
+    for (int i = 0; i &lt; m_iLength; i++)
+    {
+        kCopy.m_acText[i] = tolower(m_acText[i]);
+    }
+    return kCopy;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3String.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3String.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3String.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,63 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3STRING_H
+#define WM3STRING_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3System.h&quot;
+
+namespace Wm3
+{
+
+class WM3_ITEM String
+{
+public:
+    // construction and destruction
+    String (const char* acText = 0);
+    String (int iLength, const char* acText);
+    String (const String&amp; rkString);
+    ~String ();
+
+    // member access
+    int GetLength () const;
+    operator const char* () const;
+
+    // assignment, comparisons, implicit conversion (support for hash tables)
+    String&amp; operator= (const String&amp; rkString);
+    String&amp; operator+= (const String&amp; rkString);
+    String operator+ (const String&amp; rkString);
+    bool operator== (const String&amp; rkString) const;
+    bool operator!= (const String&amp; rkString) const;
+    operator unsigned int () const;
+
+    // memory and disk footprint (support for streaming)
+    int GetMemoryUsed () const;
+    int GetDiskUsed () const;
+
+    // Case-related
+    String ToUpper () const;
+    String ToLower () const;
+
+private:
+    // Text is stored as null-terminated character string in memory.  The
+    // length counts all but the non-null character.  When written to disk,
+    // the length is stored first and all but the non-null character are
+    // stored second.
+    int m_iLength;
+    char* m_acText;
+};
+
+#include &quot;Wm3String.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3String.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3String.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3String.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,32 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+inline int String::GetLength () const
+{
+    return m_iLength;
+}
+//----------------------------------------------------------------------------
+inline String::operator const char* () const
+{
+    return m_acText;
+}
+//----------------------------------------------------------------------------
+inline int String::GetMemoryUsed () const
+{
+    return sizeof(m_iLength) + (m_iLength+1)*sizeof(char);
+}
+//----------------------------------------------------------------------------
+inline int String::GetDiskUsed () const
+{
+    return sizeof(m_iLength) + m_iLength*sizeof(char);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3System.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3System.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3System.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,852 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3System.h&quot;
+using namespace Wm3;
+
+// support for Load
+#include &lt;sys/stat.h&gt;
+
+// support for GetTime
+#ifdef __APPLE__
+#include &lt;sys/time.h&gt;
+static timeval gs_kInitial;
+static bool gs_bInitializedTime = false;
+#else
+#include &lt;sys/timeb.h&gt;
+static long gs_lInitialSec = 0;
+static long gs_lInitialUSec = 0;
+static bool gs_bInitializedTime = false;
+#endif
+
+// support for locating the application directory
+#ifdef __APPLE__
+#include &lt;Carbon/Carbon.h&gt;
+#endif
+
+char System::ms_acPath[SYSTEM_MAX_PATH];
+
+//----------------------------------------------------------------------------
+void System::SwapBytes (int iSize, void* pvValue)
+{
+    // size must be even
+    assert(iSize &gt;= 2 &amp;&amp; (iSize &amp; 1) == 0);
+
+    char* acBytes = (char*) pvValue;
+    for (int i0 = 0, i1 = iSize-1; i0 &lt; iSize/2; i0++, i1--)
+    {
+        char cSave = acBytes[i0];
+        acBytes[i0] = acBytes[i1];
+        acBytes[i1] = cSave;
+    }
+}
+//----------------------------------------------------------------------------
+void System::SwapBytes (int iSize, int iQuantity, void* pvValue)
+{
+    // size must be even
+    assert(iSize &gt;= 2 &amp;&amp; (iSize &amp; 1) == 0);
+
+    char* acBytes = (char*) pvValue;
+    for (int i = 0; i &lt; iQuantity; i++, acBytes += iSize)
+    {
+        for (int i0 = 0, i1 = iSize-1; i0 &lt; iSize/2; i0++, i1--)
+        {
+            char cSave = acBytes[i0];
+            acBytes[i0] = acBytes[i1];
+            acBytes[i1] = cSave;
+        }
+    }
+}
+//----------------------------------------------------------------------------
+bool System::IsBigEndian ()
+{
+    int iInt = 1;
+    char* pcChar = (char*)&iInt;
+    return !(*pcChar);
+}
+//----------------------------------------------------------------------------
+void System::EndianCopy (int iSize, const void* pvSrc, void* pvDst)
+{
+    size_t uiSize = (size_t)iSize;
+    Memcpy(pvDst,uiSize,pvSrc,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(iSize,pvDst);
+#endif
+}
+//----------------------------------------------------------------------------
+void System::EndianCopy (int iSize, int iQuantity, const void* pvSrc,
+    void* pvDst)
+{
+    size_t uiSize = (size_t)(iSize*iQuantity);
+    Memcpy(pvDst,uiSize,pvSrc,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(iSize,iQuantity,pvDst);
+#endif
+}
+//----------------------------------------------------------------------------
+double System::GetTime ()
+{
+#ifdef __APPLE__
+    if (!gs_bInitializedTime)
+    {
+        gs_bInitializedTime = true;
+        gettimeofday(&amp;gs_kInitial,0);
+    }
+
+    struct timeval kCurrent;
+    gettimeofday(&amp;kCurrent,0);
+    
+    struct timeval kDelta;
+    timersub(&amp;kCurrent,&amp;gs_kInitial,&amp;kDelta);
+
+    return 0.001*(double)(1000*kDelta.tv_sec + kDelta.tv_usec/1000);
+#else
+    struct timeb kTB;
+
+    if (!gs_bInitializedTime)
+    {
+        gs_bInitializedTime = true;
+        ftime(&amp;kTB);
+        gs_lInitialSec = (long)kTB.time;
+        gs_lInitialUSec = 1000*kTB.millitm;
+    }
+
+    ftime(&amp;kTB);
+    long lCurrentSec = (long)kTB.time;
+    long lCurrentUSec = 1000*kTB.millitm;
+    long lDeltaSec = lCurrentSec - gs_lInitialSec;
+    long lDeltaUSec = lCurrentUSec -gs_lInitialUSec;
+    if (lDeltaUSec &lt; 0)
+    {
+        lDeltaUSec += 1000000;
+        lDeltaSec--;
+    }
+
+    return 0.001*(double)(1000*lDeltaSec + lDeltaUSec/1000);
+#endif
+}
+//----------------------------------------------------------------------------
+bool System::Load (const char* acFilename, char*&amp; racBuffer, int&amp; riSize)
+{
+    struct stat kStat;
+    if (stat(acFilename,&amp;kStat) != 0)
+    {
+        // file does not exist
+        racBuffer = 0;
+        riSize = 0;
+        return false;
+    }
+
+    FILE* pkFile = System::Fopen(acFilename,&quot;rb&quot;);
+    assert(pkFile);
+    if (!pkFile)
+    {
+        racBuffer = 0;
+        riSize = 0;
+        return false;
+    }
+
+    riSize = kStat.st_size;
+    racBuffer = WM3_NEW char[riSize];
+    int iRead = (int)fread(racBuffer,sizeof(char),riSize,pkFile);
+    if (System::Fclose(pkFile) != 0 || iRead != riSize)
+    {
+        assert(false);
+        WM3_DELETE[] racBuffer;
+        racBuffer = 0;
+        riSize = 0;
+        return false;
+    }
+
+    return true;
+}
+//----------------------------------------------------------------------------
+bool System::Save (const char* acFilename, const char* acBuffer, int iSize)
+{
+    if (!acBuffer || iSize &lt;= 0)
+    {
+        // The input buffer must exist.  It is not possible to verify that
+        // the buffer has the specified number of bytes.
+        assert(false);
+        return false;
+    }
+
+    FILE* pkFile = System::Fopen(acFilename,&quot;wb&quot;);
+    if (!pkFile)
+    {
+        return false;
+    }
+
+    int iWrite = (int)fwrite(acBuffer,sizeof(char),iSize,pkFile);
+    if (System::Fclose(pkFile) != 0 || iWrite != iSize)
+    {
+        assert(false);
+        return false;
+    }
+
+    return true;
+}
+//----------------------------------------------------------------------------
+bool System::Append (const char* acFilename, char* acBuffer, int iSize)
+{
+    if (!acBuffer || iSize &lt;= 0)
+    {
+        // The input buffer must exist.  It is not possible to verify that
+        // the buffer has the specified number of bytes.
+        assert(false);
+        return false;
+    }
+
+    FILE* pkFile = System::Fopen(acFilename,&quot;ab&quot;);
+    if (!pkFile)
+    {
+        return false;
+    }
+
+    int iWrite = (int)fwrite(acBuffer,sizeof(char),iSize,pkFile);
+    if (System::Fclose(pkFile) != 0 || iWrite != iSize)
+    {
+        assert(false);
+        return false;
+    }
+
+    return true;
+}
+//----------------------------------------------------------------------------
+int System::Read1 (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    size_t uiSize = (size_t)iQuantity;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+    return iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write1 (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData) ;
+    size_t uiSize = (size_t)iQuantity;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+    return iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read1 (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,1,iQuantity,pkFile);
+    return iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write1 (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fwrite(pvData,1,iQuantity,pkFile);
+    return iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read2le (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 2*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read4le (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 4*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read8le (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 8*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write2le (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 2*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write4le (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 4*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write8le (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 8*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read2le (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,2,iQuantity,pkFile);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,pvData);
+#endif
+    return 2*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read4le (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,4,iQuantity,pkFile);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,pvData);
+#endif
+    return 4*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read8le (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,8,iQuantity,pkFile);
+#ifdef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,pvData);
+#endif
+    return 8*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write2le (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifdef WM3_BIG_ENDIAN
+    const short* psData = (const short*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        short sTemp = *psData++;
+        SwapBytes(2,&amp;sTemp);
+        fwrite(&amp;sTemp,2,1,pkFile);
+    }
+#else
+    fwrite(pvData,2,iQuantity,pkFile);
+#endif
+    return 2*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write4le (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifdef WM3_BIG_ENDIAN
+    const int* piData = (const int*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        int iTemp = *piData++;
+        SwapBytes(4,&amp;iTemp);
+        fwrite(&amp;iTemp,4,1,pkFile);
+    }
+#else
+    fwrite(pvData,4,iQuantity,pkFile);
+#endif
+    return 4*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write8le (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifdef WM3_BIG_ENDIAN
+    const double* pdData = (const double*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        double dTemp = *pdData++;
+        SwapBytes(8,&amp;dTemp);
+        fwrite(&amp;dTemp,8,1,pkFile);
+    }
+#else
+    fwrite(pvData,8,iQuantity,pkFile);
+#endif
+    return 8*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read2be (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 2*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read4be (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 4*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read8be (const char* acBuffer, int iQuantity, void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 8*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(pvData,uiSize,acBuffer,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,pvData);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write2be (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 2*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write4be (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 4*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Write8be (char* acBuffer, int iQuantity, const void* pvData)
+{
+    assert(acBuffer &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    int iNumBytes = 8*iQuantity;
+    size_t uiSize = (size_t)iNumBytes;
+    Memcpy(acBuffer,uiSize,pvData,uiSize);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,acBuffer);
+#endif
+    return iNumBytes;
+}
+//----------------------------------------------------------------------------
+int System::Read2be (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,2,iQuantity,pkFile);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(2,iQuantity,pvData);
+#endif
+    return 2*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read4be (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,4,iQuantity,pkFile);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(4,iQuantity,pvData);
+#endif
+    return 4*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Read8be (FILE* pkFile, int iQuantity, void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+    fread(pvData,8,iQuantity,pkFile);
+#ifndef WM3_BIG_ENDIAN
+    SwapBytes(8,iQuantity,pvData);
+#endif
+    return 8*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write2be (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifndef WM3_BIG_ENDIAN
+    const short* psData = (const short*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        short sTemp = *psData++;
+        SwapBytes(2,&amp;sTemp);
+        fwrite(&amp;sTemp,2,1,pkFile);
+    }
+#else
+    fwrite(pvData,2,iQuantity,pkFile);
+#endif
+    return 2*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write4be (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifndef WM3_BIG_ENDIAN
+    const int* piData = (const int*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        int iTemp = *piData++;
+        SwapBytes(4,&amp;iTemp);
+        fwrite(&amp;iTemp,4,1,pkFile);
+    }
+#else
+    fwrite(pvData,4,iQuantity,pkFile);
+#endif
+    return 4*iQuantity;
+}
+//----------------------------------------------------------------------------
+int System::Write8be (FILE* pkFile, int iQuantity, const void* pvData)
+{
+    assert(pkFile &amp;&amp; iQuantity &gt; 0 &amp;&amp; pvData);
+#ifndef WM3_BIG_ENDIAN
+    const double* pdData = (const double*)pvData;
+    for (int i = 0; i &lt; iQuantity; i++)
+    {
+        double dTemp = *pdData++;
+        SwapBytes(8,&amp;dTemp);
+        fwrite(&amp;dTemp,8,1,pkFile);
+    }
+#else
+    fwrite(pvData,8,iQuantity,pkFile);
+#endif
+    return 8*iQuantity;
+}
+//----------------------------------------------------------------------------
+const char* System::GetPath (const char* acDirectory, const char* acFilename)
+{
+#ifdef __APPLE__
+    // An application-relative path is needed for the applications to be able
+    // to find the input data sets.  Unfortunately, there is no exact way to
+    // predict which directory the application is run from, since this depends
+    // on whether it was launched by the Finder, Xcode, gdb, the console, etc.
+    // To work around this, the following code switches to the application
+    // directory.  Beware of your applications themselves changing directory,
+    // which could cause the input data sets not to be found.
+    //
+    // WARNING.  The directory structure assumed here is based on the default
+    // Xcode preferences:
+    //     &quot;Put build products in project directory&quot;
+    //     &quot;Put intermediate build files with build products&quot;
+    //
+    // If you change the Xcode preferences, you will need to modify this code
+    // to correctly locate the application directory.
+    //
+    // Until I find a #define for the version of Xcode, this will have to
+    // suffice.  If you have Xcode 1.x, comment out the following #define.
+#define WM3_USE_XCODE2
+#ifdef WM3_USE_XCODE2
+    // Use this for Xcode version 2.x.
+    OSStatus eError;
+    FSRef kExeRef;    // ${ApplicationPath}/build/WildMagic/executableFile
+    FSRef kWMRef;     // ${ApplicationPath}/build/WildMagic
+    FSRef kBuildRef;  // ${ApplicationPath}/build
+    FSRef kAppRef;    // ${ApplicationPath}
+    ProcessSerialNumber kPSN;
+
+    MacGetCurrentProcess(&amp;kPSN);
+    eError = GetProcessBundleLocation(&amp;kPSN,&amp;kExeRef);
+    eError = FSGetCatalogInfo(&amp;kExeRef,0,0,0,0,&amp;kWMRef);
+    eError = FSGetCatalogInfo(&amp;kWMRef,0,0,0,0,&amp;kBuildRef);
+    eError = FSGetCatalogInfo(&amp;kBuildRef,0,0,0,0,&amp;kAppRef);
+    eError = FSRefMakePath(&amp;kAppRef,(UInt8*)ms_acPath,SYSTEM_MAX_PATH);
+    eError = chdir(ms_acPath);
+#else
+    // Use this for Xcode version 1.x.
+    OSStatus eError;
+    FSRef kExeRef;    // ${ApplicationPath}/build/executableFile
+    FSRef kBuildRef;  // ${ApplicationPath}/build
+    FSRef kAppRef;    // ${ApplicationPath}
+    ProcessSerialNumber kPSN;
+
+    MacGetCurrentProcess(&amp;kPSN);
+    eError = GetProcessBundleLocation(&amp;kPSN,&amp;kExeRef);
+    eError = FSGetCatalogInfo(&amp;kExeRef,0,0,0,0,&amp;kBuildRef);
+    eError = FSGetCatalogInfo(&amp;kBuildRef,0,0,0,0,&amp;kAppRef);
+    eError = FSRefMakePath(&amp;kAppRef,(UInt8*)ms_acPath,SYSTEM_MAX_PATH);
+    eError = chdir(ms_acPath);
+#endif
+#endif
+
+    size_t uiDLength = strlen(acDirectory);
+    size_t uiFLength = strlen(acFilename);
+    if (uiDLength + uiFLength + 1 &lt;= SYSTEM_MAX_PATH)
+    {
+        System::Strcpy(ms_acPath,SYSTEM_MAX_PATH,acDirectory);
+        System::Strcat(ms_acPath,SYSTEM_MAX_PATH,acFilename);
+        return ms_acPath;
+    }
+    return 0;
+}
+//----------------------------------------------------------------------------
+unsigned int System::MakeRGB (unsigned char ucR, unsigned char ucG,
+    unsigned char ucB)
+{
+#ifdef WM3_BIG_ENDIAN
+    return (0xFF | (ucB &lt;&lt; 8) | (ucG &lt;&lt; 16) | (ucR &lt;&lt; 24));
+#else
+    return (ucR | (ucG &lt;&lt; 8) | (ucB &lt;&lt; 16) | (0xFF &lt;&lt; 24));
+#endif
+}
+//----------------------------------------------------------------------------
+unsigned int System::MakeRGBA (unsigned char ucR, unsigned char ucG,
+    unsigned char ucB, unsigned char ucA)
+{
+#ifdef WM3_BIG_ENDIAN
+    return (ucA | (ucB &lt;&lt; 8) | (ucG &lt;&lt; 16) | (ucR &lt;&lt; 24));
+#else
+    return (ucR | (ucG &lt;&lt; 8) | (ucB &lt;&lt; 16) | (ucA &lt;&lt; 24));
+#endif
+}
+//----------------------------------------------------------------------------
+FILE* System::Fopen (const char* acFilename, const char* acMode)
+{
+#ifdef WM3_USING_VC80
+    FILE* pkFile;
+    errno_t uiError = fopen_s(&amp;pkFile,acFilename,acMode);
+    if (uiError == 0)
+    {
+        return pkFile;
+    }
+    else
+    {
+        return 0;
+    }
+#else
+    return fopen(acFilename,acMode);
+#endif
+}
+//----------------------------------------------------------------------------
+int System::Fprintf (FILE* pkFile, const char* acFormat, ...)
+{
+    if (!pkFile || !acFormat)
+    {
+        return -1;
+    }
+
+    va_list acArgs;
+    va_start(acArgs,acFormat);
+
+#ifdef WM3_USING_VC80
+    int iNumWritten = vfprintf_s(pkFile,acFormat,acArgs);
+#else
+    int iNumWritten = vfprintf(pkFile,acFormat,acArgs);
+#endif
+
+    va_end(acArgs);
+    return iNumWritten;
+}
+//----------------------------------------------------------------------------
+int System::Fclose (FILE* pkFile)
+{
+    return fclose(pkFile);
+}
+//----------------------------------------------------------------------------
+void* System::Memcpy (void* pvDst, size_t uiDstSize, const void* pvSrc,
+    size_t uiSrcSize)
+{
+#ifdef WM3_USING_VC80
+    errno_t uiError = memcpy_s(pvDst,uiDstSize,pvSrc,uiSrcSize);
+    if (uiError == 0)
+    {
+        return pvDst;
+    }
+    else
+    {
+        return 0;
+    }
+#else
+    if (!pvDst || uiDstSize == 0 || !pvSrc || uiSrcSize == 0)
+    {
+        // Be consistent with the behavior of memcpy_s.
+        return 0;
+    }
+
+    if (uiSrcSize &gt; uiDstSize)
+    {
+        // The source memory is too large to copy to the destination.  To
+        // be consistent with memcpy_s, return null as an indication that the
+        // copy failed.
+        return 0;
+    }
+    memcpy(pvDst,pvSrc,uiSrcSize);
+    return pvDst;
+#endif
+}
+//----------------------------------------------------------------------------
+int System::Sprintf (char* acDst, size_t uiDstSize, const char* acFormat, ...)
+{
+    if (!acDst || uiDstSize == 0 || !acFormat)
+    {
+        return -1;
+    }
+
+    va_list acArgs;
+    va_start(acArgs,acFormat);
+
+#ifdef WM3_USING_VC80
+    int iNumWritten = vsprintf_s(acDst,uiDstSize,acFormat,acArgs);
+#else
+    int iNumWritten = vsprintf(acDst,acFormat,acArgs);
+#endif
+
+    va_end(acArgs);
+    return iNumWritten;
+}
+//----------------------------------------------------------------------------
+char* System::Strcpy (char* acDst, size_t uiDstSize, const char* acSrc)
+{
+#ifdef WM3_USING_VC80
+    errno_t uiError = strcpy_s(acDst,uiDstSize,acSrc);
+    if (uiError == 0)
+    {
+        return acDst;
+    }
+    else
+    {
+        return 0;
+    }
+#else
+    if (!acDst || uiDstSize == 0 || !acSrc)
+    {
+        // Be consistent with the behavior of strcpy_s.
+        return 0;
+    }
+
+    size_t uiSrcLen = strlen(acSrc);
+    if (uiSrcLen + 1 &gt; uiDstSize)
+    {
+        // The source string is too large to copy to the destination.  To
+        // be consistent with strcpy_s, return null as an indication that the
+        // copy failed.
+        return 0;
+    }
+    strncpy(acDst,acSrc,uiSrcLen);
+    acDst[uiSrcLen] = 0;
+    return acDst;
+#endif
+}
+//----------------------------------------------------------------------------
+char* System::Strcat (char* acDst, size_t uiDstSize, const char* acSrc)
+{
+#ifdef WM3_USING_VC80
+    errno_t uiError = strcat_s(acDst,uiDstSize,acSrc);
+    if (uiError == 0)
+    {
+        return acDst;
+    }
+    else
+    {
+        return 0;
+    }
+#else
+    if (!acDst || uiDstSize == 0 || !acSrc)
+    {
+        // Be consistent with the behavior of strcat_s.
+        return 0;
+    }
+
+    size_t uiSrcLen = strlen(acSrc);
+    size_t uiDstLen = strlen(acDst);
+    size_t uiSumLen = uiSrcLen + uiDstLen;
+    if (uiSumLen + 1 &gt; uiDstSize)
+    {
+        // The source string is too large to append to the destination.  To
+        // be consistent with strcat_s, return null as an indication that
+        // the concatenation failed.
+        return 0;
+    }
+    strncat(acDst,acSrc,uiSrcLen);
+    acDst[uiSumLen] = 0;
+    return acDst;
+#endif
+}
+//----------------------------------------------------------------------------
+char* System::Strncpy (char* acDst, size_t uiDstSize, const char* acSrc,
+    size_t uiSrcSize)
+{
+#ifdef WM3_USING_VC80
+    errno_t uiError = strncpy_s(acDst,uiDstSize,acSrc,uiSrcSize);
+    if (uiError == 0)
+    {
+        return acDst;
+    }
+    else
+    {
+        return 0;
+    }
+#else
+    if (!acDst || uiDstSize == 0 || !acSrc || uiSrcSize == 0)
+    {
+        // Be consistent with the behavior of strncpy_s.
+        return 0;
+    }
+
+    if (uiSrcSize + 1 &gt; uiDstSize)
+    {
+        // The source string is too large to copy to the destination.  To
+        // be consistent with strncpy_s, return null as an indication that
+        // the copy failed.
+        return 0;
+    }
+    strncpy(acDst,acSrc,uiSrcSize);
+    return acDst;
+#endif
+}
+//----------------------------------------------------------------------------
+char* System::Strtok (char* acToken, const char* acDelimiters,
+    char*&amp; racNextToken)
+{
+#ifdef WM3_USING_VC80
+    return strtok_s(acToken,acDelimiters,&amp;racNextToken);
+#else
+    (void)racNextToken;  // avoid warning in release mode
+    return strtok(acToken,acDelimiters);
+#endif
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3System.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3System.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3System.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,166 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3SYSTEM_H
+#define WM3SYSTEM_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Platforms.h&quot;
+
+// common standard library headers
+#include &lt;cassert&gt;
+#include &lt;cctype&gt;
+#include &lt;cfloat&gt;
+#include &lt;cmath&gt;
+#include &lt;cstdarg&gt;
+#include &lt;cstddef&gt;
+#include &lt;cstdio&gt;
+#include &lt;cstdlib&gt;
+#include &lt;cstring&gt;
+#include &lt;ctime&gt;
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+
+// memory management
+#include &quot;Wm3Memory.h&quot;
+
+namespace Wm3
+{
+
+class WM3_ITEM System
+{
+public:
+    // swap byte order (size = 2, 4, or 8)
+    static void SwapBytes (int iSize, void* pvValue);
+    static void SwapBytes (int iSize, int iQuantity, void* pvValue);
+
+    // The output is stored in little endian format.
+    static bool IsBigEndian ();
+    static void EndianCopy (int iSize, const void* pvSrc, void* pvDst);
+    static void EndianCopy (int iSize, int iQuantity, const void* pvSrc,
+        void* pvDst);
+
+    // time utility (return value is seconds)
+    static double GetTime ();
+
+    // File support for buffer load and save.
+    static bool Load (const char* acFilename, char*&amp; racBuffer, int&amp; riSize);
+    static bool Save (const char* acFilename, const char* acBuffer,
+        int iSize);
+    static bool Append (const char* acFilename, char* acBuffer, int iSize);
+
+    // Buffer read and write, file read and write, for character data.  The
+    // endianness is irrelevant.
+    static int Read1 (const char* acBuffer, int iQuantity, void* pvData);
+    static int Write1 (char* acBuffer, int iQuantity, const void* pvData);
+    static int Read1 (FILE* pkFile, int iQuantity, void* pvData);
+    static int Write1 (FILE* pkFile, int iQuantity, const void* pvData);
+
+    // Buffer read and write, file read and write.  The operations store the
+    // results in little-endian order.  The return value is the number of
+    // bytes read or written.  The function name suffix indicates the number
+    // of bytes transferred per item.
+    static int Read2le (const char* acBuffer, int iQuantity, void* pvData);
+    static int Read4le (const char* acBuffer, int iQuantity, void* pvData);
+    static int Read8le (const char* acBuffer, int iQuantity, void* pvData);
+    static int Write2le (char* acBuffer, int iQuantity, const void* pvData);
+    static int Write4le (char* acBuffer, int iQuantity, const void* pvData);
+    static int Write8le (char* acBuffer, int iQuantity, const void* pvData);
+    static int Read2le (FILE* pkFile, int iQuantity, void* pvData);
+    static int Read4le (FILE* pkFile, int iQuantity, void* pvData);
+    static int Read8le (FILE* pkFile, int iQuantity, void* pvData);
+    static int Write2le (FILE* pkFile, int iQuantity, const void* pvData);
+    static int Write4le (FILE* pkFile, int iQuantity, const void* pvData);
+    static int Write8le (FILE* pkFile, int iQuantity, const void* pvData);
+
+    // Buffer read and write, file read and write.  The operations store the
+    // results in big-endian order.  The return value is the number of
+    // bytes read or written.  The function name suffix indicates the number
+    // of bytes transferred per item.
+    static int Read2be (const char* acBuffer, int iQuantity, void* pvData);
+    static int Read4be (const char* acBuffer, int iQuantity, void* pvData);
+    static int Read8be (const char* acBuffer, int iQuantity, void* pvData);
+    static int Write2be (char* acBuffer, int iQuantity, const void* pvData);
+    static int Write4be (char* acBuffer, int iQuantity, const void* pvData);
+    static int Write8be (char* acBuffer, int iQuantity, const void* pvData);
+    static int Read2be (FILE* pkFile, int iQuantity, void* pvData);
+    static int Read4be (FILE* pkFile, int iQuantity, void* pvData);
+    static int Read8be (FILE* pkFile, int iQuantity, void* pvData);
+    static int Write2be (FILE* pkFile, int iQuantity, const void* pvData);
+    static int Write4be (FILE* pkFile, int iQuantity, const void* pvData);
+    static int Write8be (FILE* pkFile, int iQuantity, const void* pvData);
+
+    // This is needed on the Macintosh because of its complicated application
+    // structure.  In particular, this function is used in Xcode projects and
+    // ignores the directory entry, but assumes that the data files required
+    // by an application are added to the Resources folder of the projects.
+    // The other platforms concatenate the directory and filename, the result
+    // stored in class-static memory (so be careful with threads).
+    static const char* GetPath (const char* acDirectory,
+        const char* acFilename);
+
+    // Creation of colors, hides endianness.
+    static unsigned int MakeRGB (unsigned char ucR, unsigned char ucG,
+        unsigned char ucB);
+    static unsigned int MakeRGBA (unsigned char ucR, unsigned char ucG,
+        unsigned char ucB, unsigned char ucA);
+
+    // Wrappers for standard I/O functions to support security enhancements
+    // related to buffer overruns.  TO DO:  For now these support MSVC8.0
+    // and fall back to the older standard I/O functions on other platforms.
+    // Implementations may be provided for those other platforms to adhere
+    // to the destination buffer size specification.
+    static FILE* Fopen (const char* acFilename, const char* acMode);
+    static int Fprintf (FILE* pkFile, const char* acFormat, ...);
+    static int Fclose (FILE* pkFile);
+    static void* Memcpy (void* pvDst, size_t uiDstSize, const void* pvSrc,
+        size_t uiSrcSize);
+    static int Sprintf (char* acDst, size_t uiDstSize, const char* acFormat,
+        ...);
+    static char* Strcpy (char* acDst, size_t uiDstSize, const char* acSrc);
+    static char* Strcat (char* acDst, size_t uiDstSize, const char* acSrc);
+    static char* Strncpy (char* acDst, size_t uiDstSize, const char* acSrc,
+        size_t uiSrcSize);
+    static char* Strtok (char* acToken, const char* acDelimiters,
+        char*&amp; racNextToken);
+
+private:
+    enum { SYSTEM_MAX_PATH = 1024 };
+    static char ms_acPath[SYSTEM_MAX_PATH];
+};
+
+
+// Allocation and deallocation of 2D arrays.  On deallocation, the array
+// pointer is set to null.
+template &lt;class T&gt; void Allocate (int iCols, int iRows, T**&amp; raatArray);
+template &lt;class T&gt; static void Deallocate (T**&amp; raatArray);
+
+// Allocation and deallocation of 3D arrays.  On deallocation, the array
+// pointer is set to null.
+template &lt;class T&gt; void Allocate (int iCols, int iRows, int iSlices,
+    T***&amp; raaatArray);
+template &lt;class T&gt; void Deallocate (T***&amp; raaatArray);
+
+#include &quot;Wm3System.inl&quot;
+
+}
+
+// Template classes.  These are included here because the hash classes use
+// System wrappers for memcpy, so System must be declared first.
+#include &quot;Wm3TArray.h&quot;
+#include &quot;Wm3THashSet.h&quot;
+#include &quot;Wm3THashTable.h&quot;
+#include &quot;Wm3TList.h&quot;
+#include &quot;Wm3TSet.h&quot;
+#include &quot;Wm3TStack.h&quot;
+#include &quot;Wm3TTuple.h&quot;
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3System.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3System.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3System.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,57 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void Allocate (int iCols, int iRows, T**&amp; raatArray)
+{
+    raatArray = WM3_NEW T*[iRows];
+    raatArray[0] = WM3_NEW T[iRows*iCols];
+    for (int iRow = 1; iRow &lt; iRows; iRow++)
+    {
+        raatArray[iRow] = &amp;raatArray[0][iCols*iRow];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void Deallocate (T**&amp; raatArray)
+{
+    WM3_DELETE[] raatArray[0];
+    WM3_DELETE[] raatArray;
+    raatArray = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void Allocate (int iCols, int iRows, int iSlices, T***&amp; raaatArray)
+{
+    raaatArray = WM3_NEW T**[iSlices];
+    raaatArray[0] = WM3_NEW T*[iSlices*iRows];
+    raaatArray[0][0] = WM3_NEW T[iSlices*iRows*iCols];
+    for (int iSlice = 0; iSlice &lt; iSlices; iSlice++)
+    {
+        raaatArray[iSlice] = &amp;raaatArray[0][iRows*iSlice];
+        for (int iRow = 0; iRow &lt; iRows; iRow++)
+        {
+            raaatArray[iSlice][iRow] =
+                &amp;raaatArray[0][0][iCols*(iRow+iRows*iSlice)];
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void Deallocate (T***&amp; raaatArray)
+{
+    WM3_DELETE[] raaatArray[0][0];
+    WM3_DELETE[] raaatArray[0];
+    WM3_DELETE[] raaatArray;
+    raaatArray = 0;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3TArray.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TArray.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TArray.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,75 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3TARRAY_H
+#define WM3TARRAY_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class T is either native data or is class data that has the following
+// member functions:
+//   T::T ()
+//   T::T (const T&amp;);
+//   T&amp; T::operator= (const T&amp;)
+
+namespace Wm3
+{
+
+template &lt;class T&gt;
+class TArray
+{
+public:
+    // construction and destruction
+    TArray (int iQuantity = 1, int iGrowBy = 1);
+    TArray (const TArray&amp; rkObject);
+    ~TArray ();
+
+    // assignment
+    TArray&amp; operator= (const TArray&amp; rkObject);
+
+    // element access, index i must be in range
+    int GetQuantity () const;
+    T* GetArray ();
+    const T* GetArray () const;
+    T&amp; operator[] (int i);
+    const T&amp; operator[] (int i) const;
+
+    // add new element, array will dynamically grow if necessary
+    void Append (const T&amp; rtElement);
+    void SetElement (int i, const T&amp; rtElement);
+
+    // Remove the element at the specified index.  The elements occurring
+    // after that one are shifted so that the array remains contiguous.  After
+    // the shift, but before the decrement on quantity, array[quantity-1] is
+    // a duplicate of array[quantity-2].  The element at index quantity-1 is
+    // reconstructed using the default constructor for class T.  Then the
+    // quantity is decremented.
+    void Remove (int i);
+
+    // all elements are set to the default object of class T
+    void RemoveAll ();
+
+    // dynamic growth, new array elements are default constructed
+    void SetMaxQuantity (int iNewMaxQuantity, bool bCopy);
+    int GetMaxQuantity () const;
+    void SetGrowBy (int iGrowBy);
+    int GetGrowBy () const;
+
+private:
+    int m_iQuantity, m_iMaxQuantity, m_iGrowBy;
+    T* m_atArray;
+};
+
+#include &quot;Wm3TArray.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3TArray.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TArray.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TArray.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,292 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TArray&lt;T&gt;::TArray (int iQuantity, int iGrowBy)
+{
+    assert(iQuantity &gt;= 0 &amp;&amp; iGrowBy &gt;= 0);
+
+    if (iQuantity &lt; 0)
+    {
+        iQuantity = 0;
+    }
+
+    if (iGrowBy &lt; 0)
+    {
+        iGrowBy = 0;
+    }
+
+    m_iQuantity = 0;
+    m_iMaxQuantity = iQuantity;
+    m_iGrowBy = iGrowBy;
+    m_atArray = (m_iMaxQuantity &gt; 0 ? WM3_NEW T[m_iMaxQuantity] : 0);
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TArray&lt;T&gt;::TArray (const TArray&amp; rkObject)
+{
+    m_atArray = 0;
+    *this = rkObject;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TArray&lt;T&gt;::~TArray ()
+{
+    WM3_DELETE[] m_atArray;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TArray&lt;T&gt;&amp; TArray&lt;T&gt;::operator= (const TArray&amp; rkObject)
+{
+    m_iQuantity = rkObject.m_iQuantity;
+    m_iMaxQuantity = rkObject.m_iMaxQuantity;
+    m_iGrowBy = rkObject.m_iGrowBy;
+
+    WM3_DELETE[] m_atArray;
+    if (m_iMaxQuantity &gt; 0)
+    {
+        m_atArray = WM3_NEW T[m_iMaxQuantity];
+        for (int i = 0; i &lt; m_iMaxQuantity; i++)
+        {
+            m_atArray[i] = rkObject.m_atArray[i];
+        }
+    }
+    else
+    {
+        m_atArray = 0;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TArray&lt;T&gt;::GetQuantity () const
+{
+    return m_iQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+T* TArray&lt;T&gt;::GetArray ()
+{
+    return m_atArray;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T* TArray&lt;T&gt;::GetArray () const
+{
+    return m_atArray;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+T&amp; TArray&lt;T&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; m_iQuantity);
+    if (i &lt; 0)
+    {
+        i = 0;
+    }
+    if (i &gt;= m_iQuantity)
+    {
+        i = m_iQuantity-1;
+    }
+
+    return m_atArray[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T&amp; TArray&lt;T&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; m_iQuantity);
+    if (i &lt; 0)
+    {
+        i = 0;
+    }
+    if (i &gt;= m_iQuantity)
+    {
+        i = m_iQuantity-1;
+    }
+
+    return m_atArray[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::Append (const T&amp; rtElement)
+{
+    if (++m_iQuantity &gt; m_iMaxQuantity)
+    {
+        if (m_iGrowBy &gt; 0)
+        {
+            // Increase the size of the array.  In the event rtElement is a
+            // reference to something in the current array, the reallocation
+            // in SetMaxQuantity will invalidate the reference.  A copy of
+            // rtElement is made here to avoid the invalidation.
+            T tSaveElement(rtElement);
+            SetMaxQuantity(m_iMaxQuantity+m_iGrowBy,true);
+            m_atArray[m_iQuantity-1] = tSaveElement;
+            return;
+        }
+
+        // cannot grow the array, overwrite the last element
+        --m_iQuantity;
+    }
+
+    m_atArray[m_iQuantity-1] = rtElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::SetElement (int i, const T&amp; rtElement)
+{
+    assert(i &gt;= 0);
+    if (i &lt; 0 )
+    {
+        i = 0;
+    }
+
+    if (i &gt;= m_iQuantity)
+    {
+        if (i &gt;= m_iMaxQuantity)
+        {
+            if (m_iGrowBy &gt; 0)
+            {
+                // increase the size of the array
+                if (i+1 &gt;= m_iMaxQuantity)
+                {
+                    int iN = 1 + (int)(0.5f+(i+1-m_iMaxQuantity) /
+                        (float)m_iGrowBy);
+
+                    // Increase the size of the array.  In the event rtElement
+                    // is a reference to something in the current array, the
+                    // reallocation in SetMaxQuantity will invalidate the
+                    // reference.  A copy of rtElement is made here to avoid
+                    // the invalidation.
+                    T tSaveElement(rtElement);
+                    SetMaxQuantity(m_iMaxQuantity+iN*m_iGrowBy,true);
+                    m_iQuantity = i+1;
+                    m_atArray[i] = tSaveElement;
+                    return;
+                }
+            }
+            else
+            {
+                // cannot grow the array, overwrite the last element
+                i = m_iQuantity-1;
+            }
+        }
+        m_iQuantity = i+1;
+    }
+
+    m_atArray[i] = rtElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::Remove (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; m_iQuantity);
+    if (i &lt; 0 || i &gt;= m_iQuantity)
+    {
+        return;
+    }
+
+    for (int j = i+1; j &lt; m_iQuantity; i = j++)
+    {
+        m_atArray[i] = m_atArray[j];
+    }
+    m_atArray[m_iQuantity-1] = T();
+    m_iQuantity--;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::RemoveAll ()
+{
+    for (int i = 0; i &lt; m_iQuantity; i++)
+    {
+        m_atArray[i] = T();
+    }
+    m_iQuantity = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::SetMaxQuantity (int iNewMaxQuantity, bool bCopy)
+{
+    assert(iNewMaxQuantity &gt;= 0);
+    if (iNewMaxQuantity &lt; 0)
+    {
+        iNewMaxQuantity = 0;
+    }
+
+    if (iNewMaxQuantity == 0)
+    {
+        WM3_DELETE[] m_atArray;
+        m_iQuantity = 0;
+        m_iMaxQuantity = 0;
+        return;
+    }
+
+    if (iNewMaxQuantity != m_iMaxQuantity)
+    {
+        T* atNewArray = WM3_NEW T[iNewMaxQuantity];
+
+        if (bCopy)
+        {
+            int iCopyQuantity;
+            if (iNewMaxQuantity &gt; m_iMaxQuantity)
+            {
+                iCopyQuantity = m_iMaxQuantity;
+            }
+            else
+            {
+                iCopyQuantity = iNewMaxQuantity;
+            }
+
+            for (int i = 0; i &lt; iCopyQuantity; i++)
+            {
+                atNewArray[i] = m_atArray[i];
+            }
+
+            if (m_iQuantity &gt; iNewMaxQuantity)
+            {
+                m_iQuantity = iNewMaxQuantity;
+            }
+        }
+        else
+        {
+            m_iQuantity = 0;
+        }
+
+        WM3_DELETE[] m_atArray;
+        m_atArray = atNewArray;
+        m_iMaxQuantity = iNewMaxQuantity;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TArray&lt;T&gt;::GetMaxQuantity () const
+{
+    return m_iMaxQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TArray&lt;T&gt;::SetGrowBy (int iGrowBy)
+{
+    assert(iGrowBy &gt;= 0);
+    if (iGrowBy &gt;= 0)
+    {
+        m_iGrowBy = iGrowBy;
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TArray&lt;T&gt;::GetGrowBy () const
+{
+    return m_iGrowBy;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3THashSet.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3THashSet.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3THashSet.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,91 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3THASHSET_H
+#define WM3THASHSET_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class TKEY is either native data or is class data that has the
+// following member functions:
+//   TKEY::TKEY ()
+//   TKEY&amp; TKEY::operator= (const TKEY&amp;)
+//   bool TKEY::operator== (const TKEY&amp;) const
+//   bool TKEY::operator!= (const TKEY&amp;) const
+//   TKEY::operator unsigned int () const
+// The implicit conversion to unsigned int is used to select a hash table
+// index for the T object.  The return value need not be within the range of
+// hash table indices.  THashSet will use modular arithmetic to make this
+// happen.
+
+#include &quot;Wm3System.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class TKEY&gt;
+class THashSet
+{
+public:
+    // construction and destruction
+    THashSet (int iTableSize);
+    ~THashSet ();
+
+    // element access
+    int GetQuantity () const;
+
+    // A pointer to the actual storage is returned so that the caller has
+    // direct access to it.  This allows a subset of TKEY members to be used
+    // in key comparison.
+    TKEY* Insert (const TKEY&amp; rtKey);
+
+    // If the input key exists, a pointer to the actual storage is returned.
+    // This allows a subset of TKEY members to be used in key comparison,
+    // but gives the caller a chance to modify other TKEY members.
+    TKEY* Get (const TKEY&amp; rtKey) const;
+
+    bool Remove (const TKEY&amp; rtKey);
+    void RemoveAll ();
+
+    // linear traversal of map
+    TKEY* GetFirst () const;
+    TKEY* GetNext () const;
+
+    // user-specified key-to-index construction
+    int (*UserHashFunction)(const TKEY&amp;);
+
+private:
+    class HashItem
+    {
+    public:
+        TKEY m_tKey;
+        HashItem* m_pkNext;
+    };
+
+    // Default key-to-index construction (override by user-specified when
+    // requested).
+    int HashFunction (const TKEY&amp; rtKey) const;
+
+    // hash table
+    int m_iTableSize;
+    int m_iQuantity;
+    HashItem** m_apkTable;
+
+    // iterator for traversal
+    mutable int m_iIndex;
+    mutable HashItem* m_pkItem;
+};
+
+#include &quot;Wm3THashSet.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3THashSet.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3THashSet.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3THashSet.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,211 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+THashSet&lt;TKEY&gt;::THashSet (int iTableSize)
+{
+    assert(iTableSize &gt; 0);
+
+    m_iTableSize = iTableSize;
+    m_iQuantity = 0;
+    m_iIndex = 0;
+    m_pkItem = 0;
+    m_apkTable = WM3_NEW HashItem*[m_iTableSize];
+    memset(m_apkTable,0,m_iTableSize*sizeof(HashItem*));
+    UserHashFunction = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+THashSet&lt;TKEY&gt;::~THashSet ()
+{
+    RemoveAll();
+    WM3_DELETE[] m_apkTable;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+int THashSet&lt;TKEY&gt;::GetQuantity () const
+{
+    return m_iQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+TKEY* THashSet&lt;TKEY&gt;::Insert (const TKEY&amp; rtKey)
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    // search for item in list associated with key
+    while (pkItem)
+    {
+        if (rtKey == pkItem-&gt;m_tKey)
+        {
+            // item already in hash table
+            return &amp;pkItem-&gt;m_tKey;
+        }
+        pkItem = pkItem-&gt;m_pkNext;
+    }
+
+    // add item to beginning of list
+    pkItem = WM3_NEW HashItem;
+    pkItem-&gt;m_tKey = rtKey;
+    pkItem-&gt;m_pkNext = m_apkTable[iIndex];
+    m_apkTable[iIndex] = pkItem;
+    m_iQuantity++;
+
+    return &amp;pkItem-&gt;m_tKey;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+TKEY* THashSet&lt;TKEY&gt;::Get (const TKEY&amp; rtKey) const
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    // search for item in list associated with key
+    while (pkItem)
+    {
+        if (rtKey == pkItem-&gt;m_tKey)
+        {
+            // item is in hash table
+            return &amp;pkItem-&gt;m_tKey;
+        }
+        pkItem = pkItem-&gt;m_pkNext;
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+bool THashSet&lt;TKEY&gt;::Remove (const TKEY&amp; rtKey)
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    if (!pkItem)
+    {
+        return false;
+    }
+
+    if (rtKey == pkItem-&gt;m_tKey)
+    {
+        // item is at front of list, strip it off
+        HashItem* pkSave = pkItem;
+        m_apkTable[iIndex] = pkItem-&gt;m_pkNext;
+        WM3_DELETE pkSave;
+        m_iQuantity--;
+        return true;
+    }
+
+    // search for item in list
+    HashItem* pkPrev = pkItem;
+    HashItem* pkCurr = pkItem-&gt;m_pkNext;
+    while (pkCurr &amp;&amp; rtKey != pkCurr-&gt;m_tKey)
+    {
+        pkPrev = pkCurr;
+        pkCurr = pkCurr-&gt;m_pkNext;
+    }
+
+    if (pkCurr)
+    {
+        // found the item
+        pkPrev-&gt;m_pkNext = pkCurr-&gt;m_pkNext;
+        WM3_DELETE pkCurr;
+        m_iQuantity--;
+        return true;
+    }
+
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+void THashSet&lt;TKEY&gt;::RemoveAll ()
+{
+    if (m_iQuantity &gt; 0)
+    {
+        for (int iIndex = 0; iIndex &lt; m_iTableSize; iIndex++)
+        {
+            while (m_apkTable[iIndex])
+            {
+                HashItem* pkSave = m_apkTable[iIndex];
+                m_apkTable[iIndex] = m_apkTable[iIndex]-&gt;m_pkNext;
+                WM3_DELETE pkSave;
+                if (--m_iQuantity == 0)
+                {
+                    return;
+                }
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+TKEY* THashSet&lt;TKEY&gt;::GetFirst () const
+{
+    if (m_iQuantity &gt; 0)
+    {
+        for (m_iIndex = 0; m_iIndex &lt; m_iTableSize; m_iIndex++)
+        {
+            if (m_apkTable[m_iIndex])
+            {
+                m_pkItem = m_apkTable[m_iIndex];
+                return &amp;m_pkItem-&gt;m_tKey;
+            }
+        }
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+TKEY* THashSet&lt;TKEY&gt;::GetNext () const
+{
+    if (m_iQuantity &gt; 0)
+    {
+        m_pkItem = m_pkItem-&gt;m_pkNext;
+        if (m_pkItem)
+        {
+            return &amp;m_pkItem-&gt;m_tKey;
+        }
+        
+        for (m_iIndex++; m_iIndex &lt; m_iTableSize; m_iIndex++)
+        {
+            if (m_apkTable[m_iIndex])
+            {
+                m_pkItem = m_apkTable[m_iIndex];
+                return &amp;m_pkItem-&gt;m_tKey;
+            }
+        }
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY&gt;
+int THashSet&lt;TKEY&gt;::HashFunction (const TKEY&amp; rtKey) const
+{
+    if (UserHashFunction)
+    {
+        return (*UserHashFunction)(rtKey);
+    }
+
+    // default hash function
+    static double s_dHashMultiplier = 0.5*(sqrt(5.0)-1.0);
+    unsigned int uiKey;
+    System::Memcpy(&amp;uiKey,sizeof(unsigned int),&amp;rtKey,sizeof(unsigned int));
+    uiKey %= m_iTableSize;
+    double dFraction = fmod(s_dHashMultiplier*uiKey,1.0);
+    return (int)floor(m_iTableSize*dFraction);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3THashTable.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3THashTable.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3THashTable.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,94 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3THASHTABLE_H
+#define WM3THASHTABLE_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class TKEY is either native data or is class data that has the
+// following member functions:
+//   TKEY::TKEY ()
+//   TKEY&amp; TKEY::operator= (const TKEY&amp;)
+//   bool TKEY::operator== (const TKEY&amp;) const
+//   bool TKEY::operator!= (const TKEY&amp;) const
+//   TKEY::operator unsigned int () const
+// The implicit conversion to unsigned int is used to select a hash table
+// index for the T object.  The return value need not be within the range of
+// hash table indices.  THashTable will use modular arithmetic to make this
+// happen.
+//
+// The class TVALUE is either native data or is class data that has the
+// following member functions:
+//   TVALUE::TVALUE ()
+//   TVALUE&amp; TVALUE::operator= (const TVALUE&amp;)
+
+#include &quot;Wm3System.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class TKEY, class TVALUE&gt;
+class THashTable
+{
+public:
+    // construction and destruction
+    THashTable (int iTableSize);
+    ~THashTable ();
+
+    // element access
+    int GetQuantity () const;
+
+    // insert a key-value pair into the hash table
+    bool Insert (const TKEY&amp; rtKey, const TVALUE&amp; rtValue);
+
+    // search for a key and returns it value (null, if key does not exist)
+    TVALUE* Find (const TKEY&amp; rtKey) const;
+
+    // remove key-value pairs from the hash table
+    bool Remove (const TKEY&amp; rtKey);
+    void RemoveAll ();
+
+    // linear traversal of table
+    TVALUE* GetFirst (TKEY* ptKey) const;
+    TVALUE* GetNext (TKEY* ptKey) const;
+
+    // user-specified key-to-index construction
+    int (*UserHashFunction)(const TKEY&amp;);
+
+private:
+    class HashItem
+    {
+    public:
+        TKEY m_tKey;
+        TVALUE m_tValue;
+        HashItem* m_pkNext;
+    };
+
+    // Default key-to-index construction (override by user-specified when
+    // requested).
+    int HashFunction (const TKEY&amp; rtKey) const;
+
+    // hash table
+    int m_iTableSize;
+    int m_iQuantity;
+    HashItem** m_apkTable;
+
+    // iterator for traversal
+    mutable int m_iIndex;
+    mutable HashItem* m_pkItem;
+};
+
+#include &quot;Wm3THashTable.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3THashTable.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3THashTable.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3THashTable.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,216 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+THashTable&lt;TKEY,TVALUE&gt;::THashTable (int iTableSize)
+{
+    assert(iTableSize &gt; 0);
+
+    m_iTableSize = iTableSize;
+    m_iQuantity = 0;
+    m_iIndex = 0;
+    m_pkItem = 0;
+    m_apkTable = WM3_NEW HashItem*[m_iTableSize];
+    memset(m_apkTable,0,m_iTableSize*sizeof(HashItem*));
+    UserHashFunction = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+THashTable&lt;TKEY,TVALUE&gt;::~THashTable ()
+{
+    RemoveAll();
+    WM3_DELETE[] m_apkTable;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+int THashTable&lt;TKEY,TVALUE&gt;::GetQuantity () const
+{
+    return m_iQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+bool THashTable&lt;TKEY,TVALUE&gt;::Insert (const TKEY&amp; rtKey,
+    const TVALUE&amp; rtValue)
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    // search for item in list associated with key
+    while (pkItem)
+    {
+        if (rtKey == pkItem-&gt;m_tKey)
+        {
+            // item already in hash table
+            return false;
+        }
+        pkItem = pkItem-&gt;m_pkNext;
+    }
+
+    // add item to beginning of list
+    pkItem = WM3_NEW HashItem;
+    pkItem-&gt;m_tKey = rtKey;
+    pkItem-&gt;m_tValue = rtValue;
+    pkItem-&gt;m_pkNext = m_apkTable[iIndex];
+    m_apkTable[iIndex] = pkItem;
+    m_iQuantity++;
+
+    return true;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+TVALUE* THashTable&lt;TKEY,TVALUE&gt;::Find (const TKEY&amp; rtKey) const
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    // search for item in list associated with key
+    while (pkItem)
+    {
+        if (rtKey == pkItem-&gt;m_tKey)
+        {
+            // item is in hash table
+            return &amp;pkItem-&gt;m_tValue;
+        }
+        pkItem = pkItem-&gt;m_pkNext;
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+bool THashTable&lt;TKEY,TVALUE&gt;::Remove (const TKEY&amp; rtKey)
+{
+    // find hash table entry for given key
+    int iIndex = HashFunction(rtKey);
+    HashItem* pkItem = m_apkTable[iIndex];
+
+    if (!pkItem)
+    {
+        return false;
+    }
+
+    if (rtKey == pkItem-&gt;m_tKey)
+    {
+        // item is at front of list, strip it off
+        HashItem* pkSave = pkItem;
+        m_apkTable[iIndex] = pkItem-&gt;m_pkNext;
+        WM3_DELETE pkSave;
+        m_iQuantity--;
+        return true;
+    }
+
+    // search for item in list
+    HashItem* pkPrev = pkItem;
+    HashItem* pkCurr = pkItem-&gt;m_pkNext;
+    while (pkCurr &amp;&amp; rtKey != pkCurr-&gt;m_tKey)
+    {
+        pkPrev = pkCurr;
+        pkCurr = pkCurr-&gt;m_pkNext;
+    }
+
+    if (pkCurr)
+    {
+        // found the item
+        pkPrev-&gt;m_pkNext = pkCurr-&gt;m_pkNext;
+        WM3_DELETE pkCurr;
+        m_iQuantity--;
+        return true;
+    }
+
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+void THashTable&lt;TKEY,TVALUE&gt;::RemoveAll ()
+{
+    if (m_iQuantity &gt; 0)
+    {
+        for (int iIndex = 0; iIndex &lt; m_iTableSize; iIndex++)
+        {
+            while (m_apkTable[iIndex])
+            {
+                HashItem* pkSave = m_apkTable[iIndex];
+                m_apkTable[iIndex] = m_apkTable[iIndex]-&gt;m_pkNext;
+                WM3_DELETE pkSave;
+                if (--m_iQuantity == 0)
+                {
+                    return;
+                }
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+TVALUE* THashTable&lt;TKEY,TVALUE&gt;::GetFirst (TKEY* ptKey) const
+{
+    if (m_iQuantity &gt; 0)
+    {
+        for (m_iIndex = 0; m_iIndex &lt; m_iTableSize; m_iIndex++)
+        {
+            if (m_apkTable[m_iIndex])
+            {
+                m_pkItem = m_apkTable[m_iIndex];
+                *ptKey = m_pkItem-&gt;m_tKey;
+                return &amp;m_pkItem-&gt;m_tValue;
+            }
+        }
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+TVALUE* THashTable&lt;TKEY,TVALUE&gt;::GetNext (TKEY* ptKey) const
+{
+    if (m_iQuantity &gt; 0)
+    {
+        m_pkItem = m_pkItem-&gt;m_pkNext;
+        if (m_pkItem)
+        {
+            *ptKey = m_pkItem-&gt;m_tKey;
+            return &amp;m_pkItem-&gt;m_tValue;
+        }
+        
+        for (m_iIndex++; m_iIndex &lt; m_iTableSize; m_iIndex++)
+        {
+            if (m_apkTable[m_iIndex])
+            {
+                m_pkItem = m_apkTable[m_iIndex];
+                *ptKey = m_pkItem-&gt;m_tKey;
+                return &amp;m_pkItem-&gt;m_tValue;
+            }
+        }
+    }
+
+    return 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class TKEY, class TVALUE&gt;
+int THashTable&lt;TKEY,TVALUE&gt;::HashFunction (const TKEY&amp; rtKey) const
+{
+    if (UserHashFunction)
+    {
+        return (*UserHashFunction)(rtKey);
+    }
+
+    // default hash function
+    static double s_dHashMultiplier = 0.5*(sqrt(5.0)-1.0);
+    unsigned int uiKey;
+    System::Memcpy(&amp;uiKey,sizeof(unsigned int),&amp;rtKey,sizeof(unsigned int));
+    uiKey %= m_iTableSize;
+    double dFraction = fmod(s_dHashMultiplier*uiKey,1.0);
+    return (int)floor(m_iTableSize*dFraction);
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3TList.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TList.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TList.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,55 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3TLIST_H
+#define WM3TLIST_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class T is either native data or is class data that has the following
+// member functions:
+//   T::T ()
+//   T::T (const T&amp;);
+//   T&amp; T::operator= (const T&amp;)
+
+namespace Wm3
+{
+
+template &lt;class T&gt;
+class TList
+{
+public:
+    // construction
+    TList ();
+    TList (const T&amp; rtItem, TList* pkNext);
+    ~TList ();
+
+    // member access
+    void SetItem (const T&amp; rtItem);
+    T&amp; Item ();
+    const T&amp; GetItem () const;
+    void SetNext (TList* pkNext);
+    TList*&amp; Next ();
+    const TList* GetNext () const;
+
+    // total number of nodes in the list, including this one
+    int GetQuantity () const;
+
+private:
+    T m_tItem;
+    TList* m_pkNext;
+};
+
+#include &quot;Wm3TList.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3TList.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TList.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TList.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,78 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TList&lt;T&gt;::TList ()
+{
+    m_pkNext = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TList&lt;T&gt;::TList (const T&amp; rtItem, TList* pkNext)
+    :
+    m_tItem(rtItem)
+{
+    m_pkNext = pkNext;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TList&lt;T&gt;::~TList ()
+{
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TList&lt;T&gt;::SetItem (const T&amp; rtItem)
+{
+    m_tItem = rtItem;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+T&amp; TList&lt;T&gt;::Item ()
+{
+    return m_tItem;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T&amp; TList&lt;T&gt;::GetItem () const
+{
+    return m_tItem;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TList&lt;T&gt;::SetNext (TList* pkNext)
+{
+    m_pkNext = pkNext;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TList&lt;T&gt;*&amp; TList&lt;T&gt;::Next ()
+{
+    return m_pkNext;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const TList&lt;T&gt;* TList&lt;T&gt;::GetNext () const
+{
+    return m_pkNext;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TList&lt;T&gt;::GetQuantity () const
+{
+    int iQuantity = 0;
+    for (const TList&lt;T&gt;* pkIter = this; pkIter; pkIter = pkIter-&gt;m_pkNext)
+    {
+        iQuantity++;
+    }
+    return iQuantity;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3TSet.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TSet.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TSet.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,75 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3TSET_H
+#define WM3TSET_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// This template class is for unordered sets of objects.  The intent is that
+// the sets are not too large.  If you do not plan on searching the set and
+// you know that the elements to be added are unique, then the size of the
+// set is irrelevant since a member function is provided that inserts an
+// element without checking to see if one already exists.
+//
+// The class T is either native data or is class data that has the following
+// member functions:
+//   T::T ()
+//   T::T (const T&amp;);
+//   T&amp; T::operator= (const T&amp;)
+
+namespace Wm3
+{
+
+template &lt;class T&gt;
+class TSet
+{
+public:
+    // construction and destruction
+    TSet ();
+    TSet (int iMaxQuantity, int iGrowBy);
+    TSet (const TSet&amp; rkSet);
+    ~TSet ();
+
+    // assignment
+    TSet&amp; operator= (const TSet&amp; rkSet);
+
+    // member access
+    int GetMaxQuantity () const;
+    int GetGrowBy () const;
+    int GetQuantity () const;
+    T* GetElements ();
+    const T* GetElements () const;
+    T&amp; operator[] (int i);
+    const T&amp; operator[] (int i) const;
+
+    // insertion, removal, searching
+    bool Insert (const T&amp; rkElement);
+    void InsertNoCheck (const T&amp; rkElement);
+    bool Remove (const T&amp; rkElement);
+    bool Exists (const T&amp; rkElement);
+
+    // make empty set, keep quantity and growth parameters
+    void Clear ();
+
+    // make empty set, reallocate using new quantity and growth parameters
+    void Clear (int iMaxQuantity, int iGrowBy);
+
+private:
+    int m_iQuantity, m_iMaxQuantity, m_iGrowBy;
+    T* m_atElement;
+};
+
+#include &quot;Wm3TSet.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3TSet.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TSet.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TSet.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,252 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TSet&lt;T&gt;::TSet ()
+{
+    m_iMaxQuantity = 1;
+    m_iGrowBy = 1;
+    m_iQuantity = 0;
+    m_atElement = WM3_NEW T[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TSet&lt;T&gt;::TSet (int iMaxQuantity, int iGrowBy)
+{
+    assert(iMaxQuantity &gt; 0 &amp;&amp; iGrowBy &gt; 0);
+    if (iMaxQuantity &lt;= 0)
+    {
+        iMaxQuantity = 1;
+    }
+    if (iGrowBy &lt;= 0)
+    {
+        iGrowBy = 1;
+    }
+
+    m_iMaxQuantity = iMaxQuantity;
+    m_iGrowBy = iGrowBy;
+    m_iQuantity = 0;
+    m_atElement = WM3_NEW T[iMaxQuantity];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TSet&lt;T&gt;::TSet (const TSet&amp; rkSet)
+{
+    m_iMaxQuantity = rkSet.m_iMaxQuantity;
+    m_iGrowBy = rkSet.m_iGrowBy;
+    m_iQuantity = rkSet.m_iQuantity;
+    m_atElement = WM3_NEW T[m_iMaxQuantity];
+    for (int i = 0; i &lt; m_iMaxQuantity; i++)
+    {
+        m_atElement[i] = rkSet.m_atElement[i];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TSet&lt;T&gt;::~TSet ()
+{
+    WM3_DELETE[] m_atElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TSet&lt;T&gt;&amp; TSet&lt;T&gt;::operator= (const TSet&amp; rkSet)
+{
+    WM3_DELETE[] m_atElement;
+    m_iMaxQuantity = rkSet.m_iMaxQuantity;
+    m_iGrowBy = rkSet.m_iGrowBy;
+    m_iQuantity = rkSet.m_iQuantity;
+    m_atElement = WM3_NEW T[m_iMaxQuantity];
+    for (int i = 0; i &lt; m_iMaxQuantity; i++)
+    {
+        m_atElement[i] = rkSet.m_atElement[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TSet&lt;T&gt;::GetMaxQuantity () const
+{
+    return m_iMaxQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TSet&lt;T&gt;::GetGrowBy () const
+{
+    return m_iGrowBy;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TSet&lt;T&gt;::GetQuantity () const
+{
+    return m_iQuantity;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+T* TSet&lt;T&gt;::GetElements ()
+{
+    return m_atElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T* TSet&lt;T&gt;::GetElements () const
+{
+    return m_atElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+T&amp; TSet&lt;T&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; m_iQuantity);
+    if (i &lt; 0)
+    {
+        i = 0;
+    }
+    if (i &gt;= m_iQuantity)
+    {
+        i = m_iQuantity-1;
+    }
+
+    return m_atElement[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T&amp; TSet&lt;T&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; m_iQuantity);
+    if (i &lt; 0)
+    {
+        i = 0;
+    }
+    if (i &gt;= m_iQuantity)
+    {
+        i = m_iQuantity-1;
+    }
+
+    return m_atElement[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TSet&lt;T&gt;::Insert (const T&amp; rkElement)
+{
+    for (int i = 0; i &lt; m_iQuantity; i++)
+    {
+        if (rkElement == m_atElement[i])
+        {
+            return false;
+        }
+    }
+
+    if (m_iQuantity == m_iMaxQuantity)
+    {
+        // array is full, resize it
+        int iNewMaxQuantity = m_iMaxQuantity + m_iGrowBy;
+        T* atNewElement = WM3_NEW T[iNewMaxQuantity];
+        for (int i = 0; i &lt; m_iMaxQuantity; i++)
+        {
+            atNewElement[i] = m_atElement[i];
+        }
+        WM3_DELETE[] m_atElement;
+        m_atElement = atNewElement;
+        m_iMaxQuantity = iNewMaxQuantity;
+    }
+
+    m_atElement[m_iQuantity++] = rkElement;
+    return true;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TSet&lt;T&gt;::InsertNoCheck (const T&amp; rkElement)
+{
+    if (m_iQuantity == m_iMaxQuantity)
+    {
+        // array is full, resize it
+        int iNewMaxQuantity = m_iMaxQuantity + m_iGrowBy;
+        T* atNewElement = WM3_NEW T[iNewMaxQuantity];
+        for (int i = 0; i &lt; m_iMaxQuantity; i++)
+        {
+            atNewElement[i] = m_atElement[i];
+        }
+        WM3_DELETE[] m_atElement;
+        m_atElement = atNewElement;
+        m_iMaxQuantity = iNewMaxQuantity;
+    }
+
+    m_atElement[m_iQuantity++] = rkElement;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TSet&lt;T&gt;::Remove (const T&amp; rkElement)
+{
+    for (int i = 0; i &lt; m_iQuantity; i++)
+    {
+        if (rkElement == m_atElement[i])
+        {
+            // element exists, shift array to fill in empty slot
+            for (int j = i+1; j &lt; m_iQuantity; j++, i++)
+            {
+                m_atElement[i] = m_atElement[j];
+            }
+
+            m_atElement[m_iQuantity-1] = T();
+            m_iQuantity--;
+            return true;
+        }
+    }
+
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TSet&lt;T&gt;::Exists (const T&amp; rkElement)
+{
+    for (int i = 0; i &lt; m_iQuantity; i++)
+    {
+        if (rkElement == m_atElement[i])
+        {
+            return true;
+        }
+    }
+
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TSet&lt;T&gt;::Clear ()
+{
+    for (int i = 0; i &lt; m_iQuantity; i++)
+    {
+        m_atElement[i] = T();
+    }
+
+    m_iQuantity = 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TSet&lt;T&gt;::Clear (int iMaxQuantity, int iGrowBy)
+{
+    assert(iMaxQuantity &gt; 0 &amp;&amp; iGrowBy &gt; 0);
+    if (iMaxQuantity &lt;= 0)
+    {
+        iMaxQuantity = 1;
+    }
+    if (iGrowBy &lt;= 0)
+    {
+        iGrowBy = 1;
+    }
+
+    WM3_DELETE[] m_atElement;
+    m_iMaxQuantity = iMaxQuantity;
+    m_iGrowBy = iGrowBy;
+    m_iQuantity = 0;
+    m_atElement = WM3_NEW T[iMaxQuantity];
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3TStack.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TStack.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TStack.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,53 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3TSTACK_H
+#define WM3TSTACK_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class T is either native data or is class data that has the following
+// member functions:
+//   T::T ()
+//   T::T (const T&amp;);
+//   T&amp; T::operator= (const T&amp;)
+
+namespace Wm3
+{
+
+template &lt;class T&gt;
+class TStack
+{
+public:
+    TStack (int iMaxQuantity = 64);
+    ~TStack ();
+
+    bool IsEmpty () const;
+    bool IsFull () const;
+    void Push (const T&amp; rkItem);
+    void Pop (T&amp; rkItem);
+    void Clear ();
+    bool GetTop (T&amp; rkItem) const;
+
+    // for iteration over the stack elements
+    int GetQuantity () const;
+    const T* GetData () const;
+
+private:
+    int m_iMaxQuantity, m_iTop;
+    T* m_atStack;
+};
+
+#include &quot;Wm3TStack.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3TStack.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TStack.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TStack.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,106 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TStack&lt;T&gt;::TStack (int iMaxQuantity)
+{
+    assert(iMaxQuantity &gt; 0);
+    m_iMaxQuantity = iMaxQuantity;
+    m_iTop = -1;
+    m_atStack = WM3_NEW T[m_iMaxQuantity];
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+TStack&lt;T&gt;::~TStack ()
+{
+    WM3_DELETE[] m_atStack;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TStack&lt;T&gt;::IsEmpty () const
+{
+    return m_iTop == -1;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TStack&lt;T&gt;::IsFull () const
+{
+    return m_iTop &gt;= m_iMaxQuantity-1;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TStack&lt;T&gt;::Push (const T&amp; rkItem)
+{
+    m_iTop++;
+    if (m_iTop &lt;= m_iMaxQuantity-1)
+    {
+        m_atStack[m_iTop] = rkItem;
+    }
+    else
+    {
+        // stack full, should not happen
+        assert(false);
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TStack&lt;T&gt;::Pop (T&amp; rkItem)
+{
+    if (m_iTop &gt;= 0)
+    {
+        if (m_iTop &lt;= m_iMaxQuantity-1)
+        {
+            rkItem = m_atStack[m_iTop];
+        }
+        else
+        {
+            // stack full, should not happen
+            assert(false);
+        }
+        m_iTop--;
+    }
+    else
+    {
+        // stack empty, should not happen
+        assert(false);
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+void TStack&lt;T&gt;::Clear ()
+{
+    m_iTop = -1;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+bool TStack&lt;T&gt;::GetTop (T&amp; rkItem) const
+{
+    if (0 &lt;= m_iTop &amp;&amp; m_iTop &lt;= m_iMaxQuantity-1)
+    {
+        rkItem = m_atStack[m_iTop];
+        return true;
+    }
+    return false;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+int TStack&lt;T&gt;::GetQuantity () const
+{
+    return m_iTop+1;
+}
+//----------------------------------------------------------------------------
+template &lt;class T&gt;
+const T* TStack&lt;T&gt;::GetData () const
+{
+    return m_atStack;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3TTuple.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TTuple.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TTuple.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,64 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3TTUPLE_H
+#define WM3TTUPLE_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+
+// The class TYPE is either native data or is class data that has the
+// following member functions:
+//   TYPE::TYPE ()
+//   TYPE::TYPE (const TYPE&amp;);
+//   TYPE&amp; TYPE::operator= (const TYPE&amp;)
+
+namespace Wm3
+{
+
+template &lt;int DIMENSION, class TYPE&gt;
+class TTuple
+{
+public:
+    // Construction and destruction.  The default constructor does not
+    // initialize the tuple elements for native elements.  The tuple elements
+    // are initialized for class data whenever TYPE initializes during its
+    // default construction.
+    TTuple ();
+    TTuple (const TTuple&amp; rkT);
+    ~TTuple ();
+
+    // coordinate access
+    operator const TYPE* () const;
+    operator TYPE* ();
+    TYPE operator[] (int i) const;
+    TYPE&amp; operator[] (int i);
+
+    // assignment
+    TTuple&amp; operator= (const TTuple&amp; rkT);
+
+    // Comparison.  The inequalities make the comparisons using memcmp, thus
+    // treating the tuple as an array of unsigned bytes.
+    bool operator== (const TTuple&amp; rkT) const;
+    bool operator!= (const TTuple&amp; rkT) const;
+    bool operator&lt;  (const TTuple&amp; rkT) const;
+    bool operator&lt;= (const TTuple&amp; rkT) const;
+    bool operator&gt;  (const TTuple&amp; rkT) const;
+    bool operator&gt;= (const TTuple&amp; rkT) const;
+
+private:
+    TYPE m_atTuple[DIMENSION];
+};
+
+#include &quot;Wm3TTuple.inl&quot;
+
+}
+
+#endif
+

Added: branches/scons-layout/lib/miniWm3/Wm3TTuple.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3TTuple.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3TTuple.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,111 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;::TTuple ()
+{
+    // Uninitialized for native data.  Initialized for class data as long as
+    // TYPE's default constructor initializes its own data.
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;::~TTuple ()
+{
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;::TTuple (const TTuple&amp; rkT)
+{
+    for (int i = 0; i &lt; DIMENSION; i++)
+    {
+        m_atTuple[i] = rkT.m_atTuple[i];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;::operator const TYPE* () const
+{
+    return m_atTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;::operator TYPE* ()
+{
+    return m_atTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TYPE TTuple&lt;DIMENSION,TYPE&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; DIMENSION);
+    return m_atTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TYPE&amp; TTuple&lt;DIMENSION,TYPE&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt; DIMENSION);
+    return m_atTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+TTuple&lt;DIMENSION,TYPE&gt;&amp; TTuple&lt;DIMENSION,TYPE&gt;::operator= (const TTuple&amp; rkT)
+{
+    for (int i = 0; i &lt; DIMENSION; i++)
+    {
+        m_atTuple[i] = rkT.m_atTuple[i];
+    }
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator== (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator!= (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator&lt; (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator&lt;= (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator&gt; (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;int DIMENSION, class TYPE&gt;
+bool TTuple&lt;DIMENSION,TYPE&gt;::operator&gt;= (const TTuple&amp; rkT) const
+{
+    const size_t uiSize = DIMENSION*sizeof(TYPE);
+    return memcmp(m_atTuple,rkT.m_atTuple,uiSize) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Vector2.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector2.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector2.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,23 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Vector2.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Vector2&lt;float&gt; Vector2&lt;float&gt;::ZERO(0.0f,0.0f);
+template&lt;&gt; const Vector2&lt;float&gt; Vector2&lt;float&gt;::UNIT_X(1.0f,0.0f);
+template&lt;&gt; const Vector2&lt;float&gt; Vector2&lt;float&gt;::UNIT_Y(0.0f,1.0f);
+template&lt;&gt; const Vector2&lt;float&gt; Vector2&lt;float&gt;::ONE(1.0f,1.0f);
+
+template&lt;&gt; const Vector2&lt;double&gt; Vector2&lt;double&gt;::ZERO(0.0,0.0);
+template&lt;&gt; const Vector2&lt;double&gt; Vector2&lt;double&gt;::UNIT_X(1.0,0.0);
+template&lt;&gt; const Vector2&lt;double&gt; Vector2&lt;double&gt;::UNIT_Y(0.0,1.0);
+template&lt;&gt; const Vector2&lt;double&gt; Vector2&lt;double&gt;::ONE(1.0,1.0);

Added: branches/scons-layout/lib/miniWm3/Wm3Vector2.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector2.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector2.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,128 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3VECTOR2_H
+#define WM3VECTOR2_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Math.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Vector2
+{
+public:
+    // construction
+    Vector2 ();  // uninitialized
+    Vector2 (Real fX, Real fY);
+    Vector2 (const Real* afTuple);
+    Vector2 (const Vector2&amp; rkV);
+
+    // coordinate access
+    operator const Real* () const;
+    operator Real* ();
+    Real operator[] (int i) const;
+    Real&amp; operator[] (int i);
+    Real X () const;
+    Real&amp; X ();
+    Real Y () const;
+    Real&amp; Y ();
+
+    // assignment
+    Vector2&amp; operator= (const Vector2&amp; rkV);
+
+    // comparison
+    bool operator== (const Vector2&amp; rkV) const;
+    bool operator!= (const Vector2&amp; rkV) const;
+    bool operator&lt;  (const Vector2&amp; rkV) const;
+    bool operator&lt;= (const Vector2&amp; rkV) const;
+    bool operator&gt;  (const Vector2&amp; rkV) const;
+    bool operator&gt;= (const Vector2&amp; rkV) const;
+
+    // arithmetic operations
+    Vector2 operator+ (const Vector2&amp; rkV) const;
+    Vector2 operator- (const Vector2&amp; rkV) const;
+    Vector2 operator* (Real fScalar) const;
+    Vector2 operator/ (Real fScalar) const;
+    Vector2 operator- () const;
+
+    // arithmetic updates
+    Vector2&amp; operator+= (const Vector2&amp; rkV);
+    Vector2&amp; operator-= (const Vector2&amp; rkV);
+    Vector2&amp; operator*= (Real fScalar);
+    Vector2&amp; operator/= (Real fScalar);
+
+    // vector operations
+    Real Length () const;
+    Real SquaredLength () const;
+    Real Dot (const Vector2&amp; rkV) const;
+    Real Normalize ();
+
+    // returns (y,-x)
+    Vector2 Perp () const;
+
+    // returns (y,-x)/sqrt(x*x+y*y)
+    Vector2 UnitPerp () const;
+
+    // returns DotPerp((x,y),(V.x,V.y)) = x*V.y - y*V.x
+    Real DotPerp (const Vector2&amp; rkV) const;
+
+    // Compute the barycentric coordinates of the point with respect to the
+    // triangle &lt;V0,V1,V2&gt;, P = b0*V0 + b1*V1 + b2*V2, where b0 + b1 + b2 = 1.
+    void GetBarycentrics (const Vector2&lt;Real&gt;&amp; rkV0,
+        const Vector2&lt;Real&gt;&amp; rkV1, const Vector2&lt;Real&gt;&amp; rkV2,
+        Real afBary[3]) const;
+
+    // Gram-Schmidt orthonormalization.  Take linearly independent vectors U
+    // and V and compute an orthonormal set (unit length, mutually
+    // perpendicular).
+    static void Orthonormalize (Vector2&amp; rkU, Vector2&amp; rkV);
+
+    // Input V must be initialized to a nonzero vector, output is {U,V}, an
+    // orthonormal basis.  A hint is provided about whether or not V is
+    // already unit length.
+    static void GenerateOrthonormalBasis (Vector2&amp; rkU, Vector2&amp; rkV,
+        bool bUnitLengthV);
+
+    // Compute the extreme values.
+    static void ComputeExtremes (int iVQuantity, const Vector2* akPoint,
+        Vector2&amp; rkMin, Vector2&amp; rkMax);
+
+    // special vectors
+    WM3_ITEM static const Vector2 ZERO;    // (0,0)
+    WM3_ITEM static const Vector2 UNIT_X;  // (1,0)
+    WM3_ITEM static const Vector2 UNIT_Y;  // (0,1)
+    WM3_ITEM static const Vector2 ONE;     // (1,1)
+
+private:
+    // support for comparisons
+    int CompareArrays (const Vector2&amp; rkV) const;
+
+    Real m_afTuple[2];
+};
+
+// arithmetic operations
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; operator* (Real fScalar, const Vector2&lt;Real&gt;&amp; rkV);
+
+// debugging output
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector2&lt;Real&gt;&amp; rkV);
+
+#include &quot;Wm3Vector2.inl&quot;
+
+typedef Vector2&lt;float&gt; Vector2f;
+typedef Vector2&lt;double&gt; Vector2d;
+
+}
+
+#endif

Added: branches/scons-layout/lib/miniWm3/Wm3Vector2.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector2.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector2.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,475 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::Vector2 ()
+{
+    // uninitialized for performance in array construction
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::Vector2 (Real fX, Real fY)
+{
+    m_afTuple[0] = fX;
+    m_afTuple[1] = fY;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::Vector2 (const Real* afTuple)
+{
+    m_afTuple[0] = afTuple[0];
+    m_afTuple[1] = afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::Vector2 (const Vector2&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::operator const Real* () const
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;::operator Real* ()
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 1);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector2&lt;Real&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 1);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::X () const
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector2&lt;Real&gt;::X ()
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::Y () const
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector2&lt;Real&gt;::Y ()
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;&amp; Vector2&lt;Real&gt;::operator= (const Vector2&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Vector2&lt;Real&gt;::CompareArrays (const Vector2&amp; rkV) const
+{
+    return memcmp(m_afTuple,rkV.m_afTuple,2*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator== (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator!= (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator&lt; (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator&lt;= (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator&gt; (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector2&lt;Real&gt;::operator&gt;= (const Vector2&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::operator+ (const Vector2&amp; rkV) const
+{
+    return Vector2(
+        m_afTuple[0]+rkV.m_afTuple[0],
+        m_afTuple[1]+rkV.m_afTuple[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::operator- (const Vector2&amp; rkV) const
+{
+    return Vector2(
+        m_afTuple[0]-rkV.m_afTuple[0],
+        m_afTuple[1]-rkV.m_afTuple[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::operator* (Real fScalar) const
+{
+    return Vector2(
+        fScalar*m_afTuple[0],
+        fScalar*m_afTuple[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Vector2 kQuot;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        kQuot.m_afTuple[0] = fInvScalar*m_afTuple[0];
+        kQuot.m_afTuple[1] = fInvScalar*m_afTuple[1];
+    }
+    else
+    {
+        kQuot.m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::operator- () const
+{
+    return Vector2(
+        -m_afTuple[0],
+        -m_afTuple[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; operator* (Real fScalar, const Vector2&lt;Real&gt;&amp; rkV)
+{
+    return Vector2&lt;Real&gt;(
+        fScalar*rkV[0],
+        fScalar*rkV[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;&amp; Vector2&lt;Real&gt;::operator+= (const Vector2&amp; rkV)
+{
+    m_afTuple[0] += rkV.m_afTuple[0];
+    m_afTuple[1] += rkV.m_afTuple[1];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;&amp; Vector2&lt;Real&gt;::operator-= (const Vector2&amp; rkV)
+{
+    m_afTuple[0] -= rkV.m_afTuple[0];
+    m_afTuple[1] -= rkV.m_afTuple[1];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;&amp; Vector2&lt;Real&gt;::operator*= (Real fScalar)
+{
+    m_afTuple[0] *= fScalar;
+    m_afTuple[1] *= fScalar;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt;&amp; Vector2&lt;Real&gt;::operator/= (Real fScalar)
+{
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        m_afTuple[0] *= fInvScalar;
+        m_afTuple[1] *= fInvScalar;
+    }
+    else
+    {
+        m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::Length () const
+{
+    return Math&lt;Real&gt;::Sqrt(
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::SquaredLength () const
+{
+    return
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::Dot (const Vector2&amp; rkV) const
+{
+    return
+        m_afTuple[0]*rkV.m_afTuple[0] +
+        m_afTuple[1]*rkV.m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::Normalize ()
+{
+    Real fLength = Length();
+
+    if (fLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvLength = ((Real)1.0)/fLength;
+        m_afTuple[0] *= fInvLength;
+        m_afTuple[1] *= fInvLength;
+    }
+    else
+    {
+        fLength = (Real)0.0;
+        m_afTuple[0] = (Real)0.0;
+        m_afTuple[1] = (Real)0.0;
+    }
+
+    return fLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::Perp () const
+{
+    return Vector2(m_afTuple[1],-m_afTuple[0]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector2&lt;Real&gt; Vector2&lt;Real&gt;::UnitPerp () const
+{
+    Vector2 kPerp(m_afTuple[1],-m_afTuple[0]);
+    kPerp.Normalize();
+    return kPerp;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector2&lt;Real&gt;::DotPerp (const Vector2&amp; rkV) const
+{
+    return m_afTuple[0]*rkV.m_afTuple[1] - m_afTuple[1]*rkV.m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector2&lt;Real&gt;::GetBarycentrics (const Vector2&lt;Real&gt;&amp; rkV0,
+    const Vector2&lt;Real&gt;&amp; rkV1, const Vector2&lt;Real&gt;&amp; rkV2, Real afBary[3])
+    const
+{
+    // compute the vectors relative to V2 of the triangle
+    Vector2&lt;Real&gt; akDiff[3] =
+    {
+        rkV0 - rkV2,
+        rkV1 - rkV2,
+        *this - rkV2
+    };
+
+    // If the vertices have large magnitude, the linear system of equations
+    // for computing barycentric coordinates can be ill-conditioned.  To avoid
+    // this, uniformly scale the triangle edges to be of order 1.  The scaling
+    // of all differences does not change the barycentric coordinates.
+    Real fMax = (Real)0.0;
+    int i;
+    for (i = 0; i &lt; 2; i++)
+    {
+        for (int j = 0; j &lt; 2; j++)
+        {
+            Real fValue = Math&lt;Real&gt;::FAbs(akDiff[i][j]);
+            if (fValue &gt; fMax)
+            {
+                fMax = fValue;
+            }
+        }
+    }
+
+    // scale down only large data
+    if (fMax &gt; (Real)1.0)
+    {
+        Real fInvMax = ((Real)1.0)/fMax;
+        for (i = 0; i &lt; 3; i++)
+        {
+            akDiff[i] *= fInvMax;
+        }
+    }
+
+    Real fDet = akDiff[0].DotPerp(akDiff[1]);
+    if (Math&lt;Real&gt;::FAbs(fDet) &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvDet = ((Real)1.0)/fDet;
+        afBary[0] = akDiff[2].DotPerp(akDiff[1])*fInvDet;
+        afBary[1] = akDiff[0].DotPerp(akDiff[2])*fInvDet;
+        afBary[2] = (Real)1.0 - afBary[0] - afBary[1];
+    }
+    else
+    {
+        // The triangle is a sliver.  Determine the longest edge and
+        // compute barycentric coordinates with respect to that edge.
+        Vector2&lt;Real&gt; kE2 = rkV0 - rkV1;
+        Real fMaxSqrLength = kE2.SquaredLength();
+        int iMaxIndex = 2;
+        Real fSqrLength = akDiff[1].SquaredLength();
+        if (fSqrLength &gt; fMaxSqrLength)
+        {
+            iMaxIndex = 1;
+            fMaxSqrLength = fSqrLength;
+        }
+        fSqrLength = akDiff[0].SquaredLength();
+        if (fSqrLength &gt; fMaxSqrLength)
+        {
+            iMaxIndex = 0;
+            fMaxSqrLength = fSqrLength;
+        }
+
+        if (fMaxSqrLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+        {
+            Real fInvSqrLength = ((Real)1.0)/fMaxSqrLength;
+            if (iMaxIndex == 0)
+            {
+                // P-V2 = t(V0-V2)
+                afBary[0] = akDiff[2].Dot(akDiff[0])*fInvSqrLength;
+                afBary[1] = (Real)0.0;
+                afBary[2] = (Real)1.0 - afBary[0];
+            }
+            else if (iMaxIndex == 1)
+            {
+                // P-V2 = t(V1-V2)
+                afBary[0] = (Real)0.0;
+                afBary[1] = akDiff[2].Dot(akDiff[1])*fInvSqrLength;
+                afBary[2] = (Real)1.0 - afBary[1];
+            }
+            else
+            {
+                // P-V1 = t(V0-V1)
+                akDiff[2] = *this - rkV1;
+                afBary[0] = akDiff[2].Dot(kE2)*fInvSqrLength;
+                afBary[1] = (Real)1.0 - afBary[0];
+                afBary[2] = (Real)0.0;
+            }
+        }
+        else
+        {
+            // triangle is a nearly a point, just return equal weights
+            afBary[0] = ((Real)1.0)/(Real)3.0;
+            afBary[1] = afBary[0];
+            afBary[2] = afBary[0];
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector2&lt;Real&gt;::Orthonormalize (Vector2&amp; rkU, Vector2&amp; rkV)
+{
+    // If the input vectors are v0 and v1, then the Gram-Schmidt
+    // orthonormalization produces vectors u0 and u1 as follows,
+    //
+    //   u0 = v0/|v0|
+    //   u1 = (v1-(u0*v1)u0)/|v1-(u0*v1)u0|
+    //
+    // where |A| indicates length of vector A and A*B indicates dot
+    // product of vectors A and B.
+
+    // compute u0
+    rkU.Normalize();
+
+    // compute u1
+    Real fDot0 = rkU.Dot(rkV); 
+    rkV -= rkU*fDot0;
+    rkV.Normalize();
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector2&lt;Real&gt;::GenerateOrthonormalBasis (Vector2&amp; rkU, Vector2&amp; rkV,
+    bool bUnitLengthV)
+{
+    if (!bUnitLengthV)
+    {
+        rkV.Normalize();
+    }
+
+    rkU = rkV.Perp();
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector2&lt;Real&gt;::ComputeExtremes (int iVQuantity, const Vector2* akPoint,
+    Vector2&amp; rkMin, Vector2&amp; rkMax)
+{
+    assert(iVQuantity &gt; 0 &amp;&amp; akPoint);
+
+    rkMin = akPoint[0];
+    rkMax = rkMin;
+    for (int i = 1; i &lt; iVQuantity; i++)
+    {
+        const Vector2&lt;Real&gt;&amp; rkPoint = akPoint[i];
+        for (int j = 0; j &lt; 2; j++)
+        {
+            if (rkPoint[j] &lt; rkMin[j])
+            {
+                rkMin[j] = rkPoint[j];
+            }
+            else if (rkPoint[j] &gt; rkMax[j])
+            {
+                rkMax[j] = rkPoint[j];
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector2&lt;Real&gt;&amp; rkV)
+{
+     return rkOStr &lt;&lt; rkV.X() &lt;&lt; ' ' &lt;&lt; rkV.Y();
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Vector3.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector3.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector3.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,25 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Vector3.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Vector3&lt;float&gt; Vector3&lt;float&gt;::ZERO(0.0f,0.0f,0.0f);
+template&lt;&gt; const Vector3&lt;float&gt; Vector3&lt;float&gt;::UNIT_X(1.0f,0.0f,0.0f);
+template&lt;&gt; const Vector3&lt;float&gt; Vector3&lt;float&gt;::UNIT_Y(0.0f,1.0f,0.0f);
+template&lt;&gt; const Vector3&lt;float&gt; Vector3&lt;float&gt;::UNIT_Z(0.0f,0.0f,1.0f);
+template&lt;&gt; const Vector3&lt;float&gt; Vector3&lt;float&gt;::ONE(1.0f,1.0f,1.0f);
+
+template&lt;&gt; const Vector3&lt;double&gt; Vector3&lt;double&gt;::ZERO(0.0,0.0,0.0);
+template&lt;&gt; const Vector3&lt;double&gt; Vector3&lt;double&gt;::UNIT_X(1.0,0.0,0.0);
+template&lt;&gt; const Vector3&lt;double&gt; Vector3&lt;double&gt;::UNIT_Y(0.0,1.0,0.0);
+template&lt;&gt; const Vector3&lt;double&gt; Vector3&lt;double&gt;::UNIT_Z(0.0,0.0,1.0);
+template&lt;&gt; const Vector3&lt;double&gt; Vector3&lt;double&gt;::ONE(1.0,1.0,1.0);

Added: branches/scons-layout/lib/miniWm3/Wm3Vector3.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector3.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector3.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,132 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3VECTOR3_H
+#define WM3VECTOR3_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Math.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Vector3
+{
+public:
+    // construction
+    Vector3 ();  // uninitialized
+    Vector3 (Real fX, Real fY, Real fZ);
+    Vector3 (const Real* afTuple);
+    Vector3 (const Vector3&amp; rkV);
+
+    // coordinate access
+    operator const Real* () const;
+    operator Real* ();
+    Real operator[] (int i) const;
+    Real&amp; operator[] (int i);
+    Real X () const;
+    Real&amp; X ();
+    Real Y () const;
+    Real&amp; Y ();
+    Real Z () const;
+    Real&amp; Z ();
+
+    // assignment
+    Vector3&amp; operator= (const Vector3&amp; rkV);
+
+    // comparison
+    bool operator== (const Vector3&amp; rkV) const;
+    bool operator!= (const Vector3&amp; rkV) const;
+    bool operator&lt;  (const Vector3&amp; rkV) const;
+    bool operator&lt;= (const Vector3&amp; rkV) const;
+    bool operator&gt;  (const Vector3&amp; rkV) const;
+    bool operator&gt;= (const Vector3&amp; rkV) const;
+
+    // arithmetic operations
+    Vector3 operator+ (const Vector3&amp; rkV) const;
+    Vector3 operator- (const Vector3&amp; rkV) const;
+    Vector3 operator* (Real fScalar) const;
+    Vector3 operator/ (Real fScalar) const;
+    Vector3 operator- () const;
+
+    // arithmetic updates
+    Vector3&amp; operator+= (const Vector3&amp; rkV);
+    Vector3&amp; operator-= (const Vector3&amp; rkV);
+    Vector3&amp; operator*= (Real fScalar);
+    Vector3&amp; operator/= (Real fScalar);
+
+    // vector operations
+    Real Length () const;
+    Real SquaredLength () const;
+    Real Dot (const Vector3&amp; rkV) const;
+    Real Normalize ();
+
+    // The cross products are computed using the right-handed rule.  Be aware
+    // that some graphics APIs use a left-handed rule.  If you have to compute
+    // a cross product with these functions and send the result to the API
+    // that expects left-handed, you will need to change sign on the vector
+    // (replace each component value c by -c).
+    Vector3 Cross (const Vector3&amp; rkV) const;
+    Vector3 UnitCross (const Vector3&amp; rkV) const;
+
+    // Compute the barycentric coordinates of the point with respect to the
+    // tetrahedron &lt;V0,V1,V2,V3&gt;, P = b0*V0 + b1*V1 + b2*V2 + b3*V3, where
+    // b0 + b1 + b2 + b3 = 1.
+    void GetBarycentrics (const Vector3&lt;Real&gt;&amp; rkV0,
+        const Vector3&lt;Real&gt;&amp; rkV1, const Vector3&lt;Real&gt;&amp; rkV2,
+        const Vector3&lt;Real&gt;&amp; rkV3, Real afBary[4]) const;
+
+    // Gram-Schmidt orthonormalization.  Take linearly independent vectors
+    // U, V, and W and compute an orthonormal set (unit length, mutually
+    // perpendicular).
+    static void Orthonormalize (Vector3&amp; rkU, Vector3&amp; rkV, Vector3&amp; rkW);
+    static void Orthonormalize (Vector3* akV);
+
+    // Input W must be initialized to a nonzero vector, output is {U,V,W},
+    // an orthonormal basis.  A hint is provided about whether or not W
+    // is already unit length.
+    static void GenerateOrthonormalBasis (Vector3&amp; rkU, Vector3&amp; rkV,
+        Vector3&amp; rkW, bool bUnitLengthW);
+
+    // Compute the extreme values.
+    static void ComputeExtremes (int iVQuantity, const Vector3* akPoint,
+        Vector3&amp; rkMin, Vector3&amp; rkMax);
+
+    // special vectors
+    WM3_ITEM static const Vector3 ZERO;    // (0,0,0)
+    WM3_ITEM static const Vector3 UNIT_X;  // (1,0,0)
+    WM3_ITEM static const Vector3 UNIT_Y;  // (0,1,0)
+    WM3_ITEM static const Vector3 UNIT_Z;  // (0,0,1)
+    WM3_ITEM static const Vector3 ONE;     // (1,1,1)
+
+private:
+    // support for comparisons
+    int CompareArrays (const Vector3&amp; rkV) const;
+
+    Real m_afTuple[3];
+};
+
+// arithmetic operations
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; operator* (Real fScalar, const Vector3&lt;Real&gt;&amp; rkV);
+
+// debugging output
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector3&lt;Real&gt;&amp; rkV);
+
+#include &quot;Wm3Vector3.inl&quot;
+
+typedef Vector3&lt;float&gt; Vector3f;
+typedef Vector3&lt;double&gt; Vector3d;
+
+}
+
+#endif

Added: branches/scons-layout/lib/miniWm3/Wm3Vector3.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector3.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector3.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,676 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::Vector3 ()
+{
+    // uninitialized for performance in array construction
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::Vector3 (Real fX, Real fY, Real fZ)
+{
+    m_afTuple[0] = fX;
+    m_afTuple[1] = fY;
+    m_afTuple[2] = fZ;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::Vector3 (const Real* afTuple)
+{
+    m_afTuple[0] = afTuple[0];
+    m_afTuple[1] = afTuple[1];
+    m_afTuple[2] = afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::Vector3 (const Vector3&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+    m_afTuple[2] = rkV.m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::operator const Real* () const
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;::operator Real* ()
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 2);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector3&lt;Real&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 2);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::X () const
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector3&lt;Real&gt;::X ()
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::Y () const
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector3&lt;Real&gt;::Y ()
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::Z () const
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector3&lt;Real&gt;::Z ()
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;&amp; Vector3&lt;Real&gt;::operator= (const Vector3&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+    m_afTuple[2] = rkV.m_afTuple[2];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Vector3&lt;Real&gt;::CompareArrays (const Vector3&amp; rkV) const
+{
+    return memcmp(m_afTuple,rkV.m_afTuple,3*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator== (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator!= (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator&lt; (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator&lt;= (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator&gt; (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector3&lt;Real&gt;::operator&gt;= (const Vector3&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::operator+ (const Vector3&amp; rkV) const
+{
+    return Vector3(
+        m_afTuple[0]+rkV.m_afTuple[0],
+        m_afTuple[1]+rkV.m_afTuple[1],
+        m_afTuple[2]+rkV.m_afTuple[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::operator- (const Vector3&amp; rkV) const
+{
+    return Vector3(
+        m_afTuple[0]-rkV.m_afTuple[0],
+        m_afTuple[1]-rkV.m_afTuple[1],
+        m_afTuple[2]-rkV.m_afTuple[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::operator* (Real fScalar) const
+{
+    return Vector3(
+        fScalar*m_afTuple[0],
+        fScalar*m_afTuple[1],
+        fScalar*m_afTuple[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Vector3 kQuot;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        kQuot.m_afTuple[0] = fInvScalar*m_afTuple[0];
+        kQuot.m_afTuple[1] = fInvScalar*m_afTuple[1];
+        kQuot.m_afTuple[2] = fInvScalar*m_afTuple[2];
+    }
+    else
+    {
+        kQuot.m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[2] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::operator- () const
+{
+    return Vector3(
+        -m_afTuple[0],
+        -m_afTuple[1],
+        -m_afTuple[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; operator* (Real fScalar, const Vector3&lt;Real&gt;&amp; rkV)
+{
+    return Vector3&lt;Real&gt;(
+        fScalar*rkV[0],
+        fScalar*rkV[1],
+        fScalar*rkV[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;&amp; Vector3&lt;Real&gt;::operator+= (const Vector3&amp; rkV)
+{
+    m_afTuple[0] += rkV.m_afTuple[0];
+    m_afTuple[1] += rkV.m_afTuple[1];
+    m_afTuple[2] += rkV.m_afTuple[2];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;&amp; Vector3&lt;Real&gt;::operator-= (const Vector3&amp; rkV)
+{
+    m_afTuple[0] -= rkV.m_afTuple[0];
+    m_afTuple[1] -= rkV.m_afTuple[1];
+    m_afTuple[2] -= rkV.m_afTuple[2];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;&amp; Vector3&lt;Real&gt;::operator*= (Real fScalar)
+{
+    m_afTuple[0] *= fScalar;
+    m_afTuple[1] *= fScalar;
+    m_afTuple[2] *= fScalar;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt;&amp; Vector3&lt;Real&gt;::operator/= (Real fScalar)
+{
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        m_afTuple[0] *= fInvScalar;
+        m_afTuple[1] *= fInvScalar;
+        m_afTuple[2] *= fInvScalar;
+    }
+    else
+    {
+        m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[2] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::Length () const
+{
+    return Math&lt;Real&gt;::Sqrt(
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::SquaredLength () const
+{
+    return
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::Dot (const Vector3&amp; rkV) const
+{
+    return
+        m_afTuple[0]*rkV.m_afTuple[0] +
+        m_afTuple[1]*rkV.m_afTuple[1] +
+        m_afTuple[2]*rkV.m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector3&lt;Real&gt;::Normalize ()
+{
+    Real fLength = Length();
+
+    if (fLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvLength = ((Real)1.0)/fLength;
+        m_afTuple[0] *= fInvLength;
+        m_afTuple[1] *= fInvLength;
+        m_afTuple[2] *= fInvLength;
+    }
+    else
+    {
+        fLength = (Real)0.0;
+        m_afTuple[0] = (Real)0.0;
+        m_afTuple[1] = (Real)0.0;
+        m_afTuple[2] = (Real)0.0;
+    }
+
+    return fLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::Cross (const Vector3&amp; rkV) const
+{
+    return Vector3(
+        m_afTuple[1]*rkV.m_afTuple[2] - m_afTuple[2]*rkV.m_afTuple[1],
+        m_afTuple[2]*rkV.m_afTuple[0] - m_afTuple[0]*rkV.m_afTuple[2],
+        m_afTuple[0]*rkV.m_afTuple[1] - m_afTuple[1]*rkV.m_afTuple[0]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector3&lt;Real&gt; Vector3&lt;Real&gt;::UnitCross (const Vector3&amp; rkV) const
+{
+    Vector3 kCross(
+        m_afTuple[1]*rkV.m_afTuple[2] - m_afTuple[2]*rkV.m_afTuple[1],
+        m_afTuple[2]*rkV.m_afTuple[0] - m_afTuple[0]*rkV.m_afTuple[2],
+        m_afTuple[0]*rkV.m_afTuple[1] - m_afTuple[1]*rkV.m_afTuple[0]);
+    kCross.Normalize();
+    return kCross;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector3&lt;Real&gt;::GetBarycentrics (const Vector3&lt;Real&gt;&amp; rkV0,
+    const Vector3&lt;Real&gt;&amp; rkV1, const Vector3&lt;Real&gt;&amp; rkV2,
+    const Vector3&lt;Real&gt;&amp; rkV3, Real afBary[4]) const
+{
+    // compute the vectors relative to V3 of the tetrahedron
+    Vector3&lt;Real&gt; akDiff[4] =
+    {
+        rkV0 - rkV3,
+        rkV1 - rkV3,
+        rkV2 - rkV3,
+        *this - rkV3
+    };
+
+    // If the vertices have large magnitude, the linear system of
+    // equations for computing barycentric coordinates can be
+    // ill-conditioned.  To avoid this, uniformly scale the tetrahedron
+    // edges to be of order 1.  The scaling of all differences does not
+    // change the barycentric coordinates.
+    Real fMax = (Real)0.0;
+    int i;
+    for (i = 0; i &lt; 3; i++)
+    {
+        for (int j = 0; j &lt; 3; j++)
+        {
+            Real fValue = Math&lt;Real&gt;::FAbs(akDiff[i][j]);
+            if (fValue &gt; fMax)
+            {
+                fMax = fValue;
+            }
+        }
+    }
+
+    // scale down only large data
+    if (fMax &gt; (Real)1.0)
+    {
+        Real fInvMax = ((Real)1.0)/fMax;
+        for (i = 0; i &lt; 4; i++)
+        {
+            akDiff[i] *= fInvMax;
+        }
+    }
+
+    Real fDet = akDiff[0].Dot(akDiff[1].Cross(akDiff[2]));
+    Vector3&lt;Real&gt; kE1cE2 = akDiff[1].Cross(akDiff[2]);
+    Vector3&lt;Real&gt; kE2cE0 = akDiff[2].Cross(akDiff[0]);
+    Vector3&lt;Real&gt; kE0cE1 = akDiff[0].Cross(akDiff[1]);
+    if (Math&lt;Real&gt;::FAbs(fDet) &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvDet = ((Real)1.0)/fDet;
+        afBary[0] = akDiff[3].Dot(kE1cE2)*fInvDet;
+        afBary[1] = akDiff[3].Dot(kE2cE0)*fInvDet;
+        afBary[2] = akDiff[3].Dot(kE0cE1)*fInvDet;
+        afBary[3] = (Real)1.0 - afBary[0] - afBary[1] - afBary[2];
+    }
+    else
+    {
+        // The tetrahedron is potentially flat.  Determine the face of
+        // maximum area and compute barycentric coordinates with respect
+        // to that face.
+        Vector3&lt;Real&gt; kE02 = rkV0 - rkV2;
+        Vector3&lt;Real&gt; kE12 = rkV1 - rkV2;
+        Vector3&lt;Real&gt; kE02cE12 = kE02.Cross(kE12);
+        Real fMaxSqrArea = kE02cE12.SquaredLength();
+        int iMaxIndex = 3;
+        Real fSqrArea = kE0cE1.SquaredLength();
+        if (fSqrArea &gt; fMaxSqrArea)
+        {
+            iMaxIndex = 0;
+            fMaxSqrArea = fSqrArea;
+        }
+        fSqrArea = kE1cE2.SquaredLength();
+        if (fSqrArea &gt; fMaxSqrArea)
+        {
+            iMaxIndex = 1;
+            fMaxSqrArea = fSqrArea;
+        }
+        fSqrArea = kE2cE0.SquaredLength();
+        if (fSqrArea &gt; fMaxSqrArea)
+        {
+            iMaxIndex = 2;
+            fMaxSqrArea = fSqrArea;
+        }
+
+        if (fMaxSqrArea &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+        {
+            Real fInvSqrArea = ((Real)1.0)/fMaxSqrArea;
+            Vector3&lt;Real&gt; kTmp;
+            if (iMaxIndex == 0)
+            {
+                kTmp = akDiff[3].Cross(akDiff[1]);
+                afBary[0] = kE0cE1.Dot(kTmp)*fInvSqrArea;
+                kTmp = akDiff[0].Cross(akDiff[3]);
+                afBary[1] = kE0cE1.Dot(kTmp)*fInvSqrArea;
+                afBary[2] = (Real)0.0;
+                afBary[3] = (Real)1.0 - afBary[0] - afBary[1];
+            }
+            else if (iMaxIndex == 1)
+            {
+                afBary[0] = (Real)0.0;
+                kTmp = akDiff[3].Cross(akDiff[2]);
+                afBary[1] = kE1cE2.Dot(kTmp)*fInvSqrArea;
+                kTmp = akDiff[1].Cross(akDiff[3]);
+                afBary[2] = kE1cE2.Dot(kTmp)*fInvSqrArea;
+                afBary[3] = (Real)1.0 - afBary[1] - afBary[2];
+            }
+            else if (iMaxIndex == 2)
+            {
+                kTmp = akDiff[2].Cross(akDiff[3]);
+                afBary[0] = kE2cE0.Dot(kTmp)*fInvSqrArea;
+                afBary[1] = (Real)0.0;
+                kTmp = akDiff[3].Cross(akDiff[0]);
+                afBary[2] = kE2cE0.Dot(kTmp)*fInvSqrArea;
+                afBary[3] = (Real)1.0 - afBary[0] - afBary[2];
+            }
+            else
+            {
+                akDiff[3] = *this - rkV2;
+                kTmp = akDiff[3].Cross(kE12);
+                afBary[0] = kE02cE12.Dot(kTmp)*fInvSqrArea;
+                kTmp = kE02.Cross(akDiff[3]);
+                afBary[1] = kE02cE12.Dot(kTmp)*fInvSqrArea;
+                afBary[2] = (Real)1.0 - afBary[0] - afBary[1];
+                afBary[3] = (Real)0.0;
+            }
+        }
+        else
+        {
+            // The tetrahedron is potentially a sliver.  Determine the edge of
+            // maximum length and compute barycentric coordinates with respect
+            // to that edge.
+            Real fMaxSqrLength = akDiff[0].SquaredLength();
+            iMaxIndex = 0;  // &lt;V0,V3&gt;
+            Real fSqrLength = akDiff[1].SquaredLength();
+            if (fSqrLength &gt; fMaxSqrLength)
+            {
+                iMaxIndex = 1;  // &lt;V1,V3&gt;
+                fMaxSqrLength = fSqrLength;
+            }
+            fSqrLength = akDiff[2].SquaredLength();
+            if (fSqrLength &gt; fMaxSqrLength)
+            {
+                iMaxIndex = 2;  // &lt;V2,V3&gt;
+                fMaxSqrLength = fSqrLength;
+            }
+            fSqrLength = kE02.SquaredLength();
+            if (fSqrLength &gt; fMaxSqrLength)
+            {
+                iMaxIndex = 3;  // &lt;V0,V2&gt;
+                fMaxSqrLength = fSqrLength;
+            }
+            fSqrLength = kE12.SquaredLength();
+            if (fSqrLength &gt; fMaxSqrLength)
+            {
+                iMaxIndex = 4;  // &lt;V1,V2&gt;
+                fMaxSqrLength = fSqrLength;
+            }
+            Vector3&lt;Real&gt; kE01 = rkV0 - rkV1;
+            fSqrLength = kE01.SquaredLength();
+            if (fSqrLength &gt; fMaxSqrLength)
+            {
+                iMaxIndex = 5;  // &lt;V0,V1&gt;
+                fMaxSqrLength = fSqrLength;
+            }
+
+            if (fMaxSqrLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+            {
+                Real fInvSqrLength = ((Real)1.0)/fMaxSqrLength;
+                if (iMaxIndex == 0)
+                {
+                    // P-V3 = t*(V0-V3)
+                    afBary[0] = akDiff[3].Dot(akDiff[0])*fInvSqrLength;
+                    afBary[1] = (Real)0.0;
+                    afBary[2] = (Real)0.0;
+                    afBary[3] = (Real)1.0 - afBary[0];
+                }
+                else if (iMaxIndex == 1)
+                {
+                    // P-V3 = t*(V1-V3)
+                    afBary[0] = (Real)0.0;
+                    afBary[1] = akDiff[3].Dot(akDiff[1])*fInvSqrLength;
+                    afBary[2] = (Real)0.0;
+                    afBary[3] = (Real)1.0 - afBary[1];
+                }
+                else if (iMaxIndex == 2)
+                {
+                    // P-V3 = t*(V2-V3)
+                    afBary[0] = (Real)0.0;
+                    afBary[1] = (Real)0.0;
+                    afBary[2] = akDiff[3].Dot(akDiff[2])*fInvSqrLength;
+                    afBary[3] = (Real)1.0 - afBary[2];
+                }
+                else if (iMaxIndex == 3)
+                {
+                    // P-V2 = t*(V0-V2)
+                    akDiff[3] = *this - rkV2;
+                    afBary[0] = akDiff[3].Dot(kE02)*fInvSqrLength;
+                    afBary[1] = (Real)0.0;
+                    afBary[2] = (Real)1.0 - afBary[0];
+                    afBary[3] = (Real)0.0;
+                }
+                else if (iMaxIndex == 4)
+                {
+                    // P-V2 = t*(V1-V2)
+                    akDiff[3] = *this - rkV2;
+                    afBary[0] = (Real)0.0;
+                    afBary[1] = akDiff[3].Dot(kE12)*fInvSqrLength;
+                    afBary[2] = (Real)1.0 - afBary[1];
+                    afBary[3] = (Real)0.0;
+                }
+                else
+                {
+                    // P-V1 = t*(V0-V1)
+                    akDiff[3] = *this - rkV1;
+                    afBary[0] = akDiff[3].Dot(kE01)*fInvSqrLength;
+                    afBary[1] = (Real)1.0 - afBary[0];
+                    afBary[2] = (Real)0.0;
+                    afBary[3] = (Real)0.0;
+                }
+            }
+            else
+            {
+                // tetrahedron is a nearly a point, just return equal weights
+                afBary[0] = (Real)0.25;
+                afBary[1] = afBary[0];
+                afBary[2] = afBary[0];
+                afBary[3] = afBary[0];
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector3&lt;Real&gt;::Orthonormalize (Vector3&amp; rkU, Vector3&amp; rkV, Vector3&amp; rkW)
+{
+    // If the input vectors are v0, v1, and v2, then the Gram-Schmidt
+    // orthonormalization produces vectors u0, u1, and u2 as follows,
+    //
+    //   u0 = v0/|v0|
+    //   u1 = (v1-(u0*v1)u0)/|v1-(u0*v1)u0|
+    //   u2 = (v2-(u0*v2)u0-(u1*v2)u1)/|v2-(u0*v2)u0-(u1*v2)u1|
+    //
+    // where |A| indicates length of vector A and A*B indicates dot
+    // product of vectors A and B.
+
+    // compute u0
+    rkU.Normalize();
+
+    // compute u1
+    Real fDot0 = rkU.Dot(rkV); 
+    rkV -= fDot0*rkU;
+    rkV.Normalize();
+
+    // compute u2
+    Real fDot1 = rkV.Dot(rkW);
+    fDot0 = rkU.Dot(rkW);
+    rkW -= fDot0*rkU + fDot1*rkV;
+    rkW.Normalize();
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector3&lt;Real&gt;::Orthonormalize (Vector3* akV)
+{
+    Orthonormalize(akV[0],akV[1],akV[2]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector3&lt;Real&gt;::GenerateOrthonormalBasis (Vector3&amp; rkU, Vector3&amp; rkV,
+    Vector3&amp; rkW, bool bUnitLengthW)
+{
+    if (!bUnitLengthW)
+    {
+        rkW.Normalize();
+    }
+
+    Real fInvLength;
+
+    if (Math&lt;Real&gt;::FAbs(rkW.m_afTuple[0]) &gt;=
+        Math&lt;Real&gt;::FAbs(rkW.m_afTuple[1]) )
+    {
+        // W.x or W.z is the largest magnitude component, swap them
+        fInvLength = Math&lt;Real&gt;::InvSqrt(rkW.m_afTuple[0]*rkW.m_afTuple[0] +
+            rkW.m_afTuple[2]*rkW.m_afTuple[2]);
+        rkU.m_afTuple[0] = -rkW.m_afTuple[2]*fInvLength;
+        rkU.m_afTuple[1] = (Real)0.0;
+        rkU.m_afTuple[2] = +rkW.m_afTuple[0]*fInvLength;
+        rkV.m_afTuple[0] = rkW.m_afTuple[1]*rkU.m_afTuple[2];
+        rkV.m_afTuple[1] = rkW.m_afTuple[2]*rkU.m_afTuple[0] -
+            rkW.m_afTuple[0]*rkU.m_afTuple[2];
+        rkV.m_afTuple[2] = -rkW.m_afTuple[1]*rkU.m_afTuple[0];
+    }
+    else
+    {
+        // W.y or W.z is the largest magnitude component, swap them
+        fInvLength = Math&lt;Real&gt;::InvSqrt(rkW.m_afTuple[1]*rkW.m_afTuple[1] +
+            rkW.m_afTuple[2]*rkW.m_afTuple[2]);
+        rkU.m_afTuple[0] = (Real)0.0;
+        rkU.m_afTuple[1] = +rkW.m_afTuple[2]*fInvLength;
+        rkU.m_afTuple[2] = -rkW.m_afTuple[1]*fInvLength;
+        rkV.m_afTuple[0] = rkW.m_afTuple[1]*rkU.m_afTuple[2] -
+            rkW.m_afTuple[2]*rkU.m_afTuple[1];
+        rkV.m_afTuple[1] = -rkW.m_afTuple[0]*rkU.m_afTuple[2];
+        rkV.m_afTuple[2] = rkW.m_afTuple[0]*rkU.m_afTuple[1];
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+void Vector3&lt;Real&gt;::ComputeExtremes (int iVQuantity, const Vector3* akPoint,
+    Vector3&amp; rkMin, Vector3&amp; rkMax)
+{
+    assert(iVQuantity &gt; 0 &amp;&amp; akPoint);
+
+    rkMin = akPoint[0];
+    rkMax = rkMin;
+    for (int i = 1; i &lt; iVQuantity; i++)
+    {
+        const Vector3&lt;Real&gt;&amp; rkPoint = akPoint[i];
+        for (int j = 0; j &lt; 3; j++)
+        {
+            if (rkPoint[j] &lt; rkMin[j])
+            {
+                rkMin[j] = rkPoint[j];
+            }
+            else if (rkPoint[j] &gt; rkMax[j])
+            {
+                rkMax[j] = rkPoint[j];
+            }
+        }
+    }
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector3&lt;Real&gt;&amp; rkV)
+{
+     return rkOStr &lt;&lt; rkV.X() &lt;&lt; ' ' &lt;&lt; rkV.Y() &lt;&lt; ' ' &lt;&lt; rkV.Z();
+}
+//----------------------------------------------------------------------------
+

Added: branches/scons-layout/lib/miniWm3/Wm3Vector4.cpp
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector4.cpp	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector4.cpp	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,27 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#include &quot;Wm3FoundationPCH.h&quot;
+#include &quot;Wm3Vector4.h&quot;
+using namespace Wm3;
+
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::ZERO(0.0f,0.0f,0.0f,0.0f);
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::UNIT_X(1.0f,0.0f,0.0f,0.0f);
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::UNIT_Y(0.0f,1.0f,0.0f,0.0f);
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::UNIT_Z(0.0f,0.0f,1.0f,0.0f);
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::UNIT_W(0.0f,0.0f,0.0f,1.0f);
+template&lt;&gt; const Vector4&lt;float&gt; Vector4&lt;float&gt;::ONE(1.0f,1.0f,1.0f,1.0f);
+
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::ZERO(0.0,0.0,0.0,0.0);
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::UNIT_X(1.0,0.0,0.0,0.0);
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::UNIT_Y(0.0,1.0,0.0,0.0);
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::UNIT_Z(0.0,0.0,1.0,0.0);
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::UNIT_W(0.0,0.0,0.0,1.0);
+template&lt;&gt; const Vector4&lt;double&gt; Vector4&lt;double&gt;::ONE(1.0,1.0,1.0,1.0);

Added: branches/scons-layout/lib/miniWm3/Wm3Vector4.h
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector4.h	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector4.h	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,104 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+#ifndef WM3VECTOR4_H
+#define WM3VECTOR4_H
+
+#include &quot;Wm3FoundationLIB.h&quot;
+#include &quot;Wm3Math.h&quot;
+
+namespace Wm3
+{
+
+template &lt;class Real&gt;
+class Vector4
+{
+public:
+    // construction
+    Vector4 ();  // uninitialized
+    Vector4 (Real fX, Real fY, Real fZ, Real fW);
+    Vector4 (const Real* afTuple);
+    Vector4 (const Vector4&amp; rkV);
+
+    // coordinate access
+    operator const Real* () const;
+    operator Real* ();
+    Real operator[] (int i) const;
+    Real&amp; operator[] (int i);
+    Real X () const;
+    Real&amp; X ();
+    Real Y () const;
+    Real&amp; Y ();
+    Real Z () const;
+    Real&amp; Z ();
+    Real W () const;
+    Real&amp; W ();
+
+    // assignment
+    Vector4&amp; operator= (const Vector4&amp; rkV);
+
+    // comparison
+    bool operator== (const Vector4&amp; rkV) const;
+    bool operator!= (const Vector4&amp; rkV) const;
+    bool operator&lt;  (const Vector4&amp; rkV) const;
+    bool operator&lt;= (const Vector4&amp; rkV) const;
+    bool operator&gt;  (const Vector4&amp; rkV) const;
+    bool operator&gt;= (const Vector4&amp; rkV) const;
+
+    // arithmetic operations
+    Vector4 operator+ (const Vector4&amp; rkV) const;
+    Vector4 operator- (const Vector4&amp; rkV) const;
+    Vector4 operator* (Real fScalar) const;
+    Vector4 operator/ (Real fScalar) const;
+    Vector4 operator- () const;
+
+    // arithmetic updates
+    Vector4&amp; operator+= (const Vector4&amp; rkV);
+    Vector4&amp; operator-= (const Vector4&amp; rkV);
+    Vector4&amp; operator*= (Real fScalar);
+    Vector4&amp; operator/= (Real fScalar);
+
+    // vector operations
+    Real Length () const;
+    Real SquaredLength () const;
+    Real Dot (const Vector4&amp; rkV) const;
+    Real Normalize ();
+
+    // special vectors
+    WM3_ITEM static const Vector4 ZERO;    // (0,0,0,0)
+    WM3_ITEM static const Vector4 UNIT_X;  // (1,0,0,0)
+    WM3_ITEM static const Vector4 UNIT_Y;  // (0,1,0,0)
+    WM3_ITEM static const Vector4 UNIT_Z;  // (0,0,1,0)
+    WM3_ITEM static const Vector4 UNIT_W;  // (0,0,0,1)
+    WM3_ITEM static const Vector4 ONE;     // (1,1,1,1)
+
+private:
+    // support for comparisons
+    int CompareArrays (const Vector4&amp; rkV) const;
+
+    Real m_afTuple[4];
+};
+
+// arithmetic operations
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; operator* (Real fScalar, const Vector4&lt;Real&gt;&amp; rkV);
+
+// debugging output
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector4&lt;Real&gt;&amp; rkV);
+
+#include &quot;Wm3Vector4.inl&quot;
+
+typedef Vector4&lt;float&gt; Vector4f;
+typedef Vector4&lt;double&gt; Vector4d;
+
+}
+
+#endif

Added: branches/scons-layout/lib/miniWm3/Wm3Vector4.inl
===================================================================
--- branches/scons-layout/lib/miniWm3/Wm3Vector4.inl	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/lib/miniWm3/Wm3Vector4.inl	2007-03-10 09:31:44 UTC (rev 1127)
@@ -0,0 +1,359 @@
+// Geometric Tools, Inc.
+// <A HREF="http://www.geometrictools.com">http://www.geometrictools.com</A>
+// Copyright (c) 1998-2006.  All Rights Reserved
+//
+// The Wild Magic Library (WM3) source code is supplied under the terms of
+// the license agreement
+//     <A HREF="http://www.geometrictools.com/License/WildMagic3License.pdf">http://www.geometrictools.com/License/WildMagic3License.pdf</A>
+// and may not be copied or disclosed except in accordance with the terms
+// of that agreement.
+
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::Vector4 ()
+{
+    // uninitialized for performance in array construction
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::Vector4 (Real fX, Real fY, Real fZ, Real fW)
+{
+    m_afTuple[0] = fX;
+    m_afTuple[1] = fY;
+    m_afTuple[2] = fZ;
+    m_afTuple[3] = fW;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::Vector4 (const Real* afTuple)
+{
+    m_afTuple[0] = afTuple[0];
+    m_afTuple[1] = afTuple[1];
+    m_afTuple[2] = afTuple[2];
+    m_afTuple[3] = afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::Vector4 (const Vector4&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+    m_afTuple[2] = rkV.m_afTuple[2];
+    m_afTuple[3] = rkV.m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::operator const Real* () const
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;::operator Real* ()
+{
+    return m_afTuple;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::operator[] (int i) const
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 3);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector4&lt;Real&gt;::operator[] (int i)
+{
+    assert(0 &lt;= i &amp;&amp; i &lt;= 3);
+    return m_afTuple[i];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::X () const
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector4&lt;Real&gt;::X ()
+{
+    return m_afTuple[0];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::Y () const
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector4&lt;Real&gt;::Y ()
+{
+    return m_afTuple[1];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::Z () const
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector4&lt;Real&gt;::Z ()
+{
+    return m_afTuple[2];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::W () const
+{
+    return m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real&amp; Vector4&lt;Real&gt;::W ()
+{
+    return m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;&amp; Vector4&lt;Real&gt;::operator= (const Vector4&amp; rkV)
+{
+    m_afTuple[0] = rkV.m_afTuple[0];
+    m_afTuple[1] = rkV.m_afTuple[1];
+    m_afTuple[2] = rkV.m_afTuple[2];
+    m_afTuple[3] = rkV.m_afTuple[3];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+int Vector4&lt;Real&gt;::CompareArrays (const Vector4&amp; rkV) const
+{
+    return memcmp(m_afTuple,rkV.m_afTuple,4*sizeof(Real));
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator== (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) == 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator!= (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) != 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator&lt; (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator&lt;= (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) &lt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator&gt; (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt; 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+bool Vector4&lt;Real&gt;::operator&gt;= (const Vector4&amp; rkV) const
+{
+    return CompareArrays(rkV) &gt;= 0;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Vector4&lt;Real&gt;::operator+ (const Vector4&amp; rkV) const
+{
+    return Vector4(
+        m_afTuple[0]+rkV.m_afTuple[0],
+        m_afTuple[1]+rkV.m_afTuple[1],
+        m_afTuple[2]+rkV.m_afTuple[2],
+        m_afTuple[3]+rkV.m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Vector4&lt;Real&gt;::operator- (const Vector4&amp; rkV) const
+{
+    return Vector4(
+        m_afTuple[0]-rkV.m_afTuple[0],
+        m_afTuple[1]-rkV.m_afTuple[1],
+        m_afTuple[2]-rkV.m_afTuple[2],
+        m_afTuple[3]-rkV.m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Vector4&lt;Real&gt;::operator* (Real fScalar) const
+{
+    return Vector4(
+        fScalar*m_afTuple[0],
+        fScalar*m_afTuple[1],
+        fScalar*m_afTuple[2],
+        fScalar*m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Vector4&lt;Real&gt;::operator/ (Real fScalar) const
+{
+    Vector4 kQuot;
+
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        kQuot.m_afTuple[0] = fInvScalar*m_afTuple[0];
+        kQuot.m_afTuple[1] = fInvScalar*m_afTuple[1];
+        kQuot.m_afTuple[2] = fInvScalar*m_afTuple[2];
+        kQuot.m_afTuple[3] = fInvScalar*m_afTuple[3];
+    }
+    else
+    {
+        kQuot.m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[2] = Math&lt;Real&gt;::MAX_REAL;
+        kQuot.m_afTuple[3] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return kQuot;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; Vector4&lt;Real&gt;::operator- () const
+{
+    return Vector4(
+        -m_afTuple[0],
+        -m_afTuple[1],
+        -m_afTuple[2],
+        -m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt; operator* (Real fScalar, const Vector4&lt;Real&gt;&amp; rkV)
+{
+    return Vector4&lt;Real&gt;(
+        fScalar*rkV[0],
+        fScalar*rkV[1],
+        fScalar*rkV[2],
+        fScalar*rkV[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;&amp; Vector4&lt;Real&gt;::operator+= (const Vector4&amp; rkV)
+{
+    m_afTuple[0] += rkV.m_afTuple[0];
+    m_afTuple[1] += rkV.m_afTuple[1];
+    m_afTuple[2] += rkV.m_afTuple[2];
+    m_afTuple[3] += rkV.m_afTuple[3];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;&amp; Vector4&lt;Real&gt;::operator-= (const Vector4&amp; rkV)
+{
+    m_afTuple[0] -= rkV.m_afTuple[0];
+    m_afTuple[1] -= rkV.m_afTuple[1];
+    m_afTuple[2] -= rkV.m_afTuple[2];
+    m_afTuple[3] -= rkV.m_afTuple[3];
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;&amp; Vector4&lt;Real&gt;::operator*= (Real fScalar)
+{
+    m_afTuple[0] *= fScalar;
+    m_afTuple[1] *= fScalar;
+    m_afTuple[2] *= fScalar;
+    m_afTuple[3] *= fScalar;
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Vector4&lt;Real&gt;&amp; Vector4&lt;Real&gt;::operator/= (Real fScalar)
+{
+    if (fScalar != (Real)0.0)
+    {
+        Real fInvScalar = ((Real)1.0)/fScalar;
+        m_afTuple[0] *= fInvScalar;
+        m_afTuple[1] *= fInvScalar;
+        m_afTuple[2] *= fInvScalar;
+        m_afTuple[3] *= fInvScalar;
+    }
+    else
+    {
+        m_afTuple[0] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[1] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[2] = Math&lt;Real&gt;::MAX_REAL;
+        m_afTuple[3] = Math&lt;Real&gt;::MAX_REAL;
+    }
+
+    return *this;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::Length () const
+{
+    return Math&lt;Real&gt;::Sqrt(
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2] +
+        m_afTuple[3]*m_afTuple[3]);
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::SquaredLength () const
+{
+    return
+        m_afTuple[0]*m_afTuple[0] +
+        m_afTuple[1]*m_afTuple[1] +
+        m_afTuple[2]*m_afTuple[2] +
+        m_afTuple[3]*m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::Dot (const Vector4&amp; rkV) const
+{
+    return
+        m_afTuple[0]*rkV.m_afTuple[0] +
+        m_afTuple[1]*rkV.m_afTuple[1] +
+        m_afTuple[2]*rkV.m_afTuple[2] +
+        m_afTuple[3]*rkV.m_afTuple[3];
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+Real Vector4&lt;Real&gt;::Normalize ()
+{
+    Real fLength = Length();
+
+    if (fLength &gt; Math&lt;Real&gt;::ZERO_TOLERANCE)
+    {
+        Real fInvLength = ((Real)1.0)/fLength;
+        m_afTuple[0] *= fInvLength;
+        m_afTuple[1] *= fInvLength;
+        m_afTuple[2] *= fInvLength;
+        m_afTuple[3] *= fInvLength;
+    }
+    else
+    {
+        fLength = (Real)0.0;
+        m_afTuple[0] = (Real)0.0;
+        m_afTuple[1] = (Real)0.0;
+        m_afTuple[2] = (Real)0.0;
+        m_afTuple[3] = (Real)0.0;
+    }
+
+    return fLength;
+}
+//----------------------------------------------------------------------------
+template &lt;class Real&gt;
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; rkOStr, const Vector4&lt;Real&gt;&amp; rkV)
+{
+     return rkOStr &lt;&lt; rkV.X() &lt;&lt; ' ' &lt;&lt; rkV.Y() &lt;&lt; ' ' &lt;&lt; rkV.Z()
+         &lt;&lt; ' ' &lt;&lt; rkV.W();
+}
+//----------------------------------------------------------------------------
+

Modified: branches/scons-layout/pkg/common/SConscript
===================================================================
--- branches/scons-layout/pkg/common/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/common/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -4,81 +4,81 @@
 	env.SharedLibrary('BodyAssocVector',
 		['Container/BodyAssocVector.cpp',
 			'Container/BodyAssocVectorIterator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Container']),
 
 	env.SharedLibrary('BodyRedirectionVector',
 		['Container/BodyRedirectionVector.cpp',
 			'Container/BodyRedirectionVectorIterator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Container']),
 
 	env.SharedLibrary('InteractionHashMap',
 		['Container/InteractionHashMap.cpp',
 			'Container/InteractionHashMapIterator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['Container', '$PREFIX/include']),
 
 	env.SharedLibrary('InteractionVecSet',
 		['Container/InteractionVecSet.cpp',
 			'Container/InteractionVecSetIterator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Container']),
 
 	env.SharedLibrary('PhysicalActionVectorVector',
 		['Container/PhysicalActionVectorVector.cpp',
 			'Container/PhysicalActionVectorVectorIterator.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'Container']),
 
 	env.SharedLibrary('AABB',
 		['DataClass/BoundingVolume/AABB.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['DataClass/BoundingVolume', '$PREFIX/include']),
 
 	env.SharedLibrary('BoundingSphere',
 		['DataClass/BoundingVolume/BoundingSphere.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/BoundingVolume']),
 
 	env.SharedLibrary('InteractingBox',
 		['DataClass/InteractingGeometry/InteractingBox.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractingGeometry']),
 
 	env.SharedLibrary('InteractingSphere',
 		['DataClass/InteractingGeometry/InteractingSphere.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractingGeometry']),
 
 	env.SharedLibrary('MetaInteractingGeometry',
 		['DataClass/InteractingGeometry/MetaInteractingGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractingGeometry']),
 
 	env.SharedLibrary('ParticleParameters',
 		['DataClass/PhysicalParameters/ParticleParameters.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters', '$PREFIX/include']),
 
 	env.SharedLibrary('RigidBodyParameters',
 		['DataClass/PhysicalParameters/RigidBodyParameters.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
 			'$PREFIX/include',
@@ -87,12 +87,12 @@
 	env.SharedLibrary('ElasticBodyParameters',
 		['DataClass/PhysicalParameters/ElasticBodyParameters.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'RigidBodyParameters',
 			'ParticleParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
 			'$PREFIX/include',
@@ -102,43 +102,43 @@
 	env.SharedLibrary('ClosestFeatures',
 		['DataClass/InteractionGeometry/ClosestFeatures.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionGeometry']),
 
 	env.SharedLibrary('SimpleElasticInteraction',
 		['DataClass/InteractionPhysics/SimpleElasticInteraction.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractionPhysics']),
 
 	env.SharedLibrary('Force',
 		['DataClass/PhysicalAction/Force.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base',  'yade-base'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalAction', '$PREFIX/include']),
 
 	env.SharedLibrary('Momentum',
 		['DataClass/PhysicalAction/Momentum.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base',  'yade-base'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalAction', '$PREFIX/include']),
 
 	env.SharedLibrary('Box',
 		['DataClass/GeometricalModel/Box.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('Mesh2D',
 		['DataClass/GeometricalModel/Mesh2D.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['DataClass/GeometricalModel', '$PREFIX/include']),
@@ -146,26 +146,26 @@
 	env.SharedLibrary('Sphere',
 		['DataClass/GeometricalModel/Sphere.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('Tetrahedron',
 		['DataClass/GeometricalModel/Tetrahedron.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-multimethods'],
+		LIBS=env['LIBS']+['yade-base',  'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('Quadrilateral',
 		['DataClass/GeometricalModel/Quadrilateral.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-multimethods'],
+		LIBS=env['LIBS']+['yade-base',  'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('ForceEngine',
 		['Engine/DeusExMachina/ForceEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Force', 'ParticleParameters'],
+		LIBS=env['LIBS']+['yade-base',  'Force', 'ParticleParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
 			'Engine/DeusExMachina',
 			'$PREFIX/include',
@@ -173,7 +173,7 @@
 
 	env.SharedLibrary('GravityEngine',
 		['Engine/DeusExMachina/GravityEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Force', 'ParticleParameters'],
+		LIBS=env['LIBS']+['yade-base',  'Force', 'ParticleParameters'],
 		CPPPATH=env['CPPPATH']+['Engine/DeusExMachina',
 			'DataClass/PhysicalAction',
 			'$PREFIX/include',
@@ -182,12 +182,12 @@
 	env.SharedLibrary('RotationEngine',
 		['Engine/DeusExMachina/RotationEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleParameters',
 			'RigidBodyParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['Engine/DeusExMachina',
 			'$PREFIX/include',
@@ -197,11 +197,11 @@
 	env.SharedLibrary('TranslationEngine',
 		['Engine/DeusExMachina/TranslationEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleParameters',
 			'yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -211,64 +211,64 @@
 	env.SharedLibrary('DisplacementEngine',
 		['Engine/DeusExMachina/DisplacementEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/DeusExMachina']),
 
 	env.SharedLibrary('BoundingVolumeMetaEngine',
 		['Engine/MetaEngine/BoundingVolumeMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('GeometricalModelMetaEngine',
 		['Engine/MetaEngine/GeometricalModelMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('InteractingGeometryMetaEngine',
 		['Engine/MetaEngine/InteractingGeometryMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('PhysicalParametersMetaEngine',
 		['Engine/MetaEngine/PhysicalParametersMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('InteractionGeometryMetaEngine',
 		['Engine/MetaEngine/InteractionGeometryMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['Engine/MetaEngine', '$PREFIX/include']),
 
 	env.SharedLibrary('InteractionPhysicsMetaEngine',
 		['Engine/MetaEngine/InteractionPhysicsMetaEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('PhysicalActionApplier',
 		['Engine/MetaEngine/PhysicalActionApplier.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('PhysicalActionDamper',
 		['Engine/MetaEngine/PhysicalActionDamper.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/MetaEngine']),
 
 	env.SharedLibrary('InteractingBox2AABB',
 		['Engine/EngineUnit/InteractingBox2AABB.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'BoundingVolumeMetaEngine',
 			'InteractingBox',
 			'AABB',
 			'Box',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/BoundingVolume',
 			'DataClass/InteractingGeometry',
@@ -279,7 +279,7 @@
 	env.SharedLibrary('MetaInteractingGeometry2AABB',
 		['Engine/EngineUnit/MetaInteractingGeometry2AABB.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'BoundingVolumeMetaEngine',
 			'MetaInteractingGeometry',
 			'AABB'],
@@ -292,7 +292,7 @@
 	env.SharedLibrary('LeapFrogOrientationIntegrator',
 		['Engine/EngineUnit/LeapFrogOrientationIntegrator.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalParametersMetaEngine',
 			'ParticleParameters',
 			'RigidBodyParameters'],
@@ -305,7 +305,7 @@
 	env.SharedLibrary('LeapFrogPositionIntegrator',
 		['Engine/EngineUnit/LeapFrogPositionIntegrator.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalParametersMetaEngine',
 			'ParticleParameters',
 			'RigidBodyParameters'],
@@ -317,7 +317,7 @@
 	env.SharedLibrary('NewtonsForceLaw',
 		['Engine/EngineUnit/NewtonsForceLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionApplier',
 			'Force',
 			'ParticleParameters',
@@ -333,7 +333,7 @@
 	env.SharedLibrary('NewtonsMomentumLaw',
 		['Engine/EngineUnit/NewtonsMomentumLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionApplier',
 			'Momentum',
 			'RigidBodyParameters',
@@ -348,12 +348,12 @@
 	env.SharedLibrary('InteractingSphere2AABB',
 		['Engine/EngineUnit/InteractingSphere2AABB.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'BoundingVolumeMetaEngine',
 			'InteractingSphere',
 			'AABB',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['DataClass/BoundingVolume',
 			'$PREFIX/include',
 			'Engine/MetaEngine',
@@ -363,7 +363,7 @@
 	env.SharedLibrary('CundallNonViscousForceDamping',
 		['Engine/EngineUnit/CundallNonViscousForceDamping.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionDamper',
 			'Force',
 			'ParticleParameters'],
@@ -376,7 +376,7 @@
 	env.SharedLibrary('CundallNonViscousMomentumDamping',
 		['Engine/EngineUnit/CundallNonViscousMomentumDamping.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionDamper',
 			'Momentum',
 			'RigidBodyParameters'],
@@ -390,7 +390,7 @@
 	env.SharedLibrary('ElasticBodySimpleRelationship',
 		['Engine/EngineUnit/ElasticBodySimpleRelationship.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ElasticBodyParameters',
 			'SimpleElasticInteraction',
 			'RigidBodyParameters',
@@ -406,34 +406,34 @@
 
 	env.SharedLibrary('PersistentSAPCollider',
 		['Engine/StandAloneEngine/PersistentSAPCollider.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['Engine/StandAloneEngine', '$PREFIX/include']),
 
 	env.SharedLibrary('SAPCollider',
 		['Engine/StandAloneEngine/SAPCollider.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/StandAloneEngine']),
 
 	env.SharedLibrary('PhysicalActionContainerInitializer',
 		['Engine/StandAloneEngine/PhysicalActionContainerInitializer.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['Engine/StandAloneEngine',
 			'$PREFIX/include']),
 
 	env.SharedLibrary('PhysicalActionContainerReseter',
 		['Engine/StandAloneEngine/PhysicalActionContainerReseter.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'Engine/StandAloneEngine']),
 
 	env.SharedLibrary('GLDrawAABB',
 		['RenderingEngine/GLDrawBoundingVolume/GLDrawAABB.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'AABB', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'AABB', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['DataClass/BoundingVolume',
 			'$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -441,7 +441,7 @@
 
 	env.SharedLibrary('GLDrawBoundingSphere',
 		['RenderingEngine/GLDrawBoundingVolume/GLDrawBoundingSphere.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'BoundingSphere', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'BoundingSphere', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
 			'RenderingEngine/GLDrawBoundingVolume',
@@ -449,7 +449,7 @@
 
 	env.SharedLibrary('GLDrawTetrahedron',
 		['RenderingEngine/GLDrawGeometricalModel/GLDrawTetrahedron.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Tetrahedron', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'Tetrahedron', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/GLDrawGeometricalModel',
 			'$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -457,7 +457,7 @@
 
 	env.SharedLibrary('GLDrawBox',
 		['RenderingEngine/GLDrawGeometricalModel/GLDrawBox.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Box', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'Box', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'RenderingEngine/GLDrawGeometricalModel',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -465,7 +465,7 @@
 
 	env.SharedLibrary('GLDrawMesh2D',
 		['RenderingEngine/GLDrawGeometricalModel/GLDrawMesh2D.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Mesh2D', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'Mesh2D', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['DataClass/GeometricalModel',
 			'$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -473,7 +473,7 @@
 
 	env.SharedLibrary('GLDrawSphere',
 		['RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Sphere', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'Sphere', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/OpenGLRenderingEngine',
 			'$PREFIX/include',
 			'RenderingEngine/GLDrawGeometricalModel',
@@ -481,7 +481,7 @@
 
 	env.SharedLibrary('GLDrawQuadrilateral',
 		['RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'Quadrilateral', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'Quadrilateral', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/GLDrawGeometricalModel',
 			'$PREFIX/include',
 			'DataClass/GeometricalModel',
@@ -489,7 +489,7 @@
 
 	env.SharedLibrary('GLDrawInteractingBox',
 		['RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingBox.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'InteractingBox', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'InteractingBox', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
 			'DataClass/InteractingGeometry',
@@ -497,7 +497,7 @@
 
 	env.SharedLibrary('GLDrawInteractingSphere',
 		['RenderingEngine/GLDrawInteractingGeometry/GLDrawInteractingSphere.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'InteractingSphere', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'InteractingSphere', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractingGeometry',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -505,7 +505,7 @@
 
 	env.SharedLibrary('GLDrawMetaInteractingGeometry',
 		['RenderingEngine/GLDrawInteractingGeometry/GLDrawMetaInteractingGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractingGeometry',
 			'RenderingEngine/OpenGLRenderingEngine',
@@ -514,7 +514,7 @@
 	env.SharedLibrary('GLDrawBoxShadowVolume',
 		['RenderingEngine/GLDrawShadowVolume/GLDrawBoxShadowVolume.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'Box',
 			'ParticleParameters',
 			'yade-opengl',
@@ -527,7 +527,7 @@
 	env.SharedLibrary('GLDrawSphereShadowVolume',
 		['RenderingEngine/GLDrawShadowVolume/GLDrawSphereShadowVolume.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'Sphere',
 			'ParticleParameters',
 			'yade-opengl'],
@@ -538,7 +538,7 @@
 
 	env.SharedLibrary('GLDrawClosestFeatures',
 		['RenderingEngine/GLDrawInteractionGeometry/GLDrawClosestFeatures.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'ClosestFeatures', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'ClosestFeatures', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'RenderingEngine/OpenGLRenderingEngine',
 			'DataClass/InteractionGeometry',
@@ -547,7 +547,7 @@
 	env.SharedLibrary('GLDrawSimpleElasticInteraction',
 		['RenderingEngine/GLDrawInteractionPhysics/GLDrawSimpleElasticInteraction.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'SimpleElasticInteraction',
 			'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/OpenGLRenderingEngine',
@@ -557,7 +557,7 @@
 
 	env.SharedLibrary('GLDrawParticleState',
 		['RenderingEngine/GLDrawState/GLDrawParticleState.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'ParticleParameters', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'ParticleParameters', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/OpenGLRenderingEngine',
 			'DataClass/PhysicalParameters',
 			'$PREFIX/include',
@@ -566,7 +566,7 @@
 	env.SharedLibrary('GLDrawRigidBodyState',
 		['RenderingEngine/GLDrawState/GLDrawRigidBodyState.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleParameters',
 			'RigidBodyParameters',
 			'GLDrawParticleState',
@@ -580,7 +580,7 @@
 
 	env.SharedLibrary('OpenGLRenderingEngine',
 		['RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'glut', 'GLU', 'GL'],
+		LIBS=env['LIBS']+['yade-base',  'glut', 'GLU', 'GL'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'RenderingEngine/OpenGLRenderingEngine'])
 ])
 

Modified: branches/scons-layout/pkg/dem/SConscript
===================================================================
--- branches/scons-layout/pkg/dem/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/dem/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -12,23 +12,23 @@
 			'ElasticBodyParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/PhysicalParameters']),
 
 	env.SharedLibrary('SpheresContactGeometry',
 		['DataClass/InteractionGeometry/SpheresContactGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-serialization', 'yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-serialization', 'yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionGeometry']),
 
 	env.SharedLibrary('SDECLinkGeometry',
 		['DataClass/InteractionGeometry/SDECLinkGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-serialization', 'yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-serialization', 'yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionGeometry']),
 
 	env.SharedLibrary('InteractionOfMyTetrahedron',
 		['DataClass/InteractionGeometry/InteractionOfMyTetrahedron.cpp'],
-		LIBS=env['LIBS']+['yade-serialization', 'yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-serialization', 'yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractionGeometry']),
 
@@ -44,7 +44,7 @@
 
 	env.SharedLibrary('GlobalStiffness',
 		['DataClass/PhysicalAction/GlobalStiffness.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/PhysicalAction']),
 
 	env.SharedLibrary('MacroMicroElasticRelationships',
@@ -88,7 +88,7 @@
 		LIBS=env['LIBS']+['SpheresContactGeometry',
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingSphere',
 			'InteractingBox'],
@@ -102,7 +102,7 @@
 			'SpheresContactGeometry',
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingSphere'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
@@ -116,7 +116,7 @@
 			'InteractingMyTetrahedron',
 			'AABB',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'Engine/EngineUnit',
 			'DataClass/InteractingGeometry']),
@@ -126,11 +126,11 @@
 		LIBS=env['LIBS']+['InteractionOfMyTetrahedron',
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingMyTetrahedron',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractionGeometry',
 			'DataClass/InteractingGeometry',
@@ -145,7 +145,7 @@
 			'InteractingSphere',
 			'SpheresContactGeometry',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingMyTetrahedron'],
 		CPPPATH=env['CPPPATH']+['DataClass/InteractionGeometry',
@@ -169,7 +169,7 @@
 			'SpheresContactGeometry',
 			'BodyMacroParameters',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Force',
 			'Momentum',
@@ -192,7 +192,7 @@
 			'BodyMacroParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Force',
 			'Momentum',
@@ -214,7 +214,7 @@
 			'ElasticBodyParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Force',
 			'Momentum',
@@ -267,7 +267,7 @@
 			'BodyMacroParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Force',
 			'Momentum',
@@ -286,7 +286,7 @@
 	env.SharedLibrary('GlobalStiffnessTimeStepper',
 		['Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ElasticContactInteraction',
 			'SpheresContactGeometry',
 			'MacroMicroElasticRelationships',
@@ -310,7 +310,7 @@
 		['Engine/DeusExMachina/ResultantForceEngine.cpp'],
 		LIBS=env['LIBS']+['yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'Force',
 			'ParticleParameters',
 			'GlobalStiffness'],
@@ -322,7 +322,7 @@
 		['Engine/DeusExMachina/TriaxialStressController.cpp'],
 		LIBS=env['LIBS']+['yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'Force',
 			'ParticleParameters',
 			'ElasticContactInteraction',
@@ -338,7 +338,7 @@
 		['Engine/DeusExMachina/TriaxialCompressionEngine.cpp'],
 		LIBS=env['LIBS']+['yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'Force',
 			'ParticleParameters',
 			'ElasticContactInteraction',
@@ -396,7 +396,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',
@@ -433,7 +433,7 @@
 			'InteractionVecSet',
 			'BodyRedirectionVector',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'InteractingSphere',
 			'InteractingBox',
 			'CundallNonViscousMomentumDamping',
@@ -485,7 +485,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',
@@ -529,7 +529,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',
@@ -573,7 +573,7 @@
 			'TranslationEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',
@@ -631,7 +631,7 @@
 			'Tetrahedron',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['PreProcessor',
 			'$PREFIX/include',
@@ -680,7 +680,7 @@
 			'TriaxialCompressionEngine',
 			'GlobalStiffnessTimeStepper',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['Engine/StandAloneEngine',
 			'Engine/StandAloneEngine',
 			'$PREFIX/include',
@@ -716,7 +716,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',

Modified: branches/scons-layout/pkg/fem/SConscript
===================================================================
--- branches/scons-layout/pkg/fem/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/fem/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -3,42 +3,42 @@
 
 	env.SharedLibrary('FEMSetGeometry',
 		['DataClass/GeometricalModel/FEMSetGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-multimethods'],
+		LIBS=env['LIBS']+['yade-base',  'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/GeometricalModel', '$PREFIX/include']),
 
 	env.SharedLibrary('FEMNodeData',
 		['DataClass/PhysicalParameters/FEMNodeData.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleParameters',
 			'AABB',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/PhysicalParameters']),
 
 	env.SharedLibrary('FEMSetParameters',
 		['DataClass/PhysicalParameters/FEMSetParameters.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'AABB',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters', '$PREFIX/include']),
 
 	env.SharedLibrary('FEMTetrahedronData',
 		['DataClass/PhysicalParameters/FEMTetrahedronData.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMNodeData',
 			'RigidBodyParameters',
 			'AABB',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/PhysicalParameters',
@@ -47,7 +47,7 @@
 	env.SharedLibrary('FEMSet2Tetrahedrons',
 		['Engine/EngineUnit/FEMSet2Tetrahedrons.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMSetParameters',
 			'FEMTetrahedronData',
 			'ParticleParameters',
@@ -61,7 +61,7 @@
 	env.SharedLibrary('FEMSetTextLoader',
 		['Engine/EngineUnit/FEMSetTextLoader.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMSetParameters',
 			'FEMTetrahedronData',
 			'PhysicalParametersMetaEngine',
@@ -78,7 +78,7 @@
 	env.SharedLibrary('FEMTetrahedronStiffness',
 		['Engine/EngineUnit/FEMTetrahedronStiffness.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMSetParameters',
 			'FEMTetrahedronData',
 			'PhysicalParametersMetaEngine',
@@ -91,7 +91,7 @@
 	env.SharedLibrary('FEMLaw',
 		['Engine/StandAloneEngine/FEMLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMTetrahedronData',
 			'Force',
 			'ParticleParameters'],
@@ -103,7 +103,7 @@
 	env.SharedLibrary('FEMBeam',
 		['PreProcessor/FEMBeam.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FEMTetrahedronData',
 			'FEMSetParameters',
 			'FEMLaw',
@@ -118,7 +118,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',

Modified: branches/scons-layout/pkg/lattice/SConscript
===================================================================
--- branches/scons-layout/pkg/lattice/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/lattice/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -3,26 +3,26 @@
 
 	env.SharedLibrary('LatticeInteractingGeometry',
 		['DataClass/InteractingGeometry/LatticeInteractingGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'MetaInteractingGeometry'],
+		LIBS=env['LIBS']+['yade-base',  'MetaInteractingGeometry'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractingGeometry']),
 
 	env.SharedLibrary('LatticeSetGeometry',
 		['DataClass/GeometricalModel/LatticeSetGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-multimethods'],
+		LIBS=env['LIBS']+['yade-base',  'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('LineSegment',
 		['DataClass/GeometricalModel/LineSegment.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'yade-multimethods'],
+		LIBS=env['LIBS']+['yade-base',  'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('LatticeBeamParameters',
 		['DataClass/PhysicalParameters/LatticeBeamParameters.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters', '$PREFIX/include']),
@@ -30,24 +30,24 @@
 	env.SharedLibrary('LatticeNodeParameters',
 		['DataClass/PhysicalParameters/LatticeNodeParameters.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters', '$PREFIX/include']),
 
 	env.SharedLibrary('LatticeSetParameters',
 		['DataClass/PhysicalParameters/LatticeSetParameters.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/PhysicalParameters']),
 
 	env.SharedLibrary('LatticeBeamAngularSpring',
 		['DataClass/InteractionPhysics/LatticeBeamAngularSpring.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['DataClass/InteractionPhysics',
@@ -56,9 +56,9 @@
 	env.SharedLibrary('NonLocalDependency',
 		['DataClass/InteractionPhysics/NonLocalDependency.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-serialization'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionPhysics']),
@@ -66,7 +66,7 @@
 	env.SharedLibrary('LatticeSet2LatticeBeams',
 		['Engine/EngineUnit/LatticeSet2LatticeBeams.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LineSegment',
 			'LatticeSetParameters',
 			'LatticeBeamParameters',
@@ -81,7 +81,7 @@
 	env.SharedLibrary('LatticeLaw',
 		['Engine/StandAloneEngine/LatticeLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters',
 			'LatticeSetParameters',
@@ -98,7 +98,7 @@
 	env.SharedLibrary('NonLocalInitializer',
 		['Engine/StandAloneEngine/NonLocalInitializer.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters',
 			'LatticeSetParameters',
@@ -113,7 +113,7 @@
 	env.SharedLibrary('MeasurePoisson',
 		['Engine/StandAloneEngine/MeasurePoisson.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -124,7 +124,7 @@
 	env.SharedLibrary('StrainRecorder',
 		['Engine/StandAloneEngine/StrainRecorder.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -135,7 +135,7 @@
 	env.SharedLibrary('NodeRecorder',
 		['Engine/StandAloneEngine/NodeRecorder.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -146,7 +146,7 @@
 	env.SharedLibrary('BeamRecorder',
 		['Engine/StandAloneEngine/BeamRecorder.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -157,7 +157,7 @@
 	env.SharedLibrary('MovingSupport',
 		['Engine/StandAloneEngine/MovingSupport.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeBeamParameters',
 			'LatticeNodeParameters'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
@@ -167,14 +167,14 @@
 
 	env.SharedLibrary('GLDrawLineSegment',
 		['RenderingEngine/GLDrawLineSegment/GLDrawLineSegment.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'LineSegment', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'LineSegment', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['RenderingEngine/GLDrawLineSegment',
 			'$PREFIX/include',
 			'DataClass/GeometricalModel']),
 
 	env.SharedLibrary('GLDrawLatticeBeamState',
 		['RenderingEngine/GLDrawLatticeBeamState/GLDrawLatticeBeamState.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation', 'LatticeBeamParameters', 'yade-opengl'],
+		LIBS=env['LIBS']+['yade-base',  'LatticeBeamParameters', 'yade-opengl'],
 		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
 			'$PREFIX/include',
 			'RenderingEngine/GLDrawLatticeBeamState']),
@@ -182,7 +182,7 @@
 	env.SharedLibrary('GLDrawLatticeSetGeometry',
 		['RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeSetGeometry',
 			'LatticeSetParameters',
 			'LatticeBeamParameters',
@@ -199,7 +199,7 @@
 	env.SharedLibrary('GLDrawLatticeInteractingGeometry',
 		['RenderingEngine/GLDrawLatticeInteractingGeometry/GLDrawLatticeInteractingGeometry.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LatticeSetGeometry',
 			'LatticeSetParameters',
 			'LatticeBeamParameters',
@@ -218,7 +218,7 @@
 	env.SharedLibrary('LatticeExample',
 		['PreProcessor/LatticeExample.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'LineSegment',
 			'LatticeSetParameters',
 			'LatticeBeamParameters',
@@ -250,7 +250,7 @@
 			'DisplacementEngine',
 			'LatticeLaw',
 			'yade-base',
-			'Wm3Foundation'],
+			],
 		CPPPATH=env['CPPPATH']+['Engine/StandAloneEngine',
 			'$PREFIX/include',
 			'Engine/StandAloneEngine',

Modified: branches/scons-layout/pkg/mass-spring/SConscript
===================================================================
--- branches/scons-layout/pkg/mass-spring/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/mass-spring/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -3,23 +3,23 @@
 
 	env.SharedLibrary('ParticleSetParameters',
 		['DataClass/PhysicalParameters/ParticleSetParameters.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/PhysicalParameters']),
 
 	env.SharedLibrary('SpringGeometry',
 		['DataClass/InteractionGeometry/SpringGeometry.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionGeometry']),
 
 	env.SharedLibrary('SpringPhysics',
 		['DataClass/InteractionPhysics/SpringPhysics.cpp'],
-		LIBS=env['LIBS']+['yade-base', 'Wm3Foundation'],
+		LIBS=env['LIBS']+['yade-base'],
 		CPPPATH=env['CPPPATH']+['DataClass/InteractionPhysics', '$PREFIX/include']),
 
 	env.SharedLibrary('ParticleSet2Mesh2D',
 		['Engine/EngineUnit/ParticleSet2Mesh2D.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ParticleSetParameters',
 			'GeometricalModelMetaEngine',
 			'Mesh2D'],
@@ -30,13 +30,13 @@
 	env.SharedLibrary('MassSpringLaw',
 		['Engine/StandAloneEngine/MassSpringLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'SpringPhysics',
 			'SpringGeometry',
 			'ParticleParameters',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Force',
 			'Momentum',
@@ -49,7 +49,7 @@
 	env.SharedLibrary('HangingCloth',
 		['PreProcessor/HangingCloth.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'SpringGeometry',
 			'SpringPhysics',
 			'ParticleSetParameters',
@@ -64,7 +64,7 @@
 			'MacroMicroElasticRelationships',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'GravityEngine',

Modified: branches/scons-layout/pkg/realtime-rigidbody/SConscript
===================================================================
--- branches/scons-layout/pkg/realtime-rigidbody/SConscript	2007-03-09 21:26:58 UTC (rev 1126)
+++ branches/scons-layout/pkg/realtime-rigidbody/SConscript	2007-03-10 09:31:44 UTC (rev 1127)
@@ -4,9 +4,9 @@
 	env.SharedLibrary('ErrorTolerantContact',
 		['DataClass/InteractionGeometry/ErrorTolerantContact.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-factory'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/InteractionGeometry']),
@@ -14,10 +14,10 @@
 	env.SharedLibrary('AAInteractingBox2InteractingSphere4ClosestFeatures',
 		['Engine/EngineUnit/AAInteractingBox2InteractingSphere4ClosestFeatures.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingSphere',
 			'InteractingBox',
@@ -30,10 +30,10 @@
 	env.SharedLibrary('InteractingBox2InteractingBox4ClosestFeatures',
 		['Engine/EngineUnit/InteractingBox2InteractingBox4ClosestFeatures.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'yade-computational-geometry',
 			'InteractingBox',
@@ -45,10 +45,10 @@
 	env.SharedLibrary('InteractingBox2InteractingSphere4ClosestFeatures',
 		['Engine/EngineUnit/InteractingBox2InteractingSphere4ClosestFeatures.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingBox',
 			'InteractingSphere',
@@ -61,12 +61,12 @@
 	env.SharedLibrary('InteractingBox2InteractingSphere4ErrorTolerantContact',
 		['Engine/EngineUnit/InteractingBox2InteractingSphere4ErrorTolerantContact.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ErrorTolerantContact',
 			'InteractionGeometryMetaEngine',
 			'yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingBox',
 			'InteractingSphere'],
@@ -77,10 +77,10 @@
 	env.SharedLibrary('InteractingSphere2InteractingSphere4ClosestFeatures',
 		['Engine/EngineUnit/InteractingSphere2InteractingSphere4ClosestFeatures.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'InteractionGeometryMetaEngine',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'InteractingSphere',
 			'Sphere',
@@ -91,13 +91,13 @@
 	env.SharedLibrary('InteractingSphere2InteractingSphere4ErrorTolerantContact',
 		['Engine/EngineUnit/InteractingSphere2InteractingSphere4ErrorTolerantContact.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ErrorTolerantContact',
 			'InteractionGeometryMetaEngine',
 			'yade-multimethods',
 			'yade-factory',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'Sphere'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include',
 			'DataClass/InteractionGeometry',
@@ -106,11 +106,11 @@
 	env.SharedLibrary('ErrorTolerantLaw',
 		['Engine/StandAloneEngine/ErrorTolerantLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'ErrorTolerantContact',
 			'RigidBodyParameters',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-factory',
 			'yade-multimethods'],
@@ -121,10 +121,10 @@
 	env.SharedLibrary('FrictionLessElasticContactLaw',
 		['Engine/StandAloneEngine/FrictionLessElasticContactLaw.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'yade-multimethods',
 			'Momentum',
 			'Force',
@@ -136,7 +136,7 @@
 	env.SharedLibrary('BoxStack',
 		['PreProcessor/BoxStack.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FrictionLessElasticContactLaw',
 			'RigidBodyParameters',
 			'PhysicalActionVectorVector',
@@ -149,7 +149,7 @@
 			'GravityEngine',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'InteractionGeometryMetaEngine',
@@ -170,7 +170,7 @@
 	env.SharedLibrary('RotatingBox',
 		['PreProcessor/RotatingBox.cpp'],
 		LIBS=env['LIBS']+['yade-base',
-			'Wm3Foundation',
+			
 			'FrictionLessElasticContactLaw',
 			'RigidBodyParameters',
 			'InteractionVecSet',
@@ -183,7 +183,7 @@
 			'MetaInteractingGeometry',
 			'yade-serialization',
 			'yade-base',
-			'Wm3Foundation',
+			
 			'PhysicalActionContainerInitializer',
 			'PhysicalActionContainerReseter',
 			'GravityEngine',


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000091.html">[Yade-commits] r1126 - branches/scons-layout
</A></li>
	<LI>Next message: <A HREF="000093.html">[Yade-commits] r1128 - branches/scons-layout
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
