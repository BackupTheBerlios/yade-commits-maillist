<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1167 - in trunk: core lib/miniWm3	pkg/common/Engine/DeusExMachina	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/lattice/DataClass/PhysicalParameters	pkg/lattice/Engine/EngineUnit	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor	pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry	pkg/mass-spring/Engine/StandAloneEngine
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2007/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1167%20-%20in%20trunk%3A%20core%20lib/miniWm3%0A%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%09pkg/dem/Engine/DeusExMachina%20pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20pkg/lattice/DataClass/PhysicalParameters%0A%09pkg/lattice/Engine/EngineUnit%0A%09pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor%0A%09pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry%0A%09pkg/mass-spring/Engine/StandAloneEngine&In-Reply-To=%3C200705240914.l4O9EZhn009552%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000131.html">
   <LINK REL="Next"  HREF="000133.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1167 - in trunk: core lib/miniWm3	pkg/common/Engine/DeusExMachina	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/lattice/DataClass/PhysicalParameters	pkg/lattice/Engine/EngineUnit	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor	pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry	pkg/mass-spring/Engine/StandAloneEngine</H1>
    <B>cosurgi at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1167%20-%20in%20trunk%3A%20core%20lib/miniWm3%0A%09pkg/common/Engine/DeusExMachina%0A%09pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%09pkg/dem/Engine/DeusExMachina%20pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20pkg/lattice/DataClass/PhysicalParameters%0A%09pkg/lattice/Engine/EngineUnit%0A%09pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor%0A%09pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry%0A%09pkg/mass-spring/Engine/StandAloneEngine&In-Reply-To=%3C200705240914.l4O9EZhn009552%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1167 - in trunk: core lib/miniWm3	pkg/common/Engine/DeusExMachina	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/lattice/DataClass/PhysicalParameters	pkg/lattice/Engine/EngineUnit	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor	pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry	pkg/mass-spring/Engine/StandAloneEngine">cosurgi at mail.berlios.de
       </A><BR>
    <I>Thu May 24 11:14:35 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000131.html">[Yade-commits] r1166 - trunk
</A></li>
        <LI>Next message: <A HREF="000133.html">[Yade-commits] r1168 - in trunk: . pkg/lattice/Engine/EngineUnit	pkg/lattice/PreProcessor pkg/realtime-rigidbody	pkg/realtime-rigidbody/DataClass	pkg/realtime-rigidbody/Engine/EngineUnit	pkg/realtime-rigidbody/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#132">[ date ]</a>
              <a href="thread.html#132">[ thread ]</a>
              <a href="subject.html#132">[ subject ]</a>
              <a href="author.html#132">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cosurgi
Date: 2007-05-24 11:14:33 +0200 (Thu, 24 May 2007)
New Revision: 1167

Modified:
   trunk/core/NullGUI.cpp
   trunk/lib/miniWm3/Wm3Math.cpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp
   trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral.cpp
   trunk/pkg/dem/Engine/DeusExMachina/ResultantForceEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
   trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp
   trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp
   trunk/pkg/lattice/Engine/EngineUnit/LatticeSet2LatticeBeams.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
   trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
   trunk/pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp
   trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
Log:
- fix several warnings,
- merge latest version of lattice from my PhD
- todo: serialization problems with findType in NodeRecorder and FEMBeam, remove ErrorTolerant, fix collistions in rigid body




Modified: trunk/core/NullGUI.cpp
===================================================================
--- trunk/core/NullGUI.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/core/NullGUI.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -164,7 +164,12 @@
 			// save snapshot
 			if( ( snapshotInterval != -1 ) &amp;&amp; (intervals % snapshotInterval == 0) )
 			{
-				string fileName = &quot;../data/&quot; + snapshotName + &quot;_&quot; + lexical_cast&lt;string&gt;(Omega::instance().getCurrentIteration()) + (binary?&quot;.yade&quot;:&quot;.xml&quot;);
+				string fileName = &quot;../data/&quot; 
+					+ snapshotName 
+			//		+ &quot;__dt_&quot; + lexical_cast&lt;string&gt;(Omega::instance().getTimeStep())
+			//		+ &quot;__it_&quot; + lexical_cast&lt;string&gt;(Omega::instance().getCurrentIteration()) 
+					+ &quot;_&quot; + lexical_cast&lt;string&gt;(Omega::instance().getCurrentIteration()) 
+					+ (binary?&quot;.yade&quot;:&quot;.xml&quot;);
 				cerr &lt;&lt; &quot;saving snapshot: &quot; &lt;&lt; fileName &lt;&lt; &quot;   ...&quot;;
 				Omega::instance().saveSimulation(fileName);
 				cerr &lt;&lt; &quot; done.\n&quot;;

Modified: trunk/lib/miniWm3/Wm3Math.cpp
===================================================================
--- trunk/lib/miniWm3/Wm3Math.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/lib/miniWm3/Wm3Math.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -37,13 +37,21 @@
 template&lt;&gt; const double Math&lt;double&gt;::RAD_TO_DEG = 180.0/Math&lt;double&gt;::PI;
 
 //----------------------------------------------------------------------------
+/*
+ * Those are nice, but they are not used anywhere in yade !
+ * and they give a compile-time warning.
+ * Also I know that they are not too precise, but are fast. So in fact I don't
+ * think we need them in our (precise ;) physical calculations.
+ *
 template &lt;&gt;
 float Math&lt;float&gt;::FastInvSqrt (float fValue)
 {
     float fHalf = 0.5f*fValue;
     int i  = *(int*)&fValue;
+//    int i  = *reinterpret_cast&lt;int*&gt;(&amp;fValue);
     i = 0x5f3759df - (i &gt;&gt; 1);
     fValue = *(float*)&i;
+//    fValue = *reinterpret_cast&lt;float*&gt;(&amp;i);
     fValue = fValue*(1.5f - fHalf*fValue*fValue);
     return fValue;
 }
@@ -53,15 +61,18 @@
 {
     double dHalf = 0.5*dValue;
     Integer64 i  = *(Integer64*)&dValue;
+//    Integer64 i  = *reinterpret_cast&lt;Integer64*&gt;(&amp;dValue);
 #if defined(WM3_USING_VC70) || defined(WM3_USING_VC6)
     i = 0x5fe6ec85e7de30da - (i &gt;&gt; 1);
 #else
     i = 0x5fe6ec85e7de30daLL - (i &gt;&gt; 1);
 #endif
     dValue = *(double*)&i;
+//    dValue = *reinterpret_cast&lt;double*&gt;(&amp;i);
     dValue = dValue*(1.5 - dHalf*dValue*dValue);
     return dValue;
 }
+*/
 //----------------------------------------------------------------------------
 
 }

Modified: trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementEngine.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -15,14 +15,16 @@
 	{
 		translationAxis.Normalize();
 
-		/*
+	/*	
 		if(displacement==0)
-			displacement=2e-10;
+			displacement=6e-9;
 		else
 			displacement=0;
-		*/
-	//	displacement *= 10.0;
-
+			//displacement=3e-8;
+		
+		//displacement *= 20.0;
+	*/
+	//	std::cerr &lt;&lt; &quot;displacement 0.00000000375*2: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
 		std::cerr &lt;&lt; &quot;displacement: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
 	}
 }
@@ -38,6 +40,29 @@
 
 void DisplacementEngine::applyCondition(Body * body)
 {
+
+/// FIXME - that's a hack! more control needed from the GUI !
+//
+	static int oldSec;
+	static int count=0;
+	static bool initialized=false;
+	if(!initialized)
+	{
+		Omega::instance().isoSec=0;
+		oldSec=Omega::instance().isoSec=0;
+		initialized=true;
+	}
+	if(oldSec!=Omega::instance().isoSec)
+	{
+		std::cerr &lt;&lt; &quot;multiplication by dt, before: &quot; &lt;&lt; displacement;
+		displacement*=Omega::instance().getTimeStep();
+		std::cerr &lt;&lt; &quot;after: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
+		if((count++)%6==0) oldSec=Omega::instance().isoSec;
+	}
+
+
+
+
 	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 

Modified: trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral.cpp
===================================================================
--- trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawQuadrilateral.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -14,6 +14,7 @@
 Vector3r makeColor(double val,double min,double max)
 {
 	Real sc01 = ((val-min)/(max-min))*2.0-1.0;
+	sc01*=-1.0;
 	if(sc01 &lt; 0) return Vector3r(0.9,0.9,1.0) + sc01 * Vector3r(0.9,0.9,0.0);
 	if(sc01 &gt; 0) return Vector3r(1.0,0.9,0.9) - sc01 * Vector3r(0.0,0.9,0.9);
 	return Vector3r(0.9,0.9,0.9);
@@ -21,6 +22,17 @@
 
 void GLDrawQuadrilateral::go(const shared_ptr&lt;GeometricalModel&gt;&amp; gm, const shared_ptr&lt;PhysicalParameters&gt;&amp;,bool wire)
 {	
+
+// FIXME - that's a hack also. We must give more power to the GUI
+//
+	static bool initialized=false;
+	if(!initialized)
+	{
+		Omega::instance().isoSec=0;
+		initialized=true;
+	}
+	int WTT = Omega::instance().isoSec%3; 
+
 	Quadrilateral* q = static_cast&lt;Quadrilateral*&gt;(gm.get());
 	MetaBody* mb = Omega::instance().getRootBody().get();
 	
@@ -58,14 +70,31 @@
 
 	calculateStrainQuadrilateral(ox1,oy1,ox2,oy2,ox3,oy3,ox4,oy4,nx1,ny1,nx2,ny2,nx3,ny3,nx4,ny4,0,0,e11,e22,e12,e21,x,y);
 
-	//std::cerr &lt;&lt; &quot;e11: &quot; &lt;&lt; e11 &lt;&lt; &quot; e22: &quot; &lt;&lt; e22 &lt;&lt; &quot; e12: &quot; &lt;&lt; e12 &lt;&lt; &quot; e21: &quot; &lt;&lt; e21 &lt;&lt; &quot; x: &quot; &lt;&lt; x &lt;&lt; &quot; y: &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
-	double m=-0.00005,M = 0.0001;
+//	static Real lastx = 0;
+//	//std::cout &lt;&lt; &quot; x: &quot; &lt;&lt; x &lt;&lt; &quot; y: &quot; &lt;&lt; y &lt;&lt; &quot;e11: &quot; &lt;&lt; e11 &lt;&lt; &quot; e22: &quot; &lt;&lt; e22 &lt;&lt; &quot; e12: &quot; &lt;&lt; e12 &lt;&lt; &quot; e21: &quot; &lt;&lt; e21  &lt;&lt; &quot;\n&quot;;
+//	if( x&gt;=0.20 &amp;&amp; x &lt;=0.40 &amp;&amp; y&gt;0.037 &amp;&amp; y &lt;0.10 )
+//	//if( x&gt;=0.01 &amp;&amp; x &lt;=0.31 &amp;&amp; y&gt;0.023 &amp;&amp; y &lt;0.097 )
+//		std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; e11 &lt;&lt; &quot; &quot; &lt;&lt; e22 &lt;&lt; &quot; &quot; &lt;&lt; e12 &lt;&lt; &quot; &quot; &lt;&lt; e21 &lt;&lt; &quot;\n&quot;;
+//	if(x&lt;lastx)
+//		std::cout &lt;&lt; &quot;\n&quot;;
+//	lastx=x;
+
+	//double m=-0.00005,M = 0.0001;
+	double m=-0.005,M = 0.005; // dodatni to rozciaganie, niebieski
+	//double m=-1,M = 1;//GLDrawLatticeSetGeometry
 	//M = std::max(e22,M);
 	//m = std::min(e22,m);
 	//static int zzz=0;
 	//if((++zzz%1000)==0)
 	//	std::cerr &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; M &lt;&lt; &quot;\n&quot;;
-	glColor3v(makeColor(e22,m,M));
+	static int ZZZ=0;
+	switch(WTT)
+	{
+		case 0: glColor3v(makeColor(e11,m,M));if(ZZZ++%10000==0)std::cerr &lt;&lt; &quot;e11 &quot;;break;
+		case 1: glColor3v(makeColor(e22,m,M));if(ZZZ++%10000==0)std::cerr &lt;&lt; &quot;e22 &quot;;break;
+		case 2: glColor3v(makeColor(e12,m,M));if(ZZZ++%10000==0)std::cerr &lt;&lt; &quot;e12 &quot;;break;
+		default: std::cerr &lt;&lt; &quot;WTF?\n&quot;;
+	}
 	//if(std::abs(e22) &gt; 0.0003 /*|| std::abs(e11) &gt; r*/) return;
 
 	if (gm-&gt;wire || wire)

Modified: trunk/pkg/dem/Engine/DeusExMachina/ResultantForceEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/ResultantForceEngine.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/DeusExMachina/ResultantForceEngine.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -77,7 +77,7 @@
 		if(PhysicalParameters* p = dynamic_cast&lt;PhysicalParameters*&gt;((*bodies)[*ii]-&gt;physicalParameters.get()))
 		{
 			//cerr &lt;&lt; &quot;dynamic_cast&lt;PhysicalParameters*&gt;((*bodies)[*ii]-&gt;physicalParameters.get()&quot; &lt;&lt; std::endl;
-			GlobalStiffness* sm = static_cast&lt;GlobalStiffness*&gt;( ncb-&gt;physicalActions-&gt;find (*ii, actionParameterGlobalStiffness-&gt;getClassIndex() ).get() );
+//			GlobalStiffness* sm = static_cast&lt;GlobalStiffness*&gt;( ncb-&gt;physicalActions-&gt;find (*ii, actionParameterGlobalStiffness-&gt;getClassIndex() ).get() );
 			
 			Vector3r effectiveforce =
 			 	static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find( *ii,actionParameterForce-&gt;getClassIndex() ).get() )-&gt;force; 

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -117,7 +117,7 @@
                 updateParameters(body);
 
         TriaxialStressController::applyCondition(body);
-        MetaBody * ncb2 = static_cast&lt;MetaBody*&gt;(body);
+//        MetaBody * ncb2 = static_cast&lt;MetaBody*&gt;(body);
         //cerr &lt;&lt; computeStress(ncb2)  &lt;&lt; endl;
 
         if (compressionActivated)

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -360,7 +360,6 @@
 {
 	BodyContainer::iterator bi    = ncb-&gt;bodies-&gt;begin();
         BodyContainer::iterator biEnd = ncb-&gt;bodies-&gt;end();
-        Real f;
         //cerr &lt;&lt; &quot;meanstress = &quot;radius = &quot; &lt;&lt; endl;
         //cerr &lt;&lt; &quot;bouclesurBodies&quot; &lt;&lt; endl;
         for(  ; bi!=biEnd ; ++bi ) {

Modified: trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/StandAloneEngine/ElasticCohesiveLaw.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -244,14 +244,14 @@
 			Vector3r dThetar = dUr/currentContactPhysics-&gt;averageRadius;
 			currentContactPhysics-&gt;thetar += dThetar;
 	
-			Real fNormal = currentContactPhysics-&gt;normalForce.Length();
-			Real normMPlastic = currentContactPhysics-&gt;heta*fNormal;
+		//	Real fNormal = currentContactPhysics-&gt;normalForce.Length();
+		//	Real normMPlastic = currentContactPhysics-&gt;heta*fNormal;
 			Vector3r thetarn = q_i_n*currentContactPhysics-&gt;thetar; // rolling angle
 			Vector3r mElastic = currentContactPhysics-&gt;kr * thetarn;
 	
 			//mElastic[0] = 0;  // No moment around normal direction
 	
-			Real normElastic = mElastic.Length();
+		//	Real normElastic = mElastic.Length();
 	
 	
 			//if (normElastic&lt;=normMPlastic)

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -48,9 +48,9 @@
 void GlobalStiffnessCounter::action(Body* body)
 {
         MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
-        shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+//        shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 
-        Real dt = Omega::instance().getTimeStep();
+//        Real dt = Omega::instance().getTimeStep();
 
         /// Non Permanents Links												///
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/Engine/StandAloneEngine/MyTetrahedronLaw.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -34,7 +34,7 @@
 	MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 
-	Real dt = Omega::instance().getTimeStep();
+//	Real dt = Omega::instance().getTimeStep();
 
 	InteractionContainer::iterator ii    = ncb-&gt;transientInteractions-&gt;begin();
 	InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();

Modified: trunk/pkg/dem/PreProcessor/TriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/dem/PreProcessor/TriaxialTest.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -245,7 +245,7 @@
 
 string TriaxialTest::generate()
 {
-	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2
+//	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2
 	
 	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
 	createActors(rootBody);

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -18,6 +18,7 @@
 	torsionAngle = 0;
 	torsionalStiffness = 0.6;
 	lastIter_ = -1;
+	shearing_strain = Vector3r(0,0,0);
 }
 
 
@@ -33,11 +34,20 @@
 
 	//	torsionalStiffness /= 10.0;
 
-	//	static bool first=true;
-	//	if(first)
-	//		std::cerr &lt;&lt; &quot;using dt for k.b\n&quot;, first=false;
-	//	bendingStiffness    = Omega::instance().getTimeStep();
-
+//		static bool first=true;
+//		if(first)
+//		{
+//			std::cerr &lt;&lt; &quot;using 0.2 for k.b. So k.l=&quot; &lt;&lt; longitudalStiffness 
+////				&lt;&lt; &quot; dt=&quot;&lt;&lt; Omega::instance().getTimeStep() 
+////				&lt;&lt; &quot; k.b=&quot; &lt;&lt; longitudalStiffness * Omega::instance().getTimeStep() 
+//				&lt;&lt; &quot; k.b=&quot; &lt;&lt; longitudalStiffness * 0.2 
+//				&lt;&lt;&quot;\n&quot;;
+////				//&lt;&lt;&quot;\nAnd criticalTensileStrain*10 and bendingStiffness/10 and longitudalStiffness/10\n\n&quot;, first=false;
+//			 first=false;
+//		}
+//
+//		bendingStiffness    = longitudalStiffness * 0.2;
+//
 //		bendingStiffness		/= 10.0;
 //		longitudalStiffness		/= 10.0;
 //		criticalTensileStrain		*= 10.0;
@@ -70,7 +80,7 @@
 // checking
 
 #define chk(x,y) std::cout &lt;&lt; #y &lt;&lt; &quot;,      &quot; &lt;&lt; x &lt;&lt; &quot; = &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;
-		if(criticalTensileStrain &gt; 0.00015) // E.l
+		if(criticalTensileStrain &gt; 0.0015) // E.l
 		{ // CEMENT MATRIX
 			static int cement=0;	++cement;
 			static bool d1=true;
@@ -85,7 +95,7 @@
 				chk(&quot;\tE.l&quot;,criticalTensileStrain);             // E.l
 			}
 		}
-		else if(criticalTensileStrain &gt; 0.00006) // E.l
+		else if(criticalTensileStrain &gt; 0.0006) // E.l
 		{ // AGGREGATE
 			static int aggregate=0; ++aggregate;
 			static bool d2=true;

Modified: trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp
===================================================================
--- trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/DataClass/PhysicalParameters/LatticeBeamParameters.hpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -27,6 +27,7 @@
 
 		Vector3r                 direction		// is a unit vector
 					,otherDirection;	// is a unit vector too
+		Vector3r		 shearing_strain;
 
 		Se3r                     se3Displacement;
 

Modified: trunk/pkg/lattice/Engine/EngineUnit/LatticeSet2LatticeBeams.cpp
===================================================================
--- trunk/pkg/lattice/Engine/EngineUnit/LatticeSet2LatticeBeams.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/Engine/EngineUnit/LatticeSet2LatticeBeams.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -36,11 +36,11 @@
 			line-&gt;length                    = beam-&gt;length;
 
 			// FIXME - display aggregates as brown, bonds as dark brown.
-			      if(beam-&gt;criticalTensileStrain &gt; 0.00015) line-&gt;diffuseColor = Vector3r(0.6,0.6,0.6); else // CEMENT
-			      if(beam-&gt;criticalTensileStrain &gt; 0.00006) line-&gt;diffuseColor = Vector3r(0.0,0.0,0.0); else // AGGREGATE
-			                                                line-&gt;diffuseColor = Vector3r(0.3,0.3,0.3);      // BOND
+			      if(beam-&gt;longitudalStiffness   &lt; 0.09  ) line-&gt;diffuseColor = Vector3r(0.8,0.8,0.8); else // BOND  
+			      if(beam-&gt;longitudalStiffness   &lt; 0.12  ) line-&gt;diffuseColor = Vector3r(0.4,0.4,0.4); else // CEMENT   
+			                                               line-&gt;diffuseColor = Vector3r(0.0,0.0,0.0);      // AGGREGATE
 
-			      if(beam-&gt;longitudalStiffness &gt; 3.6 ) line-&gt;diffuseColor = Vector3r(0.4,0.4,1.0); // NON-DESTROY
+			      if(beam-&gt;longitudalStiffness &gt; 1.2  ) line-&gt;diffuseColor = Vector3r(0.4,0.4,1.0); // NON-DESTROY
 		}
 	}
 }

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -144,18 +144,22 @@
 				planeAngle	= ( planeSwap180      ? -1.0 : 1.0 ) * unitVectorsAngle(beam1-&gt;direction,beam2-&gt;direction);
 
 				Real sinAngleSquared = newCP.SquaredLength();
+				//Real cosAngleSquared = std::pow(beam1-&gt;direction.Dot(beam2-&gt;direction),2);
 				if(sinAngleSquared &gt; 0.0001)
 					lastCP = newCP;
 				else
 					planeSwap180 = oldPS180;	
+				//sinAngleSquared = newCP.Length();
 				
 		 // 'B' calculate needed beam rotations 
 				Real angleDifference = planeAngle - an-&gt;initialPlaneAngle;
-				
+			
+				// FIXME - is it really necessary?
 				if( angleDifference &gt; 0 )
 					while(angleDifference &gt; Mathr::PI) angleDifference -= Mathr::TWO_PI;
 				else
 					while(angleDifference &lt; -Mathr::PI) angleDifference += Mathr::TWO_PI;
+				// FIXME END
 				
 				// axis of bending rotation is orthogonal to the plane between two beams and must have unit length
 				lastCP.Normalize();
@@ -179,6 +183,7 @@
 				Real offPlaneAngle2		= unitVectorsAngle(beam2-&gt;otherDirection,lastCP);
 		
 				/////////////////////////////////////////////////////////////
+		// FIXME [1] look below
 				Quaternionr	aligner1,aligner2;
 				aligner1.FromAxisAngle(beam1-&gt;direction , offPlaneAngle1);
 				aligner2.FromAxisAngle(beam2-&gt;direction , offPlaneAngle2);
@@ -191,6 +196,11 @@
 					offPlaneAngle1   *= -1.0;
 				if( dir2.Dot(beam2-&gt;otherDirection) &lt; 0.999999 )
 					offPlaneAngle2   *= -1.0;
+	//			if( (lastCP.Cross(beam1-&gt;direction)).Dot(beam1-&gt;otherDirection) &gt; 0.0 )
+	//				offPlaneAngle1   *= -1.0;
+	//			if( (lastCP.Cross(beam2-&gt;direction)).Dot(beam2-&gt;otherDirection) &gt; 0.0 )
+	//				offPlaneAngle2   *= -1.0;
+	//	// FIXME [1] END
 				/////////////////////////////////////////////////////////////
 
 				Real offPlaneAngleDifference1	= an-&gt;initialOffPlaneAngle1 - offPlaneAngle1;
@@ -207,16 +217,20 @@
 					while(offPlaneAngleDifference2 &lt; -Mathr::PI) offPlaneAngleDifference2 += Mathr::TWO_PI;
 
 				Real torsionAngle1, torsionAngle2;
-				if(sameFlow)
-				{
-					torsionAngle1 = offPlaneAngleDifference1 - offPlaneAngleDifference2;
-					torsionAngle2 = -torsionAngle1;
-				}
-				else
-				{
-					torsionAngle1 = offPlaneAngleDifference1 + offPlaneAngleDifference2;
-					torsionAngle2 = torsionAngle1;
-				}
+//				if(sameFlow)
+//				{
+//					torsionAngle1 = offPlaneAngleDifference1 - offPlaneAngleDifference2;
+//					torsionAngle2 = -torsionAngle1;
+//				}
+//				else
+//				{
+//					torsionAngle1 = offPlaneAngleDifference1 + offPlaneAngleDifference2;
+//					torsionAngle2 = torsionAngle1;
+//				}
+				torsionAngle1 = offPlaneAngleDifference1 + (sameFlow?-1:1)*offPlaneAngleDifference2;
+		//		torsionAngle1 *= cosAngleSquared;
+				torsionAngle2 = (sameFlow?-1:1)*torsionAngle1;
+
 				
 				if( torsionAngle1 &gt; 0 )
 					while(torsionAngle1 &gt; Mathr::PI) torsionAngle1 -= Mathr::TWO_PI;
@@ -229,6 +243,7 @@
 					while(torsionAngle2 &lt; -Mathr::PI) torsionAngle2 += Mathr::TWO_PI;
 
 				// calculate beam swirl
+		// FIXME [1] - this can solve this double checking of angle +/-180
 				if( an-&gt;lastOffPlaneAngleDifference1 &gt;  3.0 &amp;&amp; offPlaneAngleDifference1 &lt; -3.0 ) ++(an-&gt;swirl1);
 				if( an-&gt;lastOffPlaneAngleDifference1 &lt; -3.0 &amp;&amp; offPlaneAngleDifference1 &gt;  3.0 ) --(an-&gt;swirl1);
 				if( an-&gt;lastOffPlaneAngleDifference2 &gt;  3.0 &amp;&amp; offPlaneAngleDifference2 &lt; -3.0 ) ++(an-&gt;swirl2);
@@ -293,17 +308,20 @@
 
 		{ // 'R' from picture - previous rotation of the beam. try to do it again.
 			Vector3r halfLength = beam-&gt;length * beam-&gt;direction * 0.5;
-			node1-&gt;displacementIncremental += beam-&gt;se3Displacement.orientation * ( halfLength) - halfLength;
-			node2-&gt;displacementIncremental += beam-&gt;se3Displacement.orientation * (-halfLength) + halfLength;
+			Vector3r R = beam-&gt;se3Displacement.orientation * ( halfLength) - halfLength;
+			node1-&gt;displacementIncremental += R;
+			node2-&gt;displacementIncremental -= R;
+			//node1-&gt;displacementIncremental += beam-&gt;se3Displacement.orientation * ( halfLength) - halfLength;
+			//node2-&gt;displacementIncremental += beam-&gt;se3Displacement.orientation * (-halfLength) + halfLength;
 
 		//	beam-&gt;otherDirection		= beam-&gt;se3Displacement.orientation * beam-&gt;otherDirection;
 		}
 
 		{ // 'D' to nodes
-			node1-&gt;countStiffness += beam-&gt;longitudalStiffness;
-			node2-&gt;countStiffness += beam-&gt;longitudalStiffness;
-			node1-&gt;displacementAlignmental -= displacementLongitudal * beam-&gt;longitudalStiffness;
-			node2-&gt;displacementAlignmental += displacementLongitudal * beam-&gt;longitudalStiffness;
+			node1-&gt;countStiffness += (beam-&gt;longitudalStiffness)/(beam-&gt;initialLength);
+			node2-&gt;countStiffness += (beam-&gt;longitudalStiffness)/(beam-&gt;initialLength);
+			node1-&gt;displacementAlignmental -= (displacementLongitudal * beam-&gt;longitudalStiffness)/(beam-&gt;initialLength);
+			node2-&gt;displacementAlignmental += (displacementLongitudal * beam-&gt;longitudalStiffness)/(beam-&gt;initialLength);
 		}
 
 		if( beam-&gt;count != 0 )
@@ -313,17 +331,20 @@
 
 /*   
  *   Bending stiffness different for compression and tension.
- *
+ */
+			static bool first=true;
+			if(first)
+			{
+				//std::cerr &lt;&lt; &quot;\nusing k.b tension=0.6, k.b compression=0.2 !\n/beam-&gt;initialLength !\n&quot;;
+				std::cerr &lt;&lt; &quot;\nNOT! using k.b tension=0.6, k.b compression=0.2 ! (just a classical formula)\n\n&quot;;
+				first=false;
+			}
+/*
 			Real kb = beam-&gt;bendingStiffness;
-			Real Em = beam-&gt;criticalTensileStrain/2.0;
+			Real Em = beam-&gt;criticalTensileStrain/3.0;
 			Real x  = beam-&gt;strain();
-			const Real howmuch = 0.5;
-
-		//	if(beam-&gt;strain() &lt; 0) // compression
-		//	//if(beam-&gt;strain() &gt; 0) // tension
-		//		kb *= howmuch;	// FIXME - it's a material paramater. k.b in compression is 0.2 of k.b in tension.
-		//				// it should be a function in LatticeBeamParameters that returs correct value depending
-		//				// on tension/compression
+			//const Real howmuch = 0.5;
+			const Real howmuch = 0.3333333333333333333333333333;
 		
 		//	x&lt;-E ? kb*0.2 : ((kb*0.2+kb)/2+(kb*0.2-kb)/(-2*E)*x)
 
@@ -333,29 +354,31 @@
 				kb = (kb*howmuch+kb)/2.0+x*(kb*howmuch-kb)/(-2.0*Em);
 			// if strain &gt; criticalTensileStrain/2.0 then kb is not changed
 
-			node1-&gt;countStiffness += kb;
-			node2-&gt;countStiffness += kb;
+			node1-&gt;countStiffness += kb/beam-&gt;initialLength;
+			node2-&gt;countStiffness += kb/beam-&gt;initialLength;
 
-			node1-&gt;displacementAlignmental += (beam-&gt;bendingRotation * ( beam_vec) - beam_vec) * kb;
-			node2-&gt;displacementAlignmental += (beam-&gt;bendingRotation * (-beam_vec) + beam_vec) * kb;
+			node1-&gt;displacementAlignmental += ((beam-&gt;bendingRotation * ( beam_vec) - beam_vec) * kb)/(beam-&gt;initialLength);
+			node2-&gt;displacementAlignmental += ((beam-&gt;bendingRotation * (-beam_vec) + beam_vec) * kb)/(beam-&gt;initialLength);
 
 */
-			node1-&gt;countStiffness += beam-&gt;bendingStiffness;
-			node2-&gt;countStiffness += beam-&gt;bendingStiffness;
+			node1-&gt;countStiffness += (beam-&gt;bendingStiffness)/(beam-&gt;initialLength);
+			node2-&gt;countStiffness += (beam-&gt;bendingStiffness)/(beam-&gt;initialLength);
 
-			node1-&gt;displacementAlignmental += (beam-&gt;bendingRotation * ( beam_vec) - beam_vec) * beam-&gt;bendingStiffness;
-			node2-&gt;displacementAlignmental += (beam-&gt;bendingRotation * (-beam_vec) + beam_vec) * beam-&gt;bendingStiffness;
+			node1-&gt;displacementAlignmental += ((beam-&gt;bendingRotation * ( beam_vec) - beam_vec) * beam-&gt;bendingStiffness)/(beam-&gt;initialLength);
+			node2-&gt;displacementAlignmental += ((beam-&gt;bendingRotation * (-beam_vec) + beam_vec) * beam-&gt;bendingStiffness)/(beam-&gt;initialLength);
 
+			beam-&gt;shearing_strain = ((beam-&gt;bendingRotation * (-beam_vec) + beam_vec) * beam-&gt;bendingStiffness)/(beam-&gt;initialLength);
+
 		}
 		
 		if(calcTorsion)
 		{ // 'T' from picture - torsion
 
-			node1-&gt;countStiffness += beam-&gt;torsionalStiffness;
-			node2-&gt;countStiffness += beam-&gt;torsionalStiffness;
+			node1-&gt;countStiffness += (beam-&gt;torsionalStiffness)/(beam-&gt;initialLength);
+			node2-&gt;countStiffness += (beam-&gt;torsionalStiffness)/(beam-&gt;initialLength);
 
-			node1-&gt;displacementAlignmental += (beam-&gt;torsionalRotation * ( beam_vec) - beam_vec) * beam-&gt;torsionalStiffness;
-			node2-&gt;displacementAlignmental += (beam-&gt;torsionalRotation * (-beam_vec) + beam_vec) * beam-&gt;torsionalStiffness;
+			node1-&gt;displacementAlignmental += ((beam-&gt;torsionalRotation * ( beam_vec) - beam_vec) * beam-&gt;torsionalStiffness)/(beam-&gt;initialLength);
+			node2-&gt;displacementAlignmental += ((beam-&gt;torsionalRotation * (-beam_vec) + beam_vec) * beam-&gt;torsionalStiffness)/(beam-&gt;initialLength);
 		}
 		}
 	}

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/MovingSupport.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -150,7 +150,7 @@
 		std::list&lt;std::pair&lt;std::pair&lt;unsigned int,unsigned int&gt;,Real&gt; &gt;::iterator end = subscribedBodies[section].first.end();
 		int dir                               = subscribedBodies[section].second;
 		
-		Real stress=0; // in direction 'dir'
+//		Real stress=0; // in direction 'dir'
 
 		for( ; i != end ; ++i )
 		{

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/NonLocalInitializer.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -36,7 +36,7 @@
 	LatticeBeamParameters* beam1 	= static_cast&lt;LatticeBeamParameters*&gt;(body1-&gt;physicalParameters.get());
 	LatticeBeamParameters* beam2 	= static_cast&lt;LatticeBeamParameters*&gt;(body2-&gt;physicalParameters.get());
 	
-	static Real sqPi = std::sqrt(Mathr::PI);
+//	static Real sqPi = std::sqrt(Mathr::PI);
 	
 	//bool exists = false;
 	/*

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/StrainRecorder.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -57,25 +57,33 @@
 //	return;
 	
 	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
-	Real strain_y=0,stress_y=0;//,stress_nonlocal_y=0;
+	Real strain_y=0,stress_y=0,stress_s=0;//,stress_nonlocal_y=0;
 	
 	std::vector&lt;unsigned int&gt;::iterator i   = subscribedBodies.begin();
 	std::vector&lt;unsigned int&gt;::iterator end = subscribedBodies.end();
 	
-	if(!ncb-&gt;bodies-&gt;exists(*i)) std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;, exit(1);
-	LatticeNodeParameters* node1 = YADE_CAST&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
+	if(!ncb-&gt;bodies-&gt;exists(*i))
+	{
+		std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;;
+		return;
+	}
+	LatticeNodeParameters* node1 = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
 	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,0.0,0.0); // FIXME [1]
 	++i;
-	if(!ncb-&gt;bodies-&gt;exists(*i)) std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;, exit(1);
-	LatticeNodeParameters* node2 = YADE_CAST&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
+	if(!ncb-&gt;bodies-&gt;exists(*i)) 
+	{
+		std::cerr &lt;&lt; &quot;StrainRecorder missing node\n&quot;;
+		return;
+	}
+	LatticeNodeParameters* node2 = dynamic_cast&lt;LatticeNodeParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
 	(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(1.0,0.0,0.0); // FIXME [1]
 	++i;
-	// FIXME - zamiast &#182;ledzi&#230; tylko dwa punkty (jeden na dole i jeden u g&#243;ry), to lepiej zaznaczy&#230; dwa obszary punkt&#243;w i liczy&#230; &#182;redni&#177; ich po&#179;o&#191;enia,
-	// bo teraz, je&#182;li kt&#243;ry&#182; punkt zostanie wykasowany, to nie jest mo&#191;liwe kontynuowanie pomiar&#243;w.
+	// FIXME - zamiast ?ledzi? tylko dwa punkty (jeden na dole i jeden u g&#243;ry), to lepiej zaznaczy? dwa obszary punkt&#243;w i liczy? ?redni? ich po?o?enia,
+	// bo teraz, je?li kt&#243;ry? punkt zostanie wykasowany, to nie jest mo?liwe kontynuowanie pomiar&#243;w.
 	
 	Real 		currentLength = node1-&gt;se3.position[1] - node2-&gt;se3.position[1];
 	
-	strain_y = (currentLength - initialLength) / initialLength; // odkszta&#179;cenie ca&#179;ej pr&#243;bki
+	strain_y = (currentLength - initialLength) / initialLength; // odkszta?cenie ca?ej pr&#243;bki
 	
 	//bool nonlocal = false;
 	//if (ncb-&gt;transientInteractions-&gt;size() != 0) // it's non-local
@@ -86,19 +94,22 @@
 		if( (*(ncb-&gt;bodies)).exists(*i) )
 		{
 			LatticeBeamParameters* beam 	= static_cast&lt;LatticeBeamParameters*&gt;( (*(ncb-&gt;bodies))[*i]-&gt;physicalParameters . get() );
-			Real s_y 			= beam-&gt;strain() * std::abs(beam-&gt;direction[1]) * beam-&gt;longitudalStiffness; // direction is a unit vector, so direction[1] is cos(angle_to_y)
+			Real s_y 			= beam-&gt;strain()        * std::abs(beam-&gt;direction[1]) * beam-&gt;longitudalStiffness; // direction is a unit vector, so direction[1] is cos(angle_to_y)
+			Real s_s			= beam-&gt;shearing_strain[1];// * beam-&gt;bendingStiffness;
 			//Real s_nonl_y =0;
 			//if(nonlocal)
 			//	s_nonl_y 		= (beam-&gt;nonLocalStrain / beam-&gt;nonLocalDivisor) * std::abs(beam-&gt;direction[1]);
 			(*(ncb-&gt;bodies))[*i]-&gt;geometricalModel-&gt;diffuseColor = Vector3r(0.0,1.0,1.0); // FIXME [1]
 			stress_y += s_y;
+			stress_s += s_s;
 			//stress_nonlocal_y += s_nonl_y;
 		}
 	}
 	
 	//ofile &lt;&lt; lexical_cast&lt;string&gt;(Omega::instance().getSimulationTime()) &lt;&lt; &quot; &quot; 
 	ofile	&lt;&lt; lexical_cast&lt;string&gt;(strain_y) &lt;&lt; &quot; &quot; 
-		&lt;&lt; lexical_cast&lt;string&gt;(stress_y)// &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(stress_y) &lt;&lt; &quot; &quot; 
+		&lt;&lt; lexical_cast&lt;string&gt;(stress_s)// &lt;&lt; &quot; &quot; 
 		//&lt;&lt; lexical_cast&lt;string&gt;(stress_nonlocal_y)
 		&lt;&lt; endl; 
 		

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -47,9 +47,11 @@
 #include&lt;yade/pkg-common/ParticleParameters.hpp&gt;
 
 // Delaunay
-#include &lt;Wm3Delaunay3.h&gt;
-#include &lt;Wm3Delaunay2.h&gt;
-#include &lt;Wm3Query.h&gt;
+#ifndef MINIWM3
+	#include &lt;Wm3Delaunay3.h&gt;
+	#include &lt;Wm3Delaunay2.h&gt;
+	#include &lt;Wm3Query.h&gt;
+#endif
 
 using namespace boost;
 using namespace std;
@@ -63,7 +65,11 @@
         
         speciemen_size_in_meters = Vector3r(0.1,0.1,0.0001);
         cellsizeUnit_in_meters   = 0.003;
+#ifndef MINIWM3
 	use_Delaunay		 = true;
+#else
+	use_Delaunay		 = false;
+#endif
         minAngle_betweenBeams_deg= 20.0;
         disorder_in_cellsizeUnit = Vector3r(0.6,0.6,0.0);
         maxLength_in_cellsizeUnit= 1.9;
@@ -463,6 +469,7 @@
 	BodyContainer::iterator bi2;
 	BodyContainer::iterator biEnd = rootBody-&gt;bodies-&gt;end();
 
+#ifndef MINIWM3
 	if(use_Delaunay) // create beams, Delaunay
 	{
 		std::set&lt; std::pair&lt;int,int&gt; &gt; pairs;
@@ -523,6 +530,12 @@
 		}
 
 	}
+#else
+	if(use_Delaunay) // create beams, Delaunay not avauilable
+	{
+		return &quot;Yade was compiled without full installation of wildmagic-dev (Wm3 foundation library), can't use Delaunay. Please disable option use_Delaunay or compile yade with full wm3 library installed. Don't forget CPPPATH=/usr/include/wm3 scons parameter.&quot;;
+	}
+#endif
 	else
 	{ //  create beams, old method
 	int beam_counter = 0;
@@ -827,15 +840,21 @@
 //static int zzzzz=0;
 //switch(zzzzz%5)
 //{
-//      case 0  : physics-&gt;se3.position=Vector3r(0.4,1.5,0); break;
-//      case 1  : physics-&gt;se3.position=Vector3r(0.8,0.6,0); break;
-//      case 2  : physics-&gt;se3.position=Vector3r(0  ,0  ,0); break;
-//      case 3  : physics-&gt;se3.position=Vector3r(1.6,0.5,0); break;
-//      case 4  : physics-&gt;se3.position=Vector3r(2.0,0  ,0); break;
+//      case 0  : physics-&gt;se3.position=Vector3r(0,0,0); break;
+//      case 1  : physics-&gt;se3.position=Vector3r(3,0,0); break;
+//      case 2  : physics-&gt;se3.position=Vector3r(8,0,0); break;
+//      case 3  : physics-&gt;se3.position=Vector3r(0,4,0); break;
+//      case 4  : physics-&gt;se3.position=Vector3r(3,4,0); break;
 //};
 //zzzzz++;
 //
-//////////////////////
+////      case 0  : physics-&gt;se3.position=Vector3r(0.4,1.5,0); break;
+////      case 1  : physics-&gt;se3.position=Vector3r(0.8,0.6,0); break;
+////      case 2  : physics-&gt;se3.position=Vector3r(0  ,0  ,0); break;
+////      case 3  : physics-&gt;se3.position=Vector3r(1.6,0.5,0); break;
+////      case 4  : physics-&gt;se3.position=Vector3r(2.0,0  ,0); break;
+////
+////////////////////////
         
 	if( 	   position[0] &gt;= speciemen_size_in_meters[0] 
 		|| position[1] &gt;= speciemen_size_in_meters[1]
@@ -934,7 +953,7 @@
 	if( ! ints-&gt;find(otherId,thisId) &amp;&amp; otherId != thisId )
 	{
 		LatticeBeamParameters* 	beam2 		= static_cast&lt;LatticeBeamParameters*&gt;( ((*(bodies))[ otherId ])-&gt;physicalParameters.get() );
-		Real 			angle, offPlaneAngle;
+		Real 			angle;
 		
 		angle = unitVectorsAngle(beam1-&gt;direction,beam2-&gt;direction);
 
@@ -1049,9 +1068,10 @@
         rootBody-&gt;engines.push_back(geometricalModelDispatcher);
         rootBody-&gt;engines.push_back(strainRecorder);
         rootBody-&gt;engines.push_back(measurePoisson);
-        rootBody-&gt;engines.push_back(nodeRecorder);
-        rootBody-&gt;engines.push_back(beamRecorder);
-	rootBody-&gt;engines.push_back(movingSupport);
+	// FIXME - Serialization of nodeRecorder, beamRecorder and movingSupport is not wirking....
+        //rootBody-&gt;engines.push_back(nodeRecorder);
+        //rootBody-&gt;engines.push_back(beamRecorder);
+	//rootBody-&gt;engines.push_back(movingSupport);
         
         rootBody-&gt;initializers.clear();
         rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
@@ -1110,10 +1130,10 @@
         rootBody-&gt;engines.push_back((rootBody-&gt;engines)[rootBody-&gt;engines.size()-1]);
         (rootBody-&gt;engines)[rootBody-&gt;engines.size()-2]=(rootBody-&gt;engines)[rootBody-&gt;engines.size()-3];
         (rootBody-&gt;engines)[rootBody-&gt;engines.size()-3]=(rootBody-&gt;engines)[rootBody-&gt;engines.size()-4];
-        (rootBody-&gt;engines)[rootBody-&gt;engines.size()-4]=(rootBody-&gt;engines)[rootBody-&gt;engines.size()-5];
+        (rootBody-&gt;engines)[rootBody-&gt;engines.size()-4]=/*(rootBody-&gt;engines)[rootBody-&gt;engines.size()-5];
         (rootBody-&gt;engines)[rootBody-&gt;engines.size()-5]=(rootBody-&gt;engines)[rootBody-&gt;engines.size()-6];
         (rootBody-&gt;engines)[rootBody-&gt;engines.size()-6]=(rootBody-&gt;engines)[rootBody-&gt;engines.size()-7];
-        (rootBody-&gt;engines)[rootBody-&gt;engines.size()-7]=translationCondition;
+        (rootBody-&gt;engines)[rootBody-&gt;engines.size()-7]=*/translationCondition;
         translationCondition-&gt;subscribedBodies.clear();
         
         BodyContainer::iterator bi    = rootBody-&gt;bodies-&gt;begin();
@@ -1397,8 +1417,8 @@
           // - list of circles.
                 BodyContainer::iterator bi    = rootBody-&gt;bodies-&gt;begin();
                 BodyContainer::iterator biEnd = rootBody-&gt;bodies-&gt;end();
-                float all_bodies = rootBody-&gt;bodies-&gt;size();
-                int current = 0;
+                //float all_bodies = rootBody-&gt;bodies-&gt;size();
+                //int current = 0;
                 for(  ; bi!=biEnd ; ++bi )  // loop over all beams
                 {
                 //      if( ++current % 100 == 0 )

Modified: trunk/pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp
===================================================================
--- trunk/pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/lattice/RenderingEngine/GLDrawLatticeSetGeometry/GLDrawLatticeSetGeometry.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -113,7 +113,7 @@
 
 	MetaBody * lattice = static_cast&lt;MetaBody*&gt;(Omega::instance().getRootBody().get());
 
-	int nodeGroupMask  = static_cast&lt;LatticeSetParameters*&gt;(lattice-&gt;physicalParameters.get())-&gt;nodeGroupMask;
+//	int nodeGroupMask  = static_cast&lt;LatticeSetParameters*&gt;(lattice-&gt;physicalParameters.get())-&gt;nodeGroupMask;
 	int beamGroupMask  = static_cast&lt;LatticeSetParameters*&gt;(lattice-&gt;physicalParameters.get())-&gt;beamGroupMask;
 
 	BodyContainer* bodies = lattice-&gt;bodies.get();

Modified: trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp
===================================================================
--- trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2007-05-22 11:43:01 UTC (rev 1166)
+++ trunk/pkg/mass-spring/Engine/StandAloneEngine/MassSpringLaw.cpp	2007-05-24 09:14:33 UTC (rev 1167)
@@ -55,7 +55,7 @@
 			ParticleParameters * p2 = static_cast&lt;ParticleParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
 			
 			SpringPhysics* physics		= static_cast&lt;SpringPhysics*&gt;(spring-&gt;interactionPhysics.get());
-			SpringGeometry* geometry	= static_cast&lt;SpringGeometry*&gt;(spring-&gt;interactionGeometry.get());
+//			SpringGeometry* geometry	= static_cast&lt;SpringGeometry*&gt;(spring-&gt;interactionGeometry.get());
 			
 			Vector3r v1 = p2-&gt;se3.position;
 			Vector3r v2 = p1-&gt;se3.position;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000131.html">[Yade-commits] r1166 - trunk
</A></li>
	<LI>Next message: <A HREF="000133.html">[Yade-commits] r1168 - in trunk: . pkg/lattice/Engine/EngineUnit	pkg/lattice/PreProcessor pkg/realtime-rigidbody	pkg/realtime-rigidbody/DataClass	pkg/realtime-rigidbody/Engine/EngineUnit	pkg/realtime-rigidbody/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#132">[ date ]</a>
              <a href="thread.html#132">[ thread ]</a>
              <a href="subject.html#132">[ subject ]</a>
              <a href="author.html#132">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
