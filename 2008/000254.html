<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1290 - in trunk: core extra extra/usct gui/cmd	gui/qt3 pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1290%20-%20in%20trunk%3A%20core%20extra%20extra/usct%20gui/cmd%0A%09gui/qt3%20pkg/common/Engine/EngineUnit%0A%09pkg/common/Engine/MetaEngine%20pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%20pkg/dem/Engine/StandAloneEngine&In-Reply-To=%3C200803302022.m2UKMMSH008905%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000253.html">
   <LINK REL="Next"  HREF="000255.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1290 - in trunk: core extra extra/usct gui/cmd	gui/qt3 pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1290%20-%20in%20trunk%3A%20core%20extra%20extra/usct%20gui/cmd%0A%09gui/qt3%20pkg/common/Engine/EngineUnit%0A%09pkg/common/Engine/MetaEngine%20pkg/dem/Engine/DeusExMachina%0A%09pkg/dem/Engine/EngineUnit%20pkg/dem/Engine/StandAloneEngine&In-Reply-To=%3C200803302022.m2UKMMSH008905%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1290 - in trunk: core extra extra/usct gui/cmd	gui/qt3 pkg/common/Engine/EngineUnit	pkg/common/Engine/MetaEngine pkg/dem/Engine/DeusExMachina	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine">eudoxos at mail.berlios.de
       </A><BR>
    <I>Sun Mar 30 22:22:22 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000253.html">[Yade-commits] r1289 - trunk/pkg/dem/PreProcessor
</A></li>
        <LI>Next message: <A HREF="000255.html">[Yade-commits] r1291 - in trunk: . doc examples lib/miniWm3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#254">[ date ]</a>
              <a href="thread.html#254">[ thread ]</a>
              <a href="subject.html#254">[ subject ]</a>
              <a href="author.html#254">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2008-03-30 22:22:20 +0200 (Sun, 30 Mar 2008)
New Revision: 1290

Modified:
   trunk/core/MetaBody.cpp
   trunk/core/MetaBody.hpp
   trunk/core/Omega.cpp
   trunk/core/Omega.hpp
   trunk/extra/Brefcom.cpp
   trunk/extra/Brefcom.hpp
   trunk/extra/BrefcomTestGen.cpp
   trunk/extra/SConscript
   trunk/extra/usct/UniaxialStrainControlledTest.cpp
   trunk/extra/usct/UniaxialStrainControlledTest.hpp
   trunk/gui/cmd/yadeControl.cpp
   trunk/gui/qt3/GLSimulationPlayerViewer.cpp
   trunk/gui/qt3/QtSimulationPlayer.cpp
   trunk/gui/qt3/SimulationController.cpp
   trunk/gui/qt3/SimulationController.hpp
   trunk/pkg/common/Engine/EngineUnit/InteractingSphere2AABB.cpp
   trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp
   trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4DistantSpheresContactGeometry.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp
Log:
1. allow saving spheres (format like small.sdec.xyz) from python
2. PositionOrientationRecorder can optionally record RGB color of each body as well now
3. SimulationPlayer now can change colors of bodies, if the .rgb file exists
4. Bunch of fixes if brefcom, in UniaxialStrainControlledTest
5. dt moved from Omega to MetaBody for good; this allows preprocessor to set timestep that will be used when the simulation is loaded.
6. Code cleanups here and there.



Modified: trunk/core/MetaBody.cpp
===================================================================
--- trunk/core/MetaBody.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/core/MetaBody.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -28,10 +28,11 @@
 	recover=false;
 
 	// I must assign something to avoid &quot;nan&quot; when loading. When recover=false, those can be &quot;nan&quot; and lead to crash.
-	recoverDt=1;
 	recoverCurrentIteration=1;
 	recoverStopAtIteration=1;
 	recoverSimulationTime=1;
+
+	dt=1e-8;
 }
 
 
@@ -58,9 +59,9 @@
 	REGISTER_ATTRIBUTE(transientInteractions);
 	REGISTER_ATTRIBUTE(persistentInteractions);
 	REGISTER_ATTRIBUTE(physicalActions); // FIXME - needed or not ? - Olivier : yes it is needed if there is no default initialization into constructor
+	REGISTER_ATTRIBUTE(dt);
 
 	REGISTER_ATTRIBUTE(recover);
-	REGISTER_ATTRIBUTE(recoverDt);
 	REGISTER_ATTRIBUTE(recoverCurrentIteration);
 	REGISTER_ATTRIBUTE(recoverStopAtIteration);
 	REGISTER_ATTRIBUTE(recoverSimulationTime);

Modified: trunk/core/MetaBody.hpp
===================================================================
--- trunk/core/MetaBody.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/core/MetaBody.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -35,12 +35,13 @@
 		 *	Copying is being done ine Omega::loadSimulation and Omega::saveSimulation -- keep vars in sync.
 		 * */
 		bool recover;
-		Real recoverDt;
 		long recoverCurrentIteration;
 		long recoverStopAtIteration;
 		Real recoverSimulationTime;
 
+		Real dt;
 
+
 		void runInitializers();
 /// Serialization
 	protected :

Modified: trunk/core/Omega.cpp
===================================================================
--- trunk/core/Omega.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/core/Omega.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -45,7 +45,6 @@
 	simulationFileName=&quot;&quot;;
 	currentIteration = 0;
 	stopAtIteration = 0;
-	dt = 1e-8;
 }
 
 
@@ -342,7 +341,6 @@
 
 		if(rootBody-&gt;recover){
 			LOG_INFO(&quot;Simulation recovery effective.&quot;);
-			dt=rootBody-&gt;recoverDt;
 			currentIteration=rootBody-&gt;recoverCurrentIteration;
 			stopAtIteration=rootBody-&gt;recoverStopAtIteration;
 			simulationTime=rootBody-&gt;recoverSimulationTime;	
@@ -366,7 +364,6 @@
 		if(recover){
 			LOG_INFO(&quot;Simulation recovery enabled.&quot;);
 			rootBody-&gt;recover=true;
-			rootBody-&gt;recoverDt=dt;
 			rootBody-&gt;recoverCurrentIteration=currentIteration;
 			rootBody-&gt;recoverStopAtIteration=stopAtIteration;
 			rootBody-&gt;recoverSimulationTime=simulationTime;
@@ -396,13 +393,14 @@
 // FIXME - remove that
 void Omega::setTimeStep(const Real t)
 {
-	dt = t;
+	if(rootBody) rootBody-&gt;dt=t;
 }
 
 
 Real Omega::getTimeStep()
 {
-	return dt;
+	if(rootBody) return rootBody-&gt;dt;
+	else return -1;
 }
 
 

Modified: trunk/core/Omega.hpp
===================================================================
--- trunk/core/Omega.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/core/Omega.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -73,7 +73,6 @@
 		SimulationFlow			 simulationFlow_;
 
 		map&lt;string,DynlibDescriptor&gt;	 dynlibs;	// FIXME : should store that in ClassFactory ?
-		Real				 dt;		// FIXME - maybe ? move this to MetaBody.hpp OR MAYBE NOT ?
 		
 		shared_ptr&lt;MetaBody&gt;		 rootBody;
 		ptime				 sStartingSimulationTime;
@@ -143,7 +142,7 @@
 		void		incrementCurrentIteration();
 		
 		Real		getSimulationTime() { return simulationTime;};
-		void		incrementSimulationTime() { simulationTime+=dt;};
+		void		incrementSimulationTime() { simulationTime+=getTimeStep();};
 		
 		void		init();
 

Modified: trunk/extra/Brefcom.cpp
===================================================================
--- trunk/extra/Brefcom.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/Brefcom.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -19,7 +19,7 @@
 */
 
 
-YADE_PLUGIN(&quot;BrefcomMakeContact&quot;,&quot;BrefcomContact&quot;,&quot;BrefcomLaw&quot;,&quot;GLDrawBrefcomContact&quot;);
+YADE_PLUGIN(&quot;BrefcomMakeContact&quot;,&quot;BrefcomContact&quot;,&quot;BrefcomLaw&quot;,&quot;GLDrawBrefcomContact&quot;,&quot;BrefcomStiffnessCounter&quot;);
 
 /********************** BrefcomMakeContact ****************************/
 CREATE_LOGGER(BrefcomMakeContact);
@@ -45,8 +45,8 @@
 		Real E12=2*elast1-&gt;young*elast2-&gt;young/(elast1-&gt;young+elast2-&gt;young); // harmonic Young's modulus average
 		Real nu12=2*elast1-&gt;poisson*elast2-&gt;poisson/(elast1-&gt;poisson+elast2-&gt;poisson); // dtto for Poisson ratio 
 		Real S12=Mathr::PI*pow(min(contGeom-&gt;radius1,contGeom-&gt;radius2),2); // &quot;surface&quot; of interaction
-		Real d0=contGeom-&gt;radius1 + contGeom-&gt;radius2; // equilibrium distace is &quot;just touching&quot;
-		//Real d0=(elast1-&gt;se3.position-elast2-&gt;se3.position).Length();
+		//Real d0=contGeom-&gt;radius1 + contGeom-&gt;radius2; // equilibrium distace is &quot;just touching&quot;
+		Real d0=(elast1-&gt;se3.position-elast2-&gt;se3.position).Length(); // equilibrium distance is the current distance !!
 		Real Kn=(E12*S12/d0)*((1+alpha)/(beta*(1+nu12)+gamma*(1-alpha*nu12)));
 
 		/* recommend default values for parameters
@@ -60,11 +60,12 @@
 			/* equilibriumDist */ d0,
 			/* crossSection */ S12,
 			/* epsCracking */ sigmaT/E12,
-			/* epsFracture */ calibratedEpsFracture,
+			/* epsFracture */ 3*(sigmaT/E12), //calibratedEpsFracture,
 			/* expBending */ expBending
 			));
 		contPhys-&gt;prevNormal=contGeom-&gt;normal;
-		contPhys-&gt;isCohesive=(Omega::instance().getCurrentIteration()&gt;5 ? false : true);
+		if(cohesiveThresholdIter&lt;0 || Omega::instance().getCurrentIteration()&lt;cohesiveThresholdIter) contPhys-&gt;isCohesive=true;
+		else contPhys-&gt;isCohesive=false;
 
 		interaction-&gt;interactionPhysics=contPhys;
 	}
@@ -168,8 +169,8 @@
 	
 	InteractionContainer::iterator transientEnd=rootBody-&gt;transientInteractions-&gt;end();
 	for(InteractionContainer::iterator I=rootBody-&gt;transientInteractions-&gt;begin(); I!=transientEnd; ++I){
-		if(!(*I)-&gt;isReal) continue;
-		// TRACE;
+		if(!(*I)-&gt;isReal) { /*LOG_DEBUG(&quot;Skipped unreal interaction of &quot;&lt;&lt;(*I)-&gt;getId1()&lt;&lt;&quot;+&quot;&lt;&lt;(*I)-&gt;getId2());*/ continue; }
+		//TRACE;
 		// initialize temporaries
 		id1=(*I)-&gt;getId1(); id2=(*I)-&gt;getId2();
 		body1=Body::byId(id1); body2=Body::byId(id2);
@@ -183,17 +184,19 @@
 		// don't disregard links with omegaPl=1, they can still be compressed !!
 		// if(BC-&gt;omegaPl &gt;= 1) continue; // we want to keep broken links formally alive, for statistics of material damage
 		
-		recValues.clear(); recLabels.clear();
-		BREFREC2(Omega::instance().getCurrentIteration(),&quot;iter&quot;);
-		BREFREC(id1);
-		BREFREC(id2);
-		BREFREC2(rbp1-&gt;se3.position[0],&quot;x1&quot;);
-		BREFREC2(rbp1-&gt;se3.position[1],&quot;y1&quot;);
-		BREFREC2(rbp1-&gt;se3.position[2],&quot;z1&quot;);
-		BREFREC2(rbp2-&gt;se3.position[0],&quot;x2&quot;);
-		BREFREC2(rbp2-&gt;se3.position[1],&quot;y2&quot;);
-		BREFREC2(rbp2-&gt;se3.position[2],&quot;z2&quot;);
-		//BREFREC2(BC-&gt;omega,&quot;&#969;&quot;);
+		#ifdef BREFCOM_REC
+			recValues.clear(); recLabels.clear();
+			BREFREC2(Omega::instance().getCurrentIteration(),&quot;iter&quot;);
+			BREFREC(id1);
+			BREFREC(id2);
+			BREFREC2(rbp1-&gt;se3.position[0],&quot;x1&quot;);
+			BREFREC2(rbp1-&gt;se3.position[1],&quot;y1&quot;);
+			BREFREC2(rbp1-&gt;se3.position[2],&quot;z1&quot;);
+			BREFREC2(rbp2-&gt;se3.position[0],&quot;x2&quot;);
+			BREFREC2(rbp2-&gt;se3.position[1],&quot;y2&quot;);
+			BREFREC2(rbp2-&gt;se3.position[2],&quot;z2&quot;);
+			BREFREC2(BC-&gt;omega,&quot;&#969;_old&quot;);
+		#endif
 
 		// shorthands
 		Vector3r&amp; epsT(BC-&gt;epsT); Real&amp; kappaD(BC-&gt;kappaD); const Real&amp; equilibriumDist(BC-&gt;equilibriumDist); const Real&amp; xiShear(BC-&gt;xiShear); const Real&amp; Kn(BC-&gt;Kn); const Real&amp; undamagedCohesion(BC-&gt;undamagedCohesion); const Real&amp; frictionAngle(BC-&gt;frictionAngle); const Real&amp; Kt(BC-&gt;Kt); const Real&amp; crossSection(BC-&gt;crossSection); Real&amp; omega(BC-&gt;omega);
@@ -201,7 +204,9 @@
 		Real dist=(rbp1-&gt;se3.position-rbp2-&gt;se3.position).Length();
 
 		/* deleting interaction here would (maybe) break the iterator; do it once this loop is done */
-		if(!BC-&gt;isCohesive &amp;&amp; dist&gt;0){ /* delete this interaction later */ interactionsToBeDeleted.push_back(*I); continue; }
+		/* FIXME dist&gt;0 doesn't take into account interaction radius!!! */
+		// /* TODO: recover this line: */
+		if(!BC-&gt;isCohesive &amp;&amp; dist&gt;0){ /* delete this interaction later */ /* (*I)-&gt;isReal=false; */ continue; }
 
 		/* rotate epsT to the new contact plane */
 			Real dt=Omega::instance().getTimeStep();
@@ -219,7 +224,7 @@
 		epsT+=tangentialDisplacement/dist;
 		
 		/* normal strain */
-		Real epsN=(dist-equilibriumDist)/dist;
+		Real epsN=(dist-equilibriumDist)/equilibriumDist;
 
 		Real sigmaN; Vector3r sigmaT;
 
@@ -230,14 +235,23 @@
 			sigmaT=Kt*epsT;
 		#endif
 
-		// TODO: store Fn and Fs inside BC (new attributes), for use with GlobalStiffnessCounter 
+		//if(BC-&gt;omega==1){TRVAR5(equilibriumDist,dist,epsN,kappaD,BC-&gt;epsFracture);}
+
+
+		// store Fn (and Fs?), for use with BrefcomStiffnessCounter
+		Fn=sigmaN*crossSection;
 		applyForce(crossSection*(contGeom-&gt;normal*sigmaN + sigmaT));
 
-		for(size_t i=0; i&lt;recValues.size(); i++) recStream&lt;&lt;recLabels[i]&lt;&lt;&quot;: &quot;&lt;&lt;recValues[i]&lt;&lt;&quot; &quot;;
-		recStream&lt;&lt;endl;
+		#ifdef BREFCOM_REC
+			/*BREFREC(epsN); BREFREC(epsT[0]);BREFREC(epsT[1]);BREFREC(epsT[2]);*/
+			BREFREC(epsN); BREFREC(Fn);
+			BREFREC2(BC-&gt;omega,&quot;&#969;_new&quot;);
+			for(size_t i=0; i&lt;recValues.size(); i++) recStream&lt;&lt;recLabels[i]&lt;&lt;&quot;: &quot;&lt;&lt;recValues[i]&lt;&lt;&quot; &quot;;
+			recStream&lt;&lt;endl;
+		#endif
 	}
 	// delete interactions that were requested to be deleted.
-	for(list&lt;shared_ptr&lt;Interaction&gt; &gt;::iterator I=interactionsToBeDeleted.begin(); I!=interactionsToBeDeleted.end(); I++){ rootBody-&gt;transientInteractions-&gt;erase((*I)-&gt;getId1(),(*I)-&gt;getId2()); }
+	//for(list&lt;shared_ptr&lt;Interaction&gt; &gt;::iterator I=interactionsToBeDeleted.begin(); I!=interactionsToBeDeleted.end(); I++){ rootBody-&gt;transientInteractions-&gt;erase((*I)-&gt;getId1(),(*I)-&gt;getId2()); }
 }
 
 
@@ -262,14 +276,17 @@
 		glVertex3v(b2-&gt;physicalParameters-&gt;se3.position);
 	glEnd();
 
-	Vector3r mid=0.5*(b1-&gt;physicalParameters-&gt;se3.position+b2-&gt;physicalParameters-&gt;se3.position);
-	glTranslatev(mid);
-	glPushMatrix();
-		glRasterPos2i(0,0);
-		ostringstream oss; oss&lt;&lt;setprecision(3)&lt;&lt; /* &quot;w=&quot;&lt;&lt; */ (float)BC-&gt;omega;
-		//std::string str=std::string(&quot;omegaPl=&quot;)+boost::lexical_cast&lt;std::string&gt;((float)(BC-&gt;omegaPl));
-		for(unsigned int i=0;i&lt;oss.str().length();i++) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12,oss.str()[i]);
-	glPopMatrix();
+	/* show the damage parameter numerically; remove the #if 0 if wanted */
+	#if 0
+		Vector3r mid=0.5*(b1-&gt;physicalParameters-&gt;se3.position+b2-&gt;physicalParameters-&gt;se3.position);
+		glTranslatev(mid);
+		glPushMatrix();
+			glRasterPos2i(0,0);
+			ostringstream oss; oss&lt;&lt;setprecision(3)&lt;&lt; /* &quot;w=&quot;&lt;&lt; */ (float)BC-&gt;omega;
+			//std::string str=std::string(&quot;omegaPl=&quot;)+boost::lexical_cast&lt;std::string&gt;((float)(BC-&gt;omegaPl));
+			for(unsigned int i=0;i&lt;oss.str().length();i++) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12,oss.str()[i]);
+		glPopMatrix();
+	#endif
 }
 
 /********************** BrefcomDamageColorizer ****************************/
@@ -279,15 +296,34 @@
 	bodyDamage.resize(rootBody-&gt;bodies-&gt;size(),pair&lt;short,Real&gt;(0,0));
 	InteractionContainer::iterator transientEnd=rootBody-&gt;transientInteractions-&gt;end();
 	for(InteractionContainer::iterator I=rootBody-&gt;transientInteractions-&gt;begin(); I!=transientEnd; ++I){
-		shared_ptr&lt;BrefcomContact&gt; BC=YADE_PTR_CAST&lt;BrefcomContact&gt;((*I)-&gt;interactionPhysics);
-		if(!BC-&gt;isCohesive) continue;
+		shared_ptr&lt;BrefcomContact&gt; BC=dynamic_pointer_cast&lt;BrefcomContact&gt;((*I)-&gt;interactionPhysics);
+		if(!BC || !BC-&gt;isCohesive) continue;
 		const body_id_t id1=(*I)-&gt;getId1(), id2=(*I)-&gt;getId2();
 		bodyDamage[id1].first++; bodyDamage[id2].first++;
 		bodyDamage[id1].second+=BC-&gt;omega; bodyDamage[id2].second+=BC-&gt;omega;
 	}
 	BodyContainer::iterator bodiesEnd=rootBody-&gt;bodies-&gt;end();
 	for(BodyContainer::iterator I=rootBody-&gt;bodies-&gt;begin(); I!=bodiesEnd; ++I){
+		if(bodyDamage[(*I)-&gt;getId()].first==0) continue;
 		Real normDmg=bodyDamage[(*I)-&gt;getId()].second/bodyDamage[(*I)-&gt;getId()].first;
-		(*I)-&gt;geometricalModel-&gt;diffuseColor=Vector3r(normDmg,1-normDmg,.5);	
+		(*I)-&gt;geometricalModel-&gt;diffuseColor=Vector3r(normDmg,1-normDmg,(*I)-&gt;isDynamic?0:1);
 	}
 }
+
+void BrefcomStiffnessCounter::action(Body* body){
+	MetaBody *rootBody=static_cast&lt;MetaBody*&gt;(body);
+	InteractionContainer::iterator Iend=rootBody-&gt;transientInteractions-&gt;end();
+	for(InteractionContainer::iterator I=rootBody-&gt;transientInteractions-&gt;begin(); I!=Iend; ++I){
+		const shared_ptr&lt;Interaction&gt;&amp; contact = *I;
+		if(!contact-&gt;isReal) continue;
+		shared_ptr&lt;SpheresContactGeometry&gt; cGeom=YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(contact-&gt;interactionGeometry);
+		shared_ptr&lt;BrefcomContact&gt; cPhys=YADE_PTR_CAST&lt;BrefcomContact&gt;(contact-&gt;interactionPhysics);
+		if(cPhys-&gt;Fn==0) continue;
+		Vector3r diag_stiffness=Vector3r(pow(cGeom-&gt;normal[0],2),pow(cGeom-&gt;normal[1],2),pow(cGeom-&gt;normal[2],2))*(cPhys-&gt;Kn-cPhys-&gt;Kt)+Vector3r(1,1,1)*cPhys-&gt;Kt;
+		Vector3r diag_Rstiffness=Vector3r(pow(cGeom-&gt;normal[1],2)+pow(cGeom-&gt;normal[2],2),pow(cGeom-&gt;normal[0],2)+pow(cGeom-&gt;normal[2],2),pow(cGeom-&gt;normal[0],2)+pow(cGeom-&gt;normal[1],2))*cPhys-&gt;Kt;
+		GlobalStiffness* s=static_cast&lt;GlobalStiffness*&gt;(rootBody-&gt;physicalActions-&gt;find(contact-&gt;getId1(),actionStiffnessIndex).get());
+		s-&gt;stiffness+=diag_stiffness; s-&gt;Rstiffness+=diag_Rstiffness*pow(cGeom-&gt;radius1,2);	
+		s=static_cast&lt;GlobalStiffness*&gt;(rootBody-&gt;physicalActions-&gt;find(contact-&gt;getId2(),actionStiffnessIndex).get());
+		s-&gt;stiffness+=diag_stiffness; s-&gt;Rstiffness+=diag_Rstiffness*pow(cGeom-&gt;radius2,2);
+	}
+}

Modified: trunk/extra/Brefcom.hpp
===================================================================
--- trunk/extra/Brefcom.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/Brefcom.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -10,7 +10,9 @@
 #include&lt;yade/pkg-common/InteractionPhysicsEngineUnit.hpp&gt;
 #include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
 #include&lt;yade/pkg-common/GLDrawInteractionPhysicsFunctor.hpp&gt;
+#include&lt;yade/pkg-dem/GlobalStiffness.hpp&gt;
 
+// #define BREFCOM_REC
 
 /*! @brief representation of a single interaction of the brefcom type: storage for relevant parameters.
  *
@@ -36,11 +38,11 @@
 		/*! if not cohesive, interaction is deleted when distance is greater than zero. */
 		bool isCohesive;
 
-		/*! auxiliary variable for visualization, recalculated by BrefcomLaw at every iteration */
-		Real omega;
+		/*! auxiliary variable for visualization and BrefcomStiffnessCounter, recalculated by BrefcomLaw at every iteration */
+		Real omega, Fn;
 
 		BrefcomContact(): InteractionPhysics(),Kn(0), Kt(0), frictionAngle(0), undamagedCohesion(0), equilibriumDist(0), crossSection(0), expBending(0), xiShear(0) { createIndex(); epsT=Vector3r::ZERO; kappaD=0; isCohesive=false; }
-		BrefcomContact(Real _Kn, Real _Ks, Real _frictionAngle, Real _undamagedCohesion, Real _equilibriumDist, Real _crossSection, Real _epsCracking, Real _epsFracture, Real _expBending, Real _xiShear=.3): InteractionPhysics(), Kn(_Kn), Kt(_Ks), frictionAngle(_frictionAngle), undamagedCohesion(_undamagedCohesion), equilibriumDist(_equilibriumDist), crossSection(_crossSection), epsCracking(_epsCracking), epsFracture(_epsFracture), expBending(_expBending), xiShear(_xiShear) { epsT=Vector3r::ZERO; kappaD=0; isCohesive=false; }
+		BrefcomContact(Real _Kn, Real _Ks, Real _frictionAngle, Real _undamagedCohesion, Real _equilibriumDist, Real _crossSection, Real _epsCracking, Real _epsFracture, Real _expBending, Real _xiShear=.3): InteractionPhysics(), Kn(_Kn), Kt(_Ks), frictionAngle(_frictionAngle), undamagedCohesion(_undamagedCohesion), equilibriumDist(_equilibriumDist), crossSection(_crossSection), epsCracking(_epsCracking), epsFracture(_epsFracture), expBending(_expBending), xiShear(_xiShear) { epsT=Vector3r::ZERO; kappaD=0; isCohesive=false; /*TRVAR5(epsCracking,epsFracture,Kn,crossSection,equilibriumDist); */ }
 
 
 		void registerAttributes(){
@@ -99,9 +101,11 @@
 		shared_ptr&lt;RigidBodyParameters&gt; rbp1, rbp2;
 		MetaBody* rootBody;
 		// recording  values
-		ofstream recStream;
-		vector&lt;Real&gt; recValues;
-		vector&lt;string&gt; recLabels;
+		#ifdef BREFCOM_REC
+			ofstream recStream;
+			vector&lt;Real&gt; recValues;
+			vector&lt;string&gt; recLabels;
+		#endif
 		void applyForce(const Vector3r);
 		/*! Cohesion evolution law (it is 1-funcH here) */
 		Real funcH(Real kappaD){ return 1-funcG(kappaD); }
@@ -123,7 +127,11 @@
 		void action(Body* body);
 	protected: 
 		void registerAttributes(){InteractionSolver::registerAttributes();};
-		void postProcessAttributes(bool deserializing){ if(deserializing) recStream.open(&quot;/tmp/breflaw.data&quot;); }
+		void postProcessAttributes(bool deserializing){ if(deserializing)
+		#ifdef BREFCOM_REC
+			recStream.open(&quot;/tmp/breflaw.data&quot;)
+		#endif
+		; }
 
 	REGISTER_CLASS_NAME(BrefcomLaw);
 	REGISTER_BASE_CLASS_NAME(InteractionSolver);
@@ -147,20 +155,29 @@
 		/* alternatively (and more cleanly), we would have subclass of ElasticBodyParameters,
 		 * which would define just those in addition to the elastic ones.
 		 * This might be done later, for now hardcode that here. */
-		/* uniaxial traction resistance, uniaxial compression resistance, fracture energy, strain at complete fracture (calibrated in the constructor) */
+		/* uniaxial traction resistance, uniaxial compression resistance, fracture energy, strain at complete fracture (calibrated in the constructor), bending parameter of the damage evolution law */
 		Real sigmaT, sigmaC, /* Griffith's fracture energy */ Gf, calibratedEpsFracture, expBending;
+		//! Should new contacts be cohesive? They will before this iter#, they will not be afterwards. If 0, they will never be. If negative, they will always be created as cohesive.
+		long cohesiveThresholdIter;
 
 		BrefcomMakeContact(){
 			alpha=3.7; beta=2.198; gamma=3.79; sigmaC=30e6; sigmaT=sigmaC/10.;
-			expBending=4;
+			expBending=4; /* positive: concave function */
+			cohesiveThresholdIter=-1;
 			Gf=500; /* J/m^2&#160;*/
 			/* calibrate epsFracture; WARNING: this is based on the default E value from Shop
 			 * and therefore may not match the actual E !! */
 			Real E=Shop::getDefault&lt;double&gt;(&quot;phys_young&quot;);
-			Real epsCrackOnset=sigmaC/E;
-			calibratedEpsFracture=BrefcomLaw::calibrateEpsFracture(Gf,E,expBending,epsCrackOnset);
-			LOG_DEBUG(&quot;calibratedEpsFracture=&quot;&lt;&lt;calibratedEpsFracture);
-			if(calibratedEpsFracture&gt;epsCrackOnset) LOG_WARN(&quot;calibratedEpsFracture=&quot;&lt;&lt;calibratedEpsFracture&lt;&lt;&quot; &lt; epsCrackOnset=&quot;&lt;&lt;epsCrackOnset&lt;&lt;&quot;, Gf=&quot;&lt;&lt;Gf&lt;&lt;&quot;, E=&quot;&lt;&lt;E&lt;&lt;&quot;, expBending=&quot;&lt;&lt;expBending);
+			Real epsCrackOnset=sigmaT/E;
+			try{
+				calibratedEpsFracture=BrefcomLaw::calibrateEpsFracture(Gf,E,expBending,epsCrackOnset);
+				LOG_DEBUG(&quot;calibratedEpsFracture=&quot;&lt;&lt;calibratedEpsFracture);
+				if(calibratedEpsFracture&gt;epsCrackOnset) LOG_WARN(&quot;calibratedEpsFracture=&quot;&lt;&lt;calibratedEpsFracture&lt;&lt;&quot; &lt; epsCrackOnset=&quot;&lt;&lt;epsCrackOnset&lt;&lt;&quot;, Gf=&quot;&lt;&lt;Gf&lt;&lt;&quot;, E=&quot;&lt;&lt;E&lt;&lt;&quot;, expBending=&quot;&lt;&lt;expBending);
+			} catch (std::runtime_error&amp; e){
+				LOG_ERROR(&quot;Caught exception from calibration: &quot;&lt;&lt;e.what());
+				calibratedEpsFracture=3*epsCrackOnset;
+				LOG_ERROR(&quot;Setting calibratedEpsFracture to &quot;&lt;&lt;calibratedEpsFracture);
+			}
 		}
 
 		virtual void go(const shared_ptr&lt;PhysicalParameters&gt;&amp; pp1, const shared_ptr&lt;PhysicalParameters&gt;&amp; pp2, const shared_ptr&lt;Interaction&gt;&amp; interaction);
@@ -169,6 +186,9 @@
 			REGISTER_ATTRIBUTE(alpha);
 			REGISTER_ATTRIBUTE(beta);
 			REGISTER_ATTRIBUTE(gamma);
+			REGISTER_ATTRIBUTE(cohesiveThresholdIter);
+			REGISTER_ATTRIBUTE(calibratedEpsFracture);
+			REGISTER_ATTRIBUTE(expBending);
 			/* REGISTER_ATTRIBUTE(sigmaT);
 			REGISTER_ATTRIBUTE(sigmaC);
 			REGISTER_ATTRIBUTE(Gf); */
@@ -203,6 +223,23 @@
 REGISTER_SERIALIZABLE(BrefcomDamageColorizer,false);
 
 
+/***&#160;!!!&#160;BADLY&#160;BROKEN&#160;!!!&#160;Do not use !!! ***/
+class BrefcomStiffnessCounter : public InteractionSolver{
+	private :
+		int actionStiffnessIndex;
+	public:
+		unsigned int interval;
+		BrefcomStiffnessCounter() {interval=500; actionStiffnessIndex=shared_ptr&lt;PhysicalAction&gt;(new GlobalStiffness)-&gt;getClassIndex();}
+		void action(Body* body);
+		virtual bool isActivated(){return (Omega::instance().getCurrentIteration()%interval)==0;}
+	protected :
+		void registerAttributes(){REGISTER_ATTRIBUTE(interval);}
+	REGISTER_CLASS_NAME(BrefcomStiffnessCounter);
+	REGISTER_BASE_CLASS_NAME(InteractionSolver);
+};
+
+REGISTER_SERIALIZABLE(BrefcomStiffnessCounter,false);
+
  
 
 

Modified: trunk/extra/BrefcomTestGen.cpp
===================================================================
--- trunk/extra/BrefcomTestGen.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/BrefcomTestGen.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -44,6 +44,8 @@
 #include&lt;yade/pkg-common/LeapFrogPositionIntegrator.hpp&gt;
 #include&lt;yade/pkg-common/LeapFrogOrientationIntegrator.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
+#include&lt;yade/pkg-dem/PositionOrientationRecorder.hpp&gt;
+#include&lt;yade/pkg-dem/GlobalStiffnessTimeStepper.hpp&gt;
 #include&lt;yade/extra/UniaxialStrainControlledTest.hpp&gt;
 
 /*
@@ -73,6 +75,7 @@
 	shared_ptr&lt;PhysicalActionContainerInitializer&gt; physicalActionInitializer(new PhysicalActionContainerInitializer);
 	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Force&quot;);
 	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Momentum&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;GlobalStiffness&quot;);
 	rootBody-&gt;initializers.push_back(physicalActionInitializer);
 	
 	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
@@ -94,7 +97,10 @@
 	rootBody-&gt;engines.push_back(igeomDispatcher);
 
 	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; iphysDispatcher(new InteractionPhysicsMetaEngine);
-	iphysDispatcher-&gt;add(new BrefcomMakeContact);
+		shared_ptr&lt;BrefcomMakeContact&gt; bmc(new BrefcomMakeContact);
+		bmc-&gt;cohesiveThresholdIter=-1;
+		bmc-&gt;calibratedEpsFracture=.5; /* arbitrary, but large enough */
+		iphysDispatcher-&gt;add(bmc);
 	rootBody-&gt;engines.push_back(iphysDispatcher);
 
 	shared_ptr&lt;BrefcomLaw&gt; bLaw(new BrefcomLaw);
@@ -112,6 +118,26 @@
 	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
 	orientationIntegrator-&gt;add(new LeapFrogOrientationIntegrator);
 	rootBody-&gt;engines.push_back(orientationIntegrator);
+
+	shared_ptr&lt;BrefcomDamageColorizer&gt; dmg(new BrefcomDamageColorizer);
+	rootBody-&gt;engines.push_back(dmg);
+
+	shared_ptr&lt;PositionOrientationRecorder&gt; rec(new PositionOrientationRecorder);
+	rec-&gt;outputFile=&quot;/tmp/brefcom-test&quot;;
+	rec-&gt;interval=500;
+	rec-&gt;saveRgb=true;
+	rootBody-&gt;engines.push_back(rec);
+#if 0
+	shared_ptr&lt;BrefcomStiffnessCounter&gt; bsc(new BrefcomStiffnessCounter);
+	bsc-&gt;interval=100;
+	rootBody-&gt;engines.push_back(bsc);
+
+	shared_ptr&lt;GlobalStiffnessTimeStepper&gt; gsts(new GlobalStiffnessTimeStepper);
+	gsts-&gt;sdecGroupMask=1023;
+	gsts-&gt;timeStepUpdateInterval=100;
+	gsts-&gt;defaultDt=1e-4;
+	rootBody-&gt;engines.push_back(gsts);
+#endif
 }
 
 bool BrefcomTestGen::generate(){
@@ -128,11 +154,11 @@
 	
 	// control normal/shear ratio
 	//Real zCoord=.1; Real yCoord=sqrt(1-zCoord*zCoord); // distance is always 2, with contact at origin
-	Real zCoord=1, yCoord=0;
+	Real zCoord=.9, yCoord=0;
 	shared_ptr&lt;Body&gt;
-		s1=Shop::sphere(Vector3r(0,-yCoord,-zCoord),1),
-		s2=Shop::sphere(Vector3r(0,yCoord,zCoord),1),
-		sMid=Shop::sphere(Vector3r(0,0,0.01),1);
+		s1=Shop::sphere(Vector3r(0,-yCoord,-zCoord),.5),
+		s2=Shop::sphere(Vector3r(0,yCoord,zCoord),.5),
+		sMid=Shop::sphere(Vector3r(0,0,0.01),.5);
 	body_id_t id1=rootBody-&gt;bodies-&gt;insert(s1), id2=rootBody-&gt;bodies-&gt;insert(s2), id3=rootBody-&gt;bodies-&gt;insert(sMid);
 	
 	//  engines should take care of the rest of interaction; this is what collider would do normally
@@ -142,8 +168,8 @@
 	rootBody-&gt;transientInteractions-&gt;find(id1,id2)-&gt;isNew=1;
 	*/
 
-	strainer-&gt;negIds.push_back(id1); strainer-&gt;negCoords.push_back(-1);
-	strainer-&gt;posIds.push_back(id2); strainer-&gt;posCoords.push_back(1);
+	strainer-&gt;negIds.push_back(id1); strainer-&gt;negCoords.push_back(-zCoord);
+	strainer-&gt;posIds.push_back(id2); strainer-&gt;posCoords.push_back(zCoord);
 
 	return true;
 }

Modified: trunk/extra/SConscript
===================================================================
--- trunk/extra/SConscript	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/SConscript	2008-03-30 20:22:20 UTC (rev 1290)
@@ -47,11 +47,11 @@
 	
 	env.SharedLibrary('TetraTestGen',['tetra/TetraTestGen.cpp'],LIBS=env['LIBS']+['Shop','Tetra']),
 
-	env.SharedLibrary('UniaxialStrainControlledTest',['usct/UniaxialStrainControlledTest.cpp'],LIBS=env['LIBS']+['Shop','GlobalStiffnessTimeStepper','GlobalStiffnessCounter','Brefcom']),
+	env.SharedLibrary('UniaxialStrainControlledTest',['usct/UniaxialStrainControlledTest.cpp'],LIBS=env['LIBS']+['Shop','GlobalStiffnessTimeStepper','GlobalStiffnessCounter','Brefcom','PositionOrientationRecorder']),
 
 	env.SharedLibrary('Brefcom',['Brefcom.cpp'],CXXFLAGS=env['CXXFLAGS']+brefcomInclude,LIBS=env['LIBS']+['Shop','InteractingSphere2InteractingSphere4DistantSpheresContactGeometry']),
 
-	env.SharedLibrary('BrefcomTestGen',['BrefcomTestGen.cpp'],LIBS=env['LIBS']+['Shop','UniaxialStrainControlledTest']),
+	env.SharedLibrary('BrefcomTestGen',['BrefcomTestGen.cpp'],LIBS=env['LIBS']+['Shop','UniaxialStrainControlledTest','PositionOrientationRecorder']),
 
 	env.SharedLibrary('Shop',
 		['clump/Shop.cpp'],

Modified: trunk/extra/usct/UniaxialStrainControlledTest.cpp
===================================================================
--- trunk/extra/usct/UniaxialStrainControlledTest.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/usct/UniaxialStrainControlledTest.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -12,88 +12,71 @@
 /************************ UniaxialStrainer **********************/
 CREATE_LOGGER(UniaxialStrainer);
 
-void UniaxialStrainer::applyCondition(Body* _rootBody){
-	if(posIds.size()==0 || negIds.size()==0) return;
+void UniaxialStrainer::init(){
+	needsInit=false;
+
+	posCoords.clear(); negCoords.clear();
+	BOOST_FOREACH(body_id_t id,posIds){ const shared_ptr&lt;Body&gt;&amp; b=Body::byId(id); posCoords.push_back(b-&gt;physicalParameters-&gt;se3.position[axis]); b-&gt;isDynamic=false;}
+	BOOST_FOREACH(body_id_t id,negIds){ const shared_ptr&lt;Body&gt;&amp; b=Body::byId(id); negCoords.push_back(b-&gt;physicalParameters-&gt;se3.position[axis]); b-&gt;isDynamic=false;}
 	assert(posIds.size()==posCoords.size() &amp;&amp; negIds.size()==negCoords.size());
 
-	if(originalLength&lt;0) {
-		originalLength=USCT_AXIS_COORD(posIds[0])-USCT_AXIS_COORD(negIds[0]);
-		LOG_DEBUG(&quot;Reference particles: positive #&quot;&lt;&lt;posIds[0]&lt;&lt;&quot; at &quot;&lt;&lt;USCT_AXIS_COORD(posIds[0])&lt;&lt;
-			&quot;; negative #&quot;&lt;&lt;negIds[0]&lt;&lt;&quot; at &quot;&lt;&lt;USCT_AXIS_COORD(negIds[0]));
-		LOG_INFO(&quot;Setting initial length to &quot;&lt;&lt;originalLength);
-	}
+	originalLength=USCT_AXIS_COORD(posIds[0])-USCT_AXIS_COORD(negIds[0]);
+	LOG_DEBUG(&quot;Reference particles: positive #&quot;&lt;&lt;posIds[0]&lt;&lt;&quot; at &quot;&lt;&lt;USCT_AXIS_COORD(posIds[0])&lt;&lt;&quot;; negative #&quot;&lt;&lt;negIds[0]&lt;&lt;&quot; at &quot;&lt;&lt;USCT_AXIS_COORD(negIds[0]));
+	LOG_INFO(&quot;Setting initial length to &quot;&lt;&lt;originalLength);
+	assert(originalLength&gt;0);
 	
 	shared_ptr&lt;AABB&gt; rbAABB;
-	if(crossSectionArea&lt;=0){
-		if (_rootBody-&gt;boundingVolume &amp;&amp; (rbAABB=dynamic_pointer_cast&lt;AABB&gt;(_rootBody-&gt;boundingVolume))){
-			int axis2=(axis+1)%3, axis3=(axis+2)%3; // perpendicular axes indices
-			crossSectionArea=4*rbAABB-&gt;halfSize[axis2]*rbAABB-&gt;halfSize[axis3];
-			LOG_INFO(&quot;Setting crossSectionArea=&quot;&lt;&lt;crossSectionArea&lt;&lt;&quot;, using axes #&quot;&lt;&lt;axis2&lt;&lt;&quot; and #&quot;&lt;&lt;axis3&lt;&lt;&quot;.&quot;);
-		} else {
-			LOG_WARN(&quot;No Axis Aligned Bounding Box for rootBody, using garbage value (&quot;&lt;&lt;crossSectionArea&lt;&lt;&quot;) for crossSectionArea!&quot;);
-		}
+	if (Omega::instance().getRootBody()-&gt;boundingVolume &amp;&amp; (rbAABB=dynamic_pointer_cast&lt;AABB&gt;(Omega::instance().getRootBody()-&gt;boundingVolume))){
+		int axis2=(axis+1)%3, axis3=(axis+2)%3; // perpendicular axes indices
+		crossSectionArea=4*rbAABB-&gt;halfSize[axis2]*rbAABB-&gt;halfSize[axis3];
+		LOG_INFO(&quot;Setting crossSectionArea=&quot;&lt;&lt;crossSectionArea&lt;&lt;&quot;, using axes #&quot;&lt;&lt;axis2&lt;&lt;&quot; and #&quot;&lt;&lt;axis3&lt;&lt;&quot;.&quot;);
+	} else {
+		crossSectionArea=1.;
+		LOG_WARN(&quot;No Axis Aligned Bounding Box for rootBody, using garbage value (&quot;&lt;&lt;crossSectionArea&lt;&lt;&quot;) for crossSectionArea!&quot;);
 	}
+	assert(crossSectionArea&gt;1);
 
+	recStream.open(&quot;/tmp/usct.data&quot;);
+}
+
+void UniaxialStrainer::applyCondition(Body* _rootBody){
+	if(needsInit) init();
+	// postconditions for initParams
+	assert(posIds.size()==posCoords.size() &amp;&amp; negIds.size()==negCoords.size() &amp;&amp; originalLength&gt;0 &amp;&amp; crossSectionArea&gt;1);
+	//nothing to do
+	if(posIds.size()==0 || negIds.size()==0) return;
 	// linearly increase strain to the desired value
 	if(abs(currentStrainRate)&lt;abs(strainRate))currentStrainRate+=strainRate*.01; else currentStrainRate=strainRate;
-
+	// how much do we move
 	Real dAX=.5*currentStrainRate*originalLength*Omega::instance().getTimeStep();
 	for(size_t i=0; i&lt;negIds.size(); i++){
 		//TRVAR1(USCT_AXIS_COORD(negIds[i]));
 		negCoords[i]-=dAX;
 		USCT_AXIS_COORD(negIds[i])=negCoords[i]; // update current position
-		negCoords[i]-=dAX; //USCT_AXIS_COORD(negIds[i]); // store current position
-		//if(strain&lt;-0.000155 &amp;&amp; i==0) LOG_DEBUG(&quot;Moved #&quot;&lt;&lt;negIds[i]&lt;&lt;&quot; by &quot;&lt;&lt;-dAX&lt;&lt;&quot; to &quot;&lt;&lt;negCoords[i]);
+		negCoords[i]-=dAX; // store current position
 	}
 	for(size_t i=0; i&lt;posIds.size(); i++){
 		posCoords[i]+=dAX;
 		USCT_AXIS_COORD(posIds[i])=posCoords[i];
-		//if(strain&lt;-0.000155 &amp;&amp; i==0) LOG_DEBUG(&quot;Moved #&quot;&lt;&lt;posIds[i]&lt;&lt;&quot; by &quot;&lt;&lt;dAX&lt;&lt;&quot; to &quot;&lt;&lt;posCoords[i]);
 	}
 
 	Real axialLength=USCT_AXIS_COORD(posIds[0])-USCT_AXIS_COORD(negIds[0]);
 	Real strain=axialLength/originalLength-1;
 	if(Omega::instance().getCurrentIteration()%400==0) TRVAR5(dAX,axialLength,originalLength,currentStrainRate,strain);
+
 	// reverse if we're over the limit strain
-	// if(notYetReversed &amp;&amp; limitStrain!=0 &amp;&amp; ((currentStrainRate&gt;0 &amp;&amp; strain&gt;limitStrain) || (currentStrainRate&lt;0 &amp;&amp; strain&lt;limitStrain))) { currentStrainRate*=-1; notYetReversed=false; LOG_INFO(&quot;Reversed strain rate to &quot;&lt;&lt;currentStrainRate); }
-	MetaBody* rootBody=static_cast&lt;MetaBody*&gt;(_rootBody);
+	if(notYetReversed &amp;&amp; limitStrain!=0 &amp;&amp; ((currentStrainRate&gt;0 &amp;&amp; strain&gt;limitStrain) || (currentStrainRate&lt;0 &amp;&amp; strain&lt;limitStrain))) { currentStrainRate*=-1; notYetReversed=false; LOG_INFO(&quot;Reversed strain rate to &quot;&lt;&lt;currentStrainRate); }
+
 	if(Omega::instance().getCurrentIteration()%50==0 &amp;&amp; recStream.good()) {
-		computeAxialForce(rootBody);
+		computeAxialForce(static_cast&lt;MetaBody*&gt;(_rootBody));
 		Real midPos=Body::byId(1)-&gt;physicalParameters-&gt;se3.position[axis];
 		Real avgStress=(sumPosForces+sumNegForces)/(2*crossSectionArea); // average nominal stress
 		recStream&lt;&lt;Omega::instance().getCurrentIteration()&lt;&lt;&quot; &quot;&lt;&lt;strain&lt;&lt;&quot; &quot;&lt;&lt;avgStress&lt;&lt;&quot; &quot;&lt;&lt;sumPosForces&lt;&lt;&quot; &quot;&lt;&lt;sumNegForces&lt;&lt;&quot; &quot;&lt;&lt;posCoords[0]&lt;&lt;&quot; &quot;&lt;&lt;negCoords[0]&lt;&lt;&quot; &quot;&lt;&lt;midPos&lt;&lt;endl;
 	}
 }
 
-bool UniaxialStrainer::idInVector(body_id_t id, const vector&lt;body_id_t&gt;&amp; V){
-	for(size_t i=0; i&lt;V.size(); i++){ if(V[i]==id) return true; }
-	return false;
-}
-
 void UniaxialStrainer::computeAxialForce(MetaBody* rootBody){
 	sumPosForces=0; sumNegForces=0;
-	#if 0
-		for(InteractionContainer::iterator I=rootBody-&gt;transientInteractions-&gt;begin(); I!=rootBody-&gt;transientInteractions-&gt;end(); ++I){
-			if(!(*I)-&gt;isReal) { continue; }
-			const shared_ptr&lt;BrefcomContact&gt;&amp; BC=dynamic_pointer_cast&lt;BrefcomContact&gt;((*I)-&gt;interactionPhysics);
-			//const shared_ptr&lt;SpheresContactGeometry&gt;&amp; SCG=dynamic_pointer_cast&lt;SpheresContactGeometry&gt;((*I)-&gt;interactionGeometry);
-			if(/* (!SCG)&#160;|| */ (!BC) || (!BC-&gt;isStructural)) { continue; }
-			body_id_t id1=(*I)-&gt;getId1(), id2=(*I)-&gt;getId2(), id;
-
-			/* following: if (id1 || id2) &#8712; (posIds||negIds): add axis.Dot(contact-&gt;Fs+contact-&gt;Fn) to (sumPosForces||sumNegForces) */
-			bool pos1=idInVector(id1,posIds), pos2=idInVector(id2,posIds), neg1=idInVector(id1,negIds), neg2=idInVector(id2,negIds);
-			if(!(pos1&amp;&amp;pos2)) id = pos1 ? id1 : (pos2 ? id2 : Body::ID_NONE);
-			if(id!=Body::ID_NONE){
-				Vector3r ax=Vector3r::ZERO; ax[axis]=-1;
-				sumPosForces+=(id==id1?1:-1)*BC-&gt;Fn.Dot(ax); // sumPosForces+=ax.Dot(BC-&gt;Fs+BC-&gt;Fn); /* TRVAR1(ax.Dot(BC-&gt;Fs+BC-&gt;Fn)); */
-			}
-			if(!(neg1&amp;&amp;neg2)) id = neg1 ? id1 : (neg2 ? id2 : Body::ID_NONE);
-			if(id!=Body::ID_NONE){
-				Vector3r ax=Vector3r::ZERO; ax[axis]=1;
-				sumNegForces+=(id==id1?1:-1)*BC-&gt;Fn.Dot(ax); //sumNegForces+=ax.Dot(BC-&gt;Fs+BC-&gt;Fn); /* TRVAR1(ax.Dot(BC-&gt;Fs+BC-&gt;Fn)); */
-			}
-		}
-	#else
 		shared_ptr&lt;Force&gt; f(new Force);
 		for(size_t i=0; i&lt;negIds.size(); i++){
 			sumNegForces+=static_pointer_cast&lt;Force&gt;(rootBody-&gt;physicalActions-&gt;find(negIds[i],f-&gt;getClassIndex()))-&gt;force[axis];
@@ -101,7 +84,6 @@
 		for(size_t i=0; i&lt;posIds.size(); i++){
 			sumPosForces-=static_pointer_cast&lt;Force&gt;(rootBody-&gt;physicalActions-&gt;find(posIds[i],f-&gt;getClassIndex()))-&gt;force[axis];
 		}
-	#endif
 	//TRVAR2(sumPosForces,sumNegForces);
 }
 
@@ -122,7 +104,6 @@
 	// load spheres
 	Vector3r minXYZ,maxXYZ;
 	typedef vector&lt;pair&lt;Vector3r,Real&gt; &gt; vecVecReal;
-	Shop::setDefault(&quot;phys_young&quot;,30e7);
 
 	vecVecReal spheres;
 	if(spheresFile.empty()){ 
@@ -151,41 +132,11 @@
 		}
 	}
 #if 0
-	// create links between spheres
-	Real distFactor=1.2;
-	for(BodyContainer::iterator I1=rootBody-&gt;bodies-&gt;begin(); I1!=rootBody-&gt;bodies-&gt;end(); ++I1){
-		for(BodyContainer::iterator I2=rootBody-&gt;bodies-&gt;begin(); I2!=rootBody-&gt;bodies-&gt;end(); ++I2){
-			Vector3r C1=(*I1)-&gt;physicalParameters-&gt;se3.position, C2=(*I2)-&gt;physicalParameters-&gt;se3.position;
-			const shared_ptr&lt;InteractingSphere&gt;&amp; is1=dynamic_pointer_cast&lt;InteractingSphere&gt;((*I1)-&gt;interactingGeometry), is2=dynamic_pointer_cast&lt;InteractingSphere&gt;((*I2)-&gt;interactingGeometry);
-			assert(is1 &amp;&amp; is2);
-			Real r1=is1-&gt;radius, r2=is2-&gt;radius;
-			if((C2-C1).Length()&lt;(r1+r2)*distFactor){
-					shared_ptr&lt;Interaction&gt; link(new Interaction((*I1)-&gt;getId(),(*I2)-&gt;getId()));
-					shared_ptr&lt;SDECLinkGeometry&gt; geom(new SDECLinkGeometry);
-					shared_ptr&lt;SDECLinkPhysics&gt; phys(new SDECLinkPhysics);
-					geom-&gt;radius1=r1-.5*abs(r1-r2); geom-&gt;radius2=r2-.5*abs(r1-r2);
-					link-&gt;interactionGeometry=geom;
-
-					phys-&gt;initialKn=50000000; phys-&gt;knMax=550000000;
-					phys-&gt;initialKs=5000000; phys-&gt;ksMax=550000000;
-					phys-&gt;heta=1;
-					phys-&gt;initialEquilibriumDistance=(C1-C2).Length();
-					link-&gt;interactionPhysics=phys;
-
-					link-&gt;isReal=true; link-&gt;isNew=false;
-					rootBody-&gt;persistentInteractions-&gt;insert(link);
-					//LOG_DEBUG(&quot;Linked #&quot;&lt;&lt;(*I1)-&gt;getId()&lt;&lt;&quot; and #&quot;&lt;&lt;(*I2)-&gt;getId()&lt;&lt;&quot;.&quot;);
-			}
-		}
+	/* clump spheres together if requested */
+	if(clumped){
+		shared_ptr&lt;Clump&gt; clump=shared_ptr&lt;Clump&gt;(new Clump());
+		shared_ptr&lt;Body&gt; clumpAsBody(static_pointer_cast&lt;Body&gt;(clump));
 	}
-	// remove collider
-	for(vector&lt;shared_ptr&lt;Engine&gt; &gt;::iterator I=rootBody-&gt;engines.begin(); I!=rootBody-&gt;engines.end(); ++I){
-		if((*I)-&gt;getClassName()==&quot;PersistentSAPCollider&quot;) {
-			rootBody-&gt;engines.erase(I);
-			LOG_DEBUG(&quot;Removed PersistentSAPCollider engine.&quot;);
-			break;
-		}
-	}
 #endif
 	return true;
 }
@@ -218,6 +169,7 @@
 #include&lt;yade/pkg-common/LeapFrogOrientationIntegrator.hpp&gt;
 #include&lt;yade/pkg-common/PersistentSAPCollider.hpp&gt;
 #include&lt;yade/pkg-dem/GlobalStiffnessCounter.hpp&gt;
+#include&lt;yade/pkg-dem/PositionOrientationRecorder.hpp&gt;
 #include&lt;yade/pkg-dem/GlobalStiffnessTimeStepper.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
 #include&lt;yade/pkg-common/CundallNonViscousForceDamping.hpp&gt;
@@ -253,8 +205,12 @@
 		rootBody-&gt;engines.push_back(igeomDispatcher);
 
 	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; iphysDispatcher(new InteractionPhysicsMetaEngine);
-		iphysDispatcher-&gt;add(new BrefcomMakeContact);
-		rootBody-&gt;engines.push_back(iphysDispatcher);
+		shared_ptr&lt;BrefcomMakeContact&gt; bmc(new BrefcomMakeContact);
+		bmc-&gt;cohesiveThresholdIter=cohesiveThresholdIter;
+		bmc-&gt;expBending=20;
+		bmc-&gt;calibratedEpsFracture=3e-4;
+		iphysDispatcher-&gt;add(bmc);
+	rootBody-&gt;engines.push_back(iphysDispatcher);
 
 	shared_ptr&lt;BrefcomLaw&gt; bLaw(new BrefcomLaw);
 	rootBody-&gt;engines.push_back(bLaw);
@@ -282,7 +238,7 @@
 	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
 		orientationIntegrator-&gt;add(new LeapFrogOrientationIntegrator);
 		rootBody-&gt;engines.push_back(orientationIntegrator);
-
+#if 0
 	shared_ptr&lt;GlobalStiffnessCounter&gt; globalStiffnessCounter(new GlobalStiffnessCounter);
 	globalStiffnessCounter-&gt;sdecGroupMask=1023;
 	globalStiffnessCounter-&gt;interval=100;
@@ -295,6 +251,16 @@
 	rootBody-&gt;engines.push_back(globalStiffnessTimeStepper);
 
 	rootBody-&gt;engines.push_back(globalStiffnessCounter);
+#endif
+
+	rootBody-&gt;engines.push_back(shared_ptr&lt;BrefcomDamageColorizer&gt;(new BrefcomDamageColorizer));
+
+	shared_ptr&lt;PositionOrientationRecorder&gt; por(new PositionOrientationRecorder);
+	por-&gt;outputFile=&quot;/tmp/usct-traction&quot;;
+	por-&gt;interval=300;
+	por-&gt;saveRgb=true;
+	rootBody-&gt;engines.push_back(por);
+
 }
 
 

Modified: trunk/extra/usct/UniaxialStrainControlledTest.hpp
===================================================================
--- trunk/extra/usct/UniaxialStrainControlledTest.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/extra/usct/UniaxialStrainControlledTest.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -10,12 +10,13 @@
 	private:
 		void createEngines();
 	public:
-		USCTGen(){ axis=1; limitStrain=0; };
+		USCTGen(){ axis=1; limitStrain=0; damping=0.2;cohesiveThresholdIter=200; };
 		~USCTGen (){};
 		bool generate();
 		string spheresFile;
 		Real strainRate, limitStrain, damping;
 		int axis;
+		long cohesiveThresholdIter;
 	protected :
 		void registerAttributes(){
 			FileGenerator::registerAttributes();
@@ -24,18 +25,23 @@
 			REGISTER_ATTRIBUTE(strainRate);
 			REGISTER_ATTRIBUTE(limitStrain);
 			REGISTER_ATTRIBUTE(damping);
+			REGISTER_ATTRIBUTE(cohesiveThresholdIter);
 		}
 	REGISTER_CLASS_NAME(USCTGen);
 	REGISTER_BASE_CLASS_NAME(FileGenerator);
 	DECLARE_LOGGER;
 };
 REGISTER_SERIALIZABLE(USCTGen,false);
-
+/*! Axial displacing two groups of bodies in the opposite direction with given strain rate.
+ *
+ * Takes two groups of body IDs (in posIds and negIds) and displaces them at each timestep in the direction given by axis&#8712;{0,1,2} (for axes x,y,z respectively). These bodies automatically have Body::isDynamic==false.
+ */
 class UniaxialStrainer: public DeusExMachina {
 	private:
-		bool idInVector(body_id_t id, const vector&lt;body_id_t&gt;&amp; V);
+		bool idInVector(body_id_t id, const vector&lt;body_id_t&gt;&amp; V){for(size_t i=0; i&lt;V.size(); i++){ if(V[i]==id) return true; }	return false; }  // unused now
 		void computeAxialForce(MetaBody* rootBody);
 		ofstream recStream;
+		bool needsInit;
 		#define USCT_AXIS_COORD(id) (Body::byId(id)-&gt;physicalParameters-&gt;se3.position[axis])
 	public:
 		Real strainRate,currentStrainRate,originalLength,limitStrain;
@@ -43,11 +49,13 @@
 		Real crossSectionArea;
 		int axis;
 		bool notYetReversed;
+		bool clumped;
 		vector&lt;body_id_t&gt; posIds, negIds;
 		vector&lt;Real&gt; posCoords,negCoords;
 
 		virtual void applyCondition(Body* _rootBody);
-		UniaxialStrainer(){axis=2; currentStrainRate=0; originalLength=-1; limitStrain=-1; notYetReversed=true; crossSectionArea=-1; };
+		void init();
+		UniaxialStrainer(){axis=2; currentStrainRate=0; originalLength=-1; limitStrain=-1; notYetReversed=true; crossSectionArea=-1; needsInit=true; clumped=false; };
 		virtual ~UniaxialStrainer(){};
 		void registerAttributes(){
 			DeusExMachina::registerAttributes();
@@ -56,14 +64,12 @@
 			REGISTER_ATTRIBUTE(axis);
 			REGISTER_ATTRIBUTE(posIds);
 			REGISTER_ATTRIBUTE(negIds);
-			REGISTER_ATTRIBUTE(posCoords);
-			REGISTER_ATTRIBUTE(negCoords);
 			REGISTER_ATTRIBUTE(originalLength);
 			REGISTER_ATTRIBUTE(limitStrain);
 			REGISTER_ATTRIBUTE(notYetReversed);
 			REGISTER_ATTRIBUTE(crossSectionArea);
 		}
-		void postProcessAttributes(bool deserializing){if(deserializing) recStream.open(&quot;/tmp/usct.data&quot;); };
+		void postProcessAttributes(bool deserializing){ if(deserializing) needsInit=true;};
 	REGISTER_CLASS_NAME(UniaxialStrainer);
 	REGISTER_BASE_CLASS_NAME(DeusExMachina);
 	DECLARE_LOGGER;

Modified: trunk/gui/cmd/yadeControl.cpp
===================================================================
--- trunk/gui/cmd/yadeControl.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/gui/cmd/yadeControl.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -337,6 +337,8 @@
 		LOG_DEBUG(&quot;SAVE!&quot;);
 	}
 
+	void saveSpheres(std::string fileName){ Shop::saveSpheresToFile(fileName); }
+
 	python::list anyEngines_get(vector&lt;shared_ptr&lt;Engine&gt; &gt;&amp; engContainer){
 		python::list ret; 
 		BOOST_FOREACH(shared_ptr&lt;Engine&gt;&amp; eng, engContainer){
@@ -494,6 +496,7 @@
 		.add_property(&quot;usesTimeStepper&quot;,&amp;pyOmega::usesTimeStepper_get,&amp;pyOmega::usesTimeStepper_set)
 		.def(&quot;load&quot;,&amp;pyOmega::load)
 		.def(&quot;save&quot;,&amp;pyOmega::save)
+		.def(&quot;saveSpheres&quot;,&amp;pyOmega::saveSpheres)
 		.def(&quot;run&quot;,&amp;pyOmega::run,omega_overloads())
 		.def(&quot;pause&quot;,&amp;pyOmega::pause)
 		.def(&quot;step&quot;,&amp;pyOmega::step)

Modified: trunk/gui/qt3/GLSimulationPlayerViewer.cpp
===================================================================
--- trunk/gui/qt3/GLSimulationPlayerViewer.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/gui/qt3/GLSimulationPlayerViewer.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -108,7 +108,7 @@
 	filesystem::directory_iterator dEnd;
 	xyzFiles.clear();
 	for(filesystem::directory_iterator dIter(inputBaseDirectory); dIter!=dEnd; dIter++){
-		if(dIter-&gt;leaf().find(inputBaseName)!=0 || filesystem::is_directory(*dIter) || !filesystem::exists(*dIter)) continue;
+		if(dIter-&gt;leaf().find(inputBaseName)!=0 || filesystem::extension(*dIter)==&quot;.rgb&quot; || filesystem::is_directory(*dIter) || !filesystem::exists(*dIter)) continue;
 		xyzFiles.push_back(dIter-&gt;string());
 		//LOG_TRACE(&quot;Added &quot;&lt;&lt;dIter-&gt;string());
 	}
@@ -146,6 +146,8 @@
 	if(xyzFilesIter==xyzFiles.end()) return false;
 	fileName=*(xyzFilesIter++);
 	ifstream f(fileName.c_str());
+	ifstream rgb((fileName+&quot;.rgb&quot;).c_str());
+	bool doRgb=rgb.good();
 	if(!f.good()){LOG_FATAL(&quot;Snapshot file &quot;&lt;&lt;fileName&lt;&lt;&quot; could not be opened for reading (fatal, ending sequence)?!&quot;); return false;}
 	LOG_TRACE(fileName);
 	for(unsigned long id=0; !f.eof() &amp;&amp; !f.fail() &amp;&amp; id&lt;=(rootBody-&gt;bodies-&gt;size()-1); id++){
@@ -153,9 +155,13 @@
 		if(!b){ LOG_ERROR(&quot;Body #&quot;&lt;&lt;id&lt;&lt;&quot; doesn't exist (skipped)!&quot;); continue; }
 		if(!b-&gt;physicalParameters) {LOG_ERROR(&quot;Body #&quot;&lt;&lt;id&lt;&lt;&quot; has no physical parameters?! (skipping)&quot;); continue; }
 		Se3r&amp; mySe3=b-&gt;physicalParameters-&gt;se3;
+		Vector3r&amp; myColor=b-&gt;geometricalModel-&gt;diffuseColor;
 		f&gt;&gt;mySe3.position[0]&gt;&gt;mySe3.position[1]&gt;&gt;mySe3.position[2]&gt;&gt;mySe3.orientation[0]&gt;&gt;mySe3.orientation[1]&gt;&gt;mySe3.orientation[2]&gt;&gt;mySe3.orientation[3];
+		/* try loading color as well */
+		if(doRgb &amp;&amp; !rgb.eof() &amp;&amp; !rgb.fail()) rgb&gt;&gt;myColor[0]&gt;&gt;myColor[1]&gt;&gt;myColor[2];
 	}
 	f.close();
+	rgb.close();
 	return true;
 }
 

Modified: trunk/gui/qt3/QtSimulationPlayer.cpp
===================================================================
--- trunk/gui/qt3/QtSimulationPlayer.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/gui/qt3/QtSimulationPlayer.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -56,7 +56,7 @@
 
 void QtSimulationPlayer::pbOutputDirectoryClicked()
 {
-	string directory = FileDialog::getExistingDirectory ( &quot;.&quot;,&quot;Choose the directory where to save the sna shots&quot;, this-&gt;parentWidget()-&gt;parentWidget());
+	string directory = FileDialog::getExistingDirectory ( &quot;.&quot;,&quot;Choose the directory where to save the snapshots&quot;, this-&gt;parentWidget()-&gt;parentWidget());
 	if (!directory.empty())
 		leOutputDirectory-&gt;setText(directory.c_str());
 

Modified: trunk/gui/qt3/SimulationController.cpp
===================================================================
--- trunk/gui/qt3/SimulationController.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/gui/qt3/SimulationController.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -178,6 +178,11 @@
 			pbResetSimulation-&gt;setEnabled(true);
 			pbOneSimulationStep-&gt;setEnabled(true);
 
+			Real dt=Omega::instance().getTimeStep();
+			int exp10=floor(log10(dt));
+			sbSecond-&gt;setValue((int)(dt/(pow(10.,exp10)))); // we may lose quite some precision here :-(
+			sb10PowerSecond-&gt;setValue(exp10);
+
 			changeSkipTimeStepper = true;
 			if (Omega::instance().containTimeStepper())
 			{

Modified: trunk/gui/qt3/SimulationController.hpp
===================================================================
--- trunk/gui/qt3/SimulationController.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/gui/qt3/SimulationController.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -15,12 +15,13 @@
 #include&lt;yade/lib-opengl/GLWindowsManager.hpp&gt;
 #include&lt;yade/lib-serialization-qt/QtGUIGenerator.hpp&gt;
 #include&lt;yade/core/RenderingEngine.hpp&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qframe.h&gt;
-#include &lt;qscrollview.h&gt;
-#include &quot;GLViewer.hpp&quot;
-#include &quot;QtGeneratedSimulationController.h&quot;
-#include &quot;SimulationControllerUpdater.hpp&quot;
+#include&lt;qlayout.h&gt;
+#include&lt;qframe.h&gt;
+#include&lt;qscrollview.h&gt;
+#include&lt;qspinbox.h&gt;
+#include&quot;GLViewer.hpp&quot;
+#include&quot;QtGeneratedSimulationController.h&quot;
+#include&quot;SimulationControllerUpdater.hpp&quot;
 
 class SimulationController : public QtGeneratedSimulationController
 {

Modified: trunk/pkg/common/Engine/EngineUnit/InteractingSphere2AABB.cpp
===================================================================
--- trunk/pkg/common/Engine/EngineUnit/InteractingSphere2AABB.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/common/Engine/EngineUnit/InteractingSphere2AABB.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -14,10 +14,10 @@
 	InteractingSphere* sphere = static_cast&lt;InteractingSphere*&gt;(cm.get());
 	AABB* aabb = static_cast&lt;AABB*&gt;(bv.get());
 	aabb-&gt;center = se3.position;
-	aabb-&gt;halfSize = Vector3r(sphere-&gt;radius,sphere-&gt;radius,sphere-&gt;radius);
+	aabb-&gt;halfSize = aabbEnlargeFactor*Vector3r(sphere-&gt;radius,sphere-&gt;radius,sphere-&gt;radius);
 	
-	aabb-&gt;min = aabb-&gt;center-aabb-&gt;halfSize*aabbEnlargeFactor;
-	aabb-&gt;max = aabb-&gt;center+aabb-&gt;halfSize*aabbEnlargeFactor;	
+	aabb-&gt;min = aabb-&gt;center-aabb-&gt;halfSize;
+	aabb-&gt;max = aabb-&gt;center+aabb-&gt;halfSize;	
 }
 	
 YADE_PLUGIN();

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -50,8 +50,10 @@
 		 	&amp;&amp;
 			operator()( b1-&gt;interactingGeometry , b2-&gt;interactingGeometry , b1-&gt;physicalParameters-&gt;se3 , b2-&gt;physicalParameters-&gt;se3 , interaction );
 
+
 		if(wasReal==false &amp;&amp; interaction-&gt;isReal)
 			interaction-&gt;isNew=true;
+		//cerr&lt;&lt;&quot;isReal=&quot;&lt;&lt;interaction-&gt;isReal&lt;&lt;&quot;, wasReal=&quot;&lt;&lt;wasReal&lt;&lt;&quot;, isNew=&quot;&lt;&lt;interaction-&gt;isNew&lt;&lt;endl;
 
 		//tmp
 		if(!(b1-&gt;interactingGeometry&amp;&amp;b2-&gt;interactingGeometry)){

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialCompressionEngine.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -94,6 +94,7 @@
 		height0 = height; depth0 = depth; width0 = width;
 		saveSimulation=true; // saving snapshot .xml will actually be done in ::applyCondition
 		// stop simulation here, since nothing will happen from now on
+		Shop::saveSpheresToFile(&quot;/tmp/limbo.spheres&quot;);
 		Omega::instance().stopSimulationLoop();
 	}
 	else goto undefinedTransition;
@@ -115,7 +116,7 @@
 
 	if (Omega::instance().getCurrentIteration() % 100 == 0) {
 		LOG_INFO(&quot;UnbalancedForce=&quot;&lt;&lt; UnbalancedForce);
-		cerr &lt;&lt; &quot;UnbalancedForce=&quot; &lt;&lt; UnbalancedForce &lt;&lt; endl;
+		//cerr &lt;&lt; &quot;UnbalancedForce=&quot; &lt;&lt; UnbalancedForce &lt;&lt; endl;
 		/* TRVAR1(meanStress);*/ /* TRVAR2(stateName(currentState),sigma_iso); */
 	}
 

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -22,6 +22,7 @@
 #include &lt;yade/core/MetaBody.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
 
+CREATE_LOGGER(TriaxialStateRecorder);
 
 TriaxialStateRecorder::TriaxialStateRecorder () : DataRecorder()
 
@@ -81,7 +82,7 @@
         {
             if ((*itFirst)-&gt;getClassName() == &quot;TriaxialCompressionEngine&quot; ) //|| (*itFirst)-&gt;getBaseClassName() == &quot;TriaxialCompressionEngine&quot;)
             {
-                cerr &lt;&lt; &quot;stress controller engine found&quot; &lt;&lt; endl;
+                LOG_DEBUG(&quot;stress controller engine found&quot;);
                 triaxialCompressionEngine =  YADE_PTR_CAST&lt;TriaxialCompressionEngine&gt; (*itFirst);
                 //triaxialCompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (static_cast&lt;TriaxialCompressionEngine*&gt; ( (*itFirst).get()));
             }

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStateRecorder.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -49,6 +49,7 @@
 		virtual void registerAttributes();
 		virtual void action(Body* b);
 		virtual bool isActivated();
+		DECLARE_LOGGER;
 
 	protected :
 		virtual void postProcessAttributes(bool deserializing);

Modified: trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4DistantSpheresContactGeometry.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4DistantSpheresContactGeometry.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/EngineUnit/InteractingSphere2InteractingSphere4DistantSpheresContactGeometry.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -32,76 +32,25 @@
 							const Se3r&amp; se32,
 							const shared_ptr&lt;Interaction&gt;&amp; c)
 {
-	InteractingSphere* s1 = static_cast&lt;InteractingSphere*&gt;(cm1.get());
-	InteractingSphere* s2 = static_cast&lt;InteractingSphere*&gt;(cm2.get());
+	InteractingSphere *s1 = static_cast&lt;InteractingSphere*&gt;(cm1.get()), *s2=static_cast&lt;InteractingSphere*&gt;(cm2.get());
 
-	Vector3r normal = se32.position-se31.position;
-	Real penetrationDepth = pow(interactionDetectionFactor*(s1-&gt;radius+s2-&gt;radius), 2) - normal.SquaredLength();// Compute a wrong value just to check sign - faster than computing distances
-	//Real penetrationDepth = s1-&gt;radius+s2-&gt;radius-normal.Normalize();
+	Vector3r normal=se32.position-se31.position;
+	Real penetrationDepthSq = pow(interactionDetectionFactor*(s1-&gt;radius+s2-&gt;radius), 2) - normal.SquaredLength();
+	//cerr&lt;&lt;&quot;Depth is &quot;&lt;&lt;penetrationDepthSq&lt;&lt;endl;
 
-	shared_ptr&lt;SpheresContactGeometry&gt; scm;
-	if (c-&gt;interactionGeometry)
-	{
-		//scm = YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
-	//
-	// WARNING! 
-	//
-	// FIXME - this must be dynamic cast until the contaners are rewritten to support multiple interactions types
-	//         the problem is that scm can be either SDECLinkGeometry or SpheresContactGeometry and the only way CURRENTLY
-	//         to check this is by dynamic cast. This has to be fixed.
-	//
-		scm = YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry);
-		//scm = dynamic_cast&lt;SpheresContactGeometry*&gt;(c-&gt;interactionGeometry.get());
-	// BEGIN .......  FIXME FIXME	- wrong hack, to make cohesion work.
-// 		if(! scm) // this is not SpheresContactGeometry, so it is SDECLinkGeometry, dispatcher should do this job.
-// 		{
-// 			shared_ptr&lt;SDECLinkGeometry&gt; linkGeometry = dynamic_pointer_cast&lt;SDECLinkGeometry&gt;(c-&gt;interactionGeometry);
-// //			cerr &lt;&lt; &quot;it is SpringGeometry ???: &quot; &lt;&lt; c-&gt;interactionGeometry-&gt;getClassName() &lt;&lt; endl;
-// //			assert(linkGeometry);
-// 			if(linkGeometry)
-// 			{
-// 				linkGeometry-&gt;normal 			= se32.position-se31.position;
-// 				linkGeometry-&gt;normal.Normalize();
-// 				return true;
-// 			}
-// 			else
-// 				return false; // SpringGeometry !!!???????
-// 		}
-	// END
-	}
-	else
-		scm = shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry());
+	shared_ptr&lt;SpheresContactGeometry&gt; scm(c-&gt;interactionGeometry ? YADE_PTR_CAST&lt;SpheresContactGeometry&gt;(c-&gt;interactionGeometry) : shared_ptr&lt;SpheresContactGeometry&gt;(new SpheresContactGeometry()));
 		
-	if (penetrationDepth&gt;0 || c-&gt;isReal)
-	{
-		penetrationDepth = s1-&gt;radius+s2-&gt;radius-normal.Normalize();
-		scm-&gt;contactPoint = se31.position+(s1-&gt;radius-0.5*penetrationDepth)*normal;//0.5*(pt1+pt2);
-		scm-&gt;normal = normal;
-		scm-&gt;penetrationDepth = penetrationDepth;
-		scm-&gt;radius1 = s1-&gt;radius;
-		scm-&gt;radius2 = s2-&gt;radius;
-				
-		if (!c-&gt;interactionGeometry)
-			c-&gt;interactionGeometry = scm;
-	
+	if (penetrationDepthSq&gt;0 || c-&gt;isReal) {
+		//cerr&lt;&lt;__FILE__&lt;&lt;&quot;:&quot;&lt;&lt;__LINE__&lt;&lt;endl;
+		Real penetrationDepth = s1-&gt;radius+s2-&gt;radius-normal.Normalize(); /* normalize wirks in-place and returns length before normalization; from here, normal is unit vector */
+		scm-&gt;contactPoint = se31.position+(s1-&gt;radius-0.5*penetrationDepth)*normal;
+		scm-&gt;normal=normal;
+		scm-&gt;penetrationDepth=penetrationDepth;
+		scm-&gt;radius1=s1-&gt;radius;
+		scm-&gt;radius2=s2-&gt;radius;
+		if (!c-&gt;interactionGeometry){ c-&gt;interactionGeometry = scm; }
 		return true;
-	}
-	else {
-// 	if (c-&gt;isReal) {//Update geometry and let next engines decide if the interaction is real - otherwise it will be erased during next step
-// 		penetrationDepth = s1-&gt;radius+s2-&gt;radius-normal.Normalize();
-// 		scm-&gt;contactPoint = se31.position+(s1-&gt;radius-0.5*penetrationDepth)*normal;//0.5*(pt1+pt2);
-// 		scm-&gt;normal = normal;
-// 		scm-&gt;penetrationDepth = penetrationDepth;
-// 		scm-&gt;radius1 = s1-&gt;radius;
-// 		scm-&gt;radius2 = s2-&gt;radius;
-// 				
-// 		if (!c-&gt;interactionGeometry)
-// 			c-&gt;interactionGeometry = scm;
-// 	
-// 	}
-		return false;
-		}
-	
+	} else return false;
 }
 
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessCounter.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -25,7 +25,7 @@
 
 GlobalStiffnessCounter::GlobalStiffnessCounter() : InteractionSolver() , actionForce(new Force) , actionMomentum(new Momentum), actionStiffness(new GlobalStiffness)
 {
-	interval=1;//FIXME very high frequency - not required 
+	interval=100;
 	sdecGroupMask=1;
 	momentRotationLaw = true;
 	assumeElasticSpheres = true;
@@ -75,6 +75,7 @@
 		return true;
 	}
 
+
 // 	shared_ptr&lt;SDECLinkGeometry&gt; geom3=dynamic_pointer_cast&lt;SDECLinkGeometry&gt;(contact-&gt;interactionGeometry);
 // 	shared_ptr&lt;SDECLinkPhysics&gt; phys3=dynamic_pointer_cast&lt;SDECLinkPhysics&gt;(contact-&gt;interactionPhysics);
 // 	if(geom3 &amp;&amp; phys3){
@@ -96,7 +97,8 @@
 }
 
 void GlobalStiffnessCounter::traverseInteractions(MetaBody* ncb, const shared_ptr&lt;InteractionContainer&gt;&amp; interactions, bool spheresOnly){
-	for(InteractionContainer::iterator I=interactions-&gt;begin(); I!=interactions-&gt;end(); ++I){
+	InteractionContainer::iterator Iend=interactions-&gt;end();
+	for(InteractionContainer::iterator I=interactions-&gt;begin(); I!=Iend; ++I){
 		const shared_ptr&lt;Interaction&gt;&amp; contact = *I;
 		if(!contact-&gt;isReal) continue;
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/StandAloneEngine/GlobalStiffnessTimeStepper.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -177,13 +177,12 @@
 		//Omega::instance().setTimeStep(newDt);
 		computedOnce = true;	
 		//cerr &lt;&lt; &quot;computedOnce=&quot; &lt;&lt; computedOnce &lt;&lt; endl;	
-		cerr &lt;&lt; &quot;computed timestep is:&quot; &lt;&lt; newDt;
+		//cerr &lt;&lt; &quot;computed timestep is:&quot; &lt;&lt; newDt;
 	}
 	else if (!computedOnce) Omega::instance().setTimeStep(defaultDt);
-	cerr &lt;&lt; &quot; new timestep is:&quot; &lt;&lt; Omega::instance().getTimeStep() &lt;&lt; endl;
+	//cerr &lt;&lt; &quot; new timestep is:&quot; &lt;&lt; Omega::instance().getTimeStep() &lt;&lt; endl;
 
-	//if (Omega::instance().getCurrentIteration() % 100 == 0)
-		LOG_INFO(&quot;computed timestep &quot; &lt;&lt; newDt &lt;&lt;
+	LOG_INFO(&quot;computed timestep &quot; &lt;&lt; newDt &lt;&lt;
 			(Omega::instance().getTimeStep()==newDt ? string(&quot;, appplied&quot;) :
 			string(&quot;, BUT timestep is &quot;)+lexical_cast&lt;string&gt;(Omega::instance().getTimeStep()))&lt;&lt;&quot;.&quot;);
 }

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.cpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -15,10 +15,11 @@
 #include &lt;boost/lexical_cast.hpp&gt;
 
 
-PositionOrientationRecorder::PositionOrientationRecorder () : DataRecorder()//, ofile(&quot;&quot;)
+PositionOrientationRecorder::PositionOrientationRecorder () : DataRecorder()
 {
 	outputFile = &quot;positionorientation&quot;;
 	interval = 50;
+	saveRgb=false;
 }
 
 
@@ -30,10 +31,7 @@
 
 void PositionOrientationRecorder::postProcessAttributes(bool deserializing)
 {
-	if(deserializing)
-	{
-	//	ofile.open(outputFile.c_str());
-	}
+	if(deserializing) {}
 }
 
 
@@ -42,46 +40,32 @@
 	DataRecorder::registerAttributes();
 	REGISTER_ATTRIBUTE(outputFile);
 	REGISTER_ATTRIBUTE(interval);
+	REGISTER_ATTRIBUTE(saveRgb);
 }
 
 
 void PositionOrientationRecorder::action(Body * body)
 {
-	MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
-	
-	if( Omega::instance().getCurrentIteration() % interval == 0 /*&amp;&amp; ofile*/ )
-	{
+	MetaBody* ncb = YADE_CAST&lt;MetaBody*&gt;(body);
+	if( Omega::instance().getCurrentIteration() % interval == 0 ){
 		ostringstream oss;
 		oss&lt;&lt;setfill('0')&lt;&lt;outputFile&lt;&lt;&quot;_&quot;&lt;&lt;setw(6)&lt;&lt;Omega::instance().getCurrentIteration();
 		cerr&lt;&lt;&quot;Snapshot &quot;&lt;&lt;oss.str()&lt;&lt;endl;
+		std::ofstream ofile,rgbFile;
 		ofile.open(oss.str().c_str());
-		if(!ofile.good()){ cerr&lt;&lt;&quot;Snapshot &quot;&lt;&lt;oss.str()&lt;&lt;&quot; could not be opened for writing (skipping)!?&quot;&lt;&lt;endl; return; }
+		if(saveRgb) rgbFile.open((oss.str()+&quot;.rgb&quot;).c_str());
+		if(!ofile.good()){ cerr&lt;&lt;&quot;Snapshot &quot;&lt;&lt;oss.str()&lt;&lt;&quot; could not be opened for writing (skipping)!&quot;&lt;&lt;endl; return; }
+		if(saveRgb &amp;&amp; !rgbFile.good()){ cerr&lt;&lt;&quot;Snapshot &quot;&lt;&lt;oss.str()&lt;&lt;&quot; could not be opened for writing (skipping)!&quot;&lt;&lt;endl; return; }
 	
-		Real tx=0, ty=0, tz=0, rw=0, rx=0, ry=0, rz=0;
-			
-		BodyContainer::iterator bi    = ncb-&gt;bodies-&gt;begin();
 		BodyContainer::iterator biEnd = ncb-&gt;bodies-&gt;end();
-		for(  ; bi!=biEnd ; ++bi )
-		{
-			shared_ptr&lt;Body&gt; b = *bi;
-			tx = b-&gt;physicalParameters-&gt;se3.position[0];
-			ty = b-&gt;physicalParameters-&gt;se3.position[1];
-			tz = b-&gt;physicalParameters-&gt;se3.position[2];
-		
-			rw = b-&gt;physicalParameters-&gt;se3.orientation[0];
-			rx = b-&gt;physicalParameters-&gt;se3.orientation[1];
-			ry = b-&gt;physicalParameters-&gt;se3.orientation[2];
-			rz = b-&gt;physicalParameters-&gt;se3.orientation[3];
-			
-			ofile &lt;&lt;	lexical_cast&lt;string&gt;(tx) &lt;&lt; &quot; &quot; 
-					&lt;&lt; lexical_cast&lt;string&gt;(ty) &lt;&lt; &quot; &quot; 
-					&lt;&lt; lexical_cast&lt;string&gt;(tz) &lt;&lt; &quot; &quot;
-					&lt;&lt; lexical_cast&lt;string&gt;(rw) &lt;&lt; &quot; &quot;
-					&lt;&lt; lexical_cast&lt;string&gt;(rx) &lt;&lt; &quot; &quot;
-					&lt;&lt; lexical_cast&lt;string&gt;(ry) &lt;&lt; &quot; &quot;
-					&lt;&lt; lexical_cast&lt;string&gt;(rz) &lt;&lt; endl;
+		for(BodyContainer::iterator bi    = ncb-&gt;bodies-&gt;begin(); bi!=biEnd; ++bi){
+			const Se3r&amp; se3=(*bi)-&gt;physicalParameters-&gt;se3;
+			const Vector3r&amp; color=(*bi)-&gt;geometricalModel-&gt;diffuseColor;
+			ofile&lt;&lt;se3.position[0]&lt;&lt;&quot; &quot;&lt;&lt;se3.position[1]&lt;&lt;&quot; &quot;&lt;&lt;se3.position[2]&lt;&lt;&quot; &quot;&lt;&lt;se3.orientation[0]&lt;&lt;&quot; &quot;&lt;&lt;se3.orientation[1]&lt;&lt;&quot; &quot;&lt;&lt;se3.orientation[2]&lt;&lt;&quot; &quot;&lt;&lt;se3.orientation[3]&lt;&lt;endl;
+			if(saveRgb) rgbFile&lt;&lt;color[0]&lt;&lt;&quot; &quot;&lt;&lt;color[1]&lt;&lt;&quot; &quot;&lt;&lt;color[2]&lt;&lt;endl;
 		}
 		ofile.close();
+		if(saveRgb) rgbFile.close();
 	}
 }
 

Modified: trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp	2008-03-28 21:31:04 UTC (rev 1289)
+++ trunk/pkg/dem/Engine/StandAloneEngine/PositionOrientationRecorder.hpp	2008-03-30 20:22:20 UTC (rev 1290)
@@ -25,9 +25,8 @@
 		std::string outputFile;
 		//! modulo of iteration number when the se3's will be be written out
 		unsigned int interval;
+		bool saveRgb;
 	
-		std::ofstream ofile;
-
 		PositionOrientationRecorder ();
 		~PositionOrientationRecorder ();
 		virtual void action(Body* b);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000253.html">[Yade-commits] r1289 - trunk/pkg/dem/PreProcessor
</A></li>
	<LI>Next message: <A HREF="000255.html">[Yade-commits] r1291 - in trunk: . doc examples lib/miniWm3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#254">[ date ]</a>
              <a href="thread.html#254">[ thread ]</a>
              <a href="subject.html#254">[ subject ]</a>
              <a href="author.html#254">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
