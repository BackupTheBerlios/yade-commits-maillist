<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1434 - in trunk: extra/clump lib/QGLViewer	lib/QGLViewer/VRender
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1434%20-%20in%20trunk%3A%20extra/clump%20lib/QGLViewer%0A%09lib/QGLViewer/VRender&In-Reply-To=%3C200807180655.m6I6t5dA002067%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000393.html">
   <LINK REL="Next"  HREF="000395.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1434 - in trunk: extra/clump lib/QGLViewer	lib/QGLViewer/VRender</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1434%20-%20in%20trunk%3A%20extra/clump%20lib/QGLViewer%0A%09lib/QGLViewer/VRender&In-Reply-To=%3C200807180655.m6I6t5dA002067%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1434 - in trunk: extra/clump lib/QGLViewer	lib/QGLViewer/VRender">eudoxos at mail.berlios.de
       </A><BR>
    <I>Fri Jul 18 08:55:05 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000393.html">[Yade-commits] r1433 - in trunk: extra gui/py gui/qt3	pkg/common/Engine/StandAloneEngine
</A></li>
        <LI>Next message: <A HREF="000395.html">[Yade-commits] r1435 - in trunk: core gui/py gui/qt3	pkg/common/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#394">[ date ]</a>
              <a href="thread.html#394">[ thread ]</a>
              <a href="subject.html#394">[ subject ]</a>
              <a href="author.html#394">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2008-07-18 08:54:48 +0200 (Fri, 18 Jul 2008)
New Revision: 1434

Added:
   trunk/lib/QGLViewer/qglviewer_fr.ts
Removed:
   trunk/lib/QGLViewer/ImageInterface.Qt3.cpp
   trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp
Modified:
   trunk/extra/clump/Shop.cpp
   trunk/lib/QGLViewer/ImageInterface.Qt4.ui
   trunk/lib/QGLViewer/README
   trunk/lib/QGLViewer/VRender/AxisAlignedBox.h
   trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp
   trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp
   trunk/lib/QGLViewer/VRender/EPSExporter.cpp
   trunk/lib/QGLViewer/VRender/Exporter.cpp
   trunk/lib/QGLViewer/VRender/Exporter.h
   trunk/lib/QGLViewer/VRender/FIGExporter.cpp
   trunk/lib/QGLViewer/VRender/NVector3.cpp
   trunk/lib/QGLViewer/VRender/NVector3.h
   trunk/lib/QGLViewer/VRender/Optimizer.h
   trunk/lib/QGLViewer/VRender/ParserGL.cpp
   trunk/lib/QGLViewer/VRender/ParserGL.h
   trunk/lib/QGLViewer/VRender/Primitive.cpp
   trunk/lib/QGLViewer/VRender/Primitive.h
   trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp
   trunk/lib/QGLViewer/VRender/PrimitivePositioning.h
   trunk/lib/QGLViewer/VRender/SortMethod.h
   trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp
   trunk/lib/QGLViewer/VRender/Types.h
   trunk/lib/QGLViewer/VRender/VRender.cpp
   trunk/lib/QGLViewer/VRender/VRender.h
   trunk/lib/QGLViewer/VRender/Vector2.cpp
   trunk/lib/QGLViewer/VRender/Vector2.h
   trunk/lib/QGLViewer/VRender/Vector3.cpp
   trunk/lib/QGLViewer/VRender/Vector3.h
   trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp
   trunk/lib/QGLViewer/VRender/gpc.cpp
   trunk/lib/QGLViewer/VRender/gpc.h
   trunk/lib/QGLViewer/VRenderInterface.Qt3.ui
   trunk/lib/QGLViewer/VRenderInterface.Qt4.ui
   trunk/lib/QGLViewer/camera.cpp
   trunk/lib/QGLViewer/camera.h
   trunk/lib/QGLViewer/config.h
   trunk/lib/QGLViewer/constraint.cpp
   trunk/lib/QGLViewer/constraint.h
   trunk/lib/QGLViewer/domUtils.h
   trunk/lib/QGLViewer/frame.cpp
   trunk/lib/QGLViewer/frame.h
   trunk/lib/QGLViewer/keyFrameInterpolator.cpp
   trunk/lib/QGLViewer/keyFrameInterpolator.h
   trunk/lib/QGLViewer/manipulatedCameraFrame.cpp
   trunk/lib/QGLViewer/manipulatedCameraFrame.h
   trunk/lib/QGLViewer/manipulatedFrame.cpp
   trunk/lib/QGLViewer/manipulatedFrame.h
   trunk/lib/QGLViewer/mouseGrabber.cpp
   trunk/lib/QGLViewer/mouseGrabber.h
   trunk/lib/QGLViewer/qglviewer.cpp
   trunk/lib/QGLViewer/qglviewer.cw
   trunk/lib/QGLViewer/qglviewer.h
   trunk/lib/QGLViewer/quaternion.cpp
   trunk/lib/QGLViewer/quaternion.h
   trunk/lib/QGLViewer/saveSnapshot.cpp
   trunk/lib/QGLViewer/vec.cpp
   trunk/lib/QGLViewer/vec.h
Log:
Sync with upstream QGLViewer 2.3.0


Modified: trunk/extra/clump/Shop.cpp
===================================================================
--- trunk/extra/clump/Shop.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/extra/clump/Shop.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -446,7 +446,7 @@
 		for(int j=0; j&lt;3; j++) { minXYZ[j]=(spheres.size()&gt;0?min(C[j]-r,minXYZ[j]):C[j]-r); maxXYZ[j]=(spheres.size()&gt;0?max(C[j]+r,maxXYZ[j]):C[j]+r);}
 		spheres.push_back(pair&lt;Vector3r,Real&gt;(C,r));
 	}
-	TRVAR2(minXYZ,maxXYZ);
+	//TRVAR2(minXYZ,maxXYZ);
 	return spheres;
 }
 

Deleted: trunk/lib/QGLViewer/ImageInterface.Qt3.cpp
===================================================================
--- trunk/lib/QGLViewer/ImageInterface.Qt3.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/ImageInterface.Qt3.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,223 +0,0 @@
-/****************************************************************************
-** Form implementation generated from reading ui file 'ImageInterface.Qt3.ui'
-**
-** Created: &#268;t b&#345;e 13 19:58:45 2008
-**
-** WARNING! All changes made in this file will be lost!
-****************************************************************************/
-
-#include &quot;ImageInterface.Qt3.h&quot;
-
-#include &lt;qvariant.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qlabel.h&gt;
-#include &lt;qspinbox.h&gt;
-#include &lt;qcheckbox.h&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qtooltip.h&gt;
-#include &lt;qwhatsthis.h&gt;
-#include &lt;qimage.h&gt;
-#include &lt;qpixmap.h&gt;
-
-static const unsigned char image0_data[] = { 
-    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
-    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x10,
-    0x08, 0x06, 0x00, 0x00, 0x00, 0xc9, 0x56, 0x25, 0x04, 0x00, 0x00, 0x03,
-    0x4b, 0x49, 0x44, 0x41, 0x54, 0x28, 0x91, 0x75, 0x93, 0x6b, 0x6c, 0x93,
-    0x65, 0x14, 0xc7, 0xcf, 0x79, 0xde, 0xb7, 0x7d, 0x7b, 0xa1, 0xdd, 0xda,
-    0x8e, 0x6e, 0xa1, 0x73, 0xb2, 0xb5, 0x74, 0xab, 0xb3, 0x8e, 0x0e, 0xe5,
-    0x92, 0x39, 0x36, 0x2b, 0x53, 0x42, 0x82, 0x9a, 0xe8, 0xb8, 0x24, 0x26,
-    0x26, 0xc6, 0x68, 0x62, 0x96, 0x20, 0x1a, 0x09, 0x09, 0x24, 0xc6, 0x2f,
-    0xc6, 0x20, 0x8c, 0x20, 0x97, 0x2f, 0x2c, 0x46, 0x82, 0xf3, 0x83, 0xc4,
-    0x49, 0x60, 0x8a, 0x80, 0x53, 0x33, 0xa6, 0x33, 0x20, 0x6c, 0x73, 0x63,
-    0xdd, 0x6a, 0xda, 0xcd, 0xca, 0x6a, 0xa1, 0x17, 0xd6, 0xee, 0x5d, 0xdf,
-    0xbe, 0xb7, 0xe7, 0xf1, 0x0b, 0x8b, 0x8a, 0x7a, 0x92, 0xff, 0xb7, 0xdf,
-    0xc9, 0x3f, 0x39, 0xf9, 0x1d, 0x64, 0x8c, 0xc1, 0xff, 0x4d, 0x3e, 0x9b,
-    0xf5, 0x5c, 0x3e, 0xde, 0xf3, 0x5e, 0x5d, 0x20, 0x70, 0x33, 0xf4, 0xc2,
-    0xd6, 0x83, 0x88, 0x48, 0x19, 0xa5, 0x9c, 0x78, 0xb9, 0xef, 0x65, 0xce,
-    0xb5, 0x3c, 0x0b, 0x8c, 0xb1, 0x7f, 0x44, 0x51, 0x54, 0xe1, 0xb7, 0x58,
-    0x72, 0xbd, 0x54, 0x94, 0xca, 0xce, 0x1c, 0x39, 0xd6, 0xbd, 0xd7, 0xbf,
-    0x56, 0xfe, 0xf4, 0xc5, 0xae, 0x11, 0x65, 0xb1, 0xe8, 0x64, 0x8c, 0x81,
-    0x38, 0x78, 0x61, 0xfb, 0x6c, 0xfb, 0x8a, 0x4c, 0xee, 0xfd, 0xdd, 0x9f,
-    0x10, 0x00, 0x00, 0xc6, 0x18, 0x47, 0x29, 0x33, 0x00, 0x00, 0x44, 0x46,
-    0xe3, 0x4f, 0x9e, 0x3d, 0xf5, 0xc3, 0x9e, 0x3b, 0xc9, 0xd4, 0xa3, 0x4d,
-    0x6d, 0x1b, 0xbf, 0xd9, 0xf0, 0x54, 0xc7, 0x15, 0x52, 0x28, 0x2d, 0xd7,
-    0x65, 0xd5, 0x06, 0x00, 0x40, 0xe7, 0x66, 0x7c, 0x86, 0x74, 0xd2, 0x45,
-    0x66, 0xa7, 0x1a, 0x08, 0x00, 0x83, 0x89, 0x9b, 0xb7, 0x3a, 0xf2, 0x79,
-    0xd1, 0x03, 0x00, 0x5c, 0x74, 0xec, 0xce, 0x0e, 0xb3, 0xd9, 0xa1, 0x5a,
-    0x6d, 0x96, 0xa2, 0xaf, 0x29, 0x78, 0xd1, 0xe5, 0xae, 0x4a, 0x5b, 0xcc,
-    0x56, 0x89, 0x18, 0xf8, 0x12, 0x00, 0x80, 0x50, 0xe9, 0x49, 0x99, 0x8d,
-    0x02, 0x70, 0x72, 0xd1, 0x44, 0xc6, 0xa3, 0x5a, 0xf8, 0xeb, 0x6f, 0xa7,
-    0x3b, 0x79, 0x1e, 0xf3, 0xaa, 0xa2, 0x3d, 0x30, 0x17, 0xd7, 0x42, 0xde,
-    0x80, 0xe7, 0x57, 0xbb, 0xa3, 0x6c, 0x86, 0x69, 0xba, 0x41, 0xc9, 0x14,
-    0xaa, 0x6d, 0x55, 0x95, 0x49, 0xde, 0x24, 0x14, 0x00, 0x00, 0x88, 0xae,
-    0x13, 0x03, 0x22, 0xf0, 0x82, 0x45, 0x21, 0xa9, 0x1c, 0xae, 0x0c, 0xb7,
-    0xfa, 0x86, 0xac, 0x56, 0x73, 0x3e, 0x11, 0x2b, 0x34, 0xe7, 0xd2, 0xcc,
-    0xba, 0x2a, 0x58, 0x31, 0xc6, 0xf3, 0xc6, 0x8c, 0x3c, 0x5f, 0x58, 0xb1,
-    0x98, 0x48, 0x7b, 0x5d, 0xfe, 0xba, 0x71, 0xe4, 0x39, 0x09, 0x00, 0x00,
-    0xb2, 0xa9, 0x4a, 0x9e, 0x52, 0xe0, 0xdc, 0x9e, 0x39, 0xbe, 0x63, 0x1d,
-    0x77, 0xaa, 0x58, 0x74, 0x3f, 0x44, 0x29, 0x9a, 0x2f, 0xf5, 0xfd, 0xbe,
-    0xbd, 0x66, 0x95, 0xf3, 0xba, 0xcb, 0x6d, 0x8a, 0x23, 0xa2, 0x76, 0x77,
-    0x72, 0xb6, 0x45, 0x99, 0x2f, 0x3a, 0x2b, 0x56, 0x07, 0x06, 0xf1, 0xde,
-    0x6d, 0x60, 0x66, 0xaa, 0x91, 0x20, 0x01, 0xe2, 0x6d, 0x9c, 0xe0, 0x19,
-    0x00, 0x1d, 0x1e, 0x8e, 0xb4, 0x45, 0xc7, 0xd4, 0xae, 0xd1, 0x6b, 0x0b,
-    0xad, 0xbb, 0xdf, 0x6d, 0xda, 0x05, 0x08, 0x22, 0xd5, 0x75, 0x63, 0x62,
-    0xe0, 0x6a, 0xa7, 0xb9, 0xaa, 0x22, 0xe9, 0x08, 0xac, 0x1c, 0x06, 0x00,
-    0x00, 0x31, 0xef, 0x86, 0xc8, 0xc8, 0x6a, 0xb4, 0x97, 0x97, 0xb0, 0xb1,
-    0xf9, 0x27, 0x82, 0x88, 0x6c, 0x3a, 0x92, 0xaa, 0xed, 0x39, 0xf1, 0xe3,
-    0xab, 0xa1, 0xc7, 0xcb, 0x07, 0xaa, 0x6b, 0xcd, 0x23, 0x94, 0x31, 0x39,
-    0x3b, 0x39, 0xd3, 0x96, 0x18, 0xfa, 0x25, 0x5c, 0xdd, 0xbe, 0xe6, 0xbc,
-    0x50, 0x6e, 0x9b, 0x03, 0x00, 0x60, 0xd3, 0x63, 0xeb, 0x58, 0x2c, 0x52,
-    0x07, 0xb5, 0x0d, 0x71, 0xf4, 0x3d, 0x7c, 0x9d, 0x07, 0x00, 0x68, 0xdd,
-    0x18, 0xec, 0x07, 0x6d, 0x99, 0xbd, 0xf1, 0x11, 0x3a, 0x29, 0xcb, 0x25,
-    0x8b, 0xba, 0x20, 0x55, 0x8c, 0x9e, 0x3c, 0xb7, 0x1f, 0x4d, 0x82, 0x54,
-    0xb3, 0x79, 0xc3, 0x69, 0x44, 0xa4, 0x4c, 0xd7, 0x8c, 0xfa, 0xa5, 0xbe,
-    0x9d, 0x74, 0x51, 0x34, 0x72, 0xeb, 0x37, 0x0d, 0x80, 0xdd, 0x91, 0xc4,
-    0x25, 0xc3, 0x18, 0xa3, 0x7c, 0xef, 0xd1, 0x8f, 0x0f, 0x98, 0x90, 0xb3,
-    0x48, 0xe3, 0x89, 0xb5, 0xe2, 0x8d, 0x58, 0x53, 0x4b, 0x57, 0xe7, 0x07,
-    0xc1, 0x97, 0xb6, 0xec, 0x43, 0x44, 0x5d, 0x9f, 0xf8, 0xf9, 0x69, 0xf9,
-    0x8d, 0x6d, 0x9f, 0x21, 0x41, 0x26, 0x1c, 0x3b, 0xbb, 0x95, 0xf8, 0x83,
-    0x57, 0xc8, 0x92, 0x8a, 0x88, 0x44, 0xb3, 0xd9, 0x6c, 0xb9, 0xfe, 0xee,
-    0xde, 0xd7, 0x62, 0x43, 0xe3, 0xa1, 0x9a, 0xf0, 0x9a, 0x8b, 0xf5, 0xcf,
-    0xb7, 0x1f, 0x46, 0x44, 0x9d, 0x2e, 0xe4, 0xdd, 0xc5, 0x8f, 0xba, 0xf7,
-    0xaa, 0xe9, 0xdb, 0x76, 0x12, 0x7e, 0xee, 0x2b, 0xac, 0x0b, 0x5c, 0xbd,
-    0xd7, 0xf8, 0x97, 0x9a, 0xd9, 0xdb, 0x19, 0x6f, 0xcf, 0x5b, 0x07, 0xce,
-    0x1f, 0xdd, 0xb1, 0x6b, 0x22, 0x9f, 0xca, 0xd4, 0x33, 0xc6, 0x40, 0x17,
-    0x17, 0x9c, 0xd9, 0x43, 0xfb, 0x4f, 0xfe, 0x11, 0x72, 0xe8, 0x77, 0x9f,
-    0x0d, 0xdd, 0xd2, 0xe2, 0x53, 0x8f, 0x2d, 0xf1, 0x78, 0xff, 0x63, 0xc8,
-    0x92, 0xe4, 0xec, 0xdd, 0xf3, 0x66, 0xaf, 0xf7, 0xc1, 0xea, 0xa8, 0xaf,
-    0xbe, 0x21, 0x5a, 0xfa, 0xae, 0xff, 0x19, 0xfd, 0xfb, 0xfe, 0x4d, 0x16,
-    0x93, 0xa0, 0xb8, 0xf6, 0x1d, 0x7a, 0xdb, 0xb4, 0x65, 0xdb, 0x71, 0x44,
-    0x64, 0xff, 0x6a, 0x5e, 0xca, 0xe8, 0xb9, 0x2f, 0x5e, 0x39, 0xd2, 0xe0,
-    0x91, 0x3f, 0xf7, 0xbb, 0xd8, 0xa0, 0xbf, 0x8c, 0x4d, 0xb6, 0xd4, 0x8a,
-    0xf3, 0xa7, 0x4f, 0xbc, 0x43, 0x55, 0x45, 0xf8, 0x3b, 0xf7, 0x9f, 0xcb,
-    0x6a, 0x49, 0x5a, 0x76, 0xed, 0xc3, 0x83, 0x87, 0xbf, 0x7c, 0xa2, 0x39,
-    0x7d, 0x63, 0xe7, 0xe6, 0x48, 0xee, 0x42, 0xdf, 0xeb, 0x54, 0x55, 0x85,
-    0xfb, 0xb9, 0x3f, 0x01, 0xb2, 0x2d, 0xcb, 0x16, 0xd1, 0x81, 0x19, 0x0d,
-    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
-};
-
-
-/*
- *  Constructs a ImageInterface as a child of 'parent', with the
- *  name 'name' and widget flags set to 'f'.
- *
- *  The dialog will by default be modeless, unless you set 'modal' to
- *  TRUE to construct a modal dialog.
- */
-ImageInterface::ImageInterface( QWidget* parent, const char* name, bool modal, WFlags fl )
-    : QDialog( parent, name, modal, fl )
-{
-    QImage img;
-    img.loadFromData( image0_data, sizeof( image0_data ), &quot;PNG&quot; );
-    image0 = img;
-    if ( !name )
-	setName( &quot;ImageInterface&quot; );
-    setIcon( image0 );
-    ImageInterfaceLayout = new QVBoxLayout( this, 11, 6, &quot;ImageInterfaceLayout&quot;); 
-
-    layout5 = new QHBoxLayout( 0, 0, 6, &quot;layout5&quot;); 
-
-    textLabel1 = new QLabel( this, &quot;textLabel1&quot; );
-    layout5-&gt;addWidget( textLabel1 );
-
-    imgWidth = new QSpinBox( this, &quot;imgWidth&quot; );
-    imgWidth-&gt;setMaxValue( 32000 );
-    imgWidth-&gt;setMinValue( 1 );
-    layout5-&gt;addWidget( imgWidth );
-
-    textLabel2 = new QLabel( this, &quot;textLabel2&quot; );
-    layout5-&gt;addWidget( textLabel2 );
-
-    imgHeight = new QSpinBox( this, &quot;imgHeight&quot; );
-    imgHeight-&gt;setMaxValue( 32000 );
-    imgHeight-&gt;setMinValue( 1 );
-    layout5-&gt;addWidget( imgHeight );
-    ImageInterfaceLayout-&gt;addLayout( layout5 );
-
-    layout2 = new QHBoxLayout( 0, 0, 6, &quot;layout2&quot;); 
-
-    textLabel3 = new QLabel( this, &quot;textLabel3&quot; );
-    layout2-&gt;addWidget( textLabel3 );
-
-    imgQuality = new QSpinBox( this, &quot;imgQuality&quot; );
-    imgQuality-&gt;setMaxValue( 100 );
-    layout2-&gt;addWidget( imgQuality );
-    spacer1 = new QSpacerItem( 271, 31, QSizePolicy::Expanding, QSizePolicy::Minimum );
-    layout2-&gt;addItem( spacer1 );
-    ImageInterfaceLayout-&gt;addLayout( layout2 );
-
-    layout2_2 = new QHBoxLayout( 0, 0, 6, &quot;layout2_2&quot;); 
-
-    textLabel3_2 = new QLabel( this, &quot;textLabel3_2&quot; );
-    layout2_2-&gt;addWidget( textLabel3_2 );
-
-    oversampling = new QSpinBox( this, &quot;oversampling&quot; );
-    oversampling-&gt;setMaxValue( 64 );
-    oversampling-&gt;setMinValue( 1 );
-    layout2_2-&gt;addWidget( oversampling );
-    spacer1_2 = new QSpacerItem( 271, 31, QSizePolicy::Expanding, QSizePolicy::Minimum );
-    layout2_2-&gt;addItem( spacer1_2 );
-    ImageInterfaceLayout-&gt;addLayout( layout2_2 );
-
-    whiteBackground = new QCheckBox( this, &quot;whiteBackground&quot; );
-    ImageInterfaceLayout-&gt;addWidget( whiteBackground );
-
-    expandFrustum = new QCheckBox( this, &quot;expandFrustum&quot; );
-    ImageInterfaceLayout-&gt;addWidget( expandFrustum );
-
-    layout4 = new QHBoxLayout( 0, 0, 6, &quot;layout4&quot;); 
-    spacer3 = new QSpacerItem( 251, 21, QSizePolicy::Expanding, QSizePolicy::Minimum );
-    layout4-&gt;addItem( spacer3 );
-
-    pushButton1 = new QPushButton( this, &quot;pushButton1&quot; );
-    layout4-&gt;addWidget( pushButton1 );
-
-    pushButton2 = new QPushButton( this, &quot;pushButton2&quot; );
-    layout4-&gt;addWidget( pushButton2 );
-    ImageInterfaceLayout-&gt;addLayout( layout4 );
-    languageChange();
-    resize( QSize(288, 213).expandedTo(minimumSizeHint()) );
-    clearWState( WState_Polished );
-
-    // signals and slots connections
-    connect( pushButton1, SIGNAL( clicked() ), this, SLOT( accept() ) );
-    connect( pushButton2, SIGNAL( clicked() ), this, SLOT( reject() ) );
-}
-
-/*
- *  Destroys the object and frees any allocated resources
- */
-ImageInterface::~ImageInterface()
-{
-    // no need to delete child widgets, Qt does it all for us
-}
-
-/*
- *  Sets the strings of the subwidgets using the current
- *  language.
- */
-void ImageInterface::languageChange()
-{
-    setCaption( tr( &quot;Image settings&quot; ) );
-    textLabel1-&gt;setText( tr( &quot;Width&quot; ) );
-    imgWidth-&gt;setSuffix( tr( &quot; px&quot; ) );
-    QToolTip::add( imgWidth, tr( &quot;Width of the image (in pixels)&quot; ) );
-    textLabel2-&gt;setText( tr( &quot;Height&quot; ) );
-    imgHeight-&gt;setPrefix( QString::null );
-    imgHeight-&gt;setSuffix( tr( &quot; px&quot; ) );
-    QToolTip::add( imgHeight, tr( &quot;Height of the image (in pixels)&quot; ) );
-    textLabel3-&gt;setText( tr( &quot;Image quality&quot; ) );
-    QToolTip::add( imgQuality, tr( &quot;Between 0 (smallest files) and 100 (highest quality)&quot; ) );
-    textLabel3_2-&gt;setText( tr( &quot;Oversampling&quot; ) );
-    QToolTip::add( textLabel3_2, QString::null );
-    oversampling-&gt;setPrefix( tr( &quot;x &quot; ) );
-    QToolTip::add( oversampling, tr( &quot;Antialiases image (when larger then 1.0)&quot; ) );
-    whiteBackground-&gt;setText( tr( &quot;Use white background&quot; ) );
-    QToolTip::add( whiteBackground, tr( &quot;Use white as background color&quot; ) );
-    expandFrustum-&gt;setText( tr( &quot;Expand frustum if needed&quot; ) );
-    QToolTip::add( expandFrustum, tr( &quot;When image aspect ratio differs from viewer's one, expand frustum as needed. Fits inside current frustum otherwise.&quot; ) );
-    pushButton1-&gt;setText( tr( &quot;OK&quot; ) );
-    pushButton2-&gt;setText( tr( &quot;Cancel&quot; ) );
-}
-

Modified: trunk/lib/QGLViewer/ImageInterface.Qt4.ui
===================================================================
--- trunk/lib/QGLViewer/ImageInterface.Qt4.ui	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/ImageInterface.Qt4.ui	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,15 +1,12 @@
 &lt;ui version=&quot;4.0&quot; &gt;
- &lt;author&gt;&lt;/author&gt;
- &lt;comment&gt;&lt;/comment&gt;
- &lt;exportmacro&gt;&lt;/exportmacro&gt;
  &lt;class&gt;ImageInterface&lt;/class&gt;
  &lt;widget class=&quot;QDialog&quot; name=&quot;ImageInterface&quot; &gt;
   &lt;property name=&quot;geometry&quot; &gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
-    &lt;width&gt;238&lt;/width&gt;
-    &lt;height&gt;195&lt;/height&gt;
+    &lt;width&gt;235&lt;/width&gt;
+    &lt;height&gt;191&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
   &lt;property name=&quot;windowTitle&quot; &gt;
@@ -19,24 +16,42 @@
    &lt;iconset&gt;../../../../../../Documents and Settings/debunne/Bureau/libQGLViewer-2.2.0-1/doc/images/qglviewer.icon.png&lt;/iconset&gt;
   &lt;/property&gt;
   &lt;layout class=&quot;QVBoxLayout&quot; &gt;
-   &lt;property name=&quot;margin&quot; &gt;
-    &lt;number&gt;9&lt;/number&gt;
-   &lt;/property&gt;
    &lt;property name=&quot;spacing&quot; &gt;
     &lt;number&gt;6&lt;/number&gt;
    &lt;/property&gt;
+   &lt;property name=&quot;leftMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;topMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;rightMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;bottomMargin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;0&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot; &gt;
        &lt;property name=&quot;text&quot; &gt;
-        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt;&quot;&gt;Width&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+        &lt;string&gt;Width&lt;/string&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -48,12 +63,12 @@
        &lt;property name=&quot;suffix&quot; &gt;
         &lt;string&gt; px&lt;/string&gt;
        &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;1&lt;/number&gt;
+       &lt;/property&gt;
        &lt;property name=&quot;maximum&quot; &gt;
         &lt;number&gt;32000&lt;/number&gt;
        &lt;/property&gt;
-       &lt;property name=&quot;minimum&quot; &gt;
-        &lt;number&gt;1&lt;/number&gt;
-       &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
      &lt;item&gt;
@@ -72,7 +87,7 @@
      &lt;item&gt;
       &lt;widget class=&quot;QLabel&quot; name=&quot;label_3&quot; &gt;
        &lt;property name=&quot;text&quot; &gt;
-        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Height&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+        &lt;string&gt;Height&lt;/string&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -84,28 +99,37 @@
        &lt;property name=&quot;suffix&quot; &gt;
         &lt;string&gt; px&lt;/string&gt;
        &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;1&lt;/number&gt;
+       &lt;/property&gt;
        &lt;property name=&quot;maximum&quot; &gt;
         &lt;number&gt;32000&lt;/number&gt;
        &lt;/property&gt;
-       &lt;property name=&quot;minimum&quot; &gt;
-        &lt;number&gt;1&lt;/number&gt;
-       &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
     &lt;/layout&gt;
    &lt;/item&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;0&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;widget class=&quot;QLabel&quot; name=&quot;label_4&quot; &gt;
        &lt;property name=&quot;text&quot; &gt;
-        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Image quality&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+        &lt;string&gt;Image quality&lt;/string&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -114,12 +138,12 @@
        &lt;property name=&quot;toolTip&quot; &gt;
         &lt;string&gt;Between 0 (smallest files) and 100 (highest quality)&lt;/string&gt;
        &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;0&lt;/number&gt;
+       &lt;/property&gt;
        &lt;property name=&quot;maximum&quot; &gt;
         &lt;number&gt;100&lt;/number&gt;
        &lt;/property&gt;
-       &lt;property name=&quot;minimum&quot; &gt;
-        &lt;number&gt;0&lt;/number&gt;
-       &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
      &lt;item&gt;
@@ -139,16 +163,25 @@
    &lt;/item&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;0&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot; &gt;
        &lt;property name=&quot;text&quot; &gt;
-        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Oversampling&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+        &lt;string&gt;Oversampling&lt;/string&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -163,17 +196,17 @@
        &lt;property name=&quot;decimals&quot; &gt;
         &lt;number&gt;1&lt;/number&gt;
        &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;double&gt;0.100000000000000&lt;/double&gt;
+       &lt;/property&gt;
        &lt;property name=&quot;maximum&quot; &gt;
-        &lt;double&gt;64&lt;/double&gt;
+        &lt;double&gt;64.000000000000000&lt;/double&gt;
        &lt;/property&gt;
-       &lt;property name=&quot;minimum&quot; &gt;
-        &lt;double&gt;0.1&lt;/double&gt;
-       &lt;/property&gt;
        &lt;property name=&quot;singleStep&quot; &gt;
-        &lt;double&gt;1&lt;/double&gt;
+        &lt;double&gt;1.000000000000000&lt;/double&gt;
        &lt;/property&gt;
        &lt;property name=&quot;value&quot; &gt;
-        &lt;double&gt;1&lt;/double&gt;
+        &lt;double&gt;1.000000000000000&lt;/double&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -227,12 +260,21 @@
    &lt;/item&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;0&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;spacer&gt;
        &lt;property name=&quot;orientation&quot; &gt;
@@ -264,7 +306,6 @@
    &lt;/item&gt;
   &lt;/layout&gt;
  &lt;/widget&gt;
- &lt;pixmapfunction&gt;&lt;/pixmapfunction&gt;
  &lt;resources/&gt;
  &lt;connections&gt;
   &lt;connection&gt;

Modified: trunk/lib/QGLViewer/README
===================================================================
--- trunk/lib/QGLViewer/README	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/README	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,6 +1,6 @@
 Contents of this directory is a copy of upstream from <A HREF="http://artis.imag.fr/Software/QGLViewer/,">http://artis.imag.fr/Software/QGLViewer/,</A> as of
 
-2007-08-28 23:40 libQGLViewer-2.2.6-3.tar.gz
+2008-06-29 <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/src/libQGLViewer-2.3.0.tar.gz">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/src/libQGLViewer-2.3.0.tar.gz</A>
 
 SConscript file is mostly cut&amp;paste from the original .pro file. Since the qt3 tool in scons doesn't properly
 handle files named like VRenderInterace.Qt3.ui (multiple suffixes), two offending files are symlinked to 
@@ -31,6 +31,21 @@
  #  include &quot;ImageInterface.Qt2.h&quot;
  # endif
 
+Further, to avoid Qt gratuitously #defining DEBUG, apply this patch to the header:
+
+--- qglviewer.h.~orig~	2008-06-29 23:04:16.000000000 +0200
++++ qglviewer.h	2008-07-18 08:46:13.000000000 +0200
+@@ -1229,4 +1229,8 @@
+ 	bool updateGLOK_;
+ };
+ 
++#ifdef DEBUG
++	#undef DEBUG
++#endif
++
+ #endif // QGLVIEWER_QGLVIEWER_H
+
+
 This has to be kept in mind when synchronizing with upstream.
 
 V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt;

Modified: trunk/lib/QGLViewer/VRender/AxisAlignedBox.h
===================================================================
--- trunk/lib/QGLViewer/VRender/AxisAlignedBox.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/AxisAlignedBox.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/EPSExporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/EPSExporter.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/EPSExporter.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Exporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Exporter.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Exporter.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -62,7 +62,7 @@
 										const vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
 										VRenderParams&amp; vparams)
 {
-	FILE *f = fopen(filename,&quot;w&quot;) ;
+	FILE *f = fopen(filename, &quot;w&quot;) ;
 
 	if(f == NULL)
 		throw runtime_error(string(&quot;could not open file &quot;) + filename) ;

Modified: trunk/lib/QGLViewer/VRender/Exporter.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Exporter.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Exporter.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/FIGExporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/FIGExporter.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/FIGExporter.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/NVector3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/NVector3.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/NVector3.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/NVector3.h
===================================================================
--- trunk/lib/QGLViewer/VRender/NVector3.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/NVector3.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Optimizer.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Optimizer.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Optimizer.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/ParserGL.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/ParserGL.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/ParserGL.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/ParserGL.h
===================================================================
--- trunk/lib/QGLViewer/VRender/ParserGL.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/ParserGL.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Primitive.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Primitive.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Primitive.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Primitive.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Primitive.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Primitive.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/PrimitivePositioning.h
===================================================================
--- trunk/lib/QGLViewer/VRender/PrimitivePositioning.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/PrimitivePositioning.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/SortMethod.h
===================================================================
--- trunk/lib/QGLViewer/VRender/SortMethod.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/SortMethod.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -44,8 +44,10 @@
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 *****************************************************************************/
-#include &lt;limits.h&gt;
+
 #include &lt;assert.h&gt;
+#include &lt;climits&gt;
+
 #include &quot;VRender.h&quot;
 #include &quot;Primitive.h&quot;
 #include &quot;PrimitivePositioning.h&quot;

Modified: trunk/lib/QGLViewer/VRender/Types.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Types.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Types.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/VRender.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/VRender.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/VRender.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -55,10 +55,11 @@
 # include &lt;GL/gl.h&gt;
 #endif
 
+#include &lt;stdio.h&gt;
+#include &lt;vector&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;vector&gt;
+
 #include &quot;VRender.h&quot;
 #include &quot;ParserGL.h&quot;
 #include &quot;Exporter.h&quot;

Modified: trunk/lib/QGLViewer/VRender/VRender.h
===================================================================
--- trunk/lib/QGLViewer/VRender/VRender.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/VRender.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Vector2.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector2.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Vector2.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Vector2.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector2.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Vector2.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Vector3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector3.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Vector3.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/Vector3.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector3.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/Vector3.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/gpc.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/gpc.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/gpc.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/VRender/gpc.h
===================================================================
--- trunk/lib/QGLViewer/VRender/gpc.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRender/gpc.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -25,7 +25,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Deleted: trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,123 +0,0 @@
-/****************************************************************************
-** Form implementation generated from reading ui file 'VRenderInterface.Qt3.ui'
-**
-** Created: &#268;t b&#345;e 13 19:58:46 2008
-**
-** WARNING! All changes made in this file will be lost!
-****************************************************************************/
-
-#include &quot;VRenderInterface.Qt3.h&quot;
-
-#include &lt;qvariant.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qcheckbox.h&gt;
-#include &lt;qlabel.h&gt;
-#include &lt;qcombobox.h&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qtooltip.h&gt;
-#include &lt;qwhatsthis.h&gt;
-
-/*
- *  Constructs a VRenderInterface as a child of 'parent', with the
- *  name 'name' and widget flags set to 'f'.
- *
- *  The dialog will by default be modeless, unless you set 'modal' to
- *  TRUE to construct a modal dialog.
- */
-VRenderInterface::VRenderInterface( QWidget* parent, const char* name, bool modal, WFlags fl )
-    : QDialog( parent, name, modal, fl )
-{
-    if ( !name )
-	setName( &quot;VRenderInterface&quot; );
-    VRenderInterfaceLayout = new QVBoxLayout( this, 5, 6, &quot;VRenderInterfaceLayout&quot;); 
-
-    includeHidden = new QCheckBox( this, &quot;includeHidden&quot; );
-    VRenderInterfaceLayout-&gt;addWidget( includeHidden );
-
-    cullBackFaces = new QCheckBox( this, &quot;cullBackFaces&quot; );
-    VRenderInterfaceLayout-&gt;addWidget( cullBackFaces );
-
-    blackAndWhite = new QCheckBox( this, &quot;blackAndWhite&quot; );
-    VRenderInterfaceLayout-&gt;addWidget( blackAndWhite );
-
-    colorBackground = new QCheckBox( this, &quot;colorBackground&quot; );
-    VRenderInterfaceLayout-&gt;addWidget( colorBackground );
-
-    tightenBBox = new QCheckBox( this, &quot;tightenBBox&quot; );
-    VRenderInterfaceLayout-&gt;addWidget( tightenBBox );
-
-    layout3 = new QHBoxLayout( 0, 0, 6, &quot;layout3&quot;); 
-
-    sortLabel = new QLabel( this, &quot;sortLabel&quot; );
-    layout3-&gt;addWidget( sortLabel );
-
-    sortMethod = new QComboBox( FALSE, this, &quot;sortMethod&quot; );
-    layout3-&gt;addWidget( sortMethod );
-    VRenderInterfaceLayout-&gt;addLayout( layout3 );
-    spacer1 = new QSpacerItem( 31, 41, QSizePolicy::Minimum, QSizePolicy::Expanding );
-    VRenderInterfaceLayout-&gt;addItem( spacer1 );
-
-    Layout4 = new QHBoxLayout( 0, 0, 6, &quot;Layout4&quot;); 
-
-    SaveButton = new QPushButton( this, &quot;SaveButton&quot; );
-    Layout4-&gt;addWidget( SaveButton );
-
-    CancelButton = new QPushButton( this, &quot;CancelButton&quot; );
-    Layout4-&gt;addWidget( CancelButton );
-    VRenderInterfaceLayout-&gt;addLayout( Layout4 );
-    languageChange();
-    resize( QSize(298, 245).expandedTo(minimumSizeHint()) );
-    clearWState( WState_Polished );
-
-    // signals and slots connections
-    connect( SaveButton, SIGNAL( clicked() ), this, SLOT( accept() ) );
-    connect( CancelButton, SIGNAL( clicked() ), this, SLOT( reject() ) );
-
-    // tab order
-    setTabOrder( SaveButton, CancelButton );
-    setTabOrder( CancelButton, includeHidden );
-    setTabOrder( includeHidden, cullBackFaces );
-    setTabOrder( cullBackFaces, blackAndWhite );
-    setTabOrder( blackAndWhite, colorBackground );
-    setTabOrder( colorBackground, tightenBBox );
-    setTabOrder( tightenBBox, sortMethod );
-}
-
-/*
- *  Destroys the object and frees any allocated resources
- */
-VRenderInterface::~VRenderInterface()
-{
-    // no need to delete child widgets, Qt does it all for us
-}
-
-/*
- *  Sets the strings of the subwidgets using the current
- *  language.
- */
-void VRenderInterface::languageChange()
-{
-    setCaption( tr( &quot;Vectorial rendering options&quot; ) );
-    includeHidden-&gt;setText( tr( &quot;Include hidden parts&quot; ) );
-    QToolTip::add( includeHidden, tr( &quot;Hidden poligons are also included in the output (usually twice bigger)&quot; ) );
-    cullBackFaces-&gt;setText( tr( &quot;Cull back faces&quot; ) );
-    QToolTip::add( cullBackFaces, tr( &quot;Back faces (non clockwise point ordering) are removed from the output&quot; ) );
-    blackAndWhite-&gt;setText( tr( &quot;Black and white&quot; ) );
-    QToolTip::add( blackAndWhite, tr( &quot;Black and white rendering&quot; ) );
-    colorBackground-&gt;setText( tr( &quot;Color background&quot; ) );
-    QToolTip::add( colorBackground, tr( &quot;Use current background color instead of white&quot; ) );
-    tightenBBox-&gt;setText( tr( &quot;Tighten bounding box&quot; ) );
-    QToolTip::add( tightenBBox, tr( &quot;Fit output bounding box to current display&quot; ) );
-    sortLabel-&gt;setText( tr( &quot;Sort method :&quot; ) );
-    QToolTip::add( sortLabel, tr( &quot;Polygon depth sorting method&quot; ) );
-    sortMethod-&gt;clear();
-    sortMethod-&gt;insertItem( tr( &quot;No sorting&quot; ) );
-    sortMethod-&gt;insertItem( tr( &quot;BSP &quot; ) );
-    sortMethod-&gt;insertItem( tr( &quot;Topological&quot; ) );
-    sortMethod-&gt;insertItem( tr( &quot;Advanced topological&quot; ) );
-    sortMethod-&gt;setCurrentItem( 3 );
-    QToolTip::add( sortMethod, tr( &quot;Polygon depth sorting method&quot; ) );
-    SaveButton-&gt;setText( tr( &quot;Save&quot; ) );
-    CancelButton-&gt;setText( tr( &quot;Cancel&quot; ) );
-}
-

Modified: trunk/lib/QGLViewer/VRenderInterface.Qt3.ui
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt3.ui	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt3.ui	2008-07-18 06:54:48 UTC (rev 1434)
@@ -33,7 +33,7 @@
                 &lt;string&gt;Include hidden parts&lt;/string&gt;
             &lt;/property&gt;
             &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
-                &lt;string&gt;Hidden poligons are also included in the output (usually twice bigger)&lt;/string&gt;
+                &lt;string&gt;Hidden polygons are also included in the output (usually twice bigger)&lt;/string&gt;
             &lt;/property&gt;
         &lt;/widget&gt;
         &lt;widget class=&quot;QCheckBox&quot;&gt;
@@ -93,7 +93,7 @@
                         &lt;cstring&gt;sortLabel&lt;/cstring&gt;
                     &lt;/property&gt;
                     &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Sort method :&lt;/string&gt;
+                        &lt;string&gt;Sort method:&lt;/string&gt;
                     &lt;/property&gt;
                     &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
                         &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
@@ -107,7 +107,7 @@
                     &lt;/item&gt;
                     &lt;item&gt;
                         &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;BSP &lt;/string&gt;
+                            &lt;string&gt;BSP&lt;/string&gt;
                         &lt;/property&gt;
                     &lt;/item&gt;
                     &lt;item&gt;

Modified: trunk/lib/QGLViewer/VRenderInterface.Qt4.ui
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt4.ui	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt4.ui	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,31 +1,37 @@
 &lt;ui version=&quot;4.0&quot; &gt;
- &lt;author&gt;&lt;/author&gt;
- &lt;comment&gt;&lt;/comment&gt;
- &lt;exportmacro&gt;&lt;/exportmacro&gt;
  &lt;class&gt;VRenderInterface&lt;/class&gt;
  &lt;widget class=&quot;QDialog&quot; name=&quot;VRenderInterface&quot; &gt;
   &lt;property name=&quot;geometry&quot; &gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
-    &lt;width&gt;298&lt;/width&gt;
-    &lt;height&gt;224&lt;/height&gt;
+    &lt;width&gt;230&lt;/width&gt;
+    &lt;height&gt;211&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
   &lt;property name=&quot;windowTitle&quot; &gt;
    &lt;string&gt;Vectorial rendering options&lt;/string&gt;
   &lt;/property&gt;
   &lt;layout class=&quot;QVBoxLayout&quot; &gt;
-   &lt;property name=&quot;margin&quot; &gt;
-    &lt;number&gt;5&lt;/number&gt;
-   &lt;/property&gt;
    &lt;property name=&quot;spacing&quot; &gt;
     &lt;number&gt;6&lt;/number&gt;
    &lt;/property&gt;
+   &lt;property name=&quot;leftMargin&quot; &gt;
+    &lt;number&gt;5&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;topMargin&quot; &gt;
+    &lt;number&gt;5&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;rightMargin&quot; &gt;
+    &lt;number&gt;5&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;bottomMargin&quot; &gt;
+    &lt;number&gt;5&lt;/number&gt;
+   &lt;/property&gt;
    &lt;item&gt;
     &lt;widget class=&quot;QCheckBox&quot; name=&quot;includeHidden&quot; &gt;
      &lt;property name=&quot;toolTip&quot; &gt;
-      &lt;string&gt;Hidden poligons are also included in the output (usually twice bigger)&lt;/string&gt;
+      &lt;string&gt;Hidden polygons are also included in the output (usually twice bigger)&lt;/string&gt;
      &lt;/property&gt;
      &lt;property name=&quot;text&quot; &gt;
       &lt;string&gt;Include hidden parts&lt;/string&gt;
@@ -74,19 +80,28 @@
    &lt;/item&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;11&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;11&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;11&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;11&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;11&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;widget class=&quot;QLabel&quot; name=&quot;sortLabel&quot; &gt;
        &lt;property name=&quot;toolTip&quot; &gt;
         &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
        &lt;/property&gt;
        &lt;property name=&quot;text&quot; &gt;
-        &lt;string&gt;Sort method :&lt;/string&gt;
+        &lt;string&gt;Sort method:&lt;/string&gt;
        &lt;/property&gt;
       &lt;/widget&gt;
      &lt;/item&gt;
@@ -96,7 +111,7 @@
         &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
        &lt;/property&gt;
        &lt;property name=&quot;currentIndex&quot; &gt;
-        &lt;number&gt;0&lt;/number&gt;
+        &lt;number&gt;3&lt;/number&gt;
        &lt;/property&gt;
        &lt;item&gt;
         &lt;property name=&quot;text&quot; &gt;
@@ -105,7 +120,7 @@
        &lt;/item&gt;
        &lt;item&gt;
         &lt;property name=&quot;text&quot; &gt;
-         &lt;string&gt;BSP &lt;/string&gt;
+         &lt;string&gt;BSP&lt;/string&gt;
         &lt;/property&gt;
        &lt;/item&gt;
        &lt;item&gt;
@@ -140,12 +155,21 @@
    &lt;/item&gt;
    &lt;item&gt;
     &lt;layout class=&quot;QHBoxLayout&quot; &gt;
-     &lt;property name=&quot;margin&quot; &gt;
-      &lt;number&gt;0&lt;/number&gt;
-     &lt;/property&gt;
      &lt;property name=&quot;spacing&quot; &gt;
       &lt;number&gt;6&lt;/number&gt;
      &lt;/property&gt;
+     &lt;property name=&quot;leftMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;topMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;rightMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;bottomMargin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
      &lt;item&gt;
       &lt;widget class=&quot;QPushButton&quot; name=&quot;SaveButton&quot; &gt;
        &lt;property name=&quot;text&quot; &gt;

Modified: trunk/lib/QGLViewer/camera.cpp
===================================================================
--- trunk/lib/QGLViewer/camera.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/camera.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/camera.h
===================================================================
--- trunk/lib/QGLViewer/camera.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/camera.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/config.h
===================================================================
--- trunk/lib/QGLViewer/config.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/config.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -31,7 +31,7 @@
 #ifndef QGLVIEWER_CONFIG_H
 #define QGLVIEWER_CONFIG_H
 
-#define QGLVIEWER_VERSION 0x020206
+#define QGLVIEWER_VERSION 0x020300
 
 // Needed for Qt &lt; 4 (?)
 #ifndef QT_CLEAN_NAMESPACE

Modified: trunk/lib/QGLViewer/constraint.cpp
===================================================================
--- trunk/lib/QGLViewer/constraint.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/constraint.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/constraint.h
===================================================================
--- trunk/lib/QGLViewer/constraint.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/constraint.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/domUtils.h
===================================================================
--- trunk/lib/QGLViewer/domUtils.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/domUtils.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/frame.cpp
===================================================================
--- trunk/lib/QGLViewer/frame.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/frame.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/frame.h
===================================================================
--- trunk/lib/QGLViewer/frame.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/frame.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/keyFrameInterpolator.cpp
===================================================================
--- trunk/lib/QGLViewer/keyFrameInterpolator.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/keyFrameInterpolator.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/keyFrameInterpolator.h
===================================================================
--- trunk/lib/QGLViewer/keyFrameInterpolator.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/keyFrameInterpolator.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/manipulatedCameraFrame.cpp
===================================================================
--- trunk/lib/QGLViewer/manipulatedCameraFrame.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/manipulatedCameraFrame.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/manipulatedCameraFrame.h
===================================================================
--- trunk/lib/QGLViewer/manipulatedCameraFrame.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/manipulatedCameraFrame.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/manipulatedFrame.cpp
===================================================================
--- trunk/lib/QGLViewer/manipulatedFrame.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/manipulatedFrame.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -22,12 +22,14 @@
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 
 *****************************************************************************/
-#include&lt;stdlib.h&gt;
+
 #include &quot;domUtils.h&quot;
 #include &quot;manipulatedFrame.h&quot;
 #include &quot;qglviewer.h&quot;
 #include &quot;camera.h&quot;
 
+#include &lt;cstdlib&gt;
+
 #if QT_VERSION &gt;= 0x040000
 # include &lt;QMouseEvent&gt;
 #endif

Modified: trunk/lib/QGLViewer/manipulatedFrame.h
===================================================================
--- trunk/lib/QGLViewer/manipulatedFrame.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/manipulatedFrame.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/mouseGrabber.cpp
===================================================================
--- trunk/lib/QGLViewer/mouseGrabber.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/mouseGrabber.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/mouseGrabber.h
===================================================================
--- trunk/lib/QGLViewer/mouseGrabber.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/mouseGrabber.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/qglviewer.cpp
===================================================================
--- trunk/lib/QGLViewer/qglviewer.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/qglviewer.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -62,7 +62,7 @@
 #  include &lt;qkeysequence.h&gt;
 # else
 #  include &lt;qtextview.h&gt;
-   typedef QTextView QTextEdit;
+typedef QTextView QTextEdit;
 #  include &lt;qtextstream.h&gt;
 #  include &lt;algorithm&gt;
 #  include &quot;keySequence.h&quot;
@@ -72,13 +72,20 @@
 using namespace std;
 using namespace qglviewer;
 
+/*
+TXXXXXRANSLATOR qglviewer::QGLViewer
+
+Necessary for lupdate.
+*/
+
 // Static private variable
 #if QT_VERSION &gt;= 0x040000
-  QList&lt;QGLViewer*&gt; QGLViewer::QGLViewerPool_;
+QList&lt;QGLViewer*&gt; QGLViewer::QGLViewerPool_;
 #else
-  QPtrList&lt;QGLViewer&gt; QGLViewer::QGLViewerPool_;
+QPtrList&lt;QGLViewer&gt; QGLViewer::QGLViewerPool_;
 #endif
 
+
 /*! \mainpage
 
 libQGLViewer is a free C++ library based on Qt that enables the quick creation of OpenGL 3D viewers.
@@ -104,112 +111,112 @@
 
 void QGLViewer::defaultConstructor()
 {
-  //      - - -  W A R N I N G  - - -
-  // This method should not call initializeGL(). Otherwise, as we are in the
-  // base class constructor, the user-defined init() would never be called.
-  // The different QGLViewer::setXXX are hence protected, so that updateGL is not called.
-  // The different constructor code should then be EMPTY.
-  updateGLOK_ = false;
+	//      - - -  W A R N I N G  - - -
+	// This method should not call initializeGL(). Otherwise, as we are in the
+	// base class constructor, the user-defined init() would never be called.
+	// The different QGLViewer::setXXX are hence protected, so that updateGL is not called.
+	// The different constructor code should then be EMPTY.
+	updateGLOK_ = false;
 
-  // Test OpenGL context
-  // if (glGetString(GL_VERSION) == 0)
-    // qWarning(&quot;Unable to get OpenGL version, context may not be available - Check your configuration&quot;);
+	// Test OpenGL context
+	// if (glGetString(GL_VERSION) == 0)
+	// qWarning(&quot;Unable to get OpenGL version, context may not be available - Check your configuration&quot;);
 
-  QGLViewer::QGLViewerPool_.append(this);
+	QGLViewer::QGLViewerPool_.append(this);
 
-  camera_ = new Camera();
-  setCamera(camera());
+	camera_ = new Camera();
+	setCamera(camera());
 
 #if QT_VERSION &gt;= 0x040000
-  setFocusPolicy(Qt::StrongFocus);
+	setFocusPolicy(Qt::StrongFocus);
 #else
-  setFocusPolicy(QWidget::StrongFocus);
+	setFocusPolicy(QWidget::StrongFocus);
 #endif
 
-  setDefaultShortcuts();
-  setDefaultMouseBindings();
+	setDefaultShortcuts();
+	setDefaultMouseBindings();
 
-  setSnapshotFileName(&quot;snapshot&quot;);
-  initializeSnapshotFormats();
-  setSnapshotCounter(0);
-  setSnapshotQuality(95);
+	setSnapshotFileName(tr(&quot;snapshot&quot;, &quot;Default snapshot file name&quot;));
+	initializeSnapshotFormats();
+	setSnapshotCounter(0);
+	setSnapshotQuality(95);
 
-  fpsTime_.start();
-  fpsCounter_		= 0;
-  f_p_s_		= 0.0;
-  fpsString_		= &quot;?Hz&quot;;
-  visualHint_		= 0;
-  previousPathId_	= 0;
-  // prevPos_ is not initialized since pos() is not meaningful here. It will be set by setFullScreen().
+	fpsTime_.start();
+	fpsCounter_		= 0;
+	f_p_s_		= 0.0;
+	fpsString_		= tr(&quot;%1Hz&quot;, &quot;Frames per seconds, in Hertz&quot;).arg(&quot;?&quot;);
+	visualHint_		= 0;
+	previousPathId_	= 0;
+	// prevPos_ is not initialized since pos() is not meaningful here. It will be set by setFullScreen().
 
-  // #CONNECTION# default values in initFromDOMElement()
-  manipulatedFrame_ = NULL;
-  manipulatedFrameIsACamera_ = false;
-  mouseGrabberIsAManipulatedFrame_ = false;
-  mouseGrabberIsAManipulatedCameraFrame_ = false;
-  displayMessage_ = false;
-  connect(&amp;messageTimer_, SIGNAL(timeout()), SLOT(hideMessage()));
+	// #CONNECTION# default values in initFromDOMElement()
+	manipulatedFrame_ = NULL;
+	manipulatedFrameIsACamera_ = false;
+	mouseGrabberIsAManipulatedFrame_ = false;
+	mouseGrabberIsAManipulatedCameraFrame_ = false;
+	displayMessage_ = false;
+	connect(&amp;messageTimer_, SIGNAL(timeout()), SLOT(hideMessage()));
 #if QT_VERSION &gt;= 0x040000
-  messageTimer_.setSingleShot(true);
+	messageTimer_.setSingleShot(true);
 #endif
-  helpWidget_ = NULL;
-  setMouseGrabber(NULL);
+	helpWidget_ = NULL;
+	setMouseGrabber(NULL);
 
-  setSceneRadius(1.0);
-  showEntireScene();
-  setStateFileName(&quot;.qglviewer.xml&quot;);
+	setSceneRadius(1.0);
+	showEntireScene();
+	setStateFileName(&quot;.qglviewer.xml&quot;);
 
-  // #CONNECTION# default values in initFromDOMElement()
-  setAxisIsDrawn(false);
-  setGridIsDrawn(false);
-  setFPSIsDisplayed(false);
-  setCameraIsEdited(false);
-  setTextIsEnabled(true);
-  setStereoDisplay(false);
-  setFullScreen(false);
+	// #CONNECTION# default values in initFromDOMElement()
+	setAxisIsDrawn(false);
+	setGridIsDrawn(false);
+	setFPSIsDisplayed(false);
+	setCameraIsEdited(false);
+	setTextIsEnabled(true);
+	setStereoDisplay(false);
+	setFullScreen(false);
 
-  animationTimerId_ = 0;
-  stopAnimation();
-  setAnimationPeriod(40); // 25Hz
+	animationTimerId_ = 0;
+	stopAnimation();
+	setAnimationPeriod(40); // 25Hz
 
-  selectBuffer_ = NULL;
-  setSelectBufferSize(4*1000);
-  setSelectRegionWidth(3);
-  setSelectRegionHeight(3);
-  setSelectedName(-1);
+	selectBuffer_ = NULL;
+	setSelectBufferSize(4*1000);
+	setSelectRegionWidth(3);
+	setSelectRegionHeight(3);
+	setSelectedName(-1);
 
-  bufferTextureId_ = 0;
-  bufferTextureMaxU_ = 0.0;
-  bufferTextureMaxV_ = 0.0;
-  bufferTextureWidth_ = 0;
-  bufferTextureHeight_ = 0;
-  previousBufferTextureFormat_ = 0;
-  previousBufferTextureInternalFormat_ = 0;
+	bufferTextureId_ = 0;
+	bufferTextureMaxU_ = 0.0;
+	bufferTextureMaxV_ = 0.0;
+	bufferTextureWidth_ = 0;
+	bufferTextureHeight_ = 0;
+	previousBufferTextureFormat_ = 0;
+	previousBufferTextureInternalFormat_ = 0;
 
 #if QT_VERSION &gt;= 0x040000
-  setAttribute(Qt::WA_NoSystemBackground);
+	setAttribute(Qt::WA_NoSystemBackground);
 #endif
 }
 
 #if QT_VERSION &gt;= 0x040000
 /*! Constructor. See \c QGLWidget documentation for details.
 
- All viewer parameters (display flags, scene parameters, associated objects...) are set to their default values. See
- the associated documentation.
+All viewer parameters (display flags, scene parameters, associated objects...) are set to their default values. See
+the associated documentation.
 
- If the \p shareWidget parameter points to a valid \c QGLWidget, the QGLViewer will share the OpenGL
- context with \p shareWidget (see isSharing()). */
+If the \p shareWidget parameter points to a valid \c QGLWidget, the QGLViewer will share the OpenGL
+context with \p shareWidget (see isSharing()). */
 QGLViewer::QGLViewer(QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
-  : QGLWidget(parent, shareWidget, flags)
+: QGLWidget(parent, shareWidget, flags)
 { defaultConstructor(); }
 
 /*! Same as QGLViewer(), but a \c QGLContext can be provided so that viewers share GL contexts, even
- with \c QGLContext sub-classes (use \p shareWidget otherwise).
+with \c QGLContext sub-classes (use \p shareWidget otherwise).
 
- \note This constructor is correctly working only with Qt versions greater or equal than 3.2. The
- provided \p context is simply ignored otherwise. */
+\note This constructor is correctly working only with Qt versions greater or equal than 3.2. The
+provided \p context is simply ignored otherwise. */
 QGLViewer::QGLViewer(QGLContext *context, QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
-  : QGLWidget(context, parent, shareWidget, flags)
+: QGLWidget(context, parent, shareWidget, flags)
 { defaultConstructor(); }
 
 /*! Same as QGLViewer(), but a specific \c QGLFormat can be provided.
@@ -217,87 +224,88 @@
 This is for instance needed to ask for a stencil buffer or for stereo display (as is illustrated in
 the &lt;a href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt;). */
 QGLViewer::QGLViewer(const QGLFormat&amp; format, QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
-  : QGLWidget(format, parent, shareWidget, flags)
+: QGLWidget(format, parent, shareWidget, flags)
 { defaultConstructor(); }
 #endif
 
 /*! Virtual destructor.
 
-Removes viewer from QGLViewerPool() and releases allocated memory. The camera() is deleted and
-should be copied before if it is shared. */
+The viewer is replaced by \c NULL in the QGLViewerPool() (in order to preserve other viewer's indexes) and allocated 
+memory is released. The camera() is deleted and should be copied before if it is shared by an other viewer. */
 QGLViewer::~QGLViewer()
 {
-  // See closeEvent comment. Destructor is called (and not closeEvent) only when the widget is embedded.
-  // Hence we saveToFile here. It is however a bad idea if virtual domElement() has been overloaded !
-  // if (parent())
-    // saveStateToFileForAllViewers();
+	// See closeEvent comment. Destructor is called (and not closeEvent) only when the widget is embedded.
+	// Hence we saveToFile here. It is however a bad idea if virtual domElement() has been overloaded !
+	// if (parent())
+	// saveStateToFileForAllViewers();
+
 #if QT_VERSION &gt;= 0x040000
-  QGLViewer::QGLViewerPool_.removeAll(this);
+	QGLViewer::QGLViewerPool_.replace(QGLViewer::QGLViewerPool_.indexOf(this), NULL);
 #else
-  QGLViewer::QGLViewerPool_.removeRef(this);
+	QGLViewer::QGLViewerPool_.replace(QGLViewer::QGLViewerPool_.findRef(this), NULL);
 #endif
 
-  delete camera();
-  delete[] selectBuffer_;
-  if (helpWidget())
-    {
-      // Needed for Qt 4 which has no main widget.
-      helpWidget()-&gt;close();
-      delete helpWidget_;
-    }
+	delete camera();
+	delete[] selectBuffer_;
+	if (helpWidget())
+	{
+		// Needed for Qt 4 which has no main widget.
+		helpWidget()-&gt;close();
+		delete helpWidget_;
+	}
 }
 
 
 static QString QGLViewerVersionString()
 {
-  return QString::number((QGLVIEWER_VERSION &amp; 0xff0000) &gt;&gt; 16) + &quot;.&quot; +
-    QString::number((QGLVIEWER_VERSION &amp; 0x00ff00) &gt;&gt; 8) + &quot;.&quot; +
-    QString::number(QGLVIEWER_VERSION &amp; 0x0000ff);
+	return QString::number((QGLVIEWER_VERSION &amp; 0xff0000) &gt;&gt; 16) + &quot;.&quot; +
+		QString::number((QGLVIEWER_VERSION &amp; 0x00ff00) &gt;&gt; 8) + &quot;.&quot; +
+		QString::number(QGLVIEWER_VERSION &amp; 0x0000ff);
 }
 
 static int convertToKeyboardModifiers(int state)
 {
 #if QT_VERSION &lt; 0x040000
-  // Qt 2 &amp; 3 have different values for ButtonState and Modifiers.
-  // Converts CTRL,SHIFT... to ControlButton, ShiftButton...
-  if (state &amp; Qt::MODIFIER_MASK)
-    {
-      if (state &amp; Qt::CTRL)  { state &amp;= ~Qt::CTRL;	state |= Qt::ControlButton; }
-      if (state &amp; Qt::SHIFT) { state &amp;= ~Qt::SHIFT;	state |= Qt::ShiftButton; }
-      if (state &amp; Qt::ALT)   { state &amp;= ~Qt::ALT; 	state |= Qt::AltButton; }
+	// Qt 2 &amp; 3 have different values for ButtonState and Modifiers.
+	// Converts CTRL,SHIFT... to ControlButton, ShiftButton...
+	if (state &amp; Qt::MODIFIER_MASK)
+	{
+		if (state &amp; Qt::CTRL)  { state &amp;= ~Qt::CTRL;	state |= Qt::ControlButton; }
+		if (state &amp; Qt::SHIFT) { state &amp;= ~Qt::SHIFT;	state |= Qt::ShiftButton; }
+		if (state &amp; Qt::ALT)   { state &amp;= ~Qt::ALT; 	state |= Qt::AltButton; }
 # if QT_VERSION &gt;= 0x030100
-      if (state &amp; Qt::META)  { state &amp;= ~Qt::META; 	state |= Qt::MetaButton; }
+		if (state &amp; Qt::META)  { state &amp;= ~Qt::META; 	state |= Qt::MetaButton; }
 # endif
-    }
+	}
 #endif
-  return state;
+	return state;
 }
 
 static QtKeyboardModifiers convertKeyboardModifiers(QtKeyboardModifiers modifiers)
 {
 #if QT_VERSION &lt; 0x040000
-  return QtKeyboardModifiers(convertToKeyboardModifiers(modifiers));
+	return QtKeyboardModifiers(convertToKeyboardModifiers(modifiers));
 #else
-  return modifiers;
+	return modifiers;
 #endif
 }
 
 static int convertToShortModifier(int state)
 {
-  // Converts ControlButton, ShiftButton... to CTRL,SHIFT...
-  // convertToKeyboardModifiers does the opposite
+	// Converts ControlButton, ShiftButton... to CTRL,SHIFT...
+	// convertToKeyboardModifiers does the opposite
 #if QT_VERSION &lt; 0x040000
-  if (state &amp; Qt::KeyButtonMask)
-    {
-      if (state &amp; Qt::ControlButton) { state &amp;= ~Qt::ControlButton;	state |= Qt::CTRL; }
-      if (state &amp; Qt::ShiftButton)   { state &amp;= ~Qt::ShiftButton;	state |= Qt::SHIFT; }
-      if (state &amp; Qt::AltButton)     { state &amp;= ~Qt::AltButton;		state |= Qt::ALT; }
+	if (state &amp; Qt::KeyButtonMask)
+	{
+		if (state &amp; Qt::ControlButton) { state &amp;= ~Qt::ControlButton;	state |= Qt::CTRL; }
+		if (state &amp; Qt::ShiftButton)   { state &amp;= ~Qt::ShiftButton;	state |= Qt::SHIFT; }
+		if (state &amp; Qt::AltButton)     { state &amp;= ~Qt::AltButton;		state |= Qt::ALT; }
 # if QT_VERSION &gt;= 0x030100
-      if (state &amp; Qt::MetaButton)    { state &amp;= ~Qt::MetaButton; 	state |= Qt::META; }
+		if (state &amp; Qt::MetaButton)    { state &amp;= ~Qt::MetaButton; 	state |= Qt::META; }
 # endif
-    }
+	}
 #endif
-  return state;
+	return state;
 }
 
 /*! Opens an about dialog.
@@ -305,338 +313,338 @@
 Default implementation displays libQGLViewer version, copyright notice and web site. */
 void QGLViewer::aboutQGLViewer()
 {
-  QMessageBox mb(&quot;About libQGLViewer&quot;,
-		 QString(&quot;libQGLViewer, version &quot;)+QGLViewerVersionString()+QString(&quot;.&lt;br&gt;&quot;
-		 &quot;A versatile 3D viewer based on OpenGL and Qt.&lt;br&gt;&quot;
-		 &quot;Copyright 2002-2007 Gilles Debunne.&lt;br&gt;&quot;
-		 &quot;&lt;code&gt;<A HREF="http://artis.imag.fr/Software/QGLViewer&lt;/code">http://artis.imag.fr/Software/QGLViewer&lt;/code</A>&gt;&quot;),
-		 QMessageBox::Information,
-		 QMessageBox::Ok,
-		 QMessageBox::NoButton,
-		 QMessageBox::NoButton,
-		 this);
+	QMessageBox mb(tr(&quot;About libQGLViewer&quot;, &quot;About message box title&quot;),
+		tr(&quot;libQGLViewer, version %1.&lt;br&gt;&quot;
+		&quot;A versatile 3D viewer based on OpenGL and Qt.&lt;br&gt;&quot;
+		&quot;Copyright 2002-%2 Gilles Debunne.&lt;br&gt;&quot;
+		&quot;&lt;code&gt;%3&lt;/code&gt;&quot;).arg(QGLViewerVersionString()).arg(&quot;2008&quot;).arg(&quot;<A HREF="http://artis.imag.fr/Software/QGLViewer">http://artis.imag.fr/Software/QGLViewer</A>&quot;),
+		QMessageBox::Information,
+		QMessageBox::Ok,
+		QMessageBox::NoButton,
+		QMessageBox::NoButton,
+		this);	
 
 #include &quot;qglviewer-icon.xpm&quot;
-  QPixmap pixmap(qglviewer_icon);
-  mb.setIconPixmap(pixmap);
-  mb.setTextFormat(Qt::RichText);
-  mb.exec();
+	QPixmap pixmap(qglviewer_icon);
+	mb.setIconPixmap(pixmap);
+	mb.setTextFormat(Qt::RichText);
+	mb.exec();
 }
 
 /*! Initializes the QGLViewer OpenGL context and then calls user-defined init().
 
- This method is automatically called once, before the first call to paintGL().
+This method is automatically called once, before the first call to paintGL().
 
- Overload init() instead of this method to modify viewer specific OpenGL state or to create display
- lists.
+Overload init() instead of this method to modify viewer specific OpenGL state or to create display
+lists.
 
- To make beginners' life easier and to simplify the examples, this method slightly modifies the
- standard OpenGL state:
- \code
- glEnable(GL_LIGHT0);
- glEnable(GL_LIGHTING);
- glEnable(GL_DEPTH_TEST);
- glEnable(GL_COLOR_MATERIAL);
- \endcode
+To make beginners' life easier and to simplify the examples, this method slightly modifies the
+standard OpenGL state:
+\code
+glEnable(GL_LIGHT0);
+glEnable(GL_LIGHTING);
+glEnable(GL_DEPTH_TEST);
+glEnable(GL_COLOR_MATERIAL);
+\endcode
 
- If you port an existing application to QGLViewer and your display changes, you probably want to
- disable these flags in init() to get back to a standard OpenGL state. */
+If you port an existing application to QGLViewer and your display changes, you probably want to
+disable these flags in init() to get back to a standard OpenGL state. */
 void QGLViewer::initializeGL()
 {
-  if (updateGLOK_)
-    qWarning(&quot;Internal debug: initializeGL() is called in QGLViewer constructor.&quot;);
+	if (updateGLOK_)
+		qWarning(&quot;Internal debug: initializeGL() is called in QGLViewer constructor.&quot;);
 
-  glEnable(GL_LIGHT0);
-  glEnable(GL_LIGHTING);
-  glEnable(GL_DEPTH_TEST);
-  glEnable(GL_COLOR_MATERIAL);
+	glEnable(GL_LIGHT0);
+	glEnable(GL_LIGHTING);
+	glEnable(GL_DEPTH_TEST);
+	glEnable(GL_COLOR_MATERIAL);
 
-  // Default colors
-  setForegroundColor(QColor(180, 180, 180));
-  setBackgroundColor(QColor(51, 51, 51));
+	// Default colors
+	setForegroundColor(QColor(180, 180, 180));
+	setBackgroundColor(QColor(51, 51, 51));
 
-  // Clear the buffer where we're going to draw
-  if (format().stereo())
-    {
-      glDrawBuffer(GL_BACK_RIGHT);
-      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-      glDrawBuffer(GL_BACK_LEFT);
-      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-    }
-  else
-    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	// Clear the buffer where we're going to draw
+	if (format().stereo())
+	{
+		glDrawBuffer(GL_BACK_RIGHT);
+		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+		glDrawBuffer(GL_BACK_LEFT);
+		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	}
+	else
+		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
-  // Calls user defined method. Default emits a signal.
-  init();
+	// Calls user defined method. Default emits a signal.
+	init();
 
-  // Give time to glInit to finish and then call setFullScreen().
-  if (isFullScreen())
-    QTimer::singleShot( 100, this, SLOT(delayedFullScreen()) );
+	// Give time to glInit to finish and then call setFullScreen().
+	if (isFullScreen())
+		QTimer::singleShot( 100, this, SLOT(delayedFullScreen()) );
 
-  updateGLOK_ = true;
+	updateGLOK_ = true;
 }
 
 /*! Main paint method, inherited from \c QGLWidget.
 
- Calls the following methods, in that order:
- \arg preDraw() (or preDrawStereo() if viewer displaysInStereo()) : places the camera in the world coordinate system.
- \arg draw() (or fastDraw() when the camera is manipulated) : main drawing method. Should be overloaded.
- \arg postDraw() : display of visual hints (world axis, FPS...) */
+Calls the following methods, in that order:
+\arg preDraw() (or preDrawStereo() if viewer displaysInStereo()) : places the camera in the world coordinate system.
+\arg draw() (or fastDraw() when the camera is manipulated) : main drawing method. Should be overloaded.
+\arg postDraw() : display of visual hints (world axis, FPS...) */
 void QGLViewer::paintGL()
 {
-  updateGLOK_ = false;
-  if (displaysInStereo())
-    {
-      for (int view=1; view&gt;=0; --view)
+	updateGLOK_ = false;
+	if (displaysInStereo())
 	{
-	  // Clears screen, set model view matrix with shifted matrix for ith buffer
-	  preDrawStereo(view);
-	  // Used defined method. Default is empty
-	  if (camera()-&gt;frame()-&gt;isManipulated())
-	    fastDraw();
-	  else
-	    draw();
-	  postDraw();
+		for (int view=1; view&gt;=0; --view)
+		{
+			// Clears screen, set model view matrix with shifted matrix for ith buffer
+			preDrawStereo(view);
+			// Used defined method. Default is empty
+			if (camera()-&gt;frame()-&gt;isManipulated())
+				fastDraw();
+			else
+				draw();
+			postDraw();
+		}
 	}
-    }
-  else
-    {
-      // Clears screen, set model view matrix...
-      preDraw();
-      // Used defined method. Default calls draw()
-      if (camera()-&gt;frame()-&gt;isManipulated())
-	fastDraw();
-      else
-	draw();
-      // Add visual hints: axis, camera, grid...
-      postDraw();
-    }
-  updateGLOK_ = true;
-  emit drawFinished(true);
+	else
+	{
+		// Clears screen, set model view matrix...
+		preDraw();
+		// Used defined method. Default calls draw()
+		if (camera()-&gt;frame()-&gt;isManipulated())
+			fastDraw();
+		else
+			draw();
+		// Add visual hints: axis, camera, grid...
+		postDraw();
+	}
+	updateGLOK_ = true;
+	emit drawFinished(true);
 }
 
 /*! Sets OpenGL state before draw().
 
- Default behavior clears screen and sets the projection and modelView matrices:
- \code
- glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+Default behavior clears screen and sets the projection and modelView matrices:
+\code
+glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
- camera()-&gt;loadProjectionMatrix();
- camera()-&gt;loadModelViewMatrix();
- \endcode
+camera()-&gt;loadProjectionMatrix();
+camera()-&gt;loadModelViewMatrix();
+\endcode
 
- Emits the drawNeeded() signal once this is done (see the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt;). */
+Emits the drawNeeded() signal once this is done (see the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt;). */
 void QGLViewer::preDraw()
 {
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
-  // GL_PROJECTION matrix
-  camera()-&gt;loadProjectionMatrix();
-  // GL_MODELVIEW matrix
-  camera()-&gt;loadModelViewMatrix();
+	// GL_PROJECTION matrix
+	camera()-&gt;loadProjectionMatrix();
+	// GL_MODELVIEW matrix
+	camera()-&gt;loadModelViewMatrix();
 
-  emit drawNeeded();
+	emit drawNeeded();
 }
 
 /*! Called after draw() to draw viewer visual hints.
 
- Default implementation displays axis, grid, FPS... when the respective flags are sets.
+Default implementation displays axis, grid, FPS... when the respective flags are sets.
 
- See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
- href=&quot;../examples/contribs.html#thumbnail&quot;&gt;thumbnail&lt;/a&gt; examples for an overloading illustration.
+See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
+href=&quot;../examples/contribs.html#thumbnail&quot;&gt;thumbnail&lt;/a&gt; examples for an overloading illustration.
 
- The GLContext (color, LIGHTING, BLEND...) should \e not be modified by this method, so that in
- draw(), the user can rely on the OpenGL context. Respect this convention (by pushing/popping the
- different attributes) if you overload this method. */
+The GLContext (color, LIGHTING, BLEND...) is \e not modified by this method, so that in
+draw(), the user can rely on the OpenGL context he defined. Respect this convention (by pushing/popping the
+different attributes) if you overload this method. */
 void QGLViewer::postDraw()
 {
-  // Reset model view matrix to world coordinates origin
-  glMatrixMode(GL_MODELVIEW);
-  glPushMatrix();
-  camera()-&gt;loadModelViewMatrix();
-  // TODO restore model loadProjectionMatrixStereo
+	// Reset model view matrix to world coordinates origin
+	glMatrixMode(GL_MODELVIEW);
+	glPushMatrix();
+	camera()-&gt;loadModelViewMatrix();
+	// TODO restore model loadProjectionMatrixStereo
 
-  // Save OpenGL state
-  glPushAttrib(GL_ALL_ATTRIB_BITS);
+	// Save OpenGL state
+	glPushAttrib(GL_ALL_ATTRIB_BITS);
 
-  // Set neutral GL state
-  glDisable(GL_TEXTURE_1D);
-  glDisable(GL_TEXTURE_2D);
+	// Set neutral GL state
+	glDisable(GL_TEXTURE_1D);
+	glDisable(GL_TEXTURE_2D);
 #ifdef GL_TEXTURE_3D  // OpenGL 1.2 Only...
-  glDisable(GL_TEXTURE_3D);
+	glDisable(GL_TEXTURE_3D);
 #endif
 
-  glDisable(GL_TEXTURE_GEN_Q);
-  glDisable(GL_TEXTURE_GEN_R);
-  glDisable(GL_TEXTURE_GEN_S);
-  glDisable(GL_TEXTURE_GEN_T);
+	glDisable(GL_TEXTURE_GEN_Q);
+	glDisable(GL_TEXTURE_GEN_R);
+	glDisable(GL_TEXTURE_GEN_S);
+	glDisable(GL_TEXTURE_GEN_T);
 
 #ifdef GL_RESCALE_NORMAL  // OpenGL 1.2 Only...
-  glEnable(GL_RESCALE_NORMAL);
+	glEnable(GL_RESCALE_NORMAL);
 #endif
 
-  glDisable(GL_COLOR_MATERIAL);
-  qglColor(foregroundColor());
+	glDisable(GL_COLOR_MATERIAL);
+	qglColor(foregroundColor());
 
-  if (cameraIsEdited())
-    camera()-&gt;drawAllPaths();
+	if (cameraIsEdited())
+		camera()-&gt;drawAllPaths();
 
-  // Revolve Around Point, line when camera rolls, zoom region
-  drawVisualHints();
+	// Revolve Around Point, line when camera rolls, zoom region
+	drawVisualHints();
 
-  if (gridIsDrawn()) { glLineWidth(1.0); drawGrid(camera()-&gt;sceneRadius()); }
-  if (axisIsDrawn()) { glLineWidth(2.0); drawAxis(camera()-&gt;sceneRadius()); }
+	if (gridIsDrawn()) { glLineWidth(1.0); drawGrid(camera()-&gt;sceneRadius()); }
+	if (axisIsDrawn()) { glLineWidth(2.0); drawAxis(camera()-&gt;sceneRadius()); }
 
-  // FPS computation
-  const unsigned int maxCounter = 20;
-  if (++fpsCounter_ == maxCounter)
-    {
-      f_p_s_ = 1000.0 * maxCounter / fpsTime_.restart();
-      fpsString_ = QString(&quot;%1Hz&quot;).arg(f_p_s_, 0, 'f', ((f_p_s_ &lt; 10.0)?1:0));
-      fpsCounter_ = 0;
-    }
+	// FPS computation
+	const unsigned int maxCounter = 20;
+	if (++fpsCounter_ == maxCounter)
+	{
+		f_p_s_ = 1000.0 * maxCounter / fpsTime_.restart();
+		fpsString_ = tr(&quot;%1Hz&quot;, &quot;Frames per seconds, in Hertz&quot;).arg(f_p_s_, 0, 'f', ((f_p_s_ &lt; 10.0)?1:0));
+		fpsCounter_ = 0;
+	}
 
-  // Restore foregroundColor
-  float color[4];
-  color[0] = foregroundColor().red()   / 255.0;
-  color[1] = foregroundColor().green() / 255.0;
-  color[2] = foregroundColor().blue()  / 255.0;
-  color[3] = 1.0;
-  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
-  glDisable(GL_LIGHTING);
+	// Restore foregroundColor
+	float color[4];
+	color[0] = foregroundColor().red()   / 255.0;
+	color[1] = foregroundColor().green() / 255.0;
+	color[2] = foregroundColor().blue()  / 255.0;
+	color[3] = 1.0;
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+	glDisable(GL_LIGHTING);
 
-  if (FPSIsDisplayed()) displayFPS();
-  if (displayMessage_) drawText(10, height()-10,  message_);
+	if (FPSIsDisplayed()) displayFPS();
+	if (displayMessage_) drawText(10, height()-10,  message_);
 
-  // Restore GL state
-  glPopAttrib();
-  glPopMatrix();
+	// Restore GL state
+	glPopAttrib();
+	glPopMatrix();
 }
 
 /*! Called before draw() (instead of preDraw()) when viewer displaysInStereo().
 
- Same as preDraw() except that the glDrawBuffer() is set to \c GL_BACK_LEFT or \c GL_BACK_RIGHT
- depending on \p leftBuffer, and it uses qglviewer::Camera::loadProjectionMatrixStereo() and
- qglviewer::Camera::loadModelViewMatrixStereo() instead. */
+Same as preDraw() except that the glDrawBuffer() is set to \c GL_BACK_LEFT or \c GL_BACK_RIGHT
+depending on \p leftBuffer, and it uses qglviewer::Camera::loadProjectionMatrixStereo() and
+qglviewer::Camera::loadModelViewMatrixStereo() instead. */
 void QGLViewer::preDrawStereo(bool leftBuffer)
 {
-  // Set buffer to draw in
-  // Seems that SGI and Crystal Eyes are not synchronized correctly !
-  // That's why we don't draw in the appropriate buffer...
-  if (!leftBuffer)
-    glDrawBuffer(GL_BACK_LEFT);
-  else
-    glDrawBuffer(GL_BACK_RIGHT);
+	// Set buffer to draw in
+	// Seems that SGI and Crystal Eyes are not synchronized correctly !
+	// That's why we don't draw in the appropriate buffer...
+	if (!leftBuffer)
+		glDrawBuffer(GL_BACK_LEFT);
+	else
+		glDrawBuffer(GL_BACK_RIGHT);
 
-  // Clear the buffer where we're going to draw
-  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-  // GL_PROJECTION matrix
-  camera()-&gt;loadProjectionMatrixStereo(leftBuffer);
-  // GL_MODELVIEW matrix
-  camera()-&gt;loadModelViewMatrixStereo(leftBuffer);
+	// Clear the buffer where we're going to draw
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	// GL_PROJECTION matrix
+	camera()-&gt;loadProjectionMatrixStereo(leftBuffer);
+	// GL_MODELVIEW matrix
+	camera()-&gt;loadModelViewMatrixStereo(leftBuffer);
 
-  emit drawNeeded();
+	emit drawNeeded();
 }
 
 /*! Draws a simplified version of the scene to guarantee interactive camera displacements.
 
- This method is called instead of draw() when the qglviewer::Camera::frame() is
- qglviewer::ManipulatedCameraFrame::isManipulated(). Default implementation simply calls draw().
+This method is called instead of draw() when the qglviewer::Camera::frame() is
+qglviewer::ManipulatedCameraFrame::isManipulated(). Default implementation simply calls draw().
 
- Overload this method if your scene is too complex to allow for interactive camera manipulation. See
- the &lt;a href=&quot;../examples/fastDraw.html&quot;&gt;fastDraw example&lt;/a&gt; for an illustration. */
+Overload this method if your scene is too complex to allow for interactive camera manipulation. See
+the &lt;a href=&quot;../examples/fastDraw.html&quot;&gt;fastDraw example&lt;/a&gt; for an illustration. */
 void QGLViewer::fastDraw()
 {
-  draw();
+	draw();
 }
 
 /*! Starts (\p edit = \c true, default) or stops (\p edit=\c false) the edition of the camera().
 
- Current implementation is limited to paths display. Get current state using cameraIsEdited().
+Current implementation is limited to paths display. Get current state using cameraIsEdited().
 
- \attention This method sets the qglviewer::Camera::zClippingCoefficient() to 5.0 when \p edit is \c
- true, so that the Camera paths (see qglviewer::Camera::keyFrameInterpolator()) are not clipped. It
- restores the previous value when \p edit is \c false. */
+\attention This method sets the qglviewer::Camera::zClippingCoefficient() to 5.0 when \p edit is \c
+true, so that the Camera paths (see qglviewer::Camera::keyFrameInterpolator()) are not clipped. It
+restores the previous value when \p edit is \c false. */
 void QGLViewer::setCameraIsEdited(bool edit)
 {
-  cameraIsEdited_ = edit;
-  if (edit)
-    {
-      previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
-      // #CONNECTION# 5.0 also used in domElement() and in initFromDOMElement().
-      camera()-&gt;setZClippingCoefficient(5.0);
-    }
-  else
-    camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
+	cameraIsEdited_ = edit;
+	if (edit)
+	{
+		previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
+		// #CONNECTION# 5.0 also used in domElement() and in initFromDOMElement().
+		camera()-&gt;setZClippingCoefficient(5.0);
+	}
+	else
+		camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
 
-  emit cameraIsEditedChanged(edit);
+	emit cameraIsEditedChanged(edit);
 
-  if (updateGLOK_)
-    updateGL();
+	if (updateGLOK_)
+		updateGL();
 }
 
 // Key bindings. 0 means not defined
 void QGLViewer::setDefaultShortcuts()
 {
-  // D e f a u l t   a c c e l e r a t o r s
-  setShortcut(DRAW_AXIS,	Qt::Key_A);
-  setShortcut(DRAW_GRID,	Qt::Key_G);
-  setShortcut(DISPLAY_FPS,	Qt::Key_F);
-  setShortcut(ENABLE_TEXT,	Qt::SHIFT+Qt::Key_Question);
-  setShortcut(EXIT_VIEWER,	Qt::Key_Escape);
-  setShortcut(SAVE_SCREENSHOT,	Qt::CTRL+Qt::Key_S);
-  setShortcut(CAMERA_MODE,	Qt::Key_Space);
-  setShortcut(FULL_SCREEN,	Qt::ALT+Qt::Key_Return);
-  setShortcut(STEREO,		Qt::Key_S);
-  setShortcut(ANIMATION,	Qt::Key_Return);
-  setShortcut(HELP,		Qt::Key_H);
-  setShortcut(EDIT_CAMERA,	Qt::Key_C);
-  setShortcut(MOVE_CAMERA_LEFT,	Qt::Key_Left);
-  setShortcut(MOVE_CAMERA_RIGHT,Qt::Key_Right);
-  setShortcut(MOVE_CAMERA_UP,	Qt::Key_Up);
-  setShortcut(MOVE_CAMERA_DOWN,	Qt::Key_Down);
-  setShortcut(INCREASE_FLYSPEED,Qt::Key_Plus);
-  setShortcut(DECREASE_FLYSPEED,Qt::Key_Minus);
+	// D e f a u l t   a c c e l e r a t o r s
+	setShortcut(DRAW_AXIS,	Qt::Key_A);
+	setShortcut(DRAW_GRID,	Qt::Key_G);
+	setShortcut(DISPLAY_FPS,	Qt::Key_F);
+	setShortcut(ENABLE_TEXT,	Qt::SHIFT+Qt::Key_Question);
+	setShortcut(EXIT_VIEWER,	Qt::Key_Escape);
+	setShortcut(SAVE_SCREENSHOT,	Qt::CTRL+Qt::Key_S);
+	setShortcut(CAMERA_MODE,	Qt::Key_Space);
+	setShortcut(FULL_SCREEN,	Qt::ALT+Qt::Key_Return);
+	setShortcut(STEREO,		Qt::Key_S);
+	setShortcut(ANIMATION,	Qt::Key_Return);
+	setShortcut(HELP,		Qt::Key_H);
+	setShortcut(EDIT_CAMERA,	Qt::Key_C);
+	setShortcut(MOVE_CAMERA_LEFT,	Qt::Key_Left);
+	setShortcut(MOVE_CAMERA_RIGHT,Qt::Key_Right);
+	setShortcut(MOVE_CAMERA_UP,	Qt::Key_Up);
+	setShortcut(MOVE_CAMERA_DOWN,	Qt::Key_Down);
+	setShortcut(INCREASE_FLYSPEED,Qt::Key_Plus);
+	setShortcut(DECREASE_FLYSPEED,Qt::Key_Minus);
 
-  keyboardActionDescription_[DISPLAY_FPS] = 		&quot;Toggles the display of the FPS&quot;;
-  keyboardActionDescription_[SAVE_SCREENSHOT] = 	&quot;Saves a screenshot&quot;;
-  keyboardActionDescription_[FULL_SCREEN] = 		&quot;Toggles full screen display&quot;;
-  keyboardActionDescription_[DRAW_AXIS] = 		&quot;Toggles the display of the world axis&quot;;
-  keyboardActionDescription_[DRAW_GRID] = 		&quot;Toggles the display of the XY grid&quot;;
-  keyboardActionDescription_[CAMERA_MODE] = 		&quot;Changes camera mode (revolve or fly)&quot;;
-  keyboardActionDescription_[STEREO] = 			&quot;Toggles stereo display&quot;;
-  keyboardActionDescription_[HELP] = 			&quot;Opens this help window&quot;;
-  keyboardActionDescription_[ANIMATION] = 		&quot;Starts/stops the animation&quot;;
-  keyboardActionDescription_[EDIT_CAMERA] = 		&quot;Toggles camera paths display&quot;; // TODO change
-  keyboardActionDescription_[ENABLE_TEXT] = 		&quot;Toggles the display of the text&quot;;
-  keyboardActionDescription_[EXIT_VIEWER] =		&quot;Exits program&quot;;
-  keyboardActionDescription_[MOVE_CAMERA_LEFT] = 	&quot;Moves camera left&quot;;
-  keyboardActionDescription_[MOVE_CAMERA_RIGHT] = 	&quot;Moves camera right&quot;;
-  keyboardActionDescription_[MOVE_CAMERA_UP] = 		&quot;Moves camera up&quot;;
-  keyboardActionDescription_[MOVE_CAMERA_DOWN] = 	&quot;Moves camera down&quot;;
-  keyboardActionDescription_[INCREASE_FLYSPEED] = 	&quot;Increases fly speed&quot;;
-  keyboardActionDescription_[DECREASE_FLYSPEED] = 	&quot;Decreases fly speed&quot;;
+	keyboardActionDescription_[DISPLAY_FPS] = tr(&quot;Toggles the display of the FPS&quot;, &quot;DISPLAY_FPS action description&quot;);
+	keyboardActionDescription_[SAVE_SCREENSHOT] = tr(&quot;Saves a screenshot&quot;, &quot;SAVE_SCREENSHOT action description&quot;);
+	keyboardActionDescription_[FULL_SCREEN] = tr(&quot;Toggles full screen display&quot;, &quot;FULL_SCREEN action description&quot;);
+	keyboardActionDescription_[DRAW_AXIS] = tr(&quot;Toggles the display of the world axis&quot;, &quot;DRAW_AXIS action description&quot;);
+	keyboardActionDescription_[DRAW_GRID] = tr(&quot;Toggles the display of the XY grid&quot;, &quot;DRAW_GRID action description&quot;);
+	keyboardActionDescription_[CAMERA_MODE] = tr(&quot;Changes camera mode (revolve or fly)&quot;, &quot;CAMERA_MODE action description&quot;);
+	keyboardActionDescription_[STEREO] = tr(&quot;Toggles stereo display&quot;, &quot;STEREO action description&quot;);
+	keyboardActionDescription_[HELP] = tr(&quot;Opens this help window&quot;, &quot;HELP action description&quot;);
+	keyboardActionDescription_[ANIMATION] = tr(&quot;Starts/stops the animation&quot;, &quot;ANIMATION action description&quot;);
+	keyboardActionDescription_[EDIT_CAMERA] = tr(&quot;Toggles camera paths display&quot;, &quot;EDIT_CAMERA action description&quot;); // TODO change
+	keyboardActionDescription_[ENABLE_TEXT] = tr(&quot;Toggles the display of the text&quot;, &quot;ENABLE_TEXT action description&quot;);
+	keyboardActionDescription_[EXIT_VIEWER] = tr(&quot;Exits program&quot;, &quot;EXIT_VIEWER action description&quot;);
+	keyboardActionDescription_[MOVE_CAMERA_LEFT] = tr(&quot;Moves camera left&quot;, &quot;MOVE_CAMERA_LEFT action description&quot;);
+	keyboardActionDescription_[MOVE_CAMERA_RIGHT] = tr(&quot;Moves camera right&quot;, &quot;MOVE_CAMERA_RIGHT action description&quot;);
+	keyboardActionDescription_[MOVE_CAMERA_UP] = tr(&quot;Moves camera up&quot;, &quot;MOVE_CAMERA_UP action description&quot;);
+	keyboardActionDescription_[MOVE_CAMERA_DOWN] = tr(&quot;Moves camera down&quot;, &quot;MOVE_CAMERA_DOWN action description&quot;);
+	keyboardActionDescription_[INCREASE_FLYSPEED] = tr(&quot;Increases fly speed&quot;, &quot;INCREASE_FLYSPEED action description&quot;);
+	keyboardActionDescription_[DECREASE_FLYSPEED] = tr(&quot;Decreases fly speed&quot;, &quot;DECREASE_FLYSPEED action description&quot;);
 
-  // K e y f r a m e s   s h o r t c u t   k e y s
-  setPathKey(Qt::Key_F1,   1);
-  setPathKey(Qt::Key_F2,   2);
-  setPathKey(Qt::Key_F3,   3);
-  setPathKey(Qt::Key_F4,   4);
-  setPathKey(Qt::Key_F5,   5);
-  setPathKey(Qt::Key_F6,   6);
-  setPathKey(Qt::Key_F7,   7);
-  setPathKey(Qt::Key_F8,   8);
-  setPathKey(Qt::Key_F9,   9);
-  setPathKey(Qt::Key_F10, 10);
-  setPathKey(Qt::Key_F11, 11);
-  setPathKey(Qt::Key_F12, 12);
+	// K e y f r a m e s   s h o r t c u t   k e y s
+	setPathKey(Qt::Key_F1,   1);
+	setPathKey(Qt::Key_F2,   2);
+	setPathKey(Qt::Key_F3,   3);
+	setPathKey(Qt::Key_F4,   4);
+	setPathKey(Qt::Key_F5,   5);
+	setPathKey(Qt::Key_F6,   6);
+	setPathKey(Qt::Key_F7,   7);
+	setPathKey(Qt::Key_F8,   8);
+	setPathKey(Qt::Key_F9,   9);
+	setPathKey(Qt::Key_F10, 10);
+	setPathKey(Qt::Key_F11, 11);
+	setPathKey(Qt::Key_F12, 12);
 
 #if QT_VERSION &gt;= 0x040000
-  setAddKeyFrameKeyboardModifiers(Qt::AltModifier);
-  setPlayPathKeyboardModifiers(Qt::NoModifier);
+	setAddKeyFrameKeyboardModifiers(Qt::AltModifier);
+	setPlayPathKeyboardModifiers(Qt::NoModifier);
 #else
-  setAddKeyFrameKeyboardModifiers(Qt::AltButton);
-  setPlayPathKeyboardModifiers(Qt::NoButton);
+	setAddKeyFrameKeyboardModifiers(Qt::AltButton);
+	setPlayPathKeyboardModifiers(Qt::NoButton);
 #endif
 }
 
@@ -644,56 +652,56 @@
 void QGLViewer::setDefaultMouseBindings()
 {
 #if QT_VERSION &gt;= 0x040000
-  const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlModifier;
+	const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlModifier;
 #else
-  const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlButton;
+	const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlButton;
 #endif
-  //#CONNECTION# toggleCameraMode()
-  for (int handler=0; handler&lt;2; ++handler)
-    {
-      MouseHandler mh = (MouseHandler)(handler);
+	//#CONNECTION# toggleCameraMode()
+	for (int handler=0; handler&lt;2; ++handler)
+	{
+		MouseHandler mh = (MouseHandler)(handler);
 #if QT_VERSION &gt;= 0x040000
-      QtKeyboardModifiers modifiers = Qt::NoModifier;
+		QtKeyboardModifiers modifiers = Qt::NoModifier;
 #else
-      QtKeyboardModifiers modifiers = Qt::NoButton;
+		QtKeyboardModifiers modifiers = Qt::NoButton;
 #endif
-      if (mh == FRAME)
-	modifiers = frameKeyboardModifiers;
+		if (mh == FRAME)
+			modifiers = frameKeyboardModifiers;
 
-      setMouseBinding(modifiers | Qt::LeftButton,  mh, ROTATE);
-      setMouseBinding(modifiers | Qt::MidButton,   mh, ZOOM);
-      setMouseBinding(modifiers | Qt::RightButton, mh, TRANSLATE);
+		setMouseBinding(modifiers | Qt::LeftButton,  mh, ROTATE);
+		setMouseBinding(modifiers | Qt::MidButton,   mh, ZOOM);
+		setMouseBinding(modifiers | Qt::RightButton, mh, TRANSLATE);
 
-      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  mh, SCREEN_ROTATE);
-      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  mh, SCREEN_TRANSLATE);
+		setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  mh, SCREEN_ROTATE);
+		// 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  mh, SCREEN_TRANSLATE);
 
-      setWheelBinding(modifiers, mh, ZOOM);
-    }
+		setWheelBinding(modifiers, mh, ZOOM);
+	}
 
 #if QT_VERSION &gt;= 0x040000
-  // Z o o m   o n   r e g i o n
-  setMouseBinding(Qt::ShiftModifier | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
-  // S e l e c t
-  setMouseBinding(Qt::ShiftModifier | Qt::LeftButton, SELECT);
+	// Z o o m   o n   r e g i o n
+	setMouseBinding(Qt::ShiftModifier | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
+	// S e l e c t
+	setMouseBinding(Qt::ShiftModifier | Qt::LeftButton, SELECT);
 #else
-  setMouseBinding(Qt::ShiftButton | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
-  setMouseBinding(Qt::ShiftButton | Qt::LeftButton, SELECT);
+	setMouseBinding(Qt::ShiftButton | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
+	setMouseBinding(Qt::ShiftButton | Qt::LeftButton, SELECT);
 #endif
 
 
-  // D o u b l e   c l i c k
-  setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
-  setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
-  setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
+	// D o u b l e   c l i c k
+	setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
+	setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
+	setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
 
-  setMouseBinding(frameKeyboardModifiers | Qt::LeftButton,  ALIGN_FRAME,  true);
-  setMouseBinding(frameKeyboardModifiers | Qt::RightButton, CENTER_FRAME, true);
+	setMouseBinding(frameKeyboardModifiers | Qt::LeftButton,  ALIGN_FRAME,  true);
+	setMouseBinding(frameKeyboardModifiers | Qt::RightButton, CENTER_FRAME, true);
 
-  // S p e c i f i c   d o u b l e   c l i c k s
-  setMouseBinding(Qt::LeftButton,  RAP_FROM_PIXEL, true, Qt::RightButton);
-  setMouseBinding(Qt::RightButton, RAP_IS_CENTER,  true, Qt::LeftButton);
-  setMouseBinding(Qt::LeftButton,  ZOOM_ON_PIXEL,  true, Qt::MidButton);
-  setMouseBinding(Qt::RightButton, ZOOM_TO_FIT,    true, Qt::MidButton);
+	// S p e c i f i c   d o u b l e   c l i c k s
+	setMouseBinding(Qt::LeftButton,  RAP_FROM_PIXEL, true, Qt::RightButton);
+	setMouseBinding(Qt::RightButton, RAP_IS_CENTER,  true, Qt::LeftButton);
+	setMouseBinding(Qt::LeftButton,  ZOOM_ON_PIXEL,  true, Qt::MidButton);
+	setMouseBinding(Qt::RightButton, ZOOM_TO_FIT,    true, Qt::MidButton);
 }
 
 /*! Associates a new qglviewer::Camera to the viewer.
@@ -714,203 +722,203 @@
 The connections with the previous viewer's camera are removed. */
 void QGLViewer::setCamera(Camera* const camera)
 {
-  if (!camera)
-    return;
+	if (!camera)
+		return;
 
-  camera-&gt;setSceneRadius(sceneRadius());
-  camera-&gt;setSceneCenter(sceneCenter());
-  camera-&gt;setScreenWidthAndHeight(width(),height());
+	camera-&gt;setSceneRadius(sceneRadius());
+	camera-&gt;setSceneCenter(sceneCenter());
+	camera-&gt;setScreenWidthAndHeight(width(),height());
 
-  // Disconnect current camera to this viewer.
-  disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
-  disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(spun()), this, SLOT(updateGL()));
+	// Disconnect current camera to this viewer.
+	disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
+	disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(spun()), this, SLOT(updateGL()));
 
-  // Connect camera frame to this viewer.
-  connect(camera-&gt;frame(), SIGNAL(manipulated()), SLOT(updateGL()));
-  connect(camera-&gt;frame(), SIGNAL(spun()), SLOT(updateGL()));
+	// Connect camera frame to this viewer.
+	connect(camera-&gt;frame(), SIGNAL(manipulated()), SLOT(updateGL()));
+	connect(camera-&gt;frame(), SIGNAL(spun()), SLOT(updateGL()));
 
-  connectAllCameraKFIInterpolatedSignals(false);
-  camera_ = camera;
-  connectAllCameraKFIInterpolatedSignals();
+	connectAllCameraKFIInterpolatedSignals(false);
+	camera_ = camera;
+	connectAllCameraKFIInterpolatedSignals();
 
-  previousCameraZClippingCoefficient_ = this-&gt;camera()-&gt;zClippingCoefficient();
+	previousCameraZClippingCoefficient_ = this-&gt;camera()-&gt;zClippingCoefficient();
 }
 
 void QGLViewer::connectAllCameraKFIInterpolatedSignals(bool connection)
 {
-  for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = camera()-&gt;kfi_.begin(), end=camera()-&gt;kfi_.end(); it != end; ++it)
-    {
-      if (connection)
-	connect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), SLOT(updateGL()));
-      else
-	disconnect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), this, SLOT(updateGL()));
-    }
+	for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = camera()-&gt;kfi_.begin(), end=camera()-&gt;kfi_.end(); it != end; ++it)
+	{
+		if (connection)
+			connect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), SLOT(updateGL()));
+		else
+			disconnect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), this, SLOT(updateGL()));
+	}
 
-  if (connection)
-    connect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), SLOT(updateGL()));
-  else
-    disconnect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), this, SLOT(updateGL()));
+	if (connection)
+		connect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), SLOT(updateGL()));
+	else
+		disconnect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), this, SLOT(updateGL()));
 }
 
 /*! Draws a representation of \p light.
 
- Called in draw(), this method is useful to debug or display your light setup. Light drawing depends
- on the type of light (point, spot, directional).
+Called in draw(), this method is useful to debug or display your light setup. Light drawing depends
+on the type of light (point, spot, directional).
 
- The method retrieves the light setup using \c glGetLightfv. Position and define your lights before
- calling this method.
+The method retrieves the light setup using \c glGetLightfv. Position and define your lights before
+calling this method.
 
- Light is drawn using its diffuse color. Disabled lights are not displayed.
+Light is drawn using its diffuse color. Disabled lights are not displayed.
 
- Drawing size is proportional to sceneRadius(). Use \p scale to rescale it.
+Drawing size is proportional to sceneRadius(). Use \p scale to rescale it.
 
- See the &lt;a href=&quot;../examples/drawLight.html&quot;&gt;drawLight example&lt;/a&gt; for an illustration.
+See the &lt;a href=&quot;../examples/drawLight.html&quot;&gt;drawLight example&lt;/a&gt; for an illustration.
 
- \attention You need to enable \c GL_COLOR_MATERIAL before calling this method. \c glColor is set to
- the light diffuse color. */
+\attention You need to enable \c GL_COLOR_MATERIAL before calling this method. \c glColor is set to
+the light diffuse color. */
 void QGLViewer::drawLight(GLenum light, float scale) const
 {
-  static GLUquadric* quadric = gluNewQuadric();
+	static GLUquadric* quadric = gluNewQuadric();
 
-  const float length = sceneRadius() / 5.0 * scale;
+	const float length = sceneRadius() / 5.0 * scale;
 
-  GLboolean lightIsOn;
-  glGetBooleanv(light, &amp;lightIsOn);
+	GLboolean lightIsOn;
+	glGetBooleanv(light, &amp;lightIsOn);
 
-  if (lightIsOn)
-    {
-      // All light values are given in eye coordinates
-      glPushMatrix();
-      glLoadIdentity();
+	if (lightIsOn)
+	{
+		// All light values are given in eye coordinates
+		glPushMatrix();
+		glLoadIdentity();
 
-      float color[4];
-      glGetLightfv(light, GL_DIFFUSE, color);
-      glColor4fv(color);
+		float color[4];
+		glGetLightfv(light, GL_DIFFUSE, color);
+		glColor4fv(color);
 
-      float pos[4];
-      glGetLightfv(light, GL_POSITION, pos);
+		float pos[4];
+		glGetLightfv(light, GL_POSITION, pos);
 
-      if (pos[3] != 0.0)
-	{
-	  glTranslatef(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
+		if (pos[3] != 0.0)
+		{
+			glTranslatef(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
 
-	  GLfloat cutOff;
-	  glGetLightfv(light, GL_SPOT_CUTOFF, &amp;cutOff);
-	  if (cutOff != 180.0)
-	    {
-	      GLfloat dir[4];
-	      glGetLightfv(light, GL_SPOT_DIRECTION, dir);
-	      glMultMatrixd(Quaternion(Vec(0,0,1), Vec(dir)).matrix());
-	      QGLViewer::drawArrow(length);
-	      gluCylinder(quadric, 0.0, 0.7 * length * sin(cutOff * M_PI / 180.0), 0.7 * length * cos(cutOff * M_PI / 180.0), 12, 1);
-	    }
-	  else
-	    gluSphere(quadric, 0.2*length, 10, 10);
+			GLfloat cutOff;
+			glGetLightfv(light, GL_SPOT_CUTOFF, &amp;cutOff);
+			if (cutOff != 180.0)
+			{
+				GLfloat dir[4];
+				glGetLightfv(light, GL_SPOT_DIRECTION, dir);
+				glMultMatrixd(Quaternion(Vec(0,0,1), Vec(dir)).matrix());
+				QGLViewer::drawArrow(length);
+				gluCylinder(quadric, 0.0, 0.7 * length * sin(cutOff * M_PI / 180.0), 0.7 * length * cos(cutOff * M_PI / 180.0), 12, 1);
+			}
+			else
+				gluSphere(quadric, 0.2*length, 10, 10);
+		}
+		else
+		{
+			// Directional light.
+			Vec dir(pos[0], pos[1], pos[2]);
+			dir.normalize();
+			Frame fr=Frame(camera()-&gt;cameraCoordinatesOf(4.0 * length * camera()-&gt;frame()-&gt;inverseTransformOf(dir)),
+				Quaternion(Vec(0,0,-1), dir));
+			glMultMatrixd(fr.matrix());
+			drawArrow(length);
+		}
+
+		glPopMatrix();
 	}
-      else
-	{
-	  // Directional light.
-	  Vec dir(pos[0], pos[1], pos[2]);
-	  dir.normalize();
-	  Frame fr=Frame(camera()-&gt;cameraCoordinatesOf(4.0 * length * camera()-&gt;frame()-&gt;inverseTransformOf(dir)),
-			 Quaternion(Vec(0,0,-1), dir));
-	  glMultMatrixd(fr.matrix());
-	  drawArrow(length);
-	}
-
-      glPopMatrix();
-    }
 }
 
 
 /*! Draws \p text at position \p x, \p y (expressed in screen coordinates pixels, origin in the
-  upper left corner of the widget).
+upper left corner of the widget).
 
-  The default QApplication::font() is used to render the text when no \p fnt is specified. Use
-  QApplication::setFont() to define this default font.
+The default QApplication::font() is used to render the text when no \p fnt is specified. Use
+QApplication::setFont() to define this default font.
 
-  You should disable \c GL_LIGHTING before this method so that colors are properly rendered.
+You should disable \c GL_LIGHTING before this method so that colors are properly rendered.
 
-  This method can be used in conjunction with the qglviewer::Camera::projectedCoordinatesOf()
-  method to display a text attached to an object. In your draw() method use:
-  \code
-  qglviewer::Vec screenPos = camera()-&gt;projectedCoordinatesOf(myFrame.position());
-  drawText((int)screenPos[0], (int)screenPos[1], &quot;My Object&quot;);
-  \endcode
-  See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem example&lt;/a&gt; for an illustration.
+This method can be used in conjunction with the qglviewer::Camera::projectedCoordinatesOf()
+method to display a text attached to an object. In your draw() method use:
+\code
+qglviewer::Vec screenPos = camera()-&gt;projectedCoordinatesOf(myFrame.position());
+drawText((int)screenPos[0], (int)screenPos[1], &quot;My Object&quot;);
+\endcode
+See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem example&lt;/a&gt; for an illustration.
 
-  Text is displayed only when textIsEnabled() (default). This mechanism allows the user to
-  conveniently remove all the displayed text with a single keyboard shortcut.
+Text is displayed only when textIsEnabled() (default). This mechanism allows the user to
+conveniently remove all the displayed text with a single keyboard shortcut.
 
-  Use displayMessage() to drawText() for only a short amount of time.
+Use displayMessage() to drawText() for only a short amount of time.
 
-  Use the QGLWidget::renderText(x,y,z, text) method (Qt version &gt;= 3.1) to draw a text (fixed size,
-  facing the camera) located at a specific 3D position instead of 2D screen coordinates.
+Use the QGLWidget::renderText(x,y,z, text) method (Qt version &gt;= 3.1) to draw a text (fixed size,
+facing the camera) located at a specific 3D position instead of 2D screen coordinates.
 
-  The \c GL_MODELVIEW and \c GL_PROJECTION matrices are not modified by this method.
+The \c GL_MODELVIEW and \c GL_PROJECTION matrices are not modified by this method.
 
-  \attention This method uses display lists to render the characters, with an index that starts at
-  2000 by default (see the QGLWidget::renderText() documentation). If you use more than 2000 Display
-  Lists, they may overlap with these. Directly use QGLWidget::renderText() in that case, with a
-  higher \c listBase parameter (or overload &lt;code&gt;fontDisplayListBase&lt;/code&gt; with Qt4).
+\attention This method uses display lists to render the characters, with an index that starts at
+2000 by default (see the QGLWidget::renderText() documentation). If you use more than 2000 Display
+Lists, they may overlap with these. Directly use QGLWidget::renderText() in that case, with a
+higher \c listBase parameter (or overload &lt;code&gt;fontDisplayListBase&lt;/code&gt; with Qt4).
 
-  \attention There is a problem with anti-aliased font with nVidia cards and Qt versions lower than
-  3.3. Until this version, the \p fnt parameter is not taken into account to prevent a crash. It is
-  replaced by a fixed font that should be compatible with the \c qtconfig anti-aliased font
-  configuration (disable this option otherwise).
+\attention There is a problem with anti-aliased font with nVidia cards and Qt versions lower than
+3.3. Until this version, the \p fnt parameter is not taken into account to prevent a crash. It is
+replaced by a fixed font that should be compatible with the \c qtconfig anti-aliased font
+configuration (disable this option otherwise).
 
-  \note This method uses QGLWidget::renderText() if your Qt version is greater or equal to 3.1,
-  otherwise it uses (and requires) GLUT. When GLUT is used, only the \p fnt size attribute (set with
-  QFont::setPixelSize() or QFont::setPointSize()) is taken into account. Also note that in that case
-  each call to drawText() changes the camera projection matrix and restores it back (using
-  startScreenCoordinatesSystem() and stopScreenCoordinatesSystem()). If you call this method several
-  times and it slows down your frame rate, consider factorizing the context changes. */
+\note This method uses QGLWidget::renderText() if your Qt version is greater or equal to 3.1,
+otherwise it uses (and requires) GLUT. When GLUT is used, only the \p fnt size attribute (set with
+QFont::setPixelSize() or QFont::setPointSize()) is taken into account. Also note that in that case
+each call to drawText() changes the camera projection matrix and restores it back (using
+startScreenCoordinatesSystem() and stopScreenCoordinatesSystem()). If you call this method several
+times and it slows down your frame rate, consider factorizing the context changes. */
 void QGLViewer::drawText(int x, int y, const QString&amp; text, const QFont&amp; fnt)
 {
-  if (!textIsEnabled())
-    return;
+	if (!textIsEnabled())
+		return;
 
 #if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
-  const GLfloat font_scale = 119.05f - 33.33f; // see glutStrokeCharacter man page
+	const GLfloat font_scale = 119.05f - 33.33f; // see glutStrokeCharacter man page
 
-  startScreenCoordinatesSystem();
+	startScreenCoordinatesSystem();
 
-  // Anti-aliased characters
-  glPushAttrib(GL_ALL_ATTRIB_BITS);
-  glDisable(GL_LIGHTING);
-  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-  glEnable(GL_BLEND);
-  glDisable(GL_DEPTH_TEST);
-  glEnable(GL_LINE_SMOOTH);
-  glLineWidth(1.0);
+	// Anti-aliased characters
+	glPushAttrib(GL_ALL_ATTRIB_BITS);
+	glDisable(GL_LIGHTING);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	glEnable(GL_BLEND);
+	glDisable(GL_DEPTH_TEST);
+	glEnable(GL_LINE_SMOOTH);
+	glLineWidth(1.0);
 
-  glTranslatef((GLfloat)x, (GLfloat)y, 0.0);
-  const GLfloat scale = ((fnt.pixelSize()&gt;0)?fnt.pixelSize():fnt.pointSize()) / font_scale;
-  glScalef(scale, -scale, scale);
+	glTranslatef((GLfloat)x, (GLfloat)y, 0.0);
+	const GLfloat scale = ((fnt.pixelSize()&gt;0)?fnt.pixelSize():fnt.pointSize()) / font_scale;
+	glScalef(scale, -scale, scale);
 
-  for (uint i=0; i&lt;text.length(); ++i)
-    glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
+	for (uint i=0; i&lt;text.length(); ++i)
+		glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
 
-  glPopAttrib();
+	glPopAttrib();
 
-  stopScreenCoordinatesSystem();
+	stopScreenCoordinatesSystem();
 
 #else
 
 # if QT_VERSION &lt; 0x030300 &amp;&amp; defined Q_OS_UNIX
-  // Fix bug with anti-aliased fonts on nVidia driver
-  QFont newFont(fnt);
-  newFont.setFamily(&quot;fixed&quot;);
-  newFont.setRawMode(true);
-  newFont.setPixelSize(10);
-  newFont.setFixedPitch(true);
+	// Fix bug with anti-aliased fonts on nVidia driver
+	QFont newFont(fnt);
+	newFont.setFamily(&quot;fixed&quot;);
+	newFont.setRawMode(true);
+	newFont.setPixelSize(10);
+	newFont.setFixedPitch(true);
 #  if QT_VERSION &gt;= 0x030200
-  newFont.setStyleStrategy(QFont::OpenGLCompatible);
+	newFont.setStyleStrategy(QFont::OpenGLCompatible);
 #  endif
-  newFont.setStyleHint(QFont::AnyStyle, QFont::PreferBitmap);
-  renderText(x, y, text, newFont);
+	newFont.setStyleHint(QFont::AnyStyle, QFont::PreferBitmap);
+	renderText(x, y, text, newFont);
 # else
-  renderText(x, y, text, fnt);
+	renderText(x, y, text, fnt);
 # endif
 
 #endif
@@ -930,193 +938,193 @@
 
 See the &lt;a href=&quot;../examples/draw3DText.html&quot;&gt;draw3DText example&lt;/a&gt; for an illustration. */
 /*
- void QGLViewer::draw3DText(const Vec&amp; pos, const Vec&amp; normal, const QString&amp; text, GLfloat height)
- {
- #if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
- if (!textIsEnabled())
- return;
+void QGLViewer::draw3DText(const Vec&amp; pos, const Vec&amp; normal, const QString&amp; text, GLfloat height)
+{
+#if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
+if (!textIsEnabled())
+return;
 
- glMatrixMode(GL_MODELVIEW) ;
- glPushMatrix() ;
+glMatrixMode(GL_MODELVIEW) ;
+glPushMatrix() ;
 
- const GLfloat font_scale = (119.05f - 33.33f) / 8; // see glutStrokeCharacter man page
- // const GLfloat font_scale = (119.05f - 33.33f) * 15.0f; // see glutStrokeCharacter man page
+const GLfloat font_scale = (119.05f - 33.33f) / 8; // see glutStrokeCharacter man page
+// const GLfloat font_scale = (119.05f - 33.33f) * 15.0f; // see glutStrokeCharacter man page
 
- static GLfloat lineWidth;
- glGetFloatv(GL_LINE_WIDTH, &amp;lineWidth);
+static GLfloat lineWidth;
+glGetFloatv(GL_LINE_WIDTH, &amp;lineWidth);
 
- glTranslatef(pos.x, pos.y, pos.z);
- glMultMatrixd(Quaternion(Vec(0.0, 0.0, 1.0), normal).matrix());
+glTranslatef(pos.x, pos.y, pos.z);
+glMultMatrixd(Quaternion(Vec(0.0, 0.0, 1.0), normal).matrix());
 
- glLineWidth(2.0);
+glLineWidth(2.0);
 
- glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
- glEnable(GL_BLEND);
- glEnable(GL_LINE_SMOOTH);
+glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+glEnable(GL_BLEND);
+glEnable(GL_LINE_SMOOTH);
 
- const GLfloat scale = height / font_scale;
- glScalef(scale, scale, scale);
+const GLfloat scale = height / font_scale;
+glScalef(scale, scale, scale);
 
- for (uint i=0; i&lt;text.length(); ++i)
- glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
+for (uint i=0; i&lt;text.length(); ++i)
+glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
 
- glLineWidth(lineWidth);
+glLineWidth(lineWidth);
 
- glMatrixMode(GL_MODELVIEW);
- glPopMatrix() ;
- #else
- static bool displayed = false;
+glMatrixMode(GL_MODELVIEW);
+glPopMatrix() ;
+#else
+static bool displayed = false;
 
- if (!displayed)
- {
-   qWarning(&quot;draw3DText is not supported with Qt &gt;= 3.1.&quot;);
-   qWarning(&quot;Use QGLWidget::renderText() instead,&quot;);
-   qWarning(&quot;or use the glut glutStrokeCharacter() method.&quot;);
-   displayed = true;
- }
+if (!displayed)
+{
+qWarning(&quot;draw3DText is not supported with Qt &gt;= 3.1.&quot;);
+qWarning(&quot;Use QGLWidget::renderText() instead,&quot;);
+qWarning(&quot;or use the glut glutStrokeCharacter() method.&quot;);
+displayed = true;
+}
 
-  Q_UNUSED(pos)
-    Q_UNUSED(normal)
-    Q_UNUSED(text)
-    Q_UNUSED(height)
- #endif
- }
+Q_UNUSED(pos)
+Q_UNUSED(normal)
+Q_UNUSED(text)
+Q_UNUSED(height)
+#endif
+}
 */
 
 /*! Briefly displays a message in the lower left corner of the widget. Convenient to provide
- feedback to the user.
+feedback to the user.
 
- \p message is displayed during \p delay milliseconds (default is 2 seconds) using drawText().
+\p message is displayed during \p delay milliseconds (default is 2 seconds) using drawText().
 
- This method should not be called in draw(). If you want to display a text in each draw(), use
- drawText() instead.
+This method should not be called in draw(). If you want to display a text in each draw(), use
+drawText() instead.
 
- If this method is called when a message is already displayed, the new message replaces the old one.
- Use setTextIsEnabled() (default shortcut is '?') to enable or disable text (and hence messages)
- display. */
+If this method is called when a message is already displayed, the new message replaces the old one.
+Use setTextIsEnabled() (default shortcut is '?') to enable or disable text (and hence messages)
+display. */
 void QGLViewer::displayMessage(const QString&amp; message, int delay)
 {
-  message_ = message;
-  displayMessage_ = true;
+	message_ = message;
+	displayMessage_ = true;
 #if QT_VERSION &gt;= 0x040000
-  // Was set to single shot in defaultConstructor.
-  messageTimer_.start(delay);
+	// Was set to single shot in defaultConstructor.
+	messageTimer_.start(delay);
 #else
-  if (messageTimer_.isActive())
-    messageTimer_.changeInterval(delay);
-  else
-    messageTimer_.start(delay, true);
+	if (messageTimer_.isActive())
+		messageTimer_.changeInterval(delay);
+	else
+		messageTimer_.start(delay, true);
 #endif
-  if (textIsEnabled() &amp;&amp; updateGLOK_)
-    updateGL();
+	if (textIsEnabled() &amp;&amp; updateGLOK_)
+		updateGL();
 }
 
 void QGLViewer::hideMessage()
 {
-  displayMessage_ = false;
-  if (textIsEnabled())
-    updateGL();
+	displayMessage_ = false;
+	if (textIsEnabled())
+		updateGL();
 }
 
 
 /*! Displays the averaged currentFPS() frame rate in the upper left corner of the widget.
 
- updateGL() should be called in a loop in order to have a meaningful value (this is the case when
- you continuously move the camera using the mouse or when animationIsStarted()).
- setAnimationPeriod(0) to make this loop as fast as possible in order to reach and measure the
- maximum available frame rate.
+updateGL() should be called in a loop in order to have a meaningful value (this is the case when
+you continuously move the camera using the mouse or when animationIsStarted()).
+setAnimationPeriod(0) to make this loop as fast as possible in order to reach and measure the
+maximum available frame rate.
 
- When FPSIsDisplayed() is \c true (default is \c false), this method is called by postDraw() to
- display the currentFPS(). Use QApplication::setFont() to define the font (see drawText()). */
+When FPSIsDisplayed() is \c true (default is \c false), this method is called by postDraw() to
+display the currentFPS(). Use QApplication::setFont() to define the font (see drawText()). */
 void QGLViewer::displayFPS()
 {
-  drawText(10, int(1.5*((QApplication::font().pixelSize()&gt;0)?QApplication::font().pixelSize():QApplication::font().pointSize())), fpsString_);
+	drawText(10, int(1.5*((QApplication::font().pixelSize()&gt;0)?QApplication::font().pixelSize():QApplication::font().pointSize())), fpsString_);
 }
 
 /*! Modify the projection matrix so that drawing can be done directly with 2D screen coordinates.
 
- Once called, the \p x and \p y coordinates passed to \c glVertex are expressed in pixels screen
- coordinates. The origin (0,0) is in the upper left corner of the widget by default. This follows
- the Qt standards, so that you can directly use the \c pos() provided by for instance \c
- QMouseEvent. Set \p upward to \c true to place the origin in the \e lower left corner, thus
- following the OpenGL and mathematical standards. It is always possible to switch between the two
- representations using \c newY = height() - \c y.
+Once called, the \p x and \p y coordinates passed to \c glVertex are expressed in pixels screen
+coordinates. The origin (0,0) is in the upper left corner of the widget by default. This follows
+the Qt standards, so that you can directly use the \c pos() provided by for instance \c
+QMouseEvent. Set \p upward to \c true to place the origin in the \e lower left corner, thus
+following the OpenGL and mathematical standards. It is always possible to switch between the two
+representations using \c newY = height() - \c y.
 
- You need to call stopScreenCoordinatesSystem() at the end of the drawing block to restore the
- previous camera matrix.
+You need to call stopScreenCoordinatesSystem() at the end of the drawing block to restore the
+previous camera matrix.
 
- In practice, this method should be used in draw(). It sets an appropriate orthographic projection
- matrix and then sets \c glMatrixMode to \c GL_MODELVIEW.
+In practice, this method should be used in draw(). It sets an appropriate orthographic projection
+matrix and then sets \c glMatrixMode to \c GL_MODELVIEW.
 
- See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt;, &lt;a
- href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
- href=&quot;../examples/contribs.html#backgroundImage&quot;&gt;backgroundImage&lt;/a&gt; examples for an illustration.
+See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt;, &lt;a
+href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
+href=&quot;../examples/contribs.html#backgroundImage&quot;&gt;backgroundImage&lt;/a&gt; examples for an illustration.
 
- You may want to disable \c GL_LIGHTING, to enable \c GL_LINE_SMOOTH or \c GL_BLEND to draw when
- this method is used.
+You may want to disable \c GL_LIGHTING, to enable \c GL_LINE_SMOOTH or \c GL_BLEND to draw when
+this method is used.
 
- If you want to link 2D drawings to 3D objects, use qglviewer::Camera::projectedCoordinatesOf() to
- compute the 2D projection on screen of a 3D point (see the &lt;a
- href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt; example). See also drawText().
+If you want to link 2D drawings to 3D objects, use qglviewer::Camera::projectedCoordinatesOf() to
+compute the 2D projection on screen of a 3D point (see the &lt;a
+href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt; example). See also drawText().
 
- In this mode, you should use z values that are in the [0.0, 1.0[ range (0.0 corresponding to the
- near clipping plane and 1.0 being just beyond the far clipping plane). This interval matches the
- values that can be read from the z-buffer. Note that if you use the convenient \c glVertex2i() to
- provide coordinates, the implicit 0.0 z coordinate will make your drawings appear \e on \e top of
- the rest of the scene. */
+In this mode, you should use z values that are in the [0.0, 1.0[ range (0.0 corresponding to the
+near clipping plane and 1.0 being just beyond the far clipping plane). This interval matches the
+values that can be read from the z-buffer. Note that if you use the convenient \c glVertex2i() to
+provide coordinates, the implicit 0.0 z coordinate will make your drawings appear \e on \e top of
+the rest of the scene. */
 void QGLViewer::startScreenCoordinatesSystem(bool upward) const
 {
-  glMatrixMode(GL_PROJECTION);
-  glPushMatrix();
-  glLoadIdentity();
-  if (upward)
-    glOrtho(0, width(), 0, height(), 0.0, -1.0);
-  else
-    glOrtho(0, width(), height(), 0, 0.0, -1.0);
+	glMatrixMode(GL_PROJECTION);
+	glPushMatrix();
+	glLoadIdentity();
+	if (upward)
+		glOrtho(0, width(), 0, height(), 0.0, -1.0);
+	else
+		glOrtho(0, width(), height(), 0, 0.0, -1.0);
 
-  glMatrixMode(GL_MODELVIEW);
-  glPushMatrix();
-  glLoadIdentity();
+	glMatrixMode(GL_MODELVIEW);
+	glPushMatrix();
+	glLoadIdentity();
 }
 
 /*! Stops the pixel coordinate drawing block started by startScreenCoordinatesSystem().
 
- The \c GL_MODELVIEW and \c GL_PROJECTION matrices modified in
- startScreenCoordinatesSystem() are restored. \c glMatrixMode is set to \c GL_MODELVIEW. */
+The \c GL_MODELVIEW and \c GL_PROJECTION matrices modified in
+startScreenCoordinatesSystem() are restored. \c glMatrixMode is set to \c GL_MODELVIEW. */
 void QGLViewer::stopScreenCoordinatesSystem() const
 {
-  glMatrixMode(GL_PROJECTION);
-  glPopMatrix();
+	glMatrixMode(GL_PROJECTION);
+	glPopMatrix();
 
-  glMatrixMode(GL_MODELVIEW);
-  glPopMatrix();
+	glMatrixMode(GL_MODELVIEW);
+	glPopMatrix();
 }
 
 /*! Overloading of the \c QObject method.
 
- If animationIsStarted(), calls animate() and draw(). */
+If animationIsStarted(), calls animate() and draw(). */
 void QGLViewer::timerEvent(QTimerEvent *)
 {
-  if (animationIsStarted())
-    {
-      animate();
-      updateGL();
-    }
+	if (animationIsStarted())
+	{
+		animate();
+		updateGL();
+	}
 }
 
 /*! Starts the animation loop. See animationIsStarted(). */
 void QGLViewer::startAnimation()
 {
-  animationTimerId_ = startTimer(animationPeriod());
-  animationStarted_ = true;
+	animationTimerId_ = startTimer(animationPeriod());
+	animationStarted_ = true;
 }
 
 /*! Stops animation. See animationIsStarted(). */
 void QGLViewer::stopAnimation()
 {
-  animationStarted_ = false;
-  if (animationTimerId_ != 0)
-    killTimer(animationTimerId_);
+	animationStarted_ = false;
+	if (animationTimerId_ != 0)
+		killTimer(animationTimerId_);
 }
 
 /*! Overloading of the \c QWidget method.
@@ -1124,212 +1132,212 @@
 Saves the viewer state using saveStateToFile() and then calls QGLWidget::closeEvent(). */
 void QGLViewer::closeEvent(QCloseEvent *e)
 {
-  // When the user clicks on the window close (x) button:
-  // - If the viewer is a top level window, closeEvent is called and then saves to file.
-  // - Otherwise, nothing happen s:(
-  // When the user press the EXIT_VIEWER keyboard shortcut:
-  // - If the viewer is a top level window, saveStateToFile() is also called
-  // - Otherwise, closeEvent is NOT called and keyPressEvent does the job.
+	// When the user clicks on the window close (x) button:
+	// - If the viewer is a top level window, closeEvent is called and then saves to file.
+	// - Otherwise, nothing happen s:(
+	// When the user press the EXIT_VIEWER keyboard shortcut:
+	// - If the viewer is a top level window, saveStateToFile() is also called
+	// - Otherwise, closeEvent is NOT called and keyPressEvent does the job.
 
-  /* After tests:
-     E : Embedded widget
-     N : Widget created with new
-     C : closeEvent called
-     D : destructor called
+	/* After tests:
+	E : Embedded widget
+	N : Widget created with new
+	C : closeEvent called
+	D : destructor called
 
-     E	N	C	D
-     y	y
-     y	n		y
-     n	y	y
-     n	n	y	y
+	E	N	C	D
+	y	y
+	y	n		y
+	n	y	y
+	n	n	y	y
 
-     closeEvent is called iif the widget is NOT embedded.
+	closeEvent is called iif the widget is NOT embedded.
 
-     Destructor is called iif the widget is created on the stack
-     or if widget (resp. parent if embedded) is created with WDestructiveClose flag.
+	Destructor is called iif the widget is created on the stack
+	or if widget (resp. parent if embedded) is created with WDestructiveClose flag.
 
-     closeEvent always before destructor.
+	closeEvent always before destructor.
 
-     Close using qApp-&gt;closeAllWindows or (x) is identical.
-  */
+	Close using qApp-&gt;closeAllWindows or (x) is identical.
+	*/
 
-  // #CONNECTION# Also done for EXIT_VIEWER in keyPressEvent().
-  saveStateToFile();
-  QGLWidget::closeEvent(e);
+	// #CONNECTION# Also done for EXIT_VIEWER in keyPressEvent().
+	saveStateToFile();
+	QGLWidget::closeEvent(e);
 }
 
 /*! Simple wrapper method: calls \c select(event-&gt;pos()).
 
-  Emits \c pointSelected(e) which is useful only if you rely on the Qt signal-slot mechanism and you
-  did not overload QGLViewer. If you choose to derive your own viewer class, simply overload
-  select() (or probably simply drawWithNames(), see the &lt;a href=&quot;../examples/select.html&quot;&gt;select
-  example&lt;/a&gt;) to implement your selection mechanism.
+Emits \c pointSelected(e) which is useful only if you rely on the Qt signal-slot mechanism and you
+did not overload QGLViewer. If you choose to derive your own viewer class, simply overload
+select() (or probably simply drawWithNames(), see the &lt;a href=&quot;../examples/select.html&quot;&gt;select
+example&lt;/a&gt;) to implement your selection mechanism.
 
-  This method is called when you use the QGLViewer::SELECT mouse binding(s) (default is Shift + left
-  button). Use setMouseBinding() to change this. */
+This method is called when you use the QGLViewer::SELECT mouse binding(s) (default is Shift + left
+button). Use setMouseBinding() to change this. */
 void QGLViewer::select(const QMouseEvent* event)
 {
-  // For those who don't derive but rather rely on the signal-slot mechanism.
-  emit pointSelected(event);
-  select(event-&gt;pos());
+	// For those who don't derive but rather rely on the signal-slot mechanism.
+	emit pointSelected(event);
+	select(event-&gt;pos());
 }
 
 /*! This method performs a selection in the scene from pixel coordinates.
 
- It is called when the user clicks on the QGLViewer::SELECT QGLViewer::ClickAction binded button(s)
- (default is Shift + LeftButton).
+It is called when the user clicks on the QGLViewer::SELECT QGLViewer::ClickAction binded button(s)
+(default is Shift + LeftButton).
 
- This method successively calls four other methods:
- \code
- beginSelection(point);
- drawWithNames();
- endSelection(point);
- postSelection(point);
- \endcode
+This method successively calls four other methods:
+\code
+beginSelection(point);
+drawWithNames();
+endSelection(point);
+postSelection(point);
+\endcode
 
- The default implementation of these methods is as follows (see the methods' documentation for
- more details):
+The default implementation of these methods is as follows (see the methods' documentation for
+more details):
 
- \arg beginSelection() sets the \c GL_SELECT mode with the appropriate picking matrices. A
- rectangular frustum (of size defined by selectRegionWidth() and selectRegionHeight()) centered on
- \p point is created.
+\arg beginSelection() sets the \c GL_SELECT mode with the appropriate picking matrices. A
+rectangular frustum (of size defined by selectRegionWidth() and selectRegionHeight()) centered on
+\p point is created.
 
- \arg drawWithNames() is empty and should be overloaded. It draws each selectable object of the
- scene, enclosed by calls to \c glPushName() / \c glPopName() to tag the object with an integer id.
+\arg drawWithNames() is empty and should be overloaded. It draws each selectable object of the
+scene, enclosed by calls to \c glPushName() / \c glPopName() to tag the object with an integer id.
 
- \arg endSelection() then restores \c GL_RENDER mode and analyzes the selectBuffer() to set in
- selectedName() the id of the object that was drawn in the region. If several object are in the
- region, the closest one in the depth buffer is chosen. If no object has been drawn under cursor,
- selectedName() is set to -1.
+\arg endSelection() then restores \c GL_RENDER mode and analyzes the selectBuffer() to set in
+selectedName() the id of the object that was drawn in the region. If several object are in the
+region, the closest one in the depth buffer is chosen. If no object has been drawn under cursor,
+selectedName() is set to -1.
 
- \arg postSelection() is empty and can be overloaded for possible signal/display/interface update.
+\arg postSelection() is empty and can be overloaded for possible signal/display/interface update.
 
- See the \c glSelectBuffer() man page for details on this \c GL_SELECT mechanism.
+See the \c glSelectBuffer() man page for details on this \c GL_SELECT mechanism.
 
- This default implementation is quite limited: only the closer object is selected, and only one
- level of names can be pushed. However, this reveals sufficient in many cases and you usually only
- have to overload drawWithNames() to implement a simple object selection process. See the &lt;a
- href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration.
+This default implementation is quite limited: only the closer object is selected, and only one
+level of names can be pushed. However, this reveals sufficient in many cases and you usually only
+have to overload drawWithNames() to implement a simple object selection process. See the &lt;a
+href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration.
 
- If you need a more complex selection process (such as a point, edge or triangle selection, which
- is easier with a 2 or 3 levels selectBuffer() heap, and which requires a finer depth sorting to
- privilege point over edge and edges over triangles), overload the endSelection() method. Use
- setSelectRegionWidth(), setSelectRegionHeight() and setSelectBufferSize() to tune the select
- buffer configuration. See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
- an illustration.
+If you need a more complex selection process (such as a point, edge or triangle selection, which
+is easier with a 2 or 3 levels selectBuffer() heap, and which requires a finer depth sorting to
+privilege point over edge and edges over triangles), overload the endSelection() method. Use
+setSelectRegionWidth(), setSelectRegionHeight() and setSelectBufferSize() to tune the select
+buffer configuration. See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
+an illustration.
 
- \p point is the center pixel (origin in the upper left corner) of the selection region. Use
- qglviewer::Camera::convertClickToLine() to transform these coordinates in a 3D ray if you want to
- perform an analytical intersection.
+\p point is the center pixel (origin in the upper left corner) of the selection region. Use
+qglviewer::Camera::convertClickToLine() to transform these coordinates in a 3D ray if you want to
+perform an analytical intersection.
 
- \attention \c GL_SELECT mode seems to report wrong results when used in conjunction with backface
- culling. If you encounter problems try to \c glDisable(GL_CULL_FACE). */
+\attention \c GL_SELECT mode seems to report wrong results when used in conjunction with backface
+culling. If you encounter problems try to \c glDisable(GL_CULL_FACE). */
 void QGLViewer::select(const QPoint&amp; point)
 {
-  beginSelection(point);
-  drawWithNames();
-  endSelection(point);
-  postSelection(point);
+	beginSelection(point);
+	drawWithNames();
+	endSelection(point);
+	postSelection(point);
 }
 
 /*! This method should prepare the selection. It is called by select() before drawWithNames().
 
- The default implementation uses the \c GL_SELECT mode to perform a selection. It uses
- selectBuffer() and selectBufferSize() to define a \c glSelectBuffer(). The \c GL_PROJECTION is then
- set using \c gluPickMatrix(), with a window selection size defined by selectRegionWidth() and
- selectRegionHeight(). Finally, the \c GL_MODELVIEW matrix is set to the world coordinate system
- using qglviewer::Camera::loadModelViewMatrix(). See the gluPickMatrix() documentation for details.
+The default implementation uses the \c GL_SELECT mode to perform a selection. It uses
+selectBuffer() and selectBufferSize() to define a \c glSelectBuffer(). The \c GL_PROJECTION is then
+set using \c gluPickMatrix(), with a window selection size defined by selectRegionWidth() and
+selectRegionHeight(). Finally, the \c GL_MODELVIEW matrix is set to the world coordinate system
+using qglviewer::Camera::loadModelViewMatrix(). See the gluPickMatrix() documentation for details.
 
- You should not need to redefine this method (if you use the \c GL_SELECT mode to perform your
- selection), since this code is fairly classical and can be tuned. You are more likely to overload
- endSelection() if you want to use a more complex select buffer structure. */
+You should not need to redefine this method (if you use the \c GL_SELECT mode to perform your
+selection), since this code is fairly classical and can be tuned. You are more likely to overload
+endSelection() if you want to use a more complex select buffer structure. */
 void QGLViewer::beginSelection(const QPoint&amp; point)
 {
-  // Make OpenGL context current (may be needed with several viewers ?)
-  makeCurrent();
+	// Make OpenGL context current (may be needed with several viewers ?)
+	makeCurrent();
 
-  // Prepare the selection mode
-  glSelectBuffer(selectBufferSize(), selectBuffer());
-  glRenderMode(GL_SELECT);
-  glInitNames();
+	// Prepare the selection mode
+	glSelectBuffer(selectBufferSize(), selectBuffer());
+	glRenderMode(GL_SELECT);
+	glInitNames();
 
-  // Loads the matrices
-  glMatrixMode(GL_PROJECTION);
-  glLoadIdentity();
-  static GLint viewport[4];
-  camera()-&gt;getViewport(viewport);
-  gluPickMatrix(point.x(), point.y(), selectRegionWidth(), selectRegionHeight(), viewport);
+	// Loads the matrices
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	static GLint viewport[4];
+	camera()-&gt;getViewport(viewport);
+	gluPickMatrix(point.x(), point.y(), selectRegionWidth(), selectRegionHeight(), viewport);
 
-  // loadProjectionMatrix() first resets the GL_PROJECTION matrix with a glLoadIdentity().
-  // The false parameter prevents this and hence multiplies the matrices.
-  camera()-&gt;loadProjectionMatrix(false);
-  // Reset the original (world coordinates) modelview matrix
-  camera()-&gt;loadModelViewMatrix();
+	// loadProjectionMatrix() first resets the GL_PROJECTION matrix with a glLoadIdentity().
+	// The false parameter prevents this and hence multiplies the matrices.
+	camera()-&gt;loadProjectionMatrix(false);
+	// Reset the original (world coordinates) modelview matrix
+	camera()-&gt;loadModelViewMatrix();
 }
 
 /*! This method is called by select() after scene elements were drawn by drawWithNames(). It should
- analyze the selection result to determine which object is actually selected.
+analyze the selection result to determine which object is actually selected.
 
- The default implementation relies on \c GL_SELECT mode (see beginSelection()). It assumes that
- names were pushed and popped in drawWithNames(), and analyzes the selectBuffer() to find the name
- that corresponds to the closer (z min) object. It then setSelectedName() to this value, or to -1 if
- the selectBuffer() is empty (no object drawn in selection region). Use selectedName() (probably in
- the postSelection() method) to retrieve this value and update your data structure accordingly.
+The default implementation relies on \c GL_SELECT mode (see beginSelection()). It assumes that
+names were pushed and popped in drawWithNames(), and analyzes the selectBuffer() to find the name
+that corresponds to the closer (z min) object. It then setSelectedName() to this value, or to -1 if
+the selectBuffer() is empty (no object drawn in selection region). Use selectedName() (probably in
+the postSelection() method) to retrieve this value and update your data structure accordingly.
 
- This default implementation, although sufficient for many cases is however limited and you may have
- to overload this method. This will be the case if drawWithNames() uses several push levels in the
- name heap. A more precise depth selection, for instance privileging points over edges and
- triangles to avoid z precision problems, will also require an overloading. A typical implementation
- will look like:
- \code
- glFlush();
+This default implementation, although sufficient for many cases is however limited and you may have
+to overload this method. This will be the case if drawWithNames() uses several push levels in the
+name heap. A more precise depth selection, for instance privileging points over edges and
+triangles to avoid z precision problems, will also require an overloading. A typical implementation
+will look like:
+\code
+glFlush();
 
- // Get the number of objects that were seen through the pick matrix frustum.
- // Resets GL_RENDER mode.
- GLint nbHits = glRenderMode(GL_RENDER);
+// Get the number of objects that were seen through the pick matrix frustum.
+// Resets GL_RENDER mode.
+GLint nbHits = glRenderMode(GL_RENDER);
 
- if (nbHits &lt;= 0)
-   setSelectedName(-1);
- else
- {
-   // Interpret results: each object created values in the selectBuffer().
-   // See the glSelectBuffer() man page for details on the buffer structure.
-   // The following code depends on your selectBuffer() structure.
-   for (int i=0; i&lt;nbHits; ++i)
-    if ((selectBuffer())[i*4+1] &lt; zMin)
-      setSelectedName((selectBuffer())[i*4+3])
- }
- \endcode
+if (nbHits &lt;= 0)
+setSelectedName(-1);
+else
+{
+// Interpret results: each object created values in the selectBuffer().
+// See the glSelectBuffer() man page for details on the buffer structure.
+// The following code depends on your selectBuffer() structure.
+for (int i=0; i&lt;nbHits; ++i)
+if ((selectBuffer())[i*4+1] &lt; zMin)
+setSelectedName((selectBuffer())[i*4+3])
+}
+\endcode
 
- See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
- a multi-object selection implementation of this method. */
+See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
+a multi-object selection implementation of this method. */
 void QGLViewer::endSelection(const QPoint&amp; point)
 {
-  Q_UNUSED(point);
+	Q_UNUSED(point);
 
-  // Flush GL buffers
-  glFlush();
+	// Flush GL buffers
+	glFlush();
 
-  // Get the number of objects that were seen through the pick matrix frustum. Reset GL_RENDER mode.
-  GLint nbHits = glRenderMode(GL_RENDER);
+	// Get the number of objects that were seen through the pick matrix frustum. Reset GL_RENDER mode.
+	GLint nbHits = glRenderMode(GL_RENDER);
 
-  if (nbHits &lt;= 0)
-    setSelectedName(-1);
-  else
-    {
-      // Interpret results: each object created 4 values in the selectBuffer().
-      // selectBuffer[4*i+1] is the object minimum depth value, while selectBuffer[4*i+3] is the id pushed on the stack.
-      // Of all the objects that were projected in the pick region, we select the closest one (zMin comparison).
-      // This code needs to be modified if you use several stack levels. See glSelectBuffer() man page.
-      GLuint zMin = (selectBuffer())[1];
-      setSelectedName((selectBuffer())[3]);
-      for (int i=1; i&lt;nbHits; ++i)
-	if ((selectBuffer())[4*i+1] &lt; zMin)
-	  {
-	    zMin = (selectBuffer())[4*i+1];
-	    setSelectedName((selectBuffer())[4*i+3]);
-	  }
-    }
+	if (nbHits &lt;= 0)
+		setSelectedName(-1);
+	else
+	{
+		// Interpret results: each object created 4 values in the selectBuffer().
+		// selectBuffer[4*i+1] is the object minimum depth value, while selectBuffer[4*i+3] is the id pushed on the stack.
+		// Of all the objects that were projected in the pick region, we select the closest one (zMin comparison).
+		// This code needs to be modified if you use several stack levels. See glSelectBuffer() man page.
+		GLuint zMin = (selectBuffer())[1];
+		setSelectedName((selectBuffer())[3]);
+		for (int i=1; i&lt;nbHits; ++i)
+			if ((selectBuffer())[4*i+1] &lt; zMin)
+			{
+				zMin = (selectBuffer())[4*i+1];
+				setSelectedName((selectBuffer())[4*i+3]);
+			}
+	}
 }
 
 /*! Sets the selectBufferSize().
@@ -1337,415 +1345,415 @@
 The previous selectBuffer() is deleted and a new one is created. */
 void QGLViewer::setSelectBufferSize(int size)
 {
-  if (selectBuffer_)
-    delete[] selectBuffer_;
-  selectBufferSize_ = size;
-  selectBuffer_ = new GLuint[selectBufferSize()];
+	if (selectBuffer_)
+		delete[] selectBuffer_;
+	selectBufferSize_ = size;
+	selectBuffer_ = new GLuint[selectBufferSize()];
 }
 
 void QGLViewer::performClickAction(ClickAction ca, const QMouseEvent* const e)
 {
-  // Note: action that need it should updateGL().
-  switch (ca)
-    {
-      // # CONNECTION setMouseBinding prevents adding NO_CLICK_ACTION in clickBinding_
-      // This case should hence not be possible. Prevents unused case warning.
-    case NO_CLICK_ACTION :
-      break;
-    case ZOOM_ON_PIXEL :
-      camera()-&gt;interpolateToZoomOnPixel(e-&gt;pos());
-      break;
-    case ZOOM_TO_FIT :
-      camera()-&gt;interpolateToFitScene();
-      break;
-    case SELECT :
-      select(e);
-      updateGL();
-      break;
-    case RAP_FROM_PIXEL :
-      if (camera()-&gt;setRevolveAroundPointFromPixel(e-&gt;pos()))
+	// Note: action that need it should updateGL().
+	switch (ca)
 	{
-	  setVisualHintsMask(1);
-	  updateGL();
+		// # CONNECTION setMouseBinding prevents adding NO_CLICK_ACTION in clickBinding_
+		// This case should hence not be possible. Prevents unused case warning.
+	case NO_CLICK_ACTION :
+		break;
+	case ZOOM_ON_PIXEL :
+		camera()-&gt;interpolateToZoomOnPixel(e-&gt;pos());
+		break;
+	case ZOOM_TO_FIT :
+		camera()-&gt;interpolateToFitScene();
+		break;
+	case SELECT :
+		select(e);
+		updateGL();
+		break;
+	case RAP_FROM_PIXEL :
+		if (camera()-&gt;setRevolveAroundPointFromPixel(e-&gt;pos()))
+		{
+			setVisualHintsMask(1);
+			updateGL();
+		}
+		break;
+	case RAP_IS_CENTER :
+		camera()-&gt;setRevolveAroundPoint(sceneCenter());
+		setVisualHintsMask(1);
+		updateGL();
+		break;
+	case CENTER_FRAME :
+		if (manipulatedFrame())
+			manipulatedFrame()-&gt;projectOnLine(camera()-&gt;position(), camera()-&gt;viewDirection());
+		break;
+	case CENTER_SCENE :
+		camera()-&gt;centerScene();
+		break;
+	case SHOW_ENTIRE_SCENE :
+		camera()-&gt;showEntireScene();
+		break;
+	case ALIGN_FRAME :
+		if (manipulatedFrame())
+			manipulatedFrame()-&gt;alignWithFrame(camera()-&gt;frame());
+		break;
+	case ALIGN_CAMERA :
+		camera()-&gt;frame()-&gt;alignWithFrame(NULL, true);
+		break;
 	}
-      break;
-    case RAP_IS_CENTER :
-      camera()-&gt;setRevolveAroundPoint(sceneCenter());
-      setVisualHintsMask(1);
-      updateGL();
-      break;
-    case CENTER_FRAME :
-      if (manipulatedFrame())
-	manipulatedFrame()-&gt;projectOnLine(camera()-&gt;position(), camera()-&gt;viewDirection());
-      break;
-    case CENTER_SCENE :
-      camera()-&gt;centerScene();
-      break;
-    case SHOW_ENTIRE_SCENE :
-      camera()-&gt;showEntireScene();
-      break;
-    case ALIGN_FRAME :
-      if (manipulatedFrame())
-	manipulatedFrame()-&gt;alignWithFrame(camera()-&gt;frame());
-      break;
-    case ALIGN_CAMERA :
-      camera()-&gt;frame()-&gt;alignWithFrame(NULL, true);
-      break;
-    }
 }
 
 /*! Overloading of the \c QWidget method.
 
- When the user clicks on the mouse:
- \arg if a mouseGrabber() is defined, qglviewer::MouseGrabber::mousePressEvent() is called,
- \arg otherwise, the camera() or the manipulatedFrame() interprets the mouse displacements,
- depending on mouse bindings.
+When the user clicks on the mouse:
+\arg if a mouseGrabber() is defined, qglviewer::MouseGrabber::mousePressEvent() is called,
+\arg otherwise, the camera() or the manipulatedFrame() interprets the mouse displacements,
+depending on mouse bindings.
 
- Mouse bindings customization can be achieved using setMouseBinding() and setWheelBinding(). See the
- &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for a complete description of mouse bindings.
+Mouse bindings customization can be achieved using setMouseBinding() and setWheelBinding(). See the
+&lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for a complete description of mouse bindings.
 
- See the mouseMoveEvent() documentation for an example of more complex mouse behavior customization
- using overloading.
+See the mouseMoveEvent() documentation for an example of more complex mouse behavior customization
+using overloading.
 
- \note When the mouseGrabber() is a manipulatedFrame(), the modifier keys are not taken into
- account. This allows for a direct manipulation of the manipulatedFrame() when the mouse hovers,
- which is probably what is expected. */
+\note When the mouseGrabber() is a manipulatedFrame(), the modifier keys are not taken into
+account. This allows for a direct manipulation of the manipulatedFrame() when the mouse hovers,
+which is probably what is expected. */
 void QGLViewer::mousePressEvent(QMouseEvent* e)
 {
-  //#CONNECTION# mouseDoubleClickEvent has the same structure
-  //#CONNECTION# mouseString() concatenates bindings description in inverse order.
-  ClickActionPrivate cap;
-  cap.doubleClick = false;
+	//#CONNECTION# mouseDoubleClickEvent has the same structure
+	//#CONNECTION# mouseString() concatenates bindings description in inverse order.
+	ClickActionPrivate cap;
+	cap.doubleClick = false;
 #if QT_VERSION &gt;= 0x040000
-  cap.modifiers = e-&gt;modifiers();
-  cap.button = e-&gt;button();
-  cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
+	cap.modifiers = e-&gt;modifiers();
+	cap.button = e-&gt;button();
+	cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
 #else
-  cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
-  cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
-  cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
+	cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+	cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
+	cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
 #endif
 
-  if (clickBinding_.contains(cap))
-    performClickAction(clickBinding_[cap], e);
-  else
-      if (mouseGrabber())
-	{
-	  if (mouseGrabberIsAManipulatedFrame_)
-	    {
-	      for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it!=end; ++it)
+	if (clickBinding_.contains(cap))
+		performClickAction(clickBinding_[cap], e);
+	else
+		if (mouseGrabber())
+		{
+			if (mouseGrabberIsAManipulatedFrame_)
+			{
+				for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it!=end; ++it)
 #if QT_VERSION &gt;= 0x040000
-		if ((it.value().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == e-&gt;buttons()))
+					if ((it.value().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == e-&gt;buttons()))
 #else
-		  if ((it.data().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == (e-&gt;stateAfter() &amp; Qt::MouseButtonMask)))
+					if ((it.data().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == (e-&gt;stateAfter() &amp; Qt::MouseButtonMask)))
 #endif
-		    {
-		      ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
-		      if (mouseGrabberIsAManipulatedCameraFrame_)
-			{
-			  mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
-			  mf-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+					{
+						ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
+						if (mouseGrabberIsAManipulatedCameraFrame_)
+						{
+							mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
+							mf-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+						}
+						else
+						{
+							mf-&gt;startAction(it.value().action, it.value().withConstraint);
+							mf-&gt;mousePressEvent(e, camera());
+						}
+						break;
+					}
 			}
-		      else
-			{
-			  mf-&gt;startAction(it.value().action, it.value().withConstraint);
-			  mf-&gt;mousePressEvent(e, camera());
-			}
-		      break;
-		    }
-	    }
-	  else
-	    mouseGrabber()-&gt;mousePressEvent(e, camera());
-	  updateGL();
-	}
-      else
-	{
-	  //#CONNECTION# wheelEvent has the same structure
+			else
+				mouseGrabber()-&gt;mousePressEvent(e, camera());
+			updateGL();
+		}
+		else
+		{
+			//#CONNECTION# wheelEvent has the same structure
 #if QT_VERSION &gt;= 0x040000
-	  const int state = e-&gt;modifiers() | e-&gt;buttons();
+			const int state = e-&gt;modifiers() | e-&gt;buttons();
 #else
-	  const int state = e-&gt;stateAfter();
+			const int state = e-&gt;stateAfter();
 #endif
 
-	  if (mouseBinding_.contains(state))
-	    {
-	      MouseActionPrivate map = mouseBinding_[state];
-	      switch (map.handler)
-		{
-		case CAMERA :
-		  camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
-		  camera()-&gt;frame()-&gt;mousePressEvent(e, camera());
-		  break;
-		case FRAME :
-		  if (manipulatedFrame())
-		    {
-		      if (manipulatedFrameIsACamera_)
+			if (mouseBinding_.contains(state))
 			{
-			  manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
-			  manipulatedFrame()-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+				MouseActionPrivate map = mouseBinding_[state];
+				switch (map.handler)
+				{
+				case CAMERA :
+					camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
+					camera()-&gt;frame()-&gt;mousePressEvent(e, camera());
+					break;
+				case FRAME :
+					if (manipulatedFrame())
+					{
+						if (manipulatedFrameIsACamera_)
+						{
+							manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
+							manipulatedFrame()-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+						}
+						else
+						{
+							manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
+							manipulatedFrame()-&gt;mousePressEvent(e, camera());
+						}
+					}
+					break;
+				}
+				if (map.action == SCREEN_ROTATE)
+					// Display visual hint line
+					updateGL();
 			}
-		      else
-			{
-			  manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
-			  manipulatedFrame()-&gt;mousePressEvent(e, camera());
-			}
-		    }
-		  break;
-		}
-	      if (map.action == SCREEN_ROTATE)
-		// Display visual hint line
-		updateGL();
-	    }
 #if QT_VERSION &gt;= 0x030000
-	  else
-	    e-&gt;ignore();
+			else
+				e-&gt;ignore();
 #endif
-	}
+		}
 }
 
 /*! Overloading of the \c QWidget method.
 
- Mouse move event is sent to the mouseGrabber() (if any) or to the camera() or the
- manipulatedFrame(), depending on mouse bindings (see setMouseBinding()).
+Mouse move event is sent to the mouseGrabber() (if any) or to the camera() or the
+manipulatedFrame(), depending on mouse bindings (see setMouseBinding()).
 
- If you want to define your own mouse behavior, do something like this:
- \code
- void Viewer::mousePressEvent(QMouseEvent* e)
- {
+If you want to define your own mouse behavior, do something like this:
+\code
+void Viewer::mousePressEvent(QMouseEvent* e)
+{
 
-   // Qt version 2 or 3 : use Qt::KeyButtonMask and Qt::MouseButtonMask to separate the modifiers
-   // (Qt::ControlButton/Qt::AltButton/Qt::ShiftButton/Qt::MetaButton) from the mouse buttons
-   // (Qt::LeftButton/Qt::MidButton/Qt::RightButton) in state().
-   if ( ((e-&gt;state() &amp; Qt::KeyButtonMask) == myModifiers) &amp;&amp;
-        ((e-&gt;state() &amp; Qt::MouseButtonMask) == myButton) )
+// Qt version 2 or 3 : use Qt::KeyButtonMask and Qt::MouseButtonMask to separate the modifiers
+// (Qt::ControlButton/Qt::AltButton/Qt::ShiftButton/Qt::MetaButton) from the mouse buttons
+// (Qt::LeftButton/Qt::MidButton/Qt::RightButton) in state().
+if ( ((e-&gt;state() &amp; Qt::KeyButtonMask) == myModifiers) &amp;&amp;
+((e-&gt;state() &amp; Qt::MouseButtonMask) == myButton) )
 
-   // With Qt 4, use instead :
-   if ((e-&gt;button() == myButton) &amp;&amp; (e-&gt;modifiers() == myModifiers))
-     myMouseBehavior = true;
-   else
-     QGLViewer::mousePressEvent(e);
- }
+// With Qt 4, use instead :
+if ((e-&gt;button() == myButton) &amp;&amp; (e-&gt;modifiers() == myModifiers))
+myMouseBehavior = true;
+else
+QGLViewer::mousePressEvent(e);
+}
 
- void Viewer::mouseMoveEvent(QMouseEvent *e)
- {
-   if (myMouseBehavior)
-     // Use e-&gt;x() and e-&gt;y() as you want...
-   else
-     QGLViewer::mouseMoveEvent(e);
- }
+void Viewer::mouseMoveEvent(QMouseEvent *e)
+{
+if (myMouseBehavior)
+// Use e-&gt;x() and e-&gt;y() as you want...
+else
+QGLViewer::mouseMoveEvent(e);
+}
 
- void Viewer::mouseReleaseEvent(QMouseEvent* e)
- {
-   if (myMouseBehavior)
-     myMouseBehavior = false;
-   else
-     QGLViewer::mouseReleaseEvent(e);
- }
- \endcode */
+void Viewer::mouseReleaseEvent(QMouseEvent* e)
+{
+if (myMouseBehavior)
+myMouseBehavior = false;
+else
+QGLViewer::mouseReleaseEvent(e);
+}
+\endcode */
 void QGLViewer::mouseMoveEvent(QMouseEvent* e)
 {
-  if (mouseGrabber())
-    {
-      mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
-      if (mouseGrabber()-&gt;grabsMouse())
-	if (mouseGrabberIsAManipulatedCameraFrame_)
-	  (dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
-	else
-	  mouseGrabber()-&gt;mouseMoveEvent(e, camera());
-      else
-	setMouseGrabber(NULL);
-      updateGL();
-    }
+	if (mouseGrabber())
+	{
+		mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+		if (mouseGrabber()-&gt;grabsMouse())
+			if (mouseGrabberIsAManipulatedCameraFrame_)
+				(dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
+			else
+				mouseGrabber()-&gt;mouseMoveEvent(e, camera());
+		else
+			setMouseGrabber(NULL);
+		updateGL();
+	}
 
-  if (!mouseGrabber())
-    {
-      //#CONNECTION# mouseReleaseEvent has the same structure
-      if (camera()-&gt;frame()-&gt;isManipulated())
+	if (!mouseGrabber())
 	{
-	  camera()-&gt;frame()-&gt;mouseMoveEvent(e, camera());
-	  // #CONNECTION# manipulatedCameraFrame::mouseMoveEvent specific if at the beginning
-	  if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
-	    updateGL();
-	}
-      else // !
-	if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
-	  if (manipulatedFrameIsACamera_)
-	    manipulatedFrame()-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
-	  else
-	    manipulatedFrame()-&gt;mouseMoveEvent(e, camera());
-	else
-	  if (hasMouseTracking())
-	    {
+		//#CONNECTION# mouseReleaseEvent has the same structure
+		if (camera()-&gt;frame()-&gt;isManipulated())
+		{
+			camera()-&gt;frame()-&gt;mouseMoveEvent(e, camera());
+			// #CONNECTION# manipulatedCameraFrame::mouseMoveEvent specific if at the beginning
+			if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
+				updateGL();
+		}
+		else // !
+			if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
+				if (manipulatedFrameIsACamera_)
+					manipulatedFrame()-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
+				else
+					manipulatedFrame()-&gt;mouseMoveEvent(e, camera());
+			else
+				if (hasMouseTracking())
+				{
 #if QT_VERSION &gt;= 0x040000
-	      foreach (MouseGrabber* mg, MouseGrabber::MouseGrabberPool())
-		{
+					foreach (MouseGrabber* mg, MouseGrabber::MouseGrabberPool())
+					{
 #else
-	      QPtrListIterator&lt;MouseGrabber&gt; it(MouseGrabber::MouseGrabberPool());
-	      for (MouseGrabber* mg; (mg = it.current()); ++it)
-		{
+					QPtrListIterator&lt;MouseGrabber&gt; it(MouseGrabber::MouseGrabberPool());
+					for (MouseGrabber* mg; (mg = it.current()); ++it)
+					{
 #endif
-		  mg-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
-		  if (mg-&gt;grabsMouse())
-		    {
-		      setMouseGrabber(mg);
-		      // Check that MouseGrabber is not disabled
-		      if (mouseGrabber() == mg)
-			{
-			  updateGL();
-			  break;
-			}
-		    }
-		}
-	    }
-    }
+						mg-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+						if (mg-&gt;grabsMouse())
+						{
+							setMouseGrabber(mg);
+							// Check that MouseGrabber is not disabled
+							if (mouseGrabber() == mg)
+							{
+								updateGL();
+								break;
+							}
+						}
+					}
+				}
+	}
 }
 
 /*! Overloading of the \c QWidget method.
 
- Calls the mouseGrabber(), camera() or manipulatedFrame \c mouseReleaseEvent method.
+Calls the mouseGrabber(), camera() or manipulatedFrame \c mouseReleaseEvent method.
 
- See the mouseMoveEvent() documentation for an example of mouse behavior customization. */
+See the mouseMoveEvent() documentation for an example of mouse behavior customization. */
 void QGLViewer::mouseReleaseEvent(QMouseEvent* e)
 {
-  if (mouseGrabber())
-    {
-      if (mouseGrabberIsAManipulatedCameraFrame_)
-	(dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
-      else
-	mouseGrabber()-&gt;mouseReleaseEvent(e, camera());
-      mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
-      if (!(mouseGrabber()-&gt;grabsMouse()))
-	setMouseGrabber(NULL);
-      // updateGL();
-    }
-  else
-    //#CONNECTION# mouseMoveEvent has the same structure
-    if (camera()-&gt;frame()-&gt;isManipulated())
-      {
-	// bool updateGLNeeded = ((camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION) ||
-			       // (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE));
-	camera()-&gt;frame()-&gt;mouseReleaseEvent(e, camera());
-	// if (updateGLNeeded)
-	// Needed in all cases because of fastDraw().
-	// updateGL();
-      }
-    else
-      if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
+	if (mouseGrabber())
 	{
-	  // bool updateGLNeeded = (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE);
-	  if (manipulatedFrameIsACamera_)
-	    manipulatedFrame()-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
-	  else
-	    manipulatedFrame()-&gt;mouseReleaseEvent(e, camera());
-	  // if (updateGLNeeded)
-	    // updateGL();
+		if (mouseGrabberIsAManipulatedCameraFrame_)
+			(dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
+		else
+			mouseGrabber()-&gt;mouseReleaseEvent(e, camera());
+		mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+		if (!(mouseGrabber()-&gt;grabsMouse()))
+			setMouseGrabber(NULL);
+		// updateGL();
 	}
+	else
+		//#CONNECTION# mouseMoveEvent has the same structure
+		if (camera()-&gt;frame()-&gt;isManipulated())
+		{
+			// bool updateGLNeeded = ((camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION) ||
+			// (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE));
+			camera()-&gt;frame()-&gt;mouseReleaseEvent(e, camera());
+			// if (updateGLNeeded)
+			// Needed in all cases because of fastDraw().
+			// updateGL();
+		}
+		else
+			if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
+			{
+				// bool updateGLNeeded = (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE);
+				if (manipulatedFrameIsACamera_)
+					manipulatedFrame()-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
+				else
+					manipulatedFrame()-&gt;mouseReleaseEvent(e, camera());
+				// if (updateGLNeeded)
+				// updateGL();
+			}
 #if QT_VERSION &gt;= 0x030000
-      else
-	e-&gt;ignore();
+			else
+				e-&gt;ignore();
 #endif
 
-  // Not absolutely needed (see above commented code for the optimal version), but may reveal
-  // useful for specific applications.
-  updateGL();
+	// Not absolutely needed (see above commented code for the optimal version), but may reveal
+	// useful for specific applications.
+	updateGL();
 }
 
 /*! Overloading of the \c QWidget method.
 
- If defined, the wheel event is sent to the mouseGrabber(). It is otherwise sent according to wheel
- bindings (see setWheelBinding()). */
+If defined, the wheel event is sent to the mouseGrabber(). It is otherwise sent according to wheel
+bindings (see setWheelBinding()). */
 void QGLViewer::wheelEvent(QWheelEvent* e)
 {
-  if (mouseGrabber())
-    {
-      if (mouseGrabberIsAManipulatedFrame_)
+	if (mouseGrabber())
 	{
-	  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
-	    if (it.value().handler == FRAME)
-	      {
-		ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
-		if (mouseGrabberIsAManipulatedCameraFrame_)
-		  {
-		    mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
-		    mf-&gt;ManipulatedFrame::wheelEvent(e, camera());
-		  }
+		if (mouseGrabberIsAManipulatedFrame_)
+		{
+			for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
+				if (it.value().handler == FRAME)
+				{
+					ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
+					if (mouseGrabberIsAManipulatedCameraFrame_)
+					{
+						mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
+						mf-&gt;ManipulatedFrame::wheelEvent(e, camera());
+					}
+					else
+					{
+						mf-&gt;startAction(it.value().action, it.value().withConstraint);
+						mf-&gt;wheelEvent(e, camera());
+					}
+					break;
+				}
+		}
 		else
-		  {
-		    mf-&gt;startAction(it.value().action, it.value().withConstraint);
-		    mf-&gt;wheelEvent(e, camera());
-		  }
-		break;
-	      }
+			mouseGrabber()-&gt;wheelEvent(e, camera());
+		updateGL();
 	}
-      else
-	mouseGrabber()-&gt;wheelEvent(e, camera());
-      updateGL();
-    }
-  else
-    {
-      //#CONNECTION# mousePressEvent has the same structure
+	else
+	{
+		//#CONNECTION# mousePressEvent has the same structure
 #if QT_VERSION &gt;= 0x040000
-      const QtKeyboardModifiers modifiers = e-&gt;modifiers();
+		const QtKeyboardModifiers modifiers = e-&gt;modifiers();
 #else
-      const QtKeyboardModifiers modifiers = e-&gt;state();
+		const QtKeyboardModifiers modifiers = e-&gt;state();
 #endif
-      if (wheelBinding_.contains(modifiers))
-	{
-	  MouseActionPrivate map = wheelBinding_[modifiers];
-	  switch (map.handler)
-	    {
-	    case CAMERA :
-	      camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
-	      camera()-&gt;frame()-&gt;wheelEvent(e, camera());
-	      break;
-	    case FRAME :
-	      if (manipulatedFrame())
-		if (manipulatedFrameIsACamera_)
-		  {
-		    manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
-		    manipulatedFrame()-&gt;ManipulatedFrame::wheelEvent(e, camera());
-		  }
+		if (wheelBinding_.contains(modifiers))
+		{
+			MouseActionPrivate map = wheelBinding_[modifiers];
+			switch (map.handler)
+			{
+			case CAMERA :
+				camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
+				camera()-&gt;frame()-&gt;wheelEvent(e, camera());
+				break;
+			case FRAME :
+				if (manipulatedFrame())
+					if (manipulatedFrameIsACamera_)
+					{
+						manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
+						manipulatedFrame()-&gt;ManipulatedFrame::wheelEvent(e, camera());
+					}
+					else
+					{
+						manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
+						manipulatedFrame()-&gt;wheelEvent(e, camera());
+					}
+					break;
+			}
+		}
+#if QT_VERSION &gt;= 0x030000
 		else
-		  {
-		    manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
-		    manipulatedFrame()-&gt;wheelEvent(e, camera());
-		  }
-	      break;
-	    }
+			e-&gt;ignore();
+#endif
 	}
-#if QT_VERSION &gt;= 0x030000
-      else
-	e-&gt;ignore();
-#endif
-    }
 }
 
 /*! Overloading of the \c QWidget method.
 
- The behavior of the mouse double click depends on the mouse binding. See setMouseBinding() and the
- &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. */
+The behavior of the mouse double click depends on the mouse binding. See setMouseBinding() and the
+&lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. */
 void QGLViewer::mouseDoubleClickEvent(QMouseEvent* e)
 {
-  //#CONNECTION# mousePressEvent has the same structure
-  ClickActionPrivate cap;
-  cap.doubleClick = true;
+	//#CONNECTION# mousePressEvent has the same structure
+	ClickActionPrivate cap;
+	cap.doubleClick = true;
 #if QT_VERSION &gt;= 0x040000
-  cap.modifiers = e-&gt;modifiers();
-  cap.button = e-&gt;button();
-  cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
+	cap.modifiers = e-&gt;modifiers();
+	cap.button = e-&gt;button();
+	cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
 #else
-  cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
-  cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
-  cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
+	cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+	cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
+	cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
 #endif
-  if (clickBinding_.contains(cap))
-    performClickAction(clickBinding_[cap], e);
-  else
-    if (mouseGrabber())
-      mouseGrabber()-&gt;mouseDoubleClickEvent(e, camera());
+	if (clickBinding_.contains(cap))
+		performClickAction(clickBinding_[cap], e);
+	else
+		if (mouseGrabber())
+			mouseGrabber()-&gt;mouseDoubleClickEvent(e, camera());
 #if QT_VERSION &gt;= 0x030000
-    else
-      e-&gt;ignore();
+		else
+			e-&gt;ignore();
 #endif
 }
 
@@ -1755,54 +1763,54 @@
 warning message box in case of failure. Emits the stereoChanged() signal otherwise. */
 void QGLViewer::setStereoDisplay(bool stereo)
 {
-  if (format().stereo())
-    {
-      stereo_ = stereo;
-      if (!displaysInStereo())
+	if (format().stereo())
 	{
-	  glDrawBuffer(GL_BACK_LEFT);
-	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-	  glDrawBuffer(GL_BACK_RIGHT);
-	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-	}
+		stereo_ = stereo;
+		if (!displaysInStereo())
+		{
+			glDrawBuffer(GL_BACK_LEFT);
+			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+			glDrawBuffer(GL_BACK_RIGHT);
+			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+		}
 
-      emit stereoChanged(stereo_);
+		emit stereoChanged(stereo_);
 
-      if (updateGLOK_)
-	updateGL();
-    }
-  else
-    if (stereo)
-      QMessageBox::warning(this, &quot;Stereo not supported&quot;, &quot;Stereo is not supported on this display&quot;);
-    else
-      stereo_ = false;
+		if (updateGLOK_)
+			updateGL();
+	}
+	else
+		if (stereo)
+			QMessageBox::warning(this, tr(&quot;Stereo not supported&quot;, &quot;Message box window title&quot;), tr(&quot;Stereo is not supported on this display.&quot;));
+		else
+			stereo_ = false;
 }
 
 /*! Sets the isFullScreen() state.
 
- If the QGLViewer is embedded in an other QWidget (see QWidget::topLevelWidget()), this widget is
- displayed in full screen instead. */
+If the QGLViewer is embedded in an other QWidget (see QWidget::topLevelWidget()), this widget is
+displayed in full screen instead. */
 void QGLViewer::setFullScreen(bool fullScreen)
 {
-  fullScreen_ = fullScreen;
+	fullScreen_ = fullScreen;
 
-  // Tricky. A timer does it later if !updateGLOK_.
-  if (!updateGLOK_)
-    return;
+	// Tricky. A timer does it later if !updateGLOK_.
+	if (!updateGLOK_)
+		return;
 
-  QWidget* tlw = topLevelWidget();
+	QWidget* tlw = topLevelWidget();
 
-  if (isFullScreen())
-    {
-      prevPos_ = topLevelWidget()-&gt;pos();
-      tlw-&gt;showFullScreen();
-      tlw-&gt;move(0,0);
-    }
-  else
-    {
-      tlw-&gt;showNormal();
-      tlw-&gt;move(prevPos_);
-    }
+	if (isFullScreen())
+	{
+		prevPos_ = topLevelWidget()-&gt;pos();
+		tlw-&gt;showFullScreen();
+		tlw-&gt;move(0,0);
+	}
+	else
+	{
+		tlw-&gt;showNormal();
+		tlw-&gt;move(prevPos_);
+	}
 }
 
 /*! Directly defines the mouseGrabber().
@@ -1813,722 +1821,721 @@
 If the MouseGrabber is disabled (see mouseGrabberIsEnabled()), this method silently does nothing. */
 void QGLViewer::setMouseGrabber(MouseGrabber* mouseGrabber)
 {
-  if (!mouseGrabberIsEnabled(mouseGrabber))
-    return;
+	if (!mouseGrabberIsEnabled(mouseGrabber))
+		return;
 
-  mouseGrabber_ = mouseGrabber;
+	mouseGrabber_ = mouseGrabber;
 
-  mouseGrabberIsAManipulatedFrame_       = (dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber) != NULL);
-  mouseGrabberIsAManipulatedCameraFrame_ = ((dynamic_cast&lt;ManipulatedCameraFrame*&gt;(mouseGrabber) != NULL) &amp;&amp;
-					    (mouseGrabber != camera()-&gt;frame()));
-  emit mouseGrabberChanged(mouseGrabber);
+	mouseGrabberIsAManipulatedFrame_       = (dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber) != NULL);
+	mouseGrabberIsAManipulatedCameraFrame_ = ((dynamic_cast&lt;ManipulatedCameraFrame*&gt;(mouseGrabber) != NULL) &amp;&amp;
+		(mouseGrabber != camera()-&gt;frame()));
+	emit mouseGrabberChanged(mouseGrabber);
 }
 
 /*! Sets the mouseGrabberIsEnabled() state. */
 void QGLViewer::setMouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber, bool enabled)
 {
-  if (enabled)
-    disabledMouseGrabbers_.remove(reinterpret_cast&lt;size_t&gt;(mouseGrabber));
-  else
-    disabledMouseGrabbers_[reinterpret_cast&lt;size_t&gt;(mouseGrabber)];
+	if (enabled)
+		disabledMouseGrabbers_.remove(reinterpret_cast&lt;size_t&gt;(mouseGrabber));
+	else
+		disabledMouseGrabbers_[reinterpret_cast&lt;size_t&gt;(mouseGrabber)];
 }
 
 static QString keyboardModifiersString(QtKeyboardModifiers m, bool noButton=false)
 {
-  QString result(&quot;&quot;);
+	QString result(&quot;&quot;);
 #if QT_VERSION &gt;= 0x040000
-  if (m &amp; Qt::ControlModifier) 	result += &quot;Ctrl+&quot;;
-  if (m &amp; Qt::AltModifier) 	result += &quot;Alt+&quot;;
-  if (m &amp; Qt::ShiftModifier) 	result += &quot;Shift+&quot;;
-  if (m &amp; Qt::MetaModifier) 	result += &quot;Meta+&quot;;
-  if (noButton &amp;&amp; (m==Qt::NoModifier)) result += &quot;(no button)&quot;;
+	if (m &amp; Qt::ControlModifier) result += QGLViewer::tr(&quot;Ctrl+&quot;, &quot;Modifier key&quot;);
+	if (m &amp; Qt::AltModifier) result += QGLViewer::tr(&quot;Alt+&quot;, &quot;Modifier key&quot;);
+	if (m &amp; Qt::ShiftModifier) result += QGLViewer::tr(&quot;Shift+&quot;, &quot;Modifier key&quot;);
+	if (m &amp; Qt::MetaModifier) result += QGLViewer::tr(&quot;Meta+&quot;, &quot;Modifier key&quot;);
+	if (noButton &amp;&amp; (m==Qt::NoModifier)) result += QGLViewer::tr(&quot;(no button)&quot;);
 #else
-  if (m &amp; Qt::ControlButton) 	result += &quot;Ctrl+&quot;;
-  if (m &amp; Qt::AltButton) 	result += &quot;Alt+&quot;;
-  if (m &amp; Qt::ShiftButton) 	result += &quot;Shift+&quot;;
+	if (m &amp; Qt::ControlButton) result += QGLViewer::tr(&quot;Ctrl+&quot;, &quot;Modifier key&quot;);
+	if (m &amp; Qt::AltButton) result += QGLViewer::tr(&quot;Alt+&quot;, &quot;Modifier key&quot;);
+	if (m &amp; Qt::ShiftButton) result += QGLViewer::tr(&quot;Shift+&quot;, &quot;Modifier key&quot;);
 # if QT_VERSION &gt;= 0x030000
-  if (m &amp; Qt::MetaButton) 	result += &quot;Meta+&quot;;
+	if (m &amp; Qt::MetaButton) result += QGLViewer::tr(&quot;Meta+&quot;, &quot;Modifier key&quot;);
 # endif
-  if (noButton &amp;&amp; (m==Qt::NoButton)) result += &quot;(no button)&quot;;
+	if (noButton &amp;&amp; (m==Qt::NoButton)) result += QGLViewer::tr(&quot;(no button)&quot;);
 #endif
-  return result;
+	return result;
 }
 
 static QString mouseButtonsString(QtMouseButtons b)
 {
-  QString result(&quot;&quot;);
-  bool addAmpersand = false;
-  if (b &amp; Qt::LeftButton)    { result += &quot;Left&quot;; addAmpersand=true; }
-  if (b &amp; Qt::MidButton)     { if (addAmpersand) result += &quot; &amp; &quot;; result += &quot;Middle&quot;; addAmpersand=true; }
-  if (b &amp; Qt::RightButton)   { if (addAmpersand) result += &quot; &amp; &quot;; result += &quot;Right&quot;; }
-  return result;
+	QString result(&quot;&quot;);
+	bool addAmpersand = false;
+	if (b &amp; Qt::LeftButton)    { result += QGLViewer::tr(&quot;Left&quot;, &quot;left mouse button&quot;); addAmpersand=true; }
+	if (b &amp; Qt::MidButton)     { if (addAmpersand) result += &quot; &amp; &quot;; result += QGLViewer::tr(&quot;Middle&quot;, &quot;middle mouse button&quot;); addAmpersand=true; }
+	if (b &amp; Qt::RightButton)   { if (addAmpersand) result += &quot; &amp; &quot;; result += QGLViewer::tr(&quot;Right&quot;, &quot;right mouse button&quot;); }
+	return result;
 }
 
 QString QGLViewer::mouseActionString(QGLViewer::MouseAction ma)
 {
-  switch (ma)
-    {
-    case QGLViewer::NO_MOUSE_ACTION : 	return QString::null;
-    case QGLViewer::ROTATE : 		return QString(&quot;Rotates&quot;);
-    case QGLViewer::ZOOM : 		return QString(&quot;Zooms&quot;);
-    case QGLViewer::TRANSLATE : 	return QString(&quot;Translates&quot;);
-    case QGLViewer::MOVE_FORWARD : 	return QString(&quot;Moves forward&quot;);
-    case QGLViewer::LOOK_AROUND : 	return QString(&quot;Looks around&quot;);
-    case QGLViewer::MOVE_BACKWARD : 	return QString(&quot;Moves backward&quot;);
-    case QGLViewer::SCREEN_ROTATE : 	return QString(&quot;Rotates on screen&quot;);
-    case QGLViewer::ROLL :		return QString(&quot;Rolls&quot;);
-    case QGLViewer::DRIVE :		return QString(&quot;Drives&quot;);
-    case QGLViewer::SCREEN_TRANSLATE : 	return QString(&quot;Horizontally/Vertically translates&quot;);
-    case QGLViewer::ZOOM_ON_REGION : 	return QString(&quot;Zooms on region for&quot;);
-    }
-  return QString::null;
+	switch (ma)
+	{
+	case QGLViewer::NO_MOUSE_ACTION : return QString::null;
+	case QGLViewer::ROTATE : return QGLViewer::tr(&quot;Rotates&quot;, &quot;ROTATE mouse action&quot;);
+	case QGLViewer::ZOOM : return QGLViewer::tr(&quot;Zooms&quot;, &quot;ZOOM mouse action&quot;);
+	case QGLViewer::TRANSLATE : return QGLViewer::tr(&quot;Translates&quot;, &quot;TRANSLATE mouse action&quot;);
+	case QGLViewer::MOVE_FORWARD : return QGLViewer::tr(&quot;Moves forward&quot;, &quot;MOVE_FORWARD mouse action&quot;);
+	case QGLViewer::LOOK_AROUND : return QGLViewer::tr(&quot;Looks around&quot;, &quot;LOOK_AROUND mouse action&quot;);
+	case QGLViewer::MOVE_BACKWARD : return QGLViewer::tr(&quot;Moves backward&quot;, &quot;MOVE_BACKWARD mouse action&quot;);
+	case QGLViewer::SCREEN_ROTATE : return QGLViewer::tr(&quot;Rotates in screen plane&quot;, &quot;SCREEN_ROTATE mouse action&quot;);
+	case QGLViewer::ROLL : return QGLViewer::tr(&quot;Rolls&quot;, &quot;ROLL mouse action&quot;);
+	case QGLViewer::DRIVE : return QGLViewer::tr(&quot;Drives&quot;, &quot;DRIVE mouse action&quot;);
+	case QGLViewer::SCREEN_TRANSLATE : return QGLViewer::tr(&quot;Horizontally/Vertically translates&quot;, &quot;SCREEN_TRANSLATE mouse action&quot;);
+	case QGLViewer::ZOOM_ON_REGION : return QGLViewer::tr(&quot;Zooms on region for&quot;, &quot;ZOOM_ON_REGION mouse action&quot;);
+	}
+	return QString::null;
 }
 
 QString QGLViewer::clickActionString(QGLViewer::ClickAction ca)
 {
-  switch (ca)
-    {
-    case QGLViewer::NO_CLICK_ACTION : 	return QString::null;
-    case QGLViewer::ZOOM_ON_PIXEL : 	return QString(&quot;Zooms on pixel&quot;);
-    case QGLViewer::ZOOM_TO_FIT : 	return QString(&quot;Zooms to fit scene&quot;);
-    case QGLViewer::SELECT : 		return QString(&quot;Selects&quot;);
-    case QGLViewer::RAP_FROM_PIXEL : 	return QString(&quot;Sets revolve around point&quot;);
-    case QGLViewer::RAP_IS_CENTER : 	return QString(&quot;Resets revolve around point&quot;);
-    case QGLViewer::CENTER_FRAME : 	return QString(&quot;Centers frame&quot;);
-    case QGLViewer::CENTER_SCENE : 	return QString(&quot;Centers scene&quot;);
-    case QGLViewer::SHOW_ENTIRE_SCENE : return QString(&quot;Shows entire scene&quot;);
-    case QGLViewer::ALIGN_FRAME : 	return QString(&quot;Aligns frame&quot;);
-    case QGLViewer::ALIGN_CAMERA : 	return QString(&quot;Aligns camera&quot;);
-    }
-  return QString::null;
+	switch (ca)
+	{
+	case QGLViewer::NO_CLICK_ACTION : return QString::null;
+	case QGLViewer::ZOOM_ON_PIXEL : return QGLViewer::tr(&quot;Zooms on pixel&quot;, &quot;ZOOM_ON_PIXEL click action&quot;);
+	case QGLViewer::ZOOM_TO_FIT : return QGLViewer::tr(&quot;Zooms to fit scene&quot;, &quot;ZOOM_TO_FIT click action&quot;);
+	case QGLViewer::SELECT : return QGLViewer::tr(&quot;Selects&quot;, &quot;SELECT click action&quot;);
+	case QGLViewer::RAP_FROM_PIXEL : return QGLViewer::tr(&quot;Sets revolve around point&quot;, &quot;RAP_FROM_PIXEL click action&quot;);
+	case QGLViewer::RAP_IS_CENTER : return QGLViewer::tr(&quot;Resets revolve around point&quot;, &quot;RAP_IS_CENTER click action&quot;);
+	case QGLViewer::CENTER_FRAME : return QGLViewer::tr(&quot;Centers frame&quot;, &quot;CENTER_FRAME click action&quot;);
+	case QGLViewer::CENTER_SCENE : return QGLViewer::tr(&quot;Centers scene&quot;, &quot;CENTER_SCENE click action&quot;);
+	case QGLViewer::SHOW_ENTIRE_SCENE : return QGLViewer::tr(&quot;Shows entire scene&quot;, &quot;SHOW_ENTIRE_SCENE click action&quot;);
+	case QGLViewer::ALIGN_FRAME : return QGLViewer::tr(&quot;Aligns frame&quot;, &quot;ALIGN_FRAME click action&quot;);
+	case QGLViewer::ALIGN_CAMERA : return QGLViewer::tr(&quot;Aligns camera&quot;, &quot;ALIGN_CAMERA click action&quot;);
+	}
+	return QString::null;
 }
 
+QString QGLViewer::formatClickActionPrivate(ClickActionPrivate cap)
+{
+	bool buttonsBefore = cap.buttonsBefore != Qt::NoButton;
+	return tr(&quot;%1%2%3%4%5%6&quot;, &quot;Modifier / button or wheel / double click / with / button / pressed&quot;)
+		.arg(keyboardModifiersString(cap.modifiers))
+		.arg(mouseButtonsString(cap.button)+(cap.button == Qt::NoButton ? tr(&quot;Wheel&quot;, &quot;Mouse wheel&quot;) : &quot;&quot;))
+		.arg(cap.doubleClick ? tr(&quot; double click&quot;, &quot;Suffix after mouse button&quot;) : &quot;&quot;)
+		.arg(buttonsBefore ? tr(&quot; with &quot;, &quot;As in : Left button with Ctrl pressed&quot;) : &quot;&quot;)
+		.arg(buttonsBefore ? mouseButtonsString(cap.buttonsBefore) : &quot;&quot;)
+		.arg(buttonsBefore ? tr(&quot; pressed&quot;, &quot;As in : Left button with Ctrl pressed&quot;) : &quot;&quot;);
+}
+
 /*! Provides a custom mouse binding description, displayed in the help() window Mouse tab.
 
- \p state is a combination of QtKeyboardModifiers (\c Qt::ControlModifier, \c Qt::AltModifier, \c
- Qt::ShiftModifier, \c Qt::MetaModifier) and QtMouseButtons (\c Qt::LeftButton, \c Qt::MidButton and
- \c Qt::RightButton), combined using the \c &quot;|&quot; bitwise operator or simply &quot;+&quot;. One can also use the
- shorter \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
+\p state is a combination of QtKeyboardModifiers (\c Qt::ControlModifier, \c Qt::AltModifier, \c
+Qt::ShiftModifier, \c Qt::MetaModifier) and QtMouseButtons (\c Qt::LeftButton, \c Qt::MidButton and
+\c Qt::RightButton), combined using the \c &quot;|&quot; bitwise operator or simply &quot;+&quot;. One can also use the
+shorter \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
 
- \p doubleClick indicates whether or not the user has to double click this button to perform the
- described action.
+\p doubleClick indicates whether or not the user has to double click this button to perform the
+described action.
 
- Set an empty \p description to \e remove a mouse binding description.
+Set an empty \p description to \e remove a mouse binding description.
 
- \code
- // Left and Right button together simulate a middle button
- setMouseBindingDescription(Qt::LeftButton + Qt::RightButton, &quot;Emulates a middle button&quot;);
+\code
+// Left and Right button together simulate a middle button
+setMouseBindingDescription(Qt::LeftButton + Qt::RightButton, &quot;Emulates a middle button&quot;);
 
- // A left button double click toggles full screen
- setMouseBindingDescription(Qt::LeftButton, &quot;Toggles full screen mode&quot;, true);
+// A left button double click toggles full screen
+setMouseBindingDescription(Qt::LeftButton, &quot;Toggles full screen mode&quot;, true);
 
- // Removes the description of Ctrl+Right button
- setMouseBindingDescription(Qt::ControlModifier + Qt::RightButton, &quot;&quot;);
- \endcode
+// Removes the description of Ctrl+Right button
+setMouseBindingDescription(Qt::ControlModifier + Qt::RightButton, &quot;&quot;);
+\endcode
 
- Overload mouseMoveEvent() and friends to implement your custom mouse behavior (see the
- mouseMoveEvent() documentation for an example). See the &lt;a
- href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an illustration.
+Overload mouseMoveEvent() and friends to implement your custom mouse behavior (see the
+mouseMoveEvent() documentation for an example). See the &lt;a
+href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an illustration.
 
- Use setMouseBinding() and setWheelBinding() to change the standard mouse action bindings.
+Use setMouseBinding() and setWheelBinding() to change the standard mouse action bindings.
 
- \note If you use Qt version 2 or 3, the \c Modifier postfix should be replaced by \c Button in the
- examples above (\c Qt::ControlButton, \c Qt::AltButton, ...).
+\note If you use Qt version 2 or 3, the \c Modifier postfix should be replaced by \c Button in the
+examples above (\c Qt::ControlButton, \c Qt::AltButton, ...).
 
- \note If you use Qt version 2 or 3, the \p buttonsBefore parameter type is actually a
- Qt::ButtonState. */
+\note If you use Qt version 2 or 3, the \p buttonsBefore parameter type is actually a
+Qt::ButtonState. */
 void QGLViewer::setMouseBindingDescription(int state, QString description, bool doubleClick, QtMouseButtons buttonsBefore)
 {
-  ClickActionPrivate cap;
-  cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
-  cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
-  cap.doubleClick = doubleClick;
-  cap.buttonsBefore = buttonsBefore;
+	ClickActionPrivate cap;
+	cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
+	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+	cap.doubleClick = doubleClick;
+	cap.buttonsBefore = buttonsBefore;
 
-  if (description.isEmpty())
-    mouseDescription_.remove(cap);
-  else
-    mouseDescription_[cap] = description;
+	if (description.isEmpty())
+		mouseDescription_.remove(cap);
+	else
+		mouseDescription_[cap] = description;
 }
 
 static QString tableLine(const QString&amp; left, const QString&amp; right)
 {
-  static bool even = false;
-  const QString tdtd(&quot;&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&quot;);
-  const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
+	static bool even = false;
+	const QString tdtd(&quot;&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&quot;);
+	const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
 
-  QString res(&quot;&lt;tr bgcolor=\&quot;&quot;);
+	QString res(&quot;&lt;tr bgcolor=\&quot;&quot;);
 
-  if (even)
-    res += &quot;#eeeeff\&quot;&gt;&quot;;
-  else
-    res += &quot;#ffffff\&quot;&gt;&quot;;
-  res += &quot;&lt;td&gt;&lt;b&gt;&quot; + left + tdtd + right + tdtr;
-  even = !even;
+	if (even)
+		res += &quot;#eeeeff\&quot;&gt;&quot;;
+	else
+		res += &quot;#ffffff\&quot;&gt;&quot;;
+	res += &quot;&lt;td&gt;&lt;b&gt;&quot; + left + tdtd + right + tdtr;
+	even = !even;
 
-  return res;
+	return res;
 }
 
 /*! Returns a QString that describes the application mouse bindings, displayed in the help() window
-  \c Mouse tab.
+\c Mouse tab.
 
-  Result is a table that describes custom application mouse binding descriptions defined using
-  setMouseBindingDescription() as well as standard mouse bindings (defined using setMouseBinding()
-  and setWheelBinding()). See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details on mouse
-  bindings.
+Result is a table that describes custom application mouse binding descriptions defined using
+setMouseBindingDescription() as well as standard mouse bindings (defined using setMouseBinding()
+and setWheelBinding()). See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details on mouse
+bindings.
 
-  See also helpString() and keyboardString(). */
+See also helpString() and keyboardString(). */
 QString QGLViewer::mouseString() const
 {
-  QString text(&quot;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot;&gt;\n&quot;);
-  const QString trtd(&quot;&lt;tr&gt;&lt;td&gt;&quot;);
-  const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
-  const QString tdtd(&quot;&lt;/td&gt;&lt;td&gt;&quot;);
+	QString text(&quot;&lt;center&gt;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot; cellpadding=\&quot;4\&quot;&gt;\n&quot;);
+	const QString trtd(&quot;&lt;tr&gt;&lt;td&gt;&quot;);
+	const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
+	const QString tdtd(&quot;&lt;/td&gt;&lt;td&gt;&quot;);
 
-  text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;Button(s)&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;\n&quot;;
+	text += QString(&quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;%1&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;%2&lt;/th&gt;&lt;/tr&gt;\n&quot;).
+		arg(tr(&quot;Button(s)&quot;, &quot;Buttons column header in help window mouse tab&quot;)).arg(tr(&quot;Description&quot;, &quot;Description column header in help window mouse tab&quot;));
 
-  QMap&lt;ClickActionPrivate, QString&gt; mouseBinding;
+	QMap&lt;ClickActionPrivate, QString&gt; mouseBinding;
 
-  // User-defined mouse bondings come first.
-  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator itm=mouseDescription_.begin(), endm=mouseDescription_.end(); itm!=endm; ++itm)
-    mouseBinding[itm.key()] = itm.value();
+	// User-defined mouse bondings come first.
+	for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator itm=mouseDescription_.begin(), endm=mouseDescription_.end(); itm!=endm; ++itm)
+		mouseBinding[itm.key()] = itm.value();
 
-  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it=mouseBinding.begin(), end=mouseBinding.end(); it != end; ++it)
-    {
-      // Should not be needed (see setMouseBindingDescription())
-      if (it.value().isNull())
-	continue;
+	for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it=mouseBinding.begin(), end=mouseBinding.end(); it != end; ++it)
+	{
+		// Should not be needed (see setMouseBindingDescription())
+		if (it.value().isNull())
+			continue;
 
-      QString button = keyboardModifiersString(it.key().modifiers) + mouseButtonsString(it.key().button);
-      if (it.key().doubleClick)
-	button += &quot; double click&quot;;
-      if (it.key().button == Qt::NoButton)
-	button += &quot;Wheel&quot;;
-      if (it.key().buttonsBefore != Qt::NoButton)
-	button += &quot; with &quot; + mouseButtonsString(it.key().buttonsBefore) + &quot; pressed&quot;;
+		text += tableLine(formatClickActionPrivate(it.key()), it.value());
+	}
 
-      text += tableLine(button, it.value());
-    }
+	// Optionnal separator line
+	if (!mouseBinding.isEmpty())
+	{
+		mouseBinding.clear();
+		text += QString(&quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;%1&lt;/td&gt;&lt;/tr&gt;\n&quot;).arg(tr(&quot;Standard mouse bindings&quot;, &quot;In help window mouse tab&quot;));
+	}
 
-  // Optionnal separator line
-  if (!mouseBinding.isEmpty())
-    {
-      mouseBinding.clear();
-      text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;Standard mouse bindings&lt;/td&gt;&lt;/tr&gt;\n&quot;;
-    }
+	// Then concatenates the descriptions of wheelBinding_, mouseBinding_ and clickBinding_.
+	// The order is significant and corresponds to the priorities set in mousePressEvent() (reverse priority order, last one overwrites previous)
+	// #CONNECTION# mousePressEvent() order
+	for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator itw=wheelBinding_.begin(), endw=wheelBinding_.end(); itw != endw; ++itw)
+	{
+		ClickActionPrivate cap;
+		cap.doubleClick = false;
+		cap.modifiers = itw.key();
+		cap.button = Qt::NoButton;
+		cap.buttonsBefore = Qt::NoButton;
 
-  // Concatenates the descriptions of wheelBinding_, mouseBinding_, clickBinding_ and mouseDescription_.
-  // The order is significant and corresponds to the priorities set in mousePressEvent()
-  // #CONNECTION# mousePressEvent() order
-  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator itw=wheelBinding_.begin(), endw=wheelBinding_.end(); itw != endw; ++itw)
-    {
-      ClickActionPrivate cap;
-      cap.doubleClick = false;
-      cap.modifiers = itw.key();
-      cap.button = Qt::NoButton;
-      cap.buttonsBefore = Qt::NoButton;
+		QString text = mouseActionString(itw.value().action);
 
-      QString text = mouseActionString(itw.value().action);
+		if (!text.isNull())
+		{
+			switch (itw.value().handler)
+			{
+			case CAMERA: text += &quot; &quot; + tr(&quot;camera&quot;, &quot;Suffix after action&quot;); break;
+			case FRAME:  text += &quot; &quot; + tr(&quot;manipulated frame&quot;, &quot;Suffix after action&quot;); break;
+			}
+			if (!(itw.value().withConstraint))
+				text += &quot;*&quot;;
+		}
 
-      if (!text.isNull())
-	{
-	  switch (itw.value().handler)
-	    {
-	    case CAMERA: text += &quot; camera&quot;; break;
-	    case FRAME:  text += &quot; manipulated frame&quot;; break;
-	    }
-	  if (!(itw.value().withConstraint))
-	    text += &quot;*&quot;;
+		mouseBinding[cap] = text;
 	}
 
-      mouseBinding[cap] = text;
-    }
+	for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator itmb=mouseBinding_.begin(), endmb=mouseBinding_.end();
+		itmb != endmb; ++itmb)
+	{
+		ClickActionPrivate cap;
+		cap.doubleClick = false;
+		cap.modifiers = QtKeyboardModifiers(itmb.key() &amp; Qt::KeyboardModifierMask);
+		cap.button = QtMouseButtons(itmb.key() &amp; Qt::MouseButtonMask);
+		cap.buttonsBefore = Qt::NoButton;
 
-  for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator itmb=mouseBinding_.begin(), endmb=mouseBinding_.end();
-       itmb != endmb; ++itmb)
-    {
-      ClickActionPrivate cap;
-      cap.doubleClick = false;
-      cap.modifiers = QtKeyboardModifiers(itmb.key() &amp; Qt::KeyboardModifierMask);
-      cap.button = QtMouseButtons(itmb.key() &amp; Qt::MouseButtonMask);
-      cap.buttonsBefore = Qt::NoButton;
+		QString text = mouseActionString(itmb.value().action);
 
-      QString text = mouseActionString(itmb.value().action);
-
-      if (!text.isNull())
-	{
-	  switch (itmb.value().handler)
-	    {
-	    case CAMERA: text += &quot; camera&quot;; break;
-	    case FRAME:  text += &quot; manipulated frame&quot;; break;
-	    }
-	  if (!(itmb.value().withConstraint))
-	    text += &quot;*&quot;;
+		if (!text.isNull())
+		{
+			switch (itmb.value().handler)
+			{
+			case CAMERA: text += &quot; &quot; + tr(&quot;camera&quot;, &quot;Suffix after action&quot;); break;
+			case FRAME:  text += &quot; &quot; + tr(&quot;manipulated frame&quot;, &quot;Suffix after action&quot;); break;
+			}
+			if (!(itmb.value().withConstraint))
+				text += &quot;*&quot;;
+		}
+		mouseBinding[cap] = text;
 	}
-      mouseBinding[cap] = text;
-    }
 
-  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator itcb=clickBinding_.begin(), endcb=clickBinding_.end(); itcb!=endcb; ++itcb)
-    mouseBinding[itcb.key()] = clickActionString(itcb.value());
+	for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator itcb=clickBinding_.begin(), endcb=clickBinding_.end(); itcb!=endcb; ++itcb)
+		mouseBinding[itcb.key()] = clickActionString(itcb.value());
 
-  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it2=mouseBinding.begin(), end2=mouseBinding.end(); it2 != end2; ++it2)
-    {
-      if (it2.value().isNull())
-	continue;
+	for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it2=mouseBinding.begin(), end2=mouseBinding.end(); it2 != end2; ++it2)
+	{
+		if (it2.value().isNull())
+			continue;
 
-      QString button = keyboardModifiersString(it2.key().modifiers) + mouseButtonsString(it2.key().button);
-      if (it2.key().doubleClick)
-	button += &quot; double click&quot;;
-      if (it2.key().button == Qt::NoButton)
-	button += &quot;Wheel&quot;;
-      if (it2.key().buttonsBefore != Qt::NoButton)
-	button += &quot; with &quot; + mouseButtonsString(it2.key().buttonsBefore) + &quot; pressed&quot;;
+		text += tableLine(formatClickActionPrivate(it2.key()), it2.value());
+	}
 
-      text += tableLine(button, it2.value());
-    }
+	text += &quot;&lt;/table&gt;&lt;/center&gt;&quot;;
 
-  text += &quot;&lt;/table&gt;&quot;;
-
-  return text;
+	return text;
 }
 
 /*! Defines a custom keyboard shortcut description, that will be displayed in the help() window \c
- Keyboard tab.
+Keyboard tab.
 
- The \p key definition is given as an \c int using Qt enumerated values. Set an empty \p description
- to remove a shortcut description:
- \code
- setKeyDescription(Qt::Key_W, &quot;Toggles wireframe display&quot;);
- setKeyDescription(Qt::CTRL+Qt::Key_L, &quot;Loads a new scene&quot;);
- // Removes a description
- setKeyDescription(Qt::CTRL+Qt::Key_C, &quot;&quot;);
- \endcode
+The \p key definition is given as an \c int using Qt enumerated values. Set an empty \p description
+to remove a shortcut description:
+\code
+setKeyDescription(Qt::Key_W, &quot;Toggles wireframe display&quot;);
+setKeyDescription(Qt::CTRL+Qt::Key_L, &quot;Loads a new scene&quot;);
+// Removes a description
+setKeyDescription(Qt::CTRL+Qt::Key_C, &quot;&quot;);
+\endcode
 
- See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for illustration
- and the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
+See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for illustration
+and the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
 void QGLViewer::setKeyDescription(int key, QString description)
 {
 #if QT_VERSION &gt;= 0x030000
-  // #CONNECTION# keyString. In Qt 2.3, longs modifier overlap with key codes.
-  key = convertToKeyboardModifiers(key);
+	// #CONNECTION# keyString. In Qt 2.3, longs modifier overlap with key codes.
+	key = convertToKeyboardModifiers(key);
 #endif
-  if (description.isEmpty())
-    keyDescription_.remove(key);
-  else
-    keyDescription_[key] = description;
+	if (description.isEmpty())
+		keyDescription_.remove(key);
+	else
+		keyDescription_[key] = description;
 }
 
 static QString keyString(int key)
 {
 #if QT_VERSION &gt;= 0x030000
-  return QString(QKeySequence(convertToShortModifier(key)));
+	return QString(QKeySequence(convertToShortModifier(key)));
 #else
-  // #CONNECTION# setKeyDescription. In Qt 2.3, longs modifier overlap with key codes.
-  return QString(QKeySequence(key));
+	// #CONNECTION# setKeyDescription. In Qt 2.3, longs modifier overlap with key codes.
+	return QString(QKeySequence(key));
 #endif
 }
 
 QString QGLViewer::cameraPathKeysString() const
 {
-  if (pathIndex_.isEmpty())
-    return QString::null;
+	if (pathIndex_.isEmpty())
+		return QString::null;
 
 #if QT_VERSION &gt;= 0x040000 || QT_VERSION &lt; 0x030000
-  QVector&lt;int&gt; keys;
+	QVector&lt;int&gt; keys;
 #else
-  QValueVector&lt;int&gt; keys;
+	QValueVector&lt;int&gt; keys;
 #endif
-  keys.reserve(pathIndex_.count());
-  for (QMap&lt;Qt::Key, int&gt;::ConstIterator i = pathIndex_.begin(), endi=pathIndex_.end(); i != endi; ++i)
-    keys.push_back(i.key());
+	keys.reserve(pathIndex_.count());
+	for (QMap&lt;Qt::Key, int&gt;::ConstIterator i = pathIndex_.begin(), endi=pathIndex_.end(); i != endi; ++i)
+		keys.push_back(i.key());
 #if QT_VERSION &gt;= 0x040000
-  qSort(keys);
+	qSort(keys);
 #else
 # if QT_VERSION &gt;= 0x030000
-  qHeapSort(keys);
+	qHeapSort(keys);
 # else
-  sort(keys.begin(), keys.end());
+	sort(keys.begin(), keys.end());
 # endif
 #endif
 
 #if QT_VERSION &gt;= 0x040000 || QT_VERSION &lt; 0x030000
-  QVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
+	QVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
 #else
-  QValueVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
+	QValueVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
 #endif
-  QString res = keyString(*it);
+	QString res = keyString(*it);
 
-  const int maxDisplayedKeys = 6;
-  int nbDisplayedKeys = 0;
-  int previousKey = (*it);
-  int state = 0;
-  ++it;
-  while ((it != end) &amp;&amp; (nbDisplayedKeys &lt; maxDisplayedKeys-1))
-    {
-      switch (state)
+	const int maxDisplayedKeys = 6;
+	int nbDisplayedKeys = 0;
+	int previousKey = (*it);
+	int state = 0;
+	++it;
+	while ((it != end) &amp;&amp; (nbDisplayedKeys &lt; maxDisplayedKeys-1))
 	{
-	case 0 :
-	  if ((*it) == previousKey + 1)
-	    state++;
-	  else
-	    {
-	      res += &quot;, &quot; + keyString(*it);
-	      nbDisplayedKeys++;
-	    }
-	  break;
-	case 1 :
-	  if ((*it) == previousKey + 1)
-	    state++;
-	  else
-	    {
-	      res += &quot;, &quot; + keyString(previousKey);
-	      res += &quot;, &quot; + keyString(*it);
-	      nbDisplayedKeys += 2;
-	      state = 0;
-	    }
-	  break;
-	default :
-	  if ((*it) != previousKey + 1)
-	    {
-	      res += &quot;..&quot; + keyString(previousKey);
-	      res += &quot;, &quot; + keyString(*it);
-	      nbDisplayedKeys += 2;
-	      state = 0;
-	    }
-	  break;
+		switch (state)
+		{
+		case 0 :
+			if ((*it) == previousKey + 1)
+				state++;
+			else
+			{
+				res += &quot;, &quot; + keyString(*it);
+				nbDisplayedKeys++;
+			}
+			break;
+		case 1 :
+			if ((*it) == previousKey + 1)
+				state++;
+			else
+			{
+				res += &quot;, &quot; + keyString(previousKey);
+				res += &quot;, &quot; + keyString(*it);
+				nbDisplayedKeys += 2;
+				state = 0;
+			}
+			break;
+		default :
+			if ((*it) != previousKey + 1)
+			{
+				res += &quot;..&quot; + keyString(previousKey);
+				res += &quot;, &quot; + keyString(*it);
+				nbDisplayedKeys += 2;
+				state = 0;
+			}
+			break;
+		}
+		previousKey = *it;
+		++it;
 	}
-      previousKey = *it;
-      ++it;
-    }
 
-  if (state == 1)
-    res += &quot;, &quot; + keyString(previousKey);
-  if (state == 2)
-    res += &quot;..&quot; + keyString(previousKey);
-  if (it != end)
-    res += &quot;...&quot;;
+	if (state == 1)
+		res += &quot;, &quot; + keyString(previousKey);
+	if (state == 2)
+		res += &quot;..&quot; + keyString(previousKey);
+	if (it != end)
+		res += &quot;...&quot;;
 
-  return res;
+	return res;
 }
 
 /*! Returns a QString that describes the application keyboard shortcut bindings, and that will be
- displayed in the help() window \c Keyboard tab.
+displayed in the help() window \c Keyboard tab.
 
- Default value is a table that describes the custom shortcuts defined using setKeyDescription() as
- well as the \e standard QGLViewer::KeyboardAction shortcuts (defined using setShortcut()). See the
- &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details on key customization.
+Default value is a table that describes the custom shortcuts defined using setKeyDescription() as
+well as the \e standard QGLViewer::KeyboardAction shortcuts (defined using setShortcut()). See the
+&lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details on key customization.
 
- See also helpString() and mouseString(). */
+See also helpString() and mouseString(). */
 QString QGLViewer::keyboardString() const
 {
-  QString text(&quot;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot;&gt;\n&quot;);
-  text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;Key(s)&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;\n&quot;;
+	QString text(&quot;&lt;center&gt;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot; cellpadding=\&quot;4\&quot;&gt;\n&quot;);
+	text += QString(&quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;%1&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;%2&lt;/th&gt;&lt;/tr&gt;\n&quot;).
+		arg(QGLViewer::tr(&quot;Key(s)&quot;, &quot;Keys column header in help window mouse tab&quot;)).arg(QGLViewer::tr(&quot;Description&quot;, &quot;Description column header in help window mouse tab&quot;));
 
-  QMap&lt;int, QString&gt; keyDescription;
+	QMap&lt;int, QString&gt; keyDescription;
 
-  // 1 - User defined key descriptions
-  for (QMap&lt;int, QString&gt;::ConstIterator kd=keyDescription_.begin(), kdend=keyDescription_.end(); kd!=kdend; ++kd)
-    keyDescription[kd.key()] = kd.value();
+	// 1 - User defined key descriptions
+	for (QMap&lt;int, QString&gt;::ConstIterator kd=keyDescription_.begin(), kdend=keyDescription_.end(); kd!=kdend; ++kd)
+		keyDescription[kd.key()] = kd.value();
 
-  // Add to text in sorted order
-  for (QMap&lt;int, QString&gt;::ConstIterator kb=keyDescription.begin(), endb=keyDescription.end(); kb!=endb; ++kb)
-    text += tableLine(keyString(kb.key()), kb.value());
+	// Add to text in sorted order
+	for (QMap&lt;int, QString&gt;::ConstIterator kb=keyDescription.begin(), endb=keyDescription.end(); kb!=endb; ++kb)
+		text += tableLine(keyString(kb.key()), kb.value());
 
 
-  // 2 - Optional separator line
-  if (!keyDescription.isEmpty())
-    {
-      keyDescription.clear();
-      text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;Standard viewer keys&lt;/td&gt;&lt;/tr&gt;\n&quot;;
-    }
+	// 2 - Optional separator line
+	if (!keyDescription.isEmpty())
+	{
+		keyDescription.clear();
+		text += QString(&quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;%1&lt;/td&gt;&lt;/tr&gt;\n&quot;).arg(QGLViewer::tr(&quot;Standard viewer keys&quot;, &quot;In help window keys tab&quot;));
+	}
 
 
-  // 3 - KeyboardAction bindings description
-  for (QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end(); it != end; ++it)
-    if ((it.value() != 0) &amp;&amp; ((!cameraIsInRevolveMode()) || ((it.key() != INCREASE_FLYSPEED) &amp;&amp; (it.key() != DECREASE_FLYSPEED))))
-      keyDescription[it.value()] = keyboardActionDescription_[it.key()];
+	// 3 - KeyboardAction bindings description
+	for (QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end(); it != end; ++it)
+		if ((it.value() != 0) &amp;&amp; ((!cameraIsInRevolveMode()) || ((it.key() != INCREASE_FLYSPEED) &amp;&amp; (it.key() != DECREASE_FLYSPEED))))
+			keyDescription[it.value()] = keyboardActionDescription_[it.key()];
 
-  // Add to text in sorted order
-  for (QMap&lt;int, QString&gt;::ConstIterator kb2=keyDescription.begin(), endb2=keyDescription.end(); kb2!=endb2; ++kb2)
-    text += tableLine(keyString(kb2.key()), kb2.value());
+	// Add to text in sorted order
+	for (QMap&lt;int, QString&gt;::ConstIterator kb2=keyDescription.begin(), endb2=keyDescription.end(); kb2!=endb2; ++kb2)
+		text += tableLine(keyString(kb2.key()), kb2.value());
 
 
-  // 4 - Camera paths keys description
-  const QString cpks = cameraPathKeysString();
-  if (!cpks.isNull())
-    {
-      text += &quot;&lt;tr bgcolor=\&quot;#ccccff\&quot;&gt;&gt;&lt;td colspan=2&gt;\nCamera paths are controlled using &quot; + cpks + &quot; (noted &lt;i&gt;Fx&lt;/i&gt; below):&lt;/td&gt;&lt;/tr&gt;\n&quot;;
-      text += tableLine(keyboardModifiersString(playPathKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;&quot;,
-			&quot;Plays path (or resets saved position)&quot;);
-      text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;&quot;,
-			&quot;Adds a key frame (or defines a position)&quot;);
-      text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;+&lt;i&gt;Fx&lt;/i&gt;&quot;,
-			&quot;Deletes path (or saved position)&quot;);
-    }
-  text += &quot;&lt;/table&gt;&quot;;
+	// 4 - Camera paths keys description
+	const QString cpks = cameraPathKeysString();
+	if (!cpks.isNull())
+	{
+		text += &quot;&lt;tr bgcolor=\&quot;#ccccff\&quot;&gt;&lt;td colspan=2&gt;\n&quot;;
+		text += QGLViewer::tr(&quot;Camera paths are controlled using %1 (noted &lt;i&gt;Fx&lt;/i&gt; below):&quot;, &quot;Help window key tab camera keys&quot;).arg(cpks) + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;;
+		text += tableLine(keyboardModifiersString(playPathKeyboardModifiers()) + &quot;&lt;i&gt;&quot; + QGLViewer::tr(&quot;Fx&quot;, &quot;Generic function key (F1..F12)&quot;) + &quot;&lt;/i&gt;&quot;,
+			QGLViewer::tr(&quot;Plays path (or resets saved position)&quot;));
+		text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;&quot; + QGLViewer::tr(&quot;Fx&quot;, &quot;Generic function key (F1..F12)&quot;) + &quot;&lt;/i&gt;&quot;,
+			QGLViewer::tr(&quot;Adds a key frame to path (or defines a position)&quot;));
+		text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;&quot; + QGLViewer::tr(&quot;Fx&quot;, &quot;Generic function key (F1..F12)&quot;) + &quot;&lt;/i&gt;+&lt;i&gt;&quot; + QGLViewer::tr(&quot;Fx&quot;, &quot;Generic function key (F1..F12)&quot;) + &quot;&lt;/i&gt;&quot;,
+			QGLViewer::tr(&quot;Deletes path (or saved position)&quot;));
+	}
+	text += &quot;&lt;/table&gt;&lt;/center&gt;&quot;;
 
-  return text;
+	return text;
 }
 
 /*! Opens a modal help window that includes three tabs, respectively filled with helpString(),
-  keyboardString() and mouseString().
+keyboardString() and mouseString().
 
- Rich html-like text can be used (see the QStyleSheet documentation). This method is called when the
- user presses the QGLViewer::HELP (default is 'H').
+Rich html-like text can be used (see the QStyleSheet documentation). This method is called when the
+user presses the QGLViewer::HELP (default is 'H').
 
- Use helpWidget() to access to the help widget (to add/remove tabs, change layout...). The &quot;About&quot;
- button (helpWidget()-&gt;cornerWidget()) is connected to the aboutQGLViewer() slot.
+Use helpWidget() to access to the help widget (to add/remove tabs, change layout...). The &quot;About&quot;
+button (helpWidget()-&gt;cornerWidget()) is connected to the aboutQGLViewer() slot.
 
- The helpRequired() signal is emitted. */
+The helpRequired() signal is emitted. */
 void QGLViewer::help()
 {
-  emit helpRequired();
+	emit helpRequired();
 
-  bool resize = false;
-  int width=600;
-  int height=400;
+	bool resize = false;
+	int width=600;
+	int height=400;
 
-  static QString label[] = {&quot; &amp;Help &quot;, &quot; &amp;Keyboard &quot;, &quot; &amp;Mouse &quot;};
+	static QString label[] = {tr(&quot;&amp;Help&quot;, &quot;Help window tab title&quot;), tr(&quot;&amp;Keyboard&quot;, &quot;Help window tab title&quot;), tr(&quot;&amp;Mouse&quot;, &quot;Help window tab title&quot;)};
 
-  if (!helpWidget())
-    {
-      // Qt4 requires a NULL parent...
-      helpWidget_ = new QTabWidget(NULL);
+	if (!helpWidget())
+	{
+		// Qt4 requires a NULL parent...
+		helpWidget_ = new QTabWidget(NULL);
 #if QT_VERSION &gt;= 0x040000
-      helpWidget()-&gt;setWindowTitle(&quot;Help&quot;);
+		helpWidget()-&gt;setWindowTitle(tr(&quot;Help&quot;, &quot;Help window title&quot;));
 #else
-      helpWidget()-&gt;setCaption(&quot;Help&quot;);
+		helpWidget()-&gt;setCaption(tr(&quot;Help&quot;, &quot;Help window title&quot;));
 #endif
 
 #if QT_VERSION &gt;= 0x030200
-      QPushButton* aboutButton = new QPushButton(&quot;About&quot;, helpWidget());
-      connect(aboutButton, SIGNAL(released()), SLOT(aboutQGLViewer()));
-      helpWidget()-&gt;setCornerWidget(aboutButton);
+		QPushButton* aboutButton = new QPushButton(tr(&quot;About&quot;, &quot;About button in help window&quot;), helpWidget());
+		connect(aboutButton, SIGNAL(released()), SLOT(aboutQGLViewer()));
+		helpWidget()-&gt;setCornerWidget(aboutButton);
 #endif
 
-      resize = true;
-      for (int i=0; i&lt;3; ++i)
-	{
-	  QTextEdit* tab = new QTextEdit(NULL);
+		resize = true;
+		for (int i=0; i&lt;3; ++i)
+		{
+			QTextEdit* tab = new QTextEdit(NULL);
 #if QT_VERSION &gt;= 0x030000
-	  tab-&gt;setReadOnly(true);
+			tab-&gt;setReadOnly(true);
 #endif
 
 #if QT_VERSION &gt;= 0x040000
-	  helpWidget()-&gt;insertTab(i, tab, label[i]);
+			helpWidget()-&gt;insertTab(i, tab, label[i]);
 #else
-	  tab-&gt;setTextFormat(Qt::RichText);
-	  helpWidget()-&gt;insertTab(tab, label[i]);
+			tab-&gt;setTextFormat(Qt::RichText);
+			helpWidget()-&gt;insertTab(tab, label[i]);
 #endif
+		}
 	}
-    }
 
 #if QT_VERSION &lt; 0x030000
-  const int currentPageIndex = helpWidget()-&gt;currentPageIndex();
+	const int currentPageIndex = helpWidget()-&gt;currentPageIndex();
 #endif
 
-  for (int i=0; i&lt;3; ++i)
-    {
-      QString text;
-      switch (i)
+	for (int i=0; i&lt;3; ++i)
 	{
-	case 0 : text = helpString();	  break;
-	case 1 : text = keyboardString(); break;
-	case 2 : text = mouseString();	  break;
-	default : break;
-	}
+		QString text;
+		switch (i)
+		{
+		case 0 : text = helpString();	  break;
+		case 1 : text = keyboardString(); break;
+		case 2 : text = mouseString();	  break;
+		default : break;
+		}
 
 #if QT_VERSION &gt;= 0x040000
-    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;widget(i));
-    textEdit-&gt;setHtml(text);
+		QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;widget(i));
+		textEdit-&gt;setHtml(text);
 #else
 # if QT_VERSION &lt; 0x030000
-    helpWidget()-&gt;setCurrentPage(i);
-    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;currentPage());
+		helpWidget()-&gt;setCurrentPage(i);
+		QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;currentPage());
 # else
-    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;page(i));
+		QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;page(i));
 # endif
-    textEdit-&gt;setText(text);
+		textEdit-&gt;setText(text);
 #endif
 
 #if QT_VERSION &lt; 0x040000
-    if (resize &amp;&amp; (textEdit-&gt;heightForWidth(width) &gt; height))
-      height = textEdit-&gt;heightForWidth(width);
+		if (resize &amp;&amp; (textEdit-&gt;heightForWidth(width) &gt; height))
+			height = textEdit-&gt;heightForWidth(width);
 #else
-    if (resize &amp;&amp; (textEdit-&gt;height() &gt; height))
-      height = textEdit-&gt;height();
+		if (resize &amp;&amp; (textEdit-&gt;height() &gt; height))
+			height = textEdit-&gt;height();
 #endif
-    }
+	}
 
 #if QT_VERSION &lt; 0x030000
-  helpWidget()-&gt;setCurrentPage(currentPageIndex);
+	helpWidget()-&gt;setCurrentPage(currentPageIndex);
 #endif
 
-  if (resize)
-    helpWidget()-&gt;resize(width, height+40); // 40 pixels is ~ tabs' height
-  helpWidget()-&gt;show();
-  helpWidget()-&gt;raise();
+	if (resize)
+		helpWidget()-&gt;resize(width, height+40); // 40 pixels is ~ tabs' height
+	helpWidget()-&gt;show();
+	helpWidget()-&gt;raise();
 }
 
 /*! Overloading of the \c QWidget method.
 
- Default keyboard shortcuts are defined using setShortcut(). Overload this method to implement a
- specific keyboard binding. Call the original method if you do not catch the event to preserve the
- viewer default key bindings:
- \code
- void Viewer::keyPressEvent(QKeyEvent *e)
- {
-   // With Qt 2 or 3, you would retrieve modifiers keys using :
-   // const Qt::ButtonState modifiers = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);
+Default keyboard shortcuts are defined using setShortcut(). Overload this method to implement a
+specific keyboard binding. Call the original method if you do not catch the event to preserve the
+viewer default key bindings:
+\code
+void Viewer::keyPressEvent(QKeyEvent *e)
+{
+// With Qt 2 or 3, you would retrieve modifiers keys using :
+// const Qt::ButtonState modifiers = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);
 
-   // Defines the Alt+R shortcut. Call updateGL to refresh display.
-   if ((e-&gt;key() == Qt::Key_R) &amp;&amp; (e-&gt;modifiers() == Qt::AltModifier))
-     {
-       myResetFunction();
-       updateGL();
-     }
-   else
-     QGLViewer::keyPressEvent(e);
- }
- \endcode
- When you define a new keyboard shortcut, use setKeyDescription() to provide a short description
- which is displayed in the help() window Keyboard tab. See the &lt;a
- href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
+// Defines the Alt+R shortcut. Call updateGL to refresh display.
+if ((e-&gt;key() == Qt::Key_R) &amp;&amp; (e-&gt;modifiers() == Qt::AltModifier))
+{
+myResetFunction();
+updateGL();
+}
+else
+QGLViewer::keyPressEvent(e);
+}
+\endcode
+When you define a new keyboard shortcut, use setKeyDescription() to provide a short description
+which is displayed in the help() window Keyboard tab. See the &lt;a
+href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
 
- See also QGLWidget::keyReleaseEvent(). */
+See also QGLWidget::keyReleaseEvent(). */
 void QGLViewer::keyPressEvent(QKeyEvent *e)
 {
-  if (e-&gt;key() == 0)
-    {
-      e-&gt;ignore();
-      return;
-    }
+	if (e-&gt;key() == 0)
+	{
+		e-&gt;ignore();
+		return;
+	}
 
-  const Qt::Key key = Qt::Key(e-&gt;key());
+	const Qt::Key key = Qt::Key(e-&gt;key());
 #if QT_VERSION &gt;= 0x040000
-  const QtKeyboardModifiers modifiers = e-&gt;modifiers();
+	const QtKeyboardModifiers modifiers = e-&gt;modifiers();
 #else
-  const QtKeyboardModifiers modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+	const QtKeyboardModifiers modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
 #endif
 
-  QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end();
-  while ((it != end) &amp;&amp; (it.value() != (key | modifiers)))
-    ++it;
+	QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end();
+	while ((it != end) &amp;&amp; (it.value() != (key | modifiers)))
+		++it;
 
-  if (it != end)
-    handleKeyboardAction(it.key());
-  else
-    if (pathIndex_.contains(Qt::Key(key)))
-      {
-	// Camera paths
-	int index = pathIndex_[Qt::Key(key)];
+	if (it != end)
+		handleKeyboardAction(it.key());
+	else
+		if (pathIndex_.contains(Qt::Key(key)))
+		{
+			// Camera paths
+			int index = pathIndex_[Qt::Key(key)];
 
-	static QTime doublePress; // try to double press on two viewers at the same time !
+			static QTime doublePress; // try to double press on two viewers at the same time !
 
-	if (modifiers == playPathKeyboardModifiers())
-	  {
-	    int elapsed = doublePress.restart();
-	    if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
-	      camera()-&gt;resetPath(index);
-	    else
-	      {
-		// Stop previous interpolation before starting a new one.
-		if (index != previousPathId_)
-		  {
-		    KeyFrameInterpolator* previous = camera()-&gt;keyFrameInterpolator(previousPathId_);
-		    if ((previous) &amp;&amp; (previous-&gt;interpolationIsStarted()))
-		      previous-&gt;resetInterpolation();
-		  }
-		camera()-&gt;playPath(index);
-	      }
-	    previousPathId_ = index;
-	  }
-	else if (modifiers == addKeyFrameKeyboardModifiers())
-	  {
-	    int elapsed = doublePress.restart();
-	    if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
-	      {
-		if (camera()-&gt;keyFrameInterpolator(index))
-		  {
-		    disconnect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), this, SLOT(updateGL()));
-		    if (camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames() &gt; 1)
-		      displayMessage(&quot;Path &quot;+QString::number(index)+&quot; deleted&quot;);
-		    else
-		      displayMessage(&quot;Position &quot;+QString::number(index)+&quot; deleted&quot;);
-		    camera()-&gt;deletePath(index);
-		  }
-	      }
-	    else
-	      {
-		bool nullBefore = (camera()-&gt;keyFrameInterpolator(index) == NULL);
-		camera()-&gt;addKeyFrameToPath(index);
-		if (nullBefore)
-		  connect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), SLOT(updateGL()));
-		int nbKF = camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames();
-		if (nbKF == 1)
-		  displayMessage(&quot;Position &quot;+QString::number(index)+&quot; saved&quot;);
+			if (modifiers == playPathKeyboardModifiers())
+			{
+				int elapsed = doublePress.restart();
+				if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
+					camera()-&gt;resetPath(index);
+				else
+				{
+					// Stop previous interpolation before starting a new one.
+					if (index != previousPathId_)
+					{
+						KeyFrameInterpolator* previous = camera()-&gt;keyFrameInterpolator(previousPathId_);
+						if ((previous) &amp;&amp; (previous-&gt;interpolationIsStarted()))
+							previous-&gt;resetInterpolation();
+					}
+					camera()-&gt;playPath(index);
+				}
+				previousPathId_ = index;
+			}
+			else if (modifiers == addKeyFrameKeyboardModifiers())
+			{
+				int elapsed = doublePress.restart();
+				if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
+				{
+					if (camera()-&gt;keyFrameInterpolator(index))
+					{
+						disconnect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), this, SLOT(updateGL()));
+						if (camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames() &gt; 1)
+							displayMessage(tr(&quot;Path %1 deleted&quot;, &quot;Feedback message&quot;).arg(index));
+						else
+							displayMessage(tr(&quot;Position %1 deleted&quot;, &quot;Feedback message&quot;).arg(index));
+						camera()-&gt;deletePath(index);
+					}
+				}
+				else
+				{
+					bool nullBefore = (camera()-&gt;keyFrameInterpolator(index) == NULL);
+					camera()-&gt;addKeyFrameToPath(index);
+					if (nullBefore)
+						connect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), SLOT(updateGL()));
+					int nbKF = camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames();
+					if (nbKF &gt; 1)
+						displayMessage(tr(&quot;Path %1, position %2 added&quot;, &quot;Feedback message&quot;).arg(index).arg(nbKF));
+					else
+						displayMessage(tr(&quot;Position %1 saved&quot;, &quot;Feedback message&quot;).arg(index));
+				}
+				previousPathId_ = index;
+			}
+			updateGL();
+		}
 		else
-		  displayMessage(&quot;Path &quot;+QString::number(index)+&quot;, position &quot;+QString::number(nbKF)+&quot; saved&quot;);
-	      }
-	    previousPathId_ = index;
-	  }
-	updateGL();
-      }
-    else
-      e-&gt;ignore();
+			e-&gt;ignore();
 }
 
 void QGLViewer::handleKeyboardAction(KeyboardAction id)
 {
-  switch (id)
-    {
-    case DRAW_AXIS :		toggleAxisIsDrawn(); break;
-    case DRAW_GRID :		toggleGridIsDrawn(); break;
-    case DISPLAY_FPS :		toggleFPSIsDisplayed(); break;
-    case ENABLE_TEXT :		toggleTextIsEnabled(); break;
-    case EXIT_VIEWER :		saveStateToFileForAllViewers(); qApp-&gt;closeAllWindows(); break;
-    case SAVE_SCREENSHOT :	saveSnapshot(false, false); break;
-    case FULL_SCREEN :		toggleFullScreen(); break;
-    case STEREO :		toggleStereoDisplay(); break;
-    case ANIMATION :		toggleAnimation(); break;
-    case HELP :			help(); break;
-    case EDIT_CAMERA :		toggleCameraIsEdited(); break;
-    case CAMERA_MODE :
-      toggleCameraMode();
-      displayMessage(cameraIsInRevolveMode()?&quot;Camera in revolve around mode&quot;:&quot;Camera in fly mode&quot;);
-      break;
+	switch (id)
+	{
+	case DRAW_AXIS :		toggleAxisIsDrawn(); break;
+	case DRAW_GRID :		toggleGridIsDrawn(); break;
+	case DISPLAY_FPS :		toggleFPSIsDisplayed(); break;
+	case ENABLE_TEXT :		toggleTextIsEnabled(); break;
+	case EXIT_VIEWER :		saveStateToFileForAllViewers(); qApp-&gt;closeAllWindows(); break;
+	case SAVE_SCREENSHOT :	saveSnapshot(false, false); break;
+	case FULL_SCREEN :		toggleFullScreen(); break;
+	case STEREO :		toggleStereoDisplay(); break;
+	case ANIMATION :		toggleAnimation(); break;
+	case HELP :			help(); break;
+	case EDIT_CAMERA :		toggleCameraIsEdited(); break;
+	case CAMERA_MODE :
+		toggleCameraMode();
+		displayMessage(cameraIsInRevolveMode()?tr(&quot;Camera in revolve around mode&quot;, &quot;Feedback message&quot;):tr(&quot;Camera in fly mode&quot;, &quot;Feedback message&quot;));
+		break;
 
-    case MOVE_CAMERA_LEFT :
-      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(-10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
-      updateGL();
-      break;
-    case MOVE_CAMERA_RIGHT :
-      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec( 10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
-      updateGL();
-      break;
-    case MOVE_CAMERA_UP :
-      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0,  10.0*camera()-&gt;flySpeed(), 0.0)));
-      updateGL();
-      break;
-    case MOVE_CAMERA_DOWN :
-      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0, -10.0*camera()-&gt;flySpeed(), 0.0)));
-      updateGL();
-      break;
+	case MOVE_CAMERA_LEFT :
+		camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(-10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
+		updateGL();
+		break;
+	case MOVE_CAMERA_RIGHT :
+		camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec( 10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
+		updateGL();
+		break;
+	case MOVE_CAMERA_UP :
+		camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0,  10.0*camera()-&gt;flySpeed(), 0.0)));
+		updateGL();
+		break;
+	case MOVE_CAMERA_DOWN :
+		camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0, -10.0*camera()-&gt;flySpeed(), 0.0)));
+		updateGL();
+		break;
 
-    case INCREASE_FLYSPEED : 	camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() * 1.5); break;
-    case DECREASE_FLYSPEED : 	camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() / 1.5); break;
-    }
+	case INCREASE_FLYSPEED : camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() * 1.5); break;
+	case DECREASE_FLYSPEED : camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() / 1.5); break;
+	}
 }
 
 /*! Callback method used when the widget size is modified.
 
- If you overload this method, first call the inherited method. Also called when the widget is
- created, before its first display. */
+If you overload this method, first call the inherited method. Also called when the widget is
+created, before its first display. */
 void QGLViewer::resizeGL(int width, int height)
 {
-  QGLWidget::resizeGL(width, height);
-  glViewport( 0, 0, GLint(width), GLint(height) );
-  camera()-&gt;setScreenWidthAndHeight(this-&gt;width(), this-&gt;height());
+	QGLWidget::resizeGL(width, height);
+	glViewport( 0, 0, GLint(width), GLint(height) );
+	camera()-&gt;setScreenWidthAndHeight(this-&gt;width(), this-&gt;height());
 }
 
 //////////////////////////////////////////////////////////////////////////
@@ -2537,60 +2544,60 @@
 
 /*! Defines the shortcut() that triggers a given QGLViewer::KeyboardAction.
 
- Here are some examples:
- \code
- // Press 'Q' to exit application
- setShortcut(EXIT_VIEWER, Qt::Key_Q);
+Here are some examples:
+\code
+// Press 'Q' to exit application
+setShortcut(EXIT_VIEWER, Qt::Key_Q);
 
- // Alt+M toggles camera mode
- setShortcut(CAMERA_MODE, Qt::ALT+Qt::Key_M);
+// Alt+M toggles camera mode
+setShortcut(CAMERA_MODE, Qt::ALT+Qt::Key_M);
 
- // The DISPLAY_FPS action is disabled
- setShortcut(DISPLAY_FPS, 0);
- \endcode
+// The DISPLAY_FPS action is disabled
+setShortcut(DISPLAY_FPS, 0);
+\endcode
 
- Only one shortcut can be assigned to a given QGLViewer::KeyboardAction (new bindings replace
- previous ones). If several KeyboardAction are binded to the same shortcut, only one of them is
- active. */
+Only one shortcut can be assigned to a given QGLViewer::KeyboardAction (new bindings replace
+previous ones). If several KeyboardAction are binded to the same shortcut, only one of them is
+active. */
 void QGLViewer::setShortcut(KeyboardAction action, int key)
 {
-  keyboardBinding_[action] = convertToKeyboardModifiers(key);
+	keyboardBinding_[action] = convertToKeyboardModifiers(key);
 }
 
 /*! Returns the keyboard shortcut associated to a given QGLViewer::KeyboardAction.
 
- Result is an \c int defined using Qt enumerated values, as in \c Qt::Key_Q or \c
- Qt::CTRL+Qt::Key_X. Use Qt::MODIFIER_MASK to separate the key from the state keys. Returns \c 0 if
- the KeyboardAction is disabled (not binded). Set using setShortcut().
+Result is an \c int defined using Qt enumerated values, as in \c Qt::Key_Q or \c
+Qt::CTRL+Qt::Key_X. Use Qt::MODIFIER_MASK to separate the key from the state keys. Returns \c 0 if
+the KeyboardAction is disabled (not binded). Set using setShortcut().
 
- If you want to define keyboard shortcuts for custom actions (say, open a scene file), overload
- keyPressEvent() and then setKeyDescription().
+If you want to define keyboard shortcuts for custom actions (say, open a scene file), overload
+keyPressEvent() and then setKeyDescription().
 
- These shortcuts and their descriptions are automatically included in the help() window \c Keyboard
- tab.
+These shortcuts and their descriptions are automatically included in the help() window \c Keyboard
+tab.
 
- See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details and default values and the &lt;a
- href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for a practical
- illustration. */
+See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details and default values and the &lt;a
+href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for a practical
+illustration. */
 int QGLViewer::shortcut(KeyboardAction action) const
 {
-  if (keyboardBinding_.contains(action))
-    return convertToShortModifier(keyboardBinding_[action]);
-  else
-    return 0;
+	if (keyboardBinding_.contains(action))
+		return convertToShortModifier(keyboardBinding_[action]);
+	else
+		return 0;
 }
 
 #ifndef DOXYGEN
 void QGLViewer::setKeyboardAccelerator(KeyboardAction action, int key)
 {
-  qWarning(&quot;setKeyboardAccelerator is deprecated. Use setShortcut instead.&quot;);
-  setShortcut(action, key);
+	qWarning(&quot;setKeyboardAccelerator is deprecated. Use setShortcut instead.&quot;);
+	setShortcut(action, key);
 }
 
 int QGLViewer::keyboardAccelerator(KeyboardAction action) const
 {
-  qWarning(&quot;keyboardAccelerator is deprecated. Use shortcut instead.&quot;);
-  return shortcut(action);
+	qWarning(&quot;keyboardAccelerator is deprecated. Use shortcut instead.&quot;);
+	return shortcut(action);
 }
 #endif
 
@@ -2598,140 +2605,140 @@
 
 /*! Returns the keyboard key associated to camera Key Frame path \p index.
 
- Default values are F1..F12 for indexes 1..12.
+Default values are F1..F12 for indexes 1..12.
 
- addKeyFrameKeyboardModifiers() (resp. playPathKeyboardModifiers()) define the state key(s) that
- must be pressed with this key to add a KeyFrame to (resp. to play) the associated Key Frame path.
- If you quickly press twice the pathKey(), the path is reset (resp. deleted).
+addKeyFrameKeyboardModifiers() (resp. playPathKeyboardModifiers()) define the state key(s) that
+must be pressed with this key to add a KeyFrame to (resp. to play) the associated Key Frame path.
+If you quickly press twice the pathKey(), the path is reset (resp. deleted).
 
- Use camera()-&gt;keyFrameInterpolator( \p index ) to retrieve the KeyFrameInterpolator that defines
- the path.
+Use camera()-&gt;keyFrameInterpolator( \p index ) to retrieve the KeyFrameInterpolator that defines
+the path.
 
- If several keys are binded to a given \p index (see setPathKey()), one of them is returned.
- Returns \c 0 if no key is associated with this index.
+If several keys are binded to a given \p index (see setPathKey()), one of them is returned.
+Returns \c 0 if no key is associated with this index.
 
- See also the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt;. */
+See also the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt;. */
 Qt::Key QGLViewer::pathKey(int index) const
 {
-  for (QMap&lt;Qt::Key, int&gt;::ConstIterator it = pathIndex_.begin(), end=pathIndex_.end(); it != end; ++it)
-    if (it.value() == index)
-      return it.key();
-  return Qt::Key(0);
+	for (QMap&lt;Qt::Key, int&gt;::ConstIterator it = pathIndex_.begin(), end=pathIndex_.end(); it != end; ++it)
+		if (it.value() == index)
+			return it.key();
+	return Qt::Key(0);
 }
 
 /*! Sets the pathKey() associated with the camera Key Frame path \p index.
 
- Several keys can be binded to the same \p index. Use a negated \p key value to delete the binding
- (the \p index value is then ignored):
- \code
- // Press 'space' to play/pause/add/delete camera path of index 0.
- setPathKey(Qt::Key_Space, 0);
+Several keys can be binded to the same \p index. Use a negated \p key value to delete the binding
+(the \p index value is then ignored):
+\code
+// Press 'space' to play/pause/add/delete camera path of index 0.
+setPathKey(Qt::Key_Space, 0);
 
- // Remove this binding
- setPathKey(-Qt::Key_Space);
- \endcode */
+// Remove this binding
+setPathKey(-Qt::Key_Space);
+\endcode */
 void QGLViewer::setPathKey(int key, int index)
 {
-  if (key &lt; 0)
-    pathIndex_.remove(Qt::Key(-key));
-  else
-    pathIndex_[Qt::Key(key)] = index;
+	if (key &lt; 0)
+		pathIndex_.remove(Qt::Key(-key));
+	else
+		pathIndex_[Qt::Key(key)] = index;
 }
 
 /*! Sets the playPathKeyboardModifiers() value. */
 void QGLViewer::setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers)
 {
-  playPathKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
+	playPathKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
 }
 
 /*! Sets the addKeyFrameKeyboardModifiers() value. */
 void QGLViewer::setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers)
 {
-  addKeyFrameKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
+	addKeyFrameKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
 }
 
 /*! Returns the keyboard modifiers that must be pressed with a pathKey() to add the current camera
-  position to a KeyFrame path.
+position to a KeyFrame path.
 
- It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
- Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
+It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
+Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
 
- Default value is Qt::AltModifier. Defined using setAddKeyFrameKeyboardModifiers().
+Default value is Qt::AltModifier. Defined using setAddKeyFrameKeyboardModifiers().
 
- See also playPathKeyboardModifiers().
+See also playPathKeyboardModifiers().
 
- \note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
- The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
- Qt::AltButton, ...). */
+\note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
+The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
+Qt::AltButton, ...). */
 QtKeyboardModifiers QGLViewer::addKeyFrameKeyboardModifiers() const
 {
-  return addKeyFrameKeyboardModifiers_;
+	return addKeyFrameKeyboardModifiers_;
 }
 
 /*! Returns the keyboard modifiers that must be pressed with a pathKey() to play a camera KeyFrame path.
 
- It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
- Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
+It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
+Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
 
- Default value is Qt::NoModifier. Defined using setPlayPathKeyboardModifiers().
+Default value is Qt::NoModifier. Defined using setPlayPathKeyboardModifiers().
 
- See also addKeyFrameKeyboardModifiers().
+See also addKeyFrameKeyboardModifiers().
 
- \note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
- The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
- Qt::AltButton, ...). */
+\note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
+The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
+Qt::AltButton, ...). */
 QtKeyboardModifiers QGLViewer::playPathKeyboardModifiers() const
 {
-  return playPathKeyboardModifiers_;
+	return playPathKeyboardModifiers_;
 }
 
 #ifndef DOXYGEN
 // Deprecated methods
 QtKeyboardModifiers QGLViewer::addKeyFrameStateKey() const
 {
-  qWarning(&quot;addKeyFrameStateKey has been renamed addKeyFrameKeyboardModifiers&quot;);
-  return addKeyFrameKeyboardModifiers(); }
+	qWarning(&quot;addKeyFrameStateKey has been renamed addKeyFrameKeyboardModifiers&quot;);
+	return addKeyFrameKeyboardModifiers(); }
 
 QtKeyboardModifiers QGLViewer::playPathStateKey() const
 {
-  qWarning(&quot;playPathStateKey has been renamed playPathKeyboardModifiers&quot;);
-  return playPathKeyboardModifiers();
+	qWarning(&quot;playPathStateKey has been renamed playPathKeyboardModifiers&quot;);
+	return playPathKeyboardModifiers();
 }
 
 void QGLViewer::setAddKeyFrameStateKey(int buttonState)
 {
-  qWarning(&quot;setAddKeyFrameStateKey has been renamed setAddKeyFrameKeyboardModifiers&quot;);
-  setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+	qWarning(&quot;setAddKeyFrameStateKey has been renamed setAddKeyFrameKeyboardModifiers&quot;);
+	setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
 }
 
 void QGLViewer::setPlayPathStateKey(int buttonState)
 {
-  qWarning(&quot;setPlayPathStateKey has been renamed setPlayPathKeyboardModifiers&quot;);
-  setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+	qWarning(&quot;setPlayPathStateKey has been renamed setPlayPathKeyboardModifiers&quot;);
+	setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
 }
 
 Qt::Key QGLViewer::keyFrameKey(int index) const
 {
-  qWarning(&quot;keyFrameKey has been renamed pathKey.&quot;);
-  return pathKey(index);
+	qWarning(&quot;keyFrameKey has been renamed pathKey.&quot;);
+	return pathKey(index);
 }
 
 QtKeyboardModifiers QGLViewer::playKeyFramePathStateKey() const
 {
-  qWarning(&quot;playKeyFramePathStateKey has been renamed playPathKeyboardModifiers.&quot;);
-  return playPathKeyboardModifiers();
+	qWarning(&quot;playKeyFramePathStateKey has been renamed playPathKeyboardModifiers.&quot;);
+	return playPathKeyboardModifiers();
 }
 
 void QGLViewer::setKeyFrameKey(int index, int key)
 {
-  qWarning(&quot;setKeyFrameKey is deprecated, use setPathKey instead, with swapped parameters.&quot;);
-  setPathKey(key, index);
+	qWarning(&quot;setKeyFrameKey is deprecated, use setPathKey instead, with swapped parameters.&quot;);
+	setPathKey(key, index);
 }
 
 void QGLViewer::setPlayKeyFramePathStateKey(int buttonState)
 {
-  qWarning(&quot;setPlayKeyFramePathStateKey has been renamed setPlayPathKeyboardModifiers.&quot;);
-  setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+	qWarning(&quot;setPlayKeyFramePathStateKey has been renamed setPlayPathKeyboardModifiers.&quot;);
+	setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
 }
 #endif
 
@@ -2740,353 +2747,353 @@
 ////////////////////////////////////////////////////////////////////////////////
 /*! Associates keyboard modifiers to MouseHandler \p handler.
 
- The \p modifiers parameter is \c Qt::AltModifier, \c Qt::ShiftModifier, \c Qt::ControlModifier, \c
- Qt::MetaModifier or a combination of these using the '|' bitwise operator. Some shorter names are
- also available: \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
+The \p modifiers parameter is \c Qt::AltModifier, \c Qt::ShiftModifier, \c Qt::ControlModifier, \c
+Qt::MetaModifier or a combination of these using the '|' bitwise operator. Some shorter names are
+also available: \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
 
- \e All the \p handler's associated bindings will then need the specified \p modifiers key(s) to be
- activated.
+\e All the \p handler's associated bindings will then need the specified \p modifiers key(s) to be
+activated.
 
- With this code,
- \code
- setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::AltModifier);
- setHandlerKeyboardModifiers(QGLViewer::FRAME,  Qt::NoModifier);
- \endcode
- you will have to press the \c Alt key while pressing mouse buttons in order to move the camera(),
- while no key will be needed to move the manipulatedFrame().
+With this code,
+\code
+setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::AltModifier);
+setHandlerKeyboardModifiers(QGLViewer::FRAME,  Qt::NoModifier);
+\endcode
+you will have to press the \c Alt key while pressing mouse buttons in order to move the camera(),
+while no key will be needed to move the manipulatedFrame().
 
- This method has a very basic implementation: every action binded to \p handler has its keyboard
- modifier replaced by \p modifiers. If \p handler had some actions binded to different modifiers,
- these settings will be lost. You should hence consider using setMouseBinding() for finer tuning.
+This method has a very basic implementation: every action binded to \p handler has its keyboard
+modifier replaced by \p modifiers. If \p handler had some actions binded to different modifiers,
+these settings will be lost. You should hence consider using setMouseBinding() for finer tuning.
 
- The default binding associates \c Qt::ControlModifier to all the QGLViewer::FRAME actions and \c
- Qt::NoModifier to all QGLViewer::CAMERA actions. See &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for
- details.
+The default binding associates \c Qt::ControlModifier to all the QGLViewer::FRAME actions and \c
+Qt::NoModifier to all QGLViewer::CAMERA actions. See &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for
+details.
 
- \attention This method calls setMouseBinding(), which ensures that only one action is binded to a
- given modifiers. If you want to \e swap the QGLViewer::CAMERA and QGLViewer::FRAME keyboard
- modifiers, you have to use a temporary dummy modifier (as if you were swapping two variables) or
- else the first call will overwrite the previous settings:
- \code
- // Associate FRAME with Alt (temporary value)
- setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::AltModifier);
- // Control is associated with CAMERA
- setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::ControlModifier);
- // And finally, FRAME can be associated with NoModifier
- setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::NoModifier);
- \endcode
+\attention This method calls setMouseBinding(), which ensures that only one action is binded to a
+given modifiers. If you want to \e swap the QGLViewer::CAMERA and QGLViewer::FRAME keyboard
+modifiers, you have to use a temporary dummy modifier (as if you were swapping two variables) or
+else the first call will overwrite the previous settings:
+\code
+// Associate FRAME with Alt (temporary value)
+setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::AltModifier);
+// Control is associated with CAMERA
+setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::ControlModifier);
+// And finally, FRAME can be associated with NoModifier
+setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::NoModifier);
+\endcode
 
- \note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
- sufix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
- \c Qt::ShiftButton and \c Qt::MetaButton). */
+\note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
+sufix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
+\c Qt::ShiftButton and \c Qt::MetaButton). */
 void QGLViewer::setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers)
 {
-  QMap&lt;int, MouseActionPrivate&gt; newMouseBinding;
-  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; newWheelBinding;
-  QMap&lt;ClickActionPrivate, ClickAction&gt; newClickBinding_;
+	QMap&lt;int, MouseActionPrivate&gt; newMouseBinding;
+	QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; newWheelBinding;
+	QMap&lt;ClickActionPrivate, ClickAction&gt; newClickBinding_;
 
-  QMap&lt;int, MouseActionPrivate&gt;::Iterator mit;
-  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::Iterator wit;
+	QMap&lt;int, MouseActionPrivate&gt;::Iterator mit;
+	QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::Iterator wit;
 
-  // First copy unchanged bindings.
-  for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
-    if ((mit.value().handler != handler) || (mit.value().action == ZOOM_ON_REGION))
-      newMouseBinding[mit.key()] = mit.value();
+	// First copy unchanged bindings.
+	for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
+		if ((mit.value().handler != handler) || (mit.value().action == ZOOM_ON_REGION))
+			newMouseBinding[mit.key()] = mit.value();
 
-  for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
-    if (wit.value().handler != handler)
-      newWheelBinding[wit.key()] = wit.value();
+	for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
+		if (wit.value().handler != handler)
+			newWheelBinding[wit.key()] = wit.value();
 
-  // Then, add modified bindings, that can overwrite the previous ones.
-  modifiers = convertKeyboardModifiers(modifiers);
-  for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
-    if ((mit.value().handler == handler) &amp;&amp; (mit.value().action != ZOOM_ON_REGION))
-      {
-	int newState = modifiers | (mit.key() &amp; Qt::MouseButtonMask);
-	newMouseBinding[newState] = mit.value();
-      }
+	// Then, add modified bindings, that can overwrite the previous ones.
+	modifiers = convertKeyboardModifiers(modifiers);
+	for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
+		if ((mit.value().handler == handler) &amp;&amp; (mit.value().action != ZOOM_ON_REGION))
+		{
+			int newState = modifiers | (mit.key() &amp; Qt::MouseButtonMask);
+			newMouseBinding[newState] = mit.value();
+		}
 
-  for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
-    if (wit.value().handler == handler)
-      {
-	QtKeyboardModifiers newState = modifiers;
-	newWheelBinding[newState] = wit.value();
-      }
+		for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
+			if (wit.value().handler == handler)
+			{
+				QtKeyboardModifiers newState = modifiers;
+				newWheelBinding[newState] = wit.value();
+			}
 
-  // Same for button bindings
-  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator cb=clickBinding_.begin(), end=clickBinding_.end(); cb != end; ++cb)
-    if (((handler==CAMERA) &amp;&amp; ((cb.value() == CENTER_SCENE) || (cb.value() == ALIGN_CAMERA))) ||
-	((handler==FRAME)  &amp;&amp; ((cb.value() == CENTER_FRAME) || (cb.value() == ALIGN_FRAME))))
-      {
-	ClickActionPrivate cap;
-	cap.modifiers = modifiers;
-	cap.button = cb.key().button;
-	cap.doubleClick = cb.key().doubleClick;
-	cap.buttonsBefore = cb.key().buttonsBefore;
-	newClickBinding_[cap] = cb.value();
-      }
-    else
-      newClickBinding_[cb.key()] = cb.value();
-  
-  mouseBinding_ = newMouseBinding;
-  wheelBinding_ = newWheelBinding;
-  clickBinding_ = newClickBinding_;
+			// Same for button bindings
+			for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator cb=clickBinding_.begin(), end=clickBinding_.end(); cb != end; ++cb)
+				if (((handler==CAMERA) &amp;&amp; ((cb.value() == CENTER_SCENE) || (cb.value() == ALIGN_CAMERA))) ||
+					((handler==FRAME)  &amp;&amp; ((cb.value() == CENTER_FRAME) || (cb.value() == ALIGN_FRAME))))
+				{
+					ClickActionPrivate cap;
+					cap.modifiers = modifiers;
+					cap.button = cb.key().button;
+					cap.doubleClick = cb.key().doubleClick;
+					cap.buttonsBefore = cb.key().buttonsBefore;
+					newClickBinding_[cap] = cb.value();
+				}
+				else
+					newClickBinding_[cb.key()] = cb.value();
+
+			mouseBinding_ = newMouseBinding;
+			wheelBinding_ = newWheelBinding;
+			clickBinding_ = newClickBinding_;
 }
 
 
 #ifndef DOXYGEN
 void QGLViewer::setHandlerStateKey(MouseHandler handler, int buttonState)
 {
-  qWarning(&quot;setHandlerStateKey has been renamed setHandlerKeyboardModifiers&quot;);
-  setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+	qWarning(&quot;setHandlerStateKey has been renamed setHandlerKeyboardModifiers&quot;);
+	setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
 }
 
 void QGLViewer::setMouseStateKey(MouseHandler handler, int buttonState)
 {
-  qWarning(&quot;setMouseStateKey has been renamed setHandlerKeyboardModifiers.&quot;);
-  setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+	qWarning(&quot;setMouseStateKey has been renamed setHandlerKeyboardModifiers.&quot;);
+	setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
 }
 #endif
 
 /*! Associates a MouseAction to any mouse button and keyboard modifiers \p state combination. The
- receiver of the mouse events is a MouseHandler (QGLViewer::CAMERA or QGLViewer::FRAME).
+receiver of the mouse events is a MouseHandler (QGLViewer::CAMERA or QGLViewer::FRAME).
 
- The parameters should read: when the \p state mouse button and keyboard modifiers are pressed,
- activate \p action on \p handler. If \p withConstraint is \c true (default), the
- qglviewer::Frame::constraint() associated with the Frame will be enforced during motion.
+The parameters should read: when the \p state mouse button and keyboard modifiers are pressed,
+activate \p action on \p handler. If \p withConstraint is \c true (default), the
+qglviewer::Frame::constraint() associated with the Frame will be enforced during motion.
 
- Use the '|' bitwise operator or '+' to combine keys and buttons:
- \code
- // Left and right buttons together make a camera zoom: emulates a mouse third button if needed.
- setMouseBinding(Qt::LeftButton + Qt::RightButton, CAMERA, ZOOM);
+Use the '|' bitwise operator or '+' to combine keys and buttons:
+\code
+// Left and right buttons together make a camera zoom: emulates a mouse third button if needed.
+setMouseBinding(Qt::LeftButton + Qt::RightButton, CAMERA, ZOOM);
 
- // Alt + Shift + Left button rotates the manipulatedFrame().
- setMouseBinding(Qt::ALT + Qt::SHIFT + Qt::LeftButton, FRAME, ROTATE);
- \endcode
+// Alt + Shift + Left button rotates the manipulatedFrame().
+setMouseBinding(Qt::ALT + Qt::SHIFT + Qt::LeftButton, FRAME, ROTATE);
+\endcode
 
- The list of all possible MouseAction, some binding examples and default bindings are provided in
- the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;.
+The list of all possible MouseAction, some binding examples and default bindings are provided in
+the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;.
 
- See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
+See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
 
- If no mouse button is specified in \p state, the binding is ignored. If an action was previously
- associated with this \p state, it is silently overwritten (use mouseAction() before to know if the
- \p state is already binded).
+If no mouse button is specified in \p state, the binding is ignored. If an action was previously
+associated with this \p state, it is silently overwritten (use mouseAction() before to know if the
+\p state is already binded).
 
- To remove a specific mouse binding, use code like:
- \code
- setMouseBinding(myButtonAndModifiersCombo, myHandler, NO_MOUSE_ACTION);
- \endcode
+To remove a specific mouse binding, use code like:
+\code
+setMouseBinding(myButtonAndModifiersCombo, myHandler, NO_MOUSE_ACTION);
+\endcode
 
- See also setMouseBinding(int, ClickAction, bool, int) and setWheelBinding(). */
+See also setMouseBinding(int, ClickAction, bool, int) and setWheelBinding(). */
 void QGLViewer::setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint)
 {
-  if ((handler == FRAME) &amp;&amp; ((action == MOVE_FORWARD) || (action == MOVE_BACKWARD) ||
-			     (action == ROLL) || (action == LOOK_AROUND) ||
-			     (action == ZOOM_ON_REGION)))
-    {
+	if ((handler == FRAME) &amp;&amp; ((action == MOVE_FORWARD) || (action == MOVE_BACKWARD) ||
+		(action == ROLL) || (action == LOOK_AROUND) ||
+		(action == ZOOM_ON_REGION)))
+	{
 #if QT_VERSION &gt;= 0x040000
-      qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;).toLatin1().constData());
+		qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;).toLatin1().constData());
 #else
-      qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;);
+		qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;);
 #endif
-    }
-  else
-    if ((state &amp; Qt::MouseButtonMask) == 0)
-      qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
-    else
-      {
-	MouseActionPrivate map;
-	map.handler = handler;
-	map.action = action;
-	map.withConstraint = withConstraint;
-	state = convertToKeyboardModifiers(state);
+	}
+	else
+		if ((state &amp; Qt::MouseButtonMask) == 0)
+			qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
+		else
+		{
+			MouseActionPrivate map;
+			map.handler = handler;
+			map.action = action;
+			map.withConstraint = withConstraint;
+			state = convertToKeyboardModifiers(state);
 
-	mouseBinding_.remove(state);
+			mouseBinding_.remove(state);
 
-	if (action != NO_MOUSE_ACTION)
-	  mouseBinding_.insert(state, map);
+			if (action != NO_MOUSE_ACTION)
+				mouseBinding_.insert(state, map);
 
-	ClickActionPrivate cap;
-	cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
-	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
-	cap.doubleClick = false;
-	cap.buttonsBefore = Qt::NoButton;
-	clickBinding_.remove(cap);
-      }
+			ClickActionPrivate cap;
+			cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
+			cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+			cap.doubleClick = false;
+			cap.buttonsBefore = Qt::NoButton;
+			clickBinding_.remove(cap);
+		}
 }
 
 /*! Associates a ClickAction to any mouse buttons and keyboard modifiers combination.
 
- The parameters should read: when the \p state mouse button(s) is (are) pressed (possibly with Alt,
- Control or Shift modifiers or any combination of these), and possibly with a \p doubleClick,
- perform \p action.
+The parameters should read: when the \p state mouse button(s) is (are) pressed (possibly with Alt,
+Control or Shift modifiers or any combination of these), and possibly with a \p doubleClick,
+perform \p action.
 
- If \p buttonsBefore is specified (valid only when \p doubleClick is \c true), then this mouse
- button(s) has to be pressed \e before the double click occurs in order to perform \p action.
+If \p buttonsBefore is specified (valid only when \p doubleClick is \c true), then this mouse
+button(s) has to be pressed \e before the double click occurs in order to perform \p action.
 
- The list of all possible ClickAction, some binding examples and default bindings are listed in the
- &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. See also the setMouseBinding() documentation.
+The list of all possible ClickAction, some binding examples and default bindings are listed in the
+&lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. See also the setMouseBinding() documentation.
 
- See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an
- illustration.
+See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an
+illustration.
 
- The binding is ignored if no mouse button is specified in \p state.
+The binding is ignored if no mouse button is specified in \p state.
 
- \note If you use Qt version 2 or 3, the \p buttonsBefore is actually a Qt::ButtonState. */
+\note If you use Qt version 2 or 3, the \p buttonsBefore is actually a Qt::ButtonState. */
 void QGLViewer::setMouseBinding(int state, ClickAction action, bool doubleClick, QtMouseButtons buttonsBefore)
 {
-  if ((buttonsBefore != Qt::NoButton) &amp;&amp; !doubleClick)
-    qWarning(&quot;Buttons before is only meaningful when doubleClick is true in setMouseBinding().&quot;);
-  else
-    if ((state &amp; Qt::MouseButtonMask) == 0)
-      qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
-    else
-      {
-	ClickActionPrivate cap;
-	state = convertToKeyboardModifiers(state);
-	cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
-	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
-	cap.doubleClick = doubleClick;
-	cap.buttonsBefore = buttonsBefore;
-	clickBinding_.remove(cap);
+	if ((buttonsBefore != Qt::NoButton) &amp;&amp; !doubleClick)
+		qWarning(&quot;Buttons before is only meaningful when doubleClick is true in setMouseBinding().&quot;);
+	else
+		if ((state &amp; Qt::MouseButtonMask) == 0)
+			qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
+		else
+		{
+			ClickActionPrivate cap;
+			state = convertToKeyboardModifiers(state);
+			cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
+			cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+			cap.doubleClick = doubleClick;
+			cap.buttonsBefore = buttonsBefore;
+			clickBinding_.remove(cap);
 
-	// #CONNECTION performClickAction comment on NO_CLICK_ACTION
-	if (action != NO_CLICK_ACTION)
-	  clickBinding_.insert(cap, action);
+			// #CONNECTION performClickAction comment on NO_CLICK_ACTION
+			if (action != NO_CLICK_ACTION)
+				clickBinding_.insert(cap, action);
 
-	if ((!doubleClick) &amp;&amp; (buttonsBefore == Qt::NoButton))
-	  mouseBinding_.remove(state);
-      }
+			if ((!doubleClick) &amp;&amp; (buttonsBefore == Qt::NoButton))
+				mouseBinding_.remove(state);
+		}
 }
 
 /*! Associates a MouseAction and a MouseHandler to a mouse wheel event.
 
- This method is very similar to setMouseBinding(), but specific to the wheel.
+This method is very similar to setMouseBinding(), but specific to the wheel.
 
- In the current implementation only QGLViewer::ZOOM can be associated with QGLViewer::FRAME, while
- QGLViewer::CAMERA can receive QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD.
+In the current implementation only QGLViewer::ZOOM can be associated with QGLViewer::FRAME, while
+QGLViewer::CAMERA can receive QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD.
 
- The difference between QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD is that QGLViewer::ZOOM speed
- depends on the distance to the object, while QGLViewer::MOVE_FORWARD moves at a constant speed
- defined by qglviewer::Camera::flySpeed(). */
+The difference between QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD is that QGLViewer::ZOOM speed
+depends on the distance to the object, while QGLViewer::MOVE_FORWARD moves at a constant speed
+defined by qglviewer::Camera::flySpeed(). */
 void QGLViewer::setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint)
 {
-  //#CONNECTION# ManipulatedFrame::wheelEvent and ManipulatedCameraFrame::wheelEvent switches
-  if ((action != ZOOM) &amp;&amp; (action != MOVE_FORWARD) &amp;&amp; (action != MOVE_BACKWARD) &amp;&amp; (action != NO_MOUSE_ACTION))
+	//#CONNECTION# ManipulatedFrame::wheelEvent and ManipulatedCameraFrame::wheelEvent switches
+	if ((action != ZOOM) &amp;&amp; (action != MOVE_FORWARD) &amp;&amp; (action != MOVE_BACKWARD) &amp;&amp; (action != NO_MOUSE_ACTION))
 #if QT_VERSION &gt;= 0x040000
-    qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;).toLatin1().constData());
+		qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;).toLatin1().constData());
 #else
-    qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;);
+		qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;);
 #endif
-  else
-    if ((handler == FRAME) &amp;&amp; (action != ZOOM) &amp;&amp; (action != NO_MOUSE_ACTION))
+	else
+		if ((handler == FRAME) &amp;&amp; (action != ZOOM) &amp;&amp; (action != NO_MOUSE_ACTION))
 #if QT_VERSION &gt;= 0x040000
-      qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;).toLatin1().constData());
+			qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;).toLatin1().constData());
 #else
-      qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;);
+			qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;);
 #endif
-    else
-      {
-	MouseActionPrivate map;
-	map.handler = handler;
-	map.action  = action;
-	map.withConstraint = withConstraint;
-	modifiers = convertKeyboardModifiers(modifiers);
-	wheelBinding_.remove(modifiers);
+		else
+		{
+			MouseActionPrivate map;
+			map.handler = handler;
+			map.action  = action;
+			map.withConstraint = withConstraint;
+			modifiers = convertKeyboardModifiers(modifiers);
+			wheelBinding_.remove(modifiers);
 
-	if (action != NO_MOUSE_ACTION)
-	  wheelBinding_.insert(modifiers, map);
-      }
+			if (action != NO_MOUSE_ACTION)
+				wheelBinding_.insert(modifiers, map);
+		}
 }
 
 /*! Returns the MouseAction associated with the \p state mouse button(s) and keyboard modifiers.
- Returns QGLViewer::NO_MOUSE_ACTION if no action is associated.
+Returns QGLViewer::NO_MOUSE_ACTION if no action is associated.
 
- For instance, to know which motion corresponds to Alt+LeftButton, do:
- \code
- QGLViewer::MouseAction ma = mouseAction(Qt::ALT + Qt::LeftButton);
- if (ma != QGLViewer::NO_MOUSE_ACTION) ...
- \endcode
+For instance, to know which motion corresponds to Alt+LeftButton, do:
+\code
+QGLViewer::MouseAction ma = mouseAction(Qt::ALT + Qt::LeftButton);
+if (ma != QGLViewer::NO_MOUSE_ACTION) ...
+\endcode
 
- Use mouseHandler() to know which object (QGLViewer::CAMERA or QGLViewer::FRAME) will perform this
- action. */
+Use mouseHandler() to know which object (QGLViewer::CAMERA or QGLViewer::FRAME) will perform this
+action. */
 QGLViewer::MouseAction QGLViewer::mouseAction(int state) const
 {
-  state = convertToKeyboardModifiers(state);
-  if (mouseBinding_.contains(state))
-    return mouseBinding_[state].action;
-  else
-    return NO_MOUSE_ACTION;
+	state = convertToKeyboardModifiers(state);
+	if (mouseBinding_.contains(state))
+		return mouseBinding_[state].action;
+	else
+		return NO_MOUSE_ACTION;
 }
 
 /*! Returns the MouseHandler associated with the \p state. If no action is
- associated, returns \c -1.
+associated, returns \c -1.
 
- For instance, to know which handler receives the Alt+LeftButton, do:
- \code
- int mh = mouseHandler(Qt::ALT + Qt::LeftButton);
- if (mh == QGLViewer::CAMERA) ...
- \endcode
+For instance, to know which handler receives the Alt+LeftButton, do:
+\code
+int mh = mouseHandler(Qt::ALT + Qt::LeftButton);
+if (mh == QGLViewer::CAMERA) ...
+\endcode
 
- Use mouseAction() to know which action (see the MouseAction enum) will be perform on this handler. */
+Use mouseAction() to know which action (see the MouseAction enum) will be perform on this handler. */
 int QGLViewer::mouseHandler(int state) const
 {
-  state = convertToKeyboardModifiers(state);
-  if (mouseBinding_.contains(state))
-    return mouseBinding_[state].handler;
-  else
-    return -1;
+	state = convertToKeyboardModifiers(state);
+	if (mouseBinding_.contains(state))
+		return mouseBinding_[state].handler;
+	else
+		return -1;
 }
 
 /*! Returns the mouse buttons and keyboard modifiers (if any) that have to be used to activate \p
- action on \p handler (with constraint or not).
+action on \p handler (with constraint or not).
 
- If no state triggers the action, returns Qt::NoButton which is an impossible case since at least
- one mouse button has to be specified in setMouseBinding().
+If no state triggers the action, returns Qt::NoButton which is an impossible case since at least
+one mouse button has to be specified in setMouseBinding().
 
- To know which keys and mouse buttons have to be pressed to translate the camera, use tests like:
- \code
- int bs = mouseButtonState(QGLViewer::CAMERA, QGLViewer::TRANSLATE);
- if (bs &amp; Qt::RightButton) ... // Right button needed to translate the camera
- if (bs &amp; Qt::AltModifier)   ... // Alt key needed (use AltModifier with Qt version 2 or 3)
- if (bs &amp; Qt::KeyboardModifierMask == Qt::NoButton) ... // No keyboard modifier needed
- \endcode
+To know which keys and mouse buttons have to be pressed to translate the camera, use tests like:
+\code
+int bs = mouseButtonState(QGLViewer::CAMERA, QGLViewer::TRANSLATE);
+if (bs &amp; Qt::RightButton) ... // Right button needed to translate the camera
+if (bs &amp; Qt::AltModifier)   ... // Alt key needed (use AltModifier with Qt version 2 or 3)
+if (bs &amp; Qt::KeyboardModifierMask == Qt::NoButton) ... // No keyboard modifier needed
+\endcode
 
- Note that mouse bindings are displayed in the 'Mouse' help window tab.
+Note that mouse bindings are displayed in the 'Mouse' help window tab.
 
- See also mouseAction() and mouseHandler(). */
+See also mouseAction() and mouseHandler(). */
 int QGLViewer::mouseButtonState(MouseHandler handler, MouseAction action, bool withConstraint) const
 {
-  for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it != end; ++it)
-    if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
-      return it.key();
+	for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it != end; ++it)
+		if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
+			return it.key();
 
-  return Qt::NoButton;
+	return Qt::NoButton;
 }
 
 /*! Same as mouseAction(), but for the wheel action.
 
- \note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
- postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
- Qt::ShiftButton, Qt::MetaButton). */
+\note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
+postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
+Qt::ShiftButton, Qt::MetaButton). */
 QGLViewer::MouseAction QGLViewer::wheelAction(QtKeyboardModifiers modifiers) const
 {
-  modifiers = convertKeyboardModifiers(modifiers);
-  if (wheelBinding_.contains(modifiers))
-    return wheelBinding_[modifiers].action;
-  else
-    return NO_MOUSE_ACTION;
+	modifiers = convertKeyboardModifiers(modifiers);
+	if (wheelBinding_.contains(modifiers))
+		return wheelBinding_[modifiers].action;
+	else
+		return NO_MOUSE_ACTION;
 }
 
 /*! Same as mouseHandler() but for the wheel action. See also wheelAction(). */
 int QGLViewer::wheelHandler(QtKeyboardModifiers modifiers) const
 {
-  modifiers = convertKeyboardModifiers(modifiers);
-  if (wheelBinding_.contains(modifiers))
-    return wheelBinding_[modifiers].handler;
-  else
-    return -1;
+	modifiers = convertKeyboardModifiers(modifiers);
+	if (wheelBinding_.contains(modifiers))
+		return wheelBinding_[modifiers].handler;
+	else
+		return -1;
 }
 
 /*! Same as mouseButtonState(), but for the wheel.
@@ -3095,113 +3102,113 @@
 withConstraint combination (mouseButtonState() would return Qt::NoButton instead). */
 int QGLViewer::wheelButtonState(MouseHandler handler, MouseAction action, bool withConstraint) const
 {
-  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
-    if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
-      return it.key();
+	for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
+		if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
+			return it.key();
 
-  return -1;
+	return -1;
 }
 
 /*! Same as mouseAction(), but for the ClickAction set using setMouseBinding(). */
 QGLViewer::ClickAction QGLViewer::clickAction(int state, bool doubleClick, QtMouseButtons buttonsBefore) const
 {
-  ClickActionPrivate cap;
-  cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
-  cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
-  cap.doubleClick = doubleClick;
-  cap.buttonsBefore = buttonsBefore;
-  if (clickBinding_.contains(cap))
-    return clickBinding_[cap];
-  else
-    return NO_CLICK_ACTION;
+	ClickActionPrivate cap;
+	cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
+	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+	cap.doubleClick = doubleClick;
+	cap.buttonsBefore = buttonsBefore;
+	if (clickBinding_.contains(cap))
+		return clickBinding_[cap];
+	else
+		return NO_CLICK_ACTION;
 }
 
 /*! Similar to mouseButtonState(), but for ClickAction.
 
- The results of the query are returned in the \p state, \p doubleClick and \p buttonsBefore
- parameters. If the ClickAction is not associated to any mouse button, \c Qt::NoButton is returned
- in \p state. If several mouse buttons trigger in the ClickAction, one of them is returned. */
+The results of the query are returned in the \p state, \p doubleClick and \p buttonsBefore
+parameters. If the ClickAction is not associated to any mouse button, \c Qt::NoButton is returned
+in \p state. If several mouse buttons trigger in the ClickAction, one of them is returned. */
 void QGLViewer::getClickButtonState(ClickAction ca, int&amp; state, bool&amp; doubleClick, QtMouseButtons&amp; buttonsBefore) const
 {
-  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator it=clickBinding_.begin(), end=clickBinding_.end(); it != end; ++it)
-    if (it.value() == ca)
-      {
-	state = it.key().modifiers | it.key().button;
-	doubleClick = it.key().doubleClick;
-	buttonsBefore = it.key().buttonsBefore;
-	return;
-      }
+	for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator it=clickBinding_.begin(), end=clickBinding_.end(); it != end; ++it)
+		if (it.value() == ca)
+		{
+			state = it.key().modifiers | it.key().button;
+			doubleClick = it.key().doubleClick;
+			buttonsBefore = it.key().buttonsBefore;
+			return;
+		}
 
-  state = Qt::NoButton;
+		state = Qt::NoButton;
 }
 
 /*! This function should be used in conjunction with toggleCameraMode(). It returns \c true when at
-  least one mouse button is binded to the \c REVOLVE mouseAction. This is crude way of determining
-  which &quot;mode&quot; the camera is in. */
+least one mouse button is binded to the \c REVOLVE mouseAction. This is crude way of determining
+which &quot;mode&quot; the camera is in. */
 bool QGLViewer::cameraIsInRevolveMode() const
 {
-  //#CONNECTION# used in toggleCameraMode() and keyboardString()
-  return mouseButtonState(CAMERA, ROTATE) != Qt::NoButton;
+	//#CONNECTION# used in toggleCameraMode() and keyboardString()
+	return mouseButtonState(CAMERA, ROTATE) != Qt::NoButton;
 }
 
 /*! Swaps between two predefined camera mouse bindings.
 
-  The first mode makes the camera observe the scene while revolving around the
-  qglviewer::Camera::revolveAroundPoint(). The second mode is designed for walkthrough applications
-  and simulates a flying camera.
+The first mode makes the camera observe the scene while revolving around the
+qglviewer::Camera::revolveAroundPoint(). The second mode is designed for walkthrough applications
+and simulates a flying camera.
 
-  Practically, the three mouse buttons are respectively binded to:
-  \arg In revolve mode: QGLViewer::ROTATE, QGLViewer::ZOOM, QGLViewer::TRANSLATE.
-  \arg In fly mode: QGLViewer::MOVE_FORWARD, QGLViewer::LOOK_AROUND, QGLViewer::MOVE_BACKWARD.
+Practically, the three mouse buttons are respectively binded to:
+\arg In revolve mode: QGLViewer::ROTATE, QGLViewer::ZOOM, QGLViewer::TRANSLATE.
+\arg In fly mode: QGLViewer::MOVE_FORWARD, QGLViewer::LOOK_AROUND, QGLViewer::MOVE_BACKWARD.
 
-  The current mode is determined by checking if a mouse button is binded to QGLViewer::ROTATE for
-  the QGLViewer::CAMERA (using mouseButtonState()). The state key that was previously used to move
-  the camera is preserved. */
+The current mode is determined by checking if a mouse button is binded to QGLViewer::ROTATE for
+the QGLViewer::CAMERA (using mouseButtonState()). The state key that was previously used to move
+the camera is preserved. */
 void QGLViewer::toggleCameraMode()
 {
-  bool revolveMode = cameraIsInRevolveMode();
-  int bs;
-  if (revolveMode)
-    bs = mouseButtonState(CAMERA, ROTATE);
-  else
-    bs = mouseButtonState(CAMERA, MOVE_FORWARD);
-  QtKeyboardModifiers modifiers = QtKeyboardModifiers(bs &amp; Qt::KeyboardModifierMask);
+	bool revolveMode = cameraIsInRevolveMode();
+	int bs;
+	if (revolveMode)
+		bs = mouseButtonState(CAMERA, ROTATE);
+	else
+		bs = mouseButtonState(CAMERA, MOVE_FORWARD);
+	QtKeyboardModifiers modifiers = QtKeyboardModifiers(bs &amp; Qt::KeyboardModifierMask);
 
-  //#CONNECTION# setDefaultMouseBindings()
-  if (revolveMode)
-    {
-      camera()-&gt;frame()-&gt;updateFlyUpVector();
-      camera()-&gt;frame()-&gt;stopSpinning();
+	//#CONNECTION# setDefaultMouseBindings()
+	if (revolveMode)
+	{
+		camera()-&gt;frame()-&gt;updateFlyUpVector();
+		camera()-&gt;frame()-&gt;stopSpinning();
 
-      setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, MOVE_FORWARD);
-      setMouseBinding(modifiers | Qt::MidButton,   CAMERA, LOOK_AROUND);
-      setMouseBinding(modifiers | Qt::RightButton, CAMERA, MOVE_BACKWARD);
+		setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, MOVE_FORWARD);
+		setMouseBinding(modifiers | Qt::MidButton,   CAMERA, LOOK_AROUND);
+		setMouseBinding(modifiers | Qt::RightButton, CAMERA, MOVE_BACKWARD);
 
-      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, ROLL);
-      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
+		setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, ROLL);
+		// 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
 
-      setMouseBinding(Qt::LeftButton,  NO_CLICK_ACTION, true);
-      setMouseBinding(Qt::MidButton,   NO_CLICK_ACTION, true);
-      setMouseBinding(Qt::RightButton, NO_CLICK_ACTION, true);
+		setMouseBinding(Qt::LeftButton,  NO_CLICK_ACTION, true);
+		setMouseBinding(Qt::MidButton,   NO_CLICK_ACTION, true);
+		setMouseBinding(Qt::RightButton, NO_CLICK_ACTION, true);
 
-      setWheelBinding(modifiers, CAMERA, MOVE_FORWARD);
-    }
-  else
-    {
-      // Should stop flyTimer. But unlikely and not easy.
-      setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, ROTATE);
-      setMouseBinding(modifiers | Qt::MidButton,   CAMERA, ZOOM);
-      setMouseBinding(modifiers | Qt::RightButton, CAMERA, TRANSLATE);
+		setWheelBinding(modifiers, CAMERA, MOVE_FORWARD);
+	}
+	else
+	{
+		// Should stop flyTimer. But unlikely and not easy.
+		setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, ROTATE);
+		setMouseBinding(modifiers | Qt::MidButton,   CAMERA, ZOOM);
+		setMouseBinding(modifiers | Qt::RightButton, CAMERA, TRANSLATE);
 
-      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, SCREEN_ROTATE);
-      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
+		setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, SCREEN_ROTATE);
+		// 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
 
-      setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
-      setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
-      setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
+		setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
+		setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
+		setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
 
-      setWheelBinding(modifiers, CAMERA, ZOOM);
-    }
+		setWheelBinding(modifiers, CAMERA, ZOOM);
+	}
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -3221,31 +3228,31 @@
 to manipulate the camera of a first viewer in a second viewer. */
 void QGLViewer::setManipulatedFrame(ManipulatedFrame* frame)
 {
-  if (manipulatedFrame())
-    {
-      manipulatedFrame()-&gt;stopSpinning();
+	if (manipulatedFrame())
+	{
+		manipulatedFrame()-&gt;stopSpinning();
 
-      if (manipulatedFrame() != camera()-&gt;frame())
-	{
-	  disconnect(manipulatedFrame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
-	  disconnect(manipulatedFrame(), SIGNAL(spun()), this, SLOT(updateGL()));
+		if (manipulatedFrame() != camera()-&gt;frame())
+		{
+			disconnect(manipulatedFrame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
+			disconnect(manipulatedFrame(), SIGNAL(spun()), this, SLOT(updateGL()));
+		}
 	}
-    }
 
-  manipulatedFrame_ = frame;
+	manipulatedFrame_ = frame;
 
-  manipulatedFrameIsACamera_ = ((manipulatedFrame() != camera()-&gt;frame()) &amp;&amp;
-				(dynamic_cast&lt;ManipulatedCameraFrame*&gt;(manipulatedFrame()) != NULL));
+	manipulatedFrameIsACamera_ = ((manipulatedFrame() != camera()-&gt;frame()) &amp;&amp;
+		(dynamic_cast&lt;ManipulatedCameraFrame*&gt;(manipulatedFrame()) != NULL));
 
-  if (manipulatedFrame())
-    {
-      // Prevent multiple connections, that would result in useless display updates
-      if (manipulatedFrame() != camera()-&gt;frame())
+	if (manipulatedFrame())
 	{
-	  connect(manipulatedFrame(), SIGNAL(manipulated()), SLOT(updateGL()));
-	  connect(manipulatedFrame(), SIGNAL(spun()), SLOT(updateGL()));
+		// Prevent multiple connections, that would result in useless display updates
+		if (manipulatedFrame() != camera()-&gt;frame())
+		{
+			connect(manipulatedFrame(), SIGNAL(manipulated()), SLOT(updateGL()));
+			connect(manipulatedFrame(), SIGNAL(spun()), SLOT(updateGL()));
+		}
 	}
-    }
 }
 
 #ifndef DOXYGEN
@@ -3254,90 +3261,90 @@
 ////////////////////////////////////////////////////////////////////////////////
 /*! Draws viewer related visual hints.
 
- Displays the new qglviewer::Camera::revolveAroundPoint() when it is changed. See the &lt;a
- href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. Also draws a line between
- qglviewer::Camera::revolveAroundPoint() and mouse cursor when the camera is rotated around the
- camera Z axis.
+Displays the new qglviewer::Camera::revolveAroundPoint() when it is changed. See the &lt;a
+href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. Also draws a line between
+qglviewer::Camera::revolveAroundPoint() and mouse cursor when the camera is rotated around the
+camera Z axis.
 
- See also setVisualHintsMask() and resetVisualHints(). The hint color is foregroundColor().
+See also setVisualHintsMask() and resetVisualHints(). The hint color is foregroundColor().
 
- \note These methods may become more interesting one day. The current design is too limited and
- should be improved when other visual hints must be drawn.
+\note These methods may become more interesting one day. The current design is too limited and
+should be improved when other visual hints must be drawn.
 
- Limitation : One needs to have access to visualHint_ to overload this method.
+Limitation : One needs to have access to visualHint_ to overload this method.
 
- Removed from the documentation for this reason. */
+Removed from the documentation for this reason. */
 void QGLViewer::drawVisualHints()
 {
-  // Revolve Around point cross
-  if (visualHint_ &amp; 1)
-    {
-      const float size = 15.0;
-      Vec proj = camera()-&gt;projectedCoordinatesOf(camera()-&gt;revolveAroundPoint());
-      startScreenCoordinatesSystem();
-      glDisable(GL_LIGHTING);
-      glDisable(GL_DEPTH_TEST);
-      glLineWidth(3.0);
-      glBegin(GL_LINES);
-      glVertex2f(proj.x - size, proj.y);
-      glVertex2f(proj.x + size, proj.y);
-      glVertex2f(proj.x, proj.y - size);
-      glVertex2f(proj.x, proj.y + size);
-      glEnd();
-      glEnable(GL_DEPTH_TEST);
-      stopScreenCoordinatesSystem();
-    }
+	// Revolve Around point cross
+	if (visualHint_ &amp; 1)
+	{
+		const float size = 15.0;
+		Vec proj = camera()-&gt;projectedCoordinatesOf(camera()-&gt;revolveAroundPoint());
+		startScreenCoordinatesSystem();
+		glDisable(GL_LIGHTING);
+		glDisable(GL_DEPTH_TEST);
+		glLineWidth(3.0);
+		glBegin(GL_LINES);
+		glVertex2f(proj.x - size, proj.y);
+		glVertex2f(proj.x + size, proj.y);
+		glVertex2f(proj.x, proj.y - size);
+		glVertex2f(proj.x, proj.y + size);
+		glEnd();
+		glEnable(GL_DEPTH_TEST);
+		stopScreenCoordinatesSystem();
+	}
 
-  // if (visualHint_ &amp; 2)
-    // drawText(80, 10, &quot;Play&quot;);
+	// if (visualHint_ &amp; 2)
+	// drawText(80, 10, &quot;Play&quot;);
 
-  // Screen rotate line
-  ManipulatedFrame* mf = NULL;
-  Vec pnt;
-  if (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE)
-    {
-      mf = camera()-&gt;frame();
-      pnt = camera()-&gt;revolveAroundPoint();
-    }
-  if (manipulatedFrame() &amp;&amp; (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE))
-    {
-      mf = manipulatedFrame();
-      // Maybe useful if the mf is a manipCameraFrame...
-      // pnt = manipulatedFrame()-&gt;revolveAroundPoint();
-      pnt = manipulatedFrame()-&gt;position();
-    }
+	// Screen rotate line
+	ManipulatedFrame* mf = NULL;
+	Vec pnt;
+	if (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE)
+	{
+		mf = camera()-&gt;frame();
+		pnt = camera()-&gt;revolveAroundPoint();
+	}
+	if (manipulatedFrame() &amp;&amp; (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE))
+	{
+		mf = manipulatedFrame();
+		// Maybe useful if the mf is a manipCameraFrame...
+		// pnt = manipulatedFrame()-&gt;revolveAroundPoint();
+		pnt = manipulatedFrame()-&gt;position();
+	}
 
-  if (mf)
-    {
-      pnt = camera()-&gt;projectedCoordinatesOf(pnt);
-      startScreenCoordinatesSystem();
-      glDisable(GL_LIGHTING);
-      glDisable(GL_DEPTH_TEST);
-      glLineWidth(3.0);
-      glBegin(GL_LINES);
-      glVertex2f(pnt.x, pnt.y);
-      glVertex2f(mf-&gt;prevPos_.x(), mf-&gt;prevPos_.y());
-      glEnd();
-      glEnable(GL_DEPTH_TEST);
-      stopScreenCoordinatesSystem();
-    }
+	if (mf)
+	{
+		pnt = camera()-&gt;projectedCoordinatesOf(pnt);
+		startScreenCoordinatesSystem();
+		glDisable(GL_LIGHTING);
+		glDisable(GL_DEPTH_TEST);
+		glLineWidth(3.0);
+		glBegin(GL_LINES);
+		glVertex2f(pnt.x, pnt.y);
+		glVertex2f(mf-&gt;prevPos_.x(), mf-&gt;prevPos_.y());
+		glEnd();
+		glEnable(GL_DEPTH_TEST);
+		stopScreenCoordinatesSystem();
+	}
 
-  // Zoom on region: draw a rectangle
-  if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
-    {
-      startScreenCoordinatesSystem();
-      glDisable(GL_LIGHTING);
-      glDisable(GL_DEPTH_TEST);
-      glLineWidth(2.0);
-      glBegin(GL_LINE_LOOP);
-      glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;pressPos_.y());
-      glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;pressPos_.y());
-      glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;prevPos_.y());
-      glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;prevPos_.y());
-      glEnd();
-      glEnable(GL_DEPTH_TEST);
-      stopScreenCoordinatesSystem();
-    }
+	// Zoom on region: draw a rectangle
+	if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
+	{
+		startScreenCoordinatesSystem();
+		glDisable(GL_LIGHTING);
+		glDisable(GL_DEPTH_TEST);
+		glLineWidth(2.0);
+		glBegin(GL_LINE_LOOP);
+		glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;pressPos_.y());
+		glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;pressPos_.y());
+		glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;prevPos_.y());
+		glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;prevPos_.y());
+		glEnd();
+		glEnable(GL_DEPTH_TEST);
+		stopScreenCoordinatesSystem();
+	}
 }
 
 /*! Defines the mask that will be used to drawVisualHints(). The only available mask is currently 1,
@@ -3345,14 +3352,14 @@
 automatically called after \p delay milliseconds (default is 2 seconds). */
 void QGLViewer::setVisualHintsMask(int mask, int delay)
 {
-  visualHint_ = visualHint_ | mask;
-  QTimer::singleShot(delay, this, SLOT(resetVisualHints()));
+	visualHint_ = visualHint_ | mask;
+	QTimer::singleShot(delay, this, SLOT(resetVisualHints()));
 }
 
 /*! Reset the mask used by drawVisualHints(). Called by setVisualHintsMask() after 2 seconds to reset the display. */
 void QGLViewer::resetVisualHints()
 {
-  visualHint_ = 0;
+	visualHint_ = 0;
 }
 #endif
 
@@ -3362,148 +3369,148 @@
 
 /*! Draws a 3D arrow along the positive Z axis.
 
- \p length, \p radius and \p nbSubdivisions define its geometry. If \p radius is negative
- (default), it is set to 0.05 * \p length.
+\p length, \p radius and \p nbSubdivisions define its geometry. If \p radius is negative
+(default), it is set to 0.05 * \p length.
 
- Use drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions) or change the \c
- ModelView matrix to place the arrow in 3D.
- 
- Uses current color and does not modify the OpenGL state. */
+Use drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions) or change the \c
+ModelView matrix to place the arrow in 3D.
+
+Uses current color and does not modify the OpenGL state. */
 void QGLViewer::drawArrow(float length, float radius, int nbSubdivisions)
 {
-  static GLUquadric* quadric = gluNewQuadric();
+	static GLUquadric* quadric = gluNewQuadric();
 
-  if (radius &lt; 0.0)
-    radius = 0.05 * length;
+	if (radius &lt; 0.0)
+		radius = 0.05 * length;
 
-  const float head = 2.5*(radius / length) + 0.1;
-  const float coneRadiusCoef = 4.0 - 5.0 * head;
+	const float head = 2.5*(radius / length) + 0.1;
+	const float coneRadiusCoef = 4.0 - 5.0 * head;
 
-  gluCylinder(quadric, radius, radius, length * (1.0 - head/coneRadiusCoef), nbSubdivisions, 1);
-  glTranslatef(0.0, 0.0, length * (1.0 - head));
-  gluCylinder(quadric, coneRadiusCoef * radius, 0.0, head * length, nbSubdivisions, 1);
-  glTranslatef(0.0, 0.0, -length * (1.0 - head));
+	gluCylinder(quadric, radius, radius, length * (1.0 - head/coneRadiusCoef), nbSubdivisions, 1);
+	glTranslatef(0.0, 0.0, length * (1.0 - head));
+	gluCylinder(quadric, coneRadiusCoef * radius, 0.0, head * length, nbSubdivisions, 1);
+	glTranslatef(0.0, 0.0, -length * (1.0 - head));
 }
 
 /*! Draws a 3D arrow between the 3D point \p from and the 3D point \p to, both defined in the
- current ModelView coordinates system.
+current ModelView coordinates system.
 
- See drawArrow(float length, float radius, int nbSubdivisions) for details. */
+See drawArrow(float length, float radius, int nbSubdivisions) for details. */
 void QGLViewer::drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions)
 {
-  glPushMatrix();
-  glTranslatef(from[0],from[1],from[2]);
-  glMultMatrixd(Quaternion(Vec(0,0,1), to-from).matrix());
-  QGLViewer::drawArrow((to-from).norm(), radius, nbSubdivisions);
-  glPopMatrix();
+	glPushMatrix();
+	glTranslatef(from[0],from[1],from[2]);
+	glMultMatrixd(Quaternion(Vec(0,0,1), to-from).matrix());
+	QGLViewer::drawArrow((to-from).norm(), radius, nbSubdivisions);
+	glPopMatrix();
 }
 
 /*! Draws an XYZ axis, with a given size (default is 1.0).
 
-  The axis position and orientation matches the current modelView matrix state: three arrows (red,
-  green and blue) of length \p length are drawn along the positive X, Y and Z directions.
+The axis position and orientation matches the current modelView matrix state: three arrows (red,
+green and blue) of length \p length are drawn along the positive X, Y and Z directions.
 
-  Use the following code to display the current position and orientation of a qglviewer::Frame:
-  \code
-  glPushMatrix();
-  glMultMatrixd(frame.matrix());
-  QGLViewer::drawAxis(sceneRadius() / 5.0); // Or any scale
-  glPopMatrix();
-  \endcode
+Use the following code to display the current position and orientation of a qglviewer::Frame:
+\code
+glPushMatrix();
+glMultMatrixd(frame.matrix());
+QGLViewer::drawAxis(sceneRadius() / 5.0); // Or any scale
+glPopMatrix();
+\endcode
 
-  The current color and line width are used to draw the X, Y and Z characters at the extremities of
-  the three arrows. The OpenGL state is not modified by this method.
+The current color and line width are used to draw the X, Y and Z characters at the extremities of
+the three arrows. The OpenGL state is not modified by this method.
 
-  axisIsDrawn() uses this method to draw a representation of the world coordinate system. See also
-  QGLViewer::drawArrow() and QGLViewer::drawGrid(). */
+axisIsDrawn() uses this method to draw a representation of the world coordinate system. See also
+QGLViewer::drawArrow() and QGLViewer::drawGrid(). */
 void QGLViewer::drawAxis(float length)
 {
-  const float charWidth = length / 40.0;
-  const float charHeight = length / 30.0;
-  const float charShift = 1.04 * length;
+	const float charWidth = length / 40.0;
+	const float charHeight = length / 30.0;
+	const float charShift = 1.04 * length;
 
-  GLboolean lighting, colorMaterial;
-  glGetBooleanv(GL_LIGHTING, &amp;lighting);
-  glGetBooleanv(GL_COLOR_MATERIAL, &amp;colorMaterial);
+	GLboolean lighting, colorMaterial;
+	glGetBooleanv(GL_LIGHTING, &amp;lighting);
+	glGetBooleanv(GL_COLOR_MATERIAL, &amp;colorMaterial);
 
-  glDisable(GL_LIGHTING);
+	glDisable(GL_LIGHTING);
 
-  glBegin(GL_LINES);
-  // The X
-  glVertex3f(charShift,  charWidth, -charHeight);
-  glVertex3f(charShift, -charWidth,  charHeight);
-  glVertex3f(charShift, -charWidth, -charHeight);
-  glVertex3f(charShift,  charWidth,  charHeight);
-  // The Y
-  glVertex3f( charWidth, charShift, charHeight);
-  glVertex3f(0.0,        charShift, 0.0);
-  glVertex3f(-charWidth, charShift, charHeight);
-  glVertex3f(0.0,        charShift, 0.0);
-  glVertex3f(0.0,        charShift, 0.0);
-  glVertex3f(0.0,        charShift, -charHeight);
-  // The Z
-  glVertex3f(-charWidth,  charHeight, charShift);
-  glVertex3f( charWidth,  charHeight, charShift);
-  glVertex3f( charWidth,  charHeight, charShift);
-  glVertex3f(-charWidth, -charHeight, charShift);
-  glVertex3f(-charWidth, -charHeight, charShift);
-  glVertex3f( charWidth, -charHeight, charShift);
-  glEnd();
+	glBegin(GL_LINES);
+	// The X
+	glVertex3f(charShift,  charWidth, -charHeight);
+	glVertex3f(charShift, -charWidth,  charHeight);
+	glVertex3f(charShift, -charWidth, -charHeight);
+	glVertex3f(charShift,  charWidth,  charHeight);
+	// The Y
+	glVertex3f( charWidth, charShift, charHeight);
+	glVertex3f(0.0,        charShift, 0.0);
+	glVertex3f(-charWidth, charShift, charHeight);
+	glVertex3f(0.0,        charShift, 0.0);
+	glVertex3f(0.0,        charShift, 0.0);
+	glVertex3f(0.0,        charShift, -charHeight);
+	// The Z
+	glVertex3f(-charWidth,  charHeight, charShift);
+	glVertex3f( charWidth,  charHeight, charShift);
+	glVertex3f( charWidth,  charHeight, charShift);
+	glVertex3f(-charWidth, -charHeight, charShift);
+	glVertex3f(-charWidth, -charHeight, charShift);
+	glVertex3f( charWidth, -charHeight, charShift);
+	glEnd();
 
-  glEnable(GL_LIGHTING);
-  glDisable(GL_COLOR_MATERIAL);
+	glEnable(GL_LIGHTING);
+	glDisable(GL_COLOR_MATERIAL);
 
-  float color[4];
-  color[0] = 0.7f;  color[1] = 0.7f;  color[2] = 1.0f;  color[3] = 1.0f;
-  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
-  QGLViewer::drawArrow(length, 0.01*length);
+	float color[4];
+	color[0] = 0.7f;  color[1] = 0.7f;  color[2] = 1.0f;  color[3] = 1.0f;
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+	QGLViewer::drawArrow(length, 0.01*length);
 
-  color[0] = 1.0f;  color[1] = 0.7f;  color[2] = 0.7f;  color[3] = 1.0f;
-  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
-  glPushMatrix();
-  glRotatef(90.0, 0.0, 1.0, 0.0);
-  QGLViewer::drawArrow(length, 0.01*length);
-  glPopMatrix();
+	color[0] = 1.0f;  color[1] = 0.7f;  color[2] = 0.7f;  color[3] = 1.0f;
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+	glPushMatrix();
+	glRotatef(90.0, 0.0, 1.0, 0.0);
+	QGLViewer::drawArrow(length, 0.01*length);
+	glPopMatrix();
 
-  color[0] = 0.7f;  color[1] = 1.0f;  color[2] = 0.7f;  color[3] = 1.0f;
-  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
-  glPushMatrix();
-  glRotatef(-90.0, 1.0, 0.0, 0.0);
-  QGLViewer::drawArrow(length, 0.01*length);
-  glPopMatrix();
+	color[0] = 0.7f;  color[1] = 1.0f;  color[2] = 0.7f;  color[3] = 1.0f;
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+	glPushMatrix();
+	glRotatef(-90.0, 1.0, 0.0, 0.0);
+	QGLViewer::drawArrow(length, 0.01*length);
+	glPopMatrix();
 
-  if (colorMaterial)
-    glEnable(GL_COLOR_MATERIAL);
-  if (!lighting)
-    glDisable(GL_LIGHTING);
+	if (colorMaterial)
+		glEnable(GL_COLOR_MATERIAL);
+	if (!lighting)
+		glDisable(GL_LIGHTING);
 }
 
 /*! Draws a grid in the XY plane, centered on (0,0,0) (defined in the current coordinate system).
 
- \p size (OpenGL units) and \p nbSubdivisions define its geometry. Set the \c GL_MODELVIEW matrix to
- place and orientate the grid in 3D space (see the drawAxis() documentation).
+\p size (OpenGL units) and \p nbSubdivisions define its geometry. Set the \c GL_MODELVIEW matrix to
+place and orientate the grid in 3D space (see the drawAxis() documentation).
 
- The OpenGL state is not modified by this method. */
+The OpenGL state is not modified by this method. */
 void QGLViewer::drawGrid(float size, int nbSubdivisions)
 {
-  GLboolean lighting;
-  glGetBooleanv(GL_LIGHTING, &amp;lighting);
-  
-  glDisable(GL_LIGHTING);
+	GLboolean lighting;
+	glGetBooleanv(GL_LIGHTING, &amp;lighting);
 
-  glBegin(GL_LINES);
-  for (int i=0; i&lt;=nbSubdivisions; ++i)
-    {
-      const float pos = size*(2.0*i/nbSubdivisions-1.0);
-      glVertex2f(pos, -size);
-      glVertex2f(pos, +size);
-      glVertex2f(-size, pos);
-      glVertex2f( size, pos);
-    }
-  glEnd();
+	glDisable(GL_LIGHTING);
 
-  if (lighting)
-    glEnable(GL_LIGHTING);
+	glBegin(GL_LINES);
+	for (int i=0; i&lt;=nbSubdivisions; ++i)
+	{
+		const float pos = size*(2.0*i/nbSubdivisions-1.0);
+		glVertex2f(pos, -size);
+		glVertex2f(pos, +size);
+		glVertex2f(-size, pos);
+		glVertex2f( size, pos);
+	}
+	glEnd();
+
+	if (lighting)
+		glEnable(GL_LIGHTING);
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -3514,15 +3521,16 @@
 void QGLViewer::saveStateToFileForAllViewers()
 {
 #if QT_VERSION &gt;= 0x040000
-  foreach (QGLViewer* viewer, QGLViewer::QGLViewerPool())
-    {
+	foreach (QGLViewer* viewer, QGLViewer::QGLViewerPool())
+	{
 #else
-  QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
-  for (QGLViewer* viewer; (viewer = it.current()) != 0; ++it)
-    {
+	QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
+	for (QGLViewer* viewer; (viewer = it.current()) != 0; ++it)
+	{
 #endif
-    viewer-&gt;saveStateToFile();
-    }
+		if (viewer)
+			viewer-&gt;saveStateToFile();
+	}
 }
 
 //////////////////////////////////////////////////////////////////////////
@@ -3531,513 +3539,513 @@
 
 /*! Returns the state file name. Default value is \c .qglviewer.xml.
 
- This is the name of the XML file where saveStateToFile() saves the viewer state (camera state,
- widget geometry, display flags... see domElement()) on exit. Use restoreStateFromFile() to restore
- this state later (usually in your init() method).
+This is the name of the XML file where saveStateToFile() saves the viewer state (camera state,
+widget geometry, display flags... see domElement()) on exit. Use restoreStateFromFile() to restore
+this state later (usually in your init() method).
 
- Setting this value to \c QString::null will disable the automatic state file saving that normally
- occurs on exit.
+Setting this value to \c QString::null will disable the automatic state file saving that normally
+occurs on exit.
 
- If more than one viewer are created by the application, this function will return a numbered file
- name (as in &quot;.qglviewer1.xml&quot;, &quot;.qglviewer2.xml&quot;... using QGLViewer::QGLViewerIndex()) for extra
- viewers. Each viewer will then read back its own information in restoreStateFromFile(), provided
- that the viewers are created in the same order, which is usually the case. */
+If more than one viewer are created by the application, this function will return a numbered file
+name (as in &quot;.qglviewer1.xml&quot;, &quot;.qglviewer2.xml&quot;... using QGLViewer::QGLViewerIndex()) for extra
+viewers. Each viewer will then read back its own information in restoreStateFromFile(), provided
+that the viewers are created in the same order, which is usually the case. */
 QString QGLViewer::stateFileName() const
 {
-  QString name = stateFileName_;
+	QString name = stateFileName_;
 
-  if (!name.isEmpty() &amp;&amp; QGLViewer::QGLViewerIndex(this) &gt; 0)
-    {
-      QFileInfo fi(name);
+	if (!name.isEmpty() &amp;&amp; QGLViewer::QGLViewerIndex(this) &gt; 0)
+	{
+		QFileInfo fi(name);
 #if QT_VERSION &gt;= 0x040000
-      if (fi.suffix().isEmpty())
+		if (fi.suffix().isEmpty())
 #else
-      if (fi.extension(false).isEmpty())
+		if (fi.extension(false).isEmpty())
 #endif
-	name += QString::number(QGLViewer::QGLViewerIndex(this));
-      else
+			name += QString::number(QGLViewer::QGLViewerIndex(this));
+		else
 #if QT_VERSION &gt;= 0x040000
-	name = fi.absolutePath() + '/' + fi.completeBaseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.suffix();
+			name = fi.absolutePath() + '/' + fi.completeBaseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.suffix();
 #else
 # if QT_VERSION &gt;= 0x030000
-	name = fi.dirPath() + '/' + fi.baseName(true) + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension(false);
+			name = fi.dirPath() + '/' + fi.baseName(true) + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension(false);
 # else
-	name = fi.dirPath() + '/' + fi.baseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension();
+			name = fi.dirPath() + '/' + fi.baseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension();
 # endif
 #endif
-    }
+	}
 
-  return name;
+	return name;
 }
 
 /*! Saves in stateFileName() an XML representation of the QGLViewer state, obtained from
- domElement().
+domElement().
 
- Use restoreStateFromFile() to restore this viewer state.
+Use restoreStateFromFile() to restore this viewer state.
 
- This method is automatically called when a viewer is closed (using Escape or using the window's
- upper right \c x close button). setStateFileName() to \c QString::null to prevent this. */
+This method is automatically called when a viewer is closed (using Escape or using the window's
+upper right \c x close button). setStateFileName() to \c QString::null to prevent this. */
 void QGLViewer::saveStateToFile()
 {
-  QString name = stateFileName();
+	QString name = stateFileName();
 
-  if (name.isEmpty())
-    return;
+	if (name.isEmpty())
+		return;
 
-  QFileInfo fileInfo(name);
+	QFileInfo fileInfo(name);
 
-  if (fileInfo.isDir())
-    {
-      QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;State file name is a directory (&quot;+name+&quot;) and not a file.&quot;);
-      return;
-    }
+	if (fileInfo.isDir())
+	{
+		QMessageBox::warning(this, tr(&quot;Save to file error&quot;, &quot;Message box window title&quot;), tr(&quot;State file name (%1) references a directory instead of a file.&quot;).arg(name));
+		return;
+	}
 
 #if QT_VERSION &gt;= 0x040000
-  const QString dirName = fileInfo.absolutePath();
+	const QString dirName = fileInfo.absolutePath();
 #else
-  const QString dirName = fileInfo.dirPath();
+	const QString dirName = fileInfo.dirPath();
 #endif
-  if (!QFileInfo(dirName).exists())
-    {
-      QDir dir;
+	if (!QFileInfo(dirName).exists())
+	{
+		QDir dir;
 #if QT_VERSION &gt;= 0x040000
-      if (!(dir.mkdir(dirName)))
+		if (!(dir.mkdir(dirName)))
 #else
-      if (!(dir.mkdir(dirName, true)))
+		if (!(dir.mkdir(dirName, true)))
 #endif
-	{
-	  QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to create directory &quot;+dirName);
-	  return;
+		{
+			QMessageBox::warning(this, tr(&quot;Save to file error&quot;, &quot;Message box window title&quot;), tr(&quot;Unable to create directory %1&quot;).arg(dirName));
+			return;
+		}
 	}
-    }
 
-  // Write the DOM tree to file
-  QFile f(name);
+	// Write the DOM tree to file
+	QFile f(name);
 #if QT_VERSION &gt;= 0x040000
-  if (f.open(QIODevice::WriteOnly))
+	if (f.open(QIODevice::WriteOnly))
 #else
-  if (f.open(IO_WriteOnly))
+	if (f.open(IO_WriteOnly))
 #endif
-    {
-      QTextStream out(&amp;f);
-      QDomDocument doc(&quot;QGLVIEWER&quot;);
-      doc.appendChild(domElement(&quot;QGLViewer&quot;, doc));
-      doc.save(out, 2);
-      f.flush();
-      f.close();
-    }
-  else
+	{
+		QTextStream out(&amp;f);
+		QDomDocument doc(&quot;QGLVIEWER&quot;);
+		doc.appendChild(domElement(&quot;QGLViewer&quot;, doc));
+		doc.save(out, 2);
+		f.flush();
+		f.close();
+	}
+	else
 #if QT_VERSION &lt; 0x030200
-    QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to save to file &quot;+name);
+		QMessageBox::warning(this, tr(&quot;Save to file error&quot;, &quot;Message box window title&quot;), tr(&quot;Unable to save to file %1&quot;).arg(name));
 #else
-    QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to save to file &quot;+name+&quot;:\n&quot;+f.errorString());
+		QMessageBox::warning(this, tr(&quot;Save to file error&quot;, &quot;Message box window title&quot;), tr(&quot;Unable to save to file %1&quot;).arg(name) + &quot;:\n&quot; + f.errorString());
 #endif
 }
 
 /*! Restores the QGLViewer state from the stateFileName() file using initFromDOMElement().
 
- States are saved using saveStateToFile(), which is automatically called on viewer exit.
+States are saved using saveStateToFile(), which is automatically called on viewer exit.
 
- Returns \c true when the restoration is successful. Possible problems are an non existing or
- unreadable stateFileName() file, an empty stateFileName() or an XML syntax error.
+Returns \c true when the restoration is successful. Possible problems are an non existing or
+unreadable stateFileName() file, an empty stateFileName() or an XML syntax error.
 
- A manipulatedFrame() should be defined \e before calling this method, so that its state can be
- restored. Initialization code put \e after this function will override saved values:
- \code
- void Viewer::init()
- {
-   // Default initialization goes here (including the declaration of a possible manipulatedFrame).
+A manipulatedFrame() should be defined \e before calling this method, so that its state can be
+restored. Initialization code put \e after this function will override saved values:
+\code
+void Viewer::init()
+{
+// Default initialization goes here (including the declaration of a possible manipulatedFrame).
 
-   if (!restoreStateFromFile())
-     showEntireScene(); // Previous state cannot be restored: fit camera to scene.
+if (!restoreStateFromFile())
+showEntireScene(); // Previous state cannot be restored: fit camera to scene.
 
-   // Specific initialization that overrides file savings goes here.
- }
- \endcode */
+// Specific initialization that overrides file savings goes here.
+}
+\endcode */
 bool QGLViewer::restoreStateFromFile()
 {
-  QString name = stateFileName();
+	QString name = stateFileName();
 
-  if (name.isEmpty())
-    return false;
+	if (name.isEmpty())
+		return false;
 
-  QFileInfo fileInfo(name);
+	QFileInfo fileInfo(name);
 
-  if (!fileInfo.isFile())
-    // No warning since it would be displayed at first start.
-    return false;
+	if (!fileInfo.isFile())
+		// No warning since it would be displayed at first start.
+		return false;
 
-  if (!fileInfo.isReadable())
-    {
-      QMessageBox::warning(this, &quot;restoreStateFromFile problem&quot;, &quot;File &quot;+name+&quot; is not readable.&quot;);
-      return false;
-    }
+	if (!fileInfo.isReadable())
+	{
+		QMessageBox::warning(this, tr(&quot;Problem in state restoration&quot;, &quot;Message box window title&quot;), tr(&quot;File %1 is not readable.&quot;).arg(name));
+		return false;
+	}
 
-  // Read the DOM tree form file
-  QFile f(name);
+	// Read the DOM tree form file
+	QFile f(name);
 #if QT_VERSION &gt;= 0x040000
-  if (f.open(QIODevice::ReadOnly) == true)
+	if (f.open(QIODevice::ReadOnly) == true)
 #else
-  if (f.open(IO_ReadOnly) == true)
+	if (f.open(IO_ReadOnly) == true)
 #endif
-    {
-      QDomDocument doc;
-      doc.setContent(&amp;f);
-      f.close();
-      QDomElement main = doc.documentElement();
-      initFromDOMElement(main);
-    }
-  else
-    {
+	{
+		QDomDocument doc;
+		doc.setContent(&amp;f);
+		f.close();
+		QDomElement main = doc.documentElement();
+		initFromDOMElement(main);
+	}
+	else
+	{
 #if QT_VERSION &lt; 0x030200
-      QMessageBox::warning(this, &quot;Open file error&quot;, &quot;Unable to open file &quot;+name);
+		QMessageBox::warning(this, tr(&quot;Open file error&quot;, &quot;Message box window title&quot;), tr(&quot;Unable to open file %1&quot;).arg(name));
 #else
-      QMessageBox::warning(this, &quot;Open file error&quot;, &quot;Unable to open file &quot;+name+&quot;:\n&quot;+f.errorString());
+		QMessageBox::warning(this, tr(&quot;Open file error&quot;, &quot;Message box window title&quot;), tr(&quot;Unable to open file %1&quot;).arg(name) + &quot;:\n&quot; + f.errorString());
 #endif
-      return false;
-    }
+		return false;
+	}
 
-  return true;
+	return true;
 }
 
 /*! Returns an XML \c QDomElement that represents the QGLViewer.
 
- Used by saveStateToFile(). restoreStateFromFile() uses initFromDOMElement() to restore the
- QGLViewer state from the resulting \c QDomElement.
+Used by saveStateToFile(). restoreStateFromFile() uses initFromDOMElement() to restore the
+QGLViewer state from the resulting \c QDomElement.
 
- \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
- QDomElement.
+\p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+QDomElement.
 
- The created QDomElement contains state values (axisIsDrawn(), FPSIsDisplayed(), isFullScreen()...),
- viewer geometry, as well as camera() (see qglviewer::Camera::domElement()) and manipulatedFrame()
- (if defined, see qglviewer::ManipulatedFrame::domElement()) states.
+The created QDomElement contains state values (axisIsDrawn(), FPSIsDisplayed(), isFullScreen()...),
+viewer geometry, as well as camera() (see qglviewer::Camera::domElement()) and manipulatedFrame()
+(if defined, see qglviewer::ManipulatedFrame::domElement()) states.
 
- Overload this method to add your own attributes to the state file:
- \code
- QDomElement Viewer::domElement(const QString&amp; name, QDomDocument&amp; document) const
- {
-   // Creates a custom node for a light
-   QDomElement de = document.createElement(&quot;Light&quot;);
-   de.setAttribute(&quot;state&quot;, (lightIsOn()?&quot;on&quot;:&quot;off&quot;));
-   // Note the include of the ManipulatedFrame domElement method.
-   de.appendChild(lightManipulatedFrame()-&gt;domElement(&quot;LightFrame&quot;, document));
+Overload this method to add your own attributes to the state file:
+\code
+QDomElement Viewer::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+// Creates a custom node for a light
+QDomElement de = document.createElement(&quot;Light&quot;);
+de.setAttribute(&quot;state&quot;, (lightIsOn()?&quot;on&quot;:&quot;off&quot;));
+// Note the include of the ManipulatedFrame domElement method.
+de.appendChild(lightManipulatedFrame()-&gt;domElement(&quot;LightFrame&quot;, document));
 
-   // Get default state domElement and append custom node
-   QDomElement res = QGLViewer::domElement(name, document);
-   res.appendChild(de);
-   return res;
- }
- \endcode
- See initFromDOMElement() for the associated restoration code.
+// Get default state domElement and append custom node
+QDomElement res = QGLViewer::domElement(name, document);
+res.appendChild(de);
+return res;
+}
+\endcode
+See initFromDOMElement() for the associated restoration code.
 
- \attention For the manipulatedFrame(), qglviewer::Frame::constraint() and
- qglviewer::Frame::referenceFrame() are not saved. See qglviewer::Frame::domElement(). */
+\attention For the manipulatedFrame(), qglviewer::Frame::constraint() and
+qglviewer::Frame::referenceFrame() are not saved. See qglviewer::Frame::domElement(). */
 QDomElement QGLViewer::domElement(const QString&amp; name, QDomDocument&amp; document) const
 {
-  QDomElement de = document.createElement(name);
-  de.setAttribute(&quot;version&quot;, QGLViewerVersionString());
+	QDomElement de = document.createElement(name);
+	de.setAttribute(&quot;version&quot;, QGLViewerVersionString());
 
-  QDomElement stateNode = document.createElement(&quot;State&quot;);
-  // stateNode.setAttribute(&quot;mouseTracking&quot;, (hasMouseTracking()?&quot;true&quot;:&quot;false&quot;));
-  stateNode.appendChild(DomUtils::QColorDomElement(foregroundColor(), &quot;foregroundColor&quot;, document));
-  stateNode.appendChild(DomUtils::QColorDomElement(backgroundColor(), &quot;backgroundColor&quot;, document));
-  stateNode.setAttribute(&quot;stereo&quot;, (displaysInStereo()?&quot;true&quot;:&quot;false&quot;));
-  stateNode.setAttribute(&quot;cameraMode&quot;, (cameraIsInRevolveMode()?&quot;revolve&quot;:&quot;fly&quot;));
-  de.appendChild(stateNode);
+	QDomElement stateNode = document.createElement(&quot;State&quot;);
+	// stateNode.setAttribute(&quot;mouseTracking&quot;, (hasMouseTracking()?&quot;true&quot;:&quot;false&quot;));
+	stateNode.appendChild(DomUtils::QColorDomElement(foregroundColor(), &quot;foregroundColor&quot;, document));
+	stateNode.appendChild(DomUtils::QColorDomElement(backgroundColor(), &quot;backgroundColor&quot;, document));
+	stateNode.setAttribute(&quot;stereo&quot;, (displaysInStereo()?&quot;true&quot;:&quot;false&quot;));
+	stateNode.setAttribute(&quot;cameraMode&quot;, (cameraIsInRevolveMode()?&quot;revolve&quot;:&quot;fly&quot;));
+	de.appendChild(stateNode);
 
-  QDomElement displayNode = document.createElement(&quot;Display&quot;);
-  displayNode.setAttribute(&quot;axisIsDrawn&quot;,       (axisIsDrawn()?&quot;true&quot;:&quot;false&quot;));
-  displayNode.setAttribute(&quot;gridIsDrawn&quot;,       (gridIsDrawn()?&quot;true&quot;:&quot;false&quot;));
-  displayNode.setAttribute(&quot;FPSIsDisplayed&quot;,    (FPSIsDisplayed()?&quot;true&quot;:&quot;false&quot;));
-  displayNode.setAttribute(&quot;cameraIsEdited&quot;,    (cameraIsEdited()?&quot;true&quot;:&quot;false&quot;));
-  // displayNode.setAttribute(&quot;textIsEnabled&quot;,  (textIsEnabled()?&quot;true&quot;:&quot;false&quot;));
-  de.appendChild(displayNode);
+	QDomElement displayNode = document.createElement(&quot;Display&quot;);
+	displayNode.setAttribute(&quot;axisIsDrawn&quot;,       (axisIsDrawn()?&quot;true&quot;:&quot;false&quot;));
+	displayNode.setAttribute(&quot;gridIsDrawn&quot;,       (gridIsDrawn()?&quot;true&quot;:&quot;false&quot;));
+	displayNode.setAttribute(&quot;FPSIsDisplayed&quot;,    (FPSIsDisplayed()?&quot;true&quot;:&quot;false&quot;));
+	displayNode.setAttribute(&quot;cameraIsEdited&quot;,    (cameraIsEdited()?&quot;true&quot;:&quot;false&quot;));
+	// displayNode.setAttribute(&quot;textIsEnabled&quot;,  (textIsEnabled()?&quot;true&quot;:&quot;false&quot;));
+	de.appendChild(displayNode);
 
-  QDomElement geometryNode = document.createElement(&quot;Geometry&quot;);
-  geometryNode.setAttribute(&quot;fullScreen&quot;, (isFullScreen()?&quot;true&quot;:&quot;false&quot;));
-  if (isFullScreen())
-    {
-      geometryNode.setAttribute(&quot;prevPosX&quot;, QString::number(prevPos_.x()));
-      geometryNode.setAttribute(&quot;prevPosY&quot;, QString::number(prevPos_.y()));
-    }
-  else
-    {
-      QWidget* tlw = topLevelWidget();
-      geometryNode.setAttribute(&quot;width&quot;,  QString::number(tlw-&gt;width()));
-      geometryNode.setAttribute(&quot;height&quot;, QString::number(tlw-&gt;height()));
-      geometryNode.setAttribute(&quot;posX&quot;,   QString::number(tlw-&gt;pos().x()));
-      geometryNode.setAttribute(&quot;posY&quot;,   QString::number(tlw-&gt;pos().y()));
-    }
-  de.appendChild(geometryNode);
+	QDomElement geometryNode = document.createElement(&quot;Geometry&quot;);
+	geometryNode.setAttribute(&quot;fullScreen&quot;, (isFullScreen()?&quot;true&quot;:&quot;false&quot;));
+	if (isFullScreen())
+	{
+		geometryNode.setAttribute(&quot;prevPosX&quot;, QString::number(prevPos_.x()));
+		geometryNode.setAttribute(&quot;prevPosY&quot;, QString::number(prevPos_.y()));
+	}
+	else
+	{
+		QWidget* tlw = topLevelWidget();
+		geometryNode.setAttribute(&quot;width&quot;,  QString::number(tlw-&gt;width()));
+		geometryNode.setAttribute(&quot;height&quot;, QString::number(tlw-&gt;height()));
+		geometryNode.setAttribute(&quot;posX&quot;,   QString::number(tlw-&gt;pos().x()));
+		geometryNode.setAttribute(&quot;posY&quot;,   QString::number(tlw-&gt;pos().y()));
+	}
+	de.appendChild(geometryNode);
 
-  // Restore original Camera zClippingCoefficient before saving.
-  if (cameraIsEdited())
-    camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
-  de.appendChild(camera()-&gt;domElement(&quot;Camera&quot;, document));
-  if (cameraIsEdited())
-    // #CONNECTION# 5.0 from setCameraIsEdited()
-    camera()-&gt;setZClippingCoefficient(5.0);
+	// Restore original Camera zClippingCoefficient before saving.
+	if (cameraIsEdited())
+		camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
+	de.appendChild(camera()-&gt;domElement(&quot;Camera&quot;, document));
+	if (cameraIsEdited())
+		// #CONNECTION# 5.0 from setCameraIsEdited()
+		camera()-&gt;setZClippingCoefficient(5.0);
 
-  if (manipulatedFrame())
-    de.appendChild(manipulatedFrame()-&gt;domElement(&quot;ManipulatedFrame&quot;, document));
+	if (manipulatedFrame())
+		de.appendChild(manipulatedFrame()-&gt;domElement(&quot;ManipulatedFrame&quot;, document));
 
-  return de;
+	return de;
 }
 
 /*! Restores the QGLViewer state from a \c QDomElement created by domElement().
 
- Used by restoreStateFromFile() to restore the QGLViewer state from a file.
+Used by restoreStateFromFile() to restore the QGLViewer state from a file.
 
- Overload this method to retrieve custom attributes from the QGLViewer state file. This code
- corresponds to the one given in the domElement() documentation:
- \code
- void Viewer::initFromDOMElement(const QDomElement&amp; element)
- {
-   // Restore standard state
-   QGLViewer::initFromDOMElement(element);
+Overload this method to retrieve custom attributes from the QGLViewer state file. This code
+corresponds to the one given in the domElement() documentation:
+\code
+void Viewer::initFromDOMElement(const QDomElement&amp; element)
+{
+// Restore standard state
+QGLViewer::initFromDOMElement(element);
 
-   QDomElement child=element.firstChild().toElement();
-   while (!child.isNull())
-   {
-     if (child.tagName() == &quot;Light&quot;)
-     {
-       if (child.hasAttribute(&quot;state&quot;))
-	 setLightOn(child.attribute(&quot;state&quot;).lower() == &quot;on&quot;);
+QDomElement child=element.firstChild().toElement();
+while (!child.isNull())
+{
+if (child.tagName() == &quot;Light&quot;)
+{
+if (child.hasAttribute(&quot;state&quot;))
+setLightOn(child.attribute(&quot;state&quot;).lower() == &quot;on&quot;);
 
-       // Assumes there is only one child. Otherwise you need to parse child's children recursively.
-       QDomElement lf = child.firstChild().toElement();
-       if (!lf.isNull() &amp;&amp; lf.tagName() == &quot;LightFrame&quot;)
-         lightManipulatedFrame()-&gt;initFromDomElement(lf);
-     }
-     child = child.nextSibling().toElement();
-   }
- }
- \endcode
+// Assumes there is only one child. Otherwise you need to parse child's children recursively.
+QDomElement lf = child.firstChild().toElement();
+if (!lf.isNull() &amp;&amp; lf.tagName() == &quot;LightFrame&quot;)
+lightManipulatedFrame()-&gt;initFromDomElement(lf);
+}
+child = child.nextSibling().toElement();
+}
+}
+\endcode
 
- See also qglviewer::Camera::initFromDOMElement(), qglviewer::ManipulatedFrame::initFromDOMElement().
+See also qglviewer::Camera::initFromDOMElement(), qglviewer::ManipulatedFrame::initFromDOMElement().
 
- \note The manipulatedFrame() \e pointer is not modified by this method. If defined, its state is
- simply set from the \p element values. */
+\note The manipulatedFrame() \e pointer is not modified by this method. If defined, its state is
+simply set from the \p element values. */
 void QGLViewer::initFromDOMElement(const QDomElement&amp; element)
 {
-  const QString version = element.attribute(&quot;version&quot;);
-  // if (version != QGLViewerVersionString())
-  if (version[0] != '2')
-    // Patches for previous versions should go here when the state file syntax is modified.
+	const QString version = element.attribute(&quot;version&quot;);
+	// if (version != QGLViewerVersionString())
+	if (version[0] != '2')
+		// Patches for previous versions should go here when the state file syntax is modified.
 #if QT_VERSION &gt;= 0x040000
-    qWarning(QString(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;+QGLViewerVersionString()).toLatin1().constData());
+		qWarning(QString(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;+QGLViewerVersionString()).toLatin1().constData());
 #else
-  qWarning(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;);
+		qWarning(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;);
 #endif
 
-  QDomElement child=element.firstChild().toElement();
-  bool tmpCameraIsEdited = cameraIsEdited();
-  while (!child.isNull())
-    {
-      if (child.tagName() == &quot;State&quot;)
+	QDomElement child=element.firstChild().toElement();
+	bool tmpCameraIsEdited = cameraIsEdited();
+	while (!child.isNull())
 	{
-	  // #CONNECTION# default values from defaultConstructor()
-	  // setMouseTracking(DomUtils::boolFromDom(child, &quot;mouseTracking&quot;, false));
-	  setStereoDisplay(DomUtils::boolFromDom(child, &quot;stereo&quot;, false));
-	  if ((child.attribute(&quot;cameraMode&quot;, &quot;revolve&quot;) == &quot;fly&quot;) &amp;&amp; (cameraIsInRevolveMode()))
-	    toggleCameraMode();
+		if (child.tagName() == &quot;State&quot;)
+		{
+			// #CONNECTION# default values from defaultConstructor()
+			// setMouseTracking(DomUtils::boolFromDom(child, &quot;mouseTracking&quot;, false));
+			setStereoDisplay(DomUtils::boolFromDom(child, &quot;stereo&quot;, false));
+			if ((child.attribute(&quot;cameraMode&quot;, &quot;revolve&quot;) == &quot;fly&quot;) &amp;&amp; (cameraIsInRevolveMode()))
+				toggleCameraMode();
 
-	  QDomElement ch=child.firstChild().toElement();
-	  while (!ch.isNull())
-	    {
-	      if (ch.tagName() == &quot;foregroundColor&quot;)
-		setForegroundColor(DomUtils::QColorFromDom(ch));
-	      if (ch.tagName() == &quot;backgroundColor&quot;)
-		setBackgroundColor(DomUtils::QColorFromDom(ch));
-	      ch = ch.nextSibling().toElement();
-	    }
-	}
+			QDomElement ch=child.firstChild().toElement();
+			while (!ch.isNull())
+			{
+				if (ch.tagName() == &quot;foregroundColor&quot;)
+					setForegroundColor(DomUtils::QColorFromDom(ch));
+				if (ch.tagName() == &quot;backgroundColor&quot;)
+					setBackgroundColor(DomUtils::QColorFromDom(ch));
+				ch = ch.nextSibling().toElement();
+			}
+		}
 
-      if (child.tagName() == &quot;Display&quot;)
-	{
-	  // #CONNECTION# default values from defaultConstructor()
-	  setAxisIsDrawn(DomUtils::boolFromDom(child, &quot;axisIsDrawn&quot;, false));
-	  setGridIsDrawn(DomUtils::boolFromDom(child, &quot;gridIsDrawn&quot;, false));
-	  setFPSIsDisplayed(DomUtils::boolFromDom(child, &quot;FPSIsDisplayed&quot;, false));
-	  // See comment below.
-	  tmpCameraIsEdited = DomUtils::boolFromDom(child, &quot;cameraIsEdited&quot;, false);
-	  // setTextIsEnabled(DomUtils::boolFromDom(child, &quot;textIsEnabled&quot;, true));
-	}
+		if (child.tagName() == &quot;Display&quot;)
+		{
+			// #CONNECTION# default values from defaultConstructor()
+			setAxisIsDrawn(DomUtils::boolFromDom(child, &quot;axisIsDrawn&quot;, false));
+			setGridIsDrawn(DomUtils::boolFromDom(child, &quot;gridIsDrawn&quot;, false));
+			setFPSIsDisplayed(DomUtils::boolFromDom(child, &quot;FPSIsDisplayed&quot;, false));
+			// See comment below.
+			tmpCameraIsEdited = DomUtils::boolFromDom(child, &quot;cameraIsEdited&quot;, false);
+			// setTextIsEnabled(DomUtils::boolFromDom(child, &quot;textIsEnabled&quot;, true));
+		}
 
-      if (child.tagName() == &quot;Geometry&quot;)
-	{
-	  setFullScreen(DomUtils::boolFromDom(child, &quot;fullScreen&quot;, false));
+		if (child.tagName() == &quot;Geometry&quot;)
+		{
+			setFullScreen(DomUtils::boolFromDom(child, &quot;fullScreen&quot;, false));
 
-	  if (isFullScreen())
-	    {
-	      prevPos_.setX(DomUtils::intFromDom(child, &quot;prevPosX&quot;, 0));
-	      prevPos_.setY(DomUtils::intFromDom(child, &quot;prevPosY&quot;, 0));
-	    }
-	  else
-	    {
-	      int width  = DomUtils::intFromDom(child, &quot;width&quot;,  600);
-	      int height = DomUtils::intFromDom(child, &quot;height&quot;, 400);
-	      topLevelWidget()-&gt;resize(width, height);
+			if (isFullScreen())
+			{
+				prevPos_.setX(DomUtils::intFromDom(child, &quot;prevPosX&quot;, 0));
+				prevPos_.setY(DomUtils::intFromDom(child, &quot;prevPosY&quot;, 0));
+			}
+			else
+			{
+				int width  = DomUtils::intFromDom(child, &quot;width&quot;,  600);
+				int height = DomUtils::intFromDom(child, &quot;height&quot;, 400);
+				topLevelWidget()-&gt;resize(width, height);
 
-	      QPoint pos;
-	      pos.setX(DomUtils::intFromDom(child, &quot;posX&quot;, 0));
-	      pos.setY(DomUtils::intFromDom(child, &quot;posY&quot;, 0));
-	      topLevelWidget()-&gt;move(pos);
-	    }
+				QPoint pos;
+				pos.setX(DomUtils::intFromDom(child, &quot;posX&quot;, 0));
+				pos.setY(DomUtils::intFromDom(child, &quot;posY&quot;, 0));
+				topLevelWidget()-&gt;move(pos);
+			}
+		}
+
+		if (child.tagName() == &quot;Camera&quot;)
+		{
+			connectAllCameraKFIInterpolatedSignals(false);
+			camera()-&gt;initFromDOMElement(child);
+			connectAllCameraKFIInterpolatedSignals();
+		}
+
+		if ((child.tagName() == &quot;ManipulatedFrame&quot;) &amp;&amp; (manipulatedFrame()))
+			manipulatedFrame()-&gt;initFromDOMElement(child);
+
+		child = child.nextSibling().toElement();
 	}
 
-      if (child.tagName() == &quot;Camera&quot;)
+	// The Camera always stores its &quot;real&quot; zClippingCoef in domElement(). If it is edited,
+	// its &quot;real&quot; coef must be saved and the coef set to 5.0, as is done in setCameraIsEdited().
+	// BUT : Camera and Display are read in an arbitrary order. We must initialize Camera's
+	// &quot;real&quot; coef BEFORE calling setCameraIsEdited. Hence this temp cameraIsEdited and delayed call
+	cameraIsEdited_ = tmpCameraIsEdited;
+	if (cameraIsEdited_)
 	{
-	  connectAllCameraKFIInterpolatedSignals(false);
-	  camera()-&gt;initFromDOMElement(child);
-	  connectAllCameraKFIInterpolatedSignals();
+		previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
+		// #CONNECTION# 5.0 from setCameraIsEdited.
+		camera()-&gt;setZClippingCoefficient(5.0);
 	}
-
-      if ((child.tagName() == &quot;ManipulatedFrame&quot;) &amp;&amp; (manipulatedFrame()))
-	manipulatedFrame()-&gt;initFromDOMElement(child);
-
-      child = child.nextSibling().toElement();
-    }
-
-  // The Camera always stores its &quot;real&quot; zClippingCoef in domElement(). If it is edited,
-  // its &quot;real&quot; coef must be saved and the coef set to 5.0, as is done in setCameraIsEdited().
-  // BUT : Camera and Display are read in an arbitrary order. We must initialize Camera's
-  // &quot;real&quot; coef BEFORE calling setCameraIsEdited. Hence this temp cameraIsEdited and delayed call
-  cameraIsEdited_ = tmpCameraIsEdited;
-  if (cameraIsEdited_)
-    {
-      previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
-      // #CONNECTION# 5.0 from setCameraIsEdited.
-      camera()-&gt;setZClippingCoefficient(5.0);
-    }
 }
 
 #ifndef DOXYGEN
 /*! This method is deprecated since version 1.3.9-5. Use saveStateToFile() and setStateFileName()
-  instead. */
+instead. */
 void QGLViewer::saveToFile(const QString&amp; fileName)
 {
-  if (!fileName.isEmpty())
-    setStateFileName(fileName);
+	if (!fileName.isEmpty())
+		setStateFileName(fileName);
 
-  qWarning(&quot;saveToFile() is deprecated, use saveStateToFile() instead.&quot;);
-  saveStateToFile();
+	qWarning(&quot;saveToFile() is deprecated, use saveStateToFile() instead.&quot;);
+	saveStateToFile();
 }
 
 /*! This function is deprecated since version 1.3.9-5. Use restoreStateFromFile() and
-  setStateFileName() instead. */
+setStateFileName() instead. */
 bool QGLViewer::restoreFromFile(const QString&amp; fileName)
 {
-  if (!fileName.isEmpty())
-    setStateFileName(fileName);
+	if (!fileName.isEmpty())
+		setStateFileName(fileName);
 
-  qWarning(&quot;restoreFromFile() is deprecated, use restoreStateFromFile() instead.&quot;);
-  return restoreStateFromFile();
+	qWarning(&quot;restoreFromFile() is deprecated, use restoreStateFromFile() instead.&quot;);
+	return restoreStateFromFile();
 }
 #endif
 
 /*! Makes a copy of the current buffer into a texture.
 
- Creates a texture (when needed) and uses glCopyTexSubImage2D() to directly copy the buffer in it.
+Creates a texture (when needed) and uses glCopyTexSubImage2D() to directly copy the buffer in it.
 
- Use \p internalFormat and \p format to define the texture format and hence which and how components
- of the buffer are copied into the texture. See the glTexImage2D() documentation for details.
+Use \p internalFormat and \p format to define the texture format and hence which and how components
+of the buffer are copied into the texture. See the glTexImage2D() documentation for details.
 
- When \p format is c GL_NONE (default), its value is set to \p internalFormat, which fits most
- cases. Typical \p internalFormat (and \p format) values are \c GL_DEPTH_COMPONENT and \c GL_RGBA.
- Use \c GL_LUMINANCE as the \p internalFormat and \c GL_RED, \c GL_GREEN or \c GL_BLUE as \p format
- to capture a single color component as a luminance (grey scaled) value. Note that \c GL_STENCIL is
- not supported as a format.
+When \p format is c GL_NONE (default), its value is set to \p internalFormat, which fits most
+cases. Typical \p internalFormat (and \p format) values are \c GL_DEPTH_COMPONENT and \c GL_RGBA.
+Use \c GL_LUMINANCE as the \p internalFormat and \c GL_RED, \c GL_GREEN or \c GL_BLUE as \p format
+to capture a single color component as a luminance (grey scaled) value. Note that \c GL_STENCIL is
+not supported as a format.
 
- The texture has dimensions which are powers of two. It is as small as possible while always being
- larger or equal to the current size of the widget. The buffer image hence does not entirely fill
- the texture: it is stuck to the lower left corner (corresponding to the (0,0) texture coordinates).
- Use bufferTextureMaxU() and bufferTextureMaxV() to get the upper right corner maximum u and v
- texture coordinates. Use bufferTextureId() to retrieve the id of the created texture.
+The texture has dimensions which are powers of two. It is as small as possible while always being
+larger or equal to the current size of the widget. The buffer image hence does not entirely fill
+the texture: it is stuck to the lower left corner (corresponding to the (0,0) texture coordinates).
+Use bufferTextureMaxU() and bufferTextureMaxV() to get the upper right corner maximum u and v
+texture coordinates. Use bufferTextureId() to retrieve the id of the created texture.
 
- Here is how to display a grey-level image of the z-buffer:
- \code
- copyBufferToTexture(GL_DEPTH_COMPONENT);
+Here is how to display a grey-level image of the z-buffer:
+\code
+copyBufferToTexture(GL_DEPTH_COMPONENT);
 
- glMatrixMode(GL_TEXTURE);
- glLoadIdentity();
+glMatrixMode(GL_TEXTURE);
+glLoadIdentity();
 
- glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
- glEnable(GL_TEXTURE_2D);
+glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+glEnable(GL_TEXTURE_2D);
 
- startScreenCoordinatesSystem(true);
+startScreenCoordinatesSystem(true);
 
- glBegin(GL_QUADS);
- glTexCoord2f(0.0, 0.0);                                 glVertex2i(0, 0);
- glTexCoord2f(bufferTextureMaxU(), 0.0);                 glVertex2i(width(), 0);
- glTexCoord2f(bufferTextureMaxU(), bufferTextureMaxV()); glVertex2i(width(), height());
- glTexCoord2f(0.0, bufferTextureMaxV());                 glVertex2i(0, height());
- glEnd();
+glBegin(GL_QUADS);
+glTexCoord2f(0.0, 0.0);                                 glVertex2i(0, 0);
+glTexCoord2f(bufferTextureMaxU(), 0.0);                 glVertex2i(width(), 0);
+glTexCoord2f(bufferTextureMaxU(), bufferTextureMaxV()); glVertex2i(width(), height());
+glTexCoord2f(0.0, bufferTextureMaxV());                 glVertex2i(0, height());
+glEnd();
 
- stopScreenCoordinatesSystem();
- 
- glDisable(GL_TEXTURE_2D);
- \endcode
- 
- Use glReadBuffer() to select which buffer is copied into the texture. See also \c
- glPixelTransfer(), \c glPixelZoom() and \c glCopyPixel() for pixel color transformations during
- copy.
+stopScreenCoordinatesSystem();
 
- Call makeCurrent() before this method to make the OpenGL context active if needed.
+glDisable(GL_TEXTURE_2D);
+\endcode
 
- \note The \c GL_DEPTH_COMPONENT format may not be supported by all hardware. It may sometimes be
- emulated in software, resulting in poor performances.
+Use glReadBuffer() to select which buffer is copied into the texture. See also \c
+glPixelTransfer(), \c glPixelZoom() and \c glCopyPixel() for pixel color transformations during
+copy.
 
- \note The bufferTextureId() texture is binded at the end of this method. */
+Call makeCurrent() before this method to make the OpenGL context active if needed.
+
+\note The \c GL_DEPTH_COMPONENT format may not be supported by all hardware. It may sometimes be
+emulated in software, resulting in poor performances.
+
+\note The bufferTextureId() texture is binded at the end of this method. */
 void QGLViewer::copyBufferToTexture(GLint internalFormat, GLenum format)
 {
-  int h = 16;
-  int w = 16;
-  // Todo compare performance with qt code.
-  while (w &lt; width())
-    w &lt;&lt;= 1;
-  while (h &lt; height())
-    h &lt;&lt;= 1;
+	int h = 16;
+	int w = 16;
+	// Todo compare performance with qt code.
+	while (w &lt; width())
+		w &lt;&lt;= 1;
+	while (h &lt; height())
+		h &lt;&lt;= 1;
 
-  bool init = false;
+	bool init = false;
 
-  if ((w != bufferTextureWidth_) || (h != bufferTextureHeight_))
-    {
-      bufferTextureWidth_ = w;
-      bufferTextureHeight_ = h;
-      bufferTextureMaxU_ = width()  / float(bufferTextureWidth_);
-      bufferTextureMaxV_ = height() / float(bufferTextureHeight_);
-      init = true;
-    }
+	if ((w != bufferTextureWidth_) || (h != bufferTextureHeight_))
+	{
+		bufferTextureWidth_ = w;
+		bufferTextureHeight_ = h;
+		bufferTextureMaxU_ = width()  / float(bufferTextureWidth_);
+		bufferTextureMaxV_ = height() / float(bufferTextureHeight_);
+		init = true;
+	}
 
-  if (bufferTextureId() == 0)
-    {
-      glGenTextures(1, &amp;bufferTextureId_);
-      glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-      init = true;
-    }
-  else
-    glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
+	if (bufferTextureId() == 0)
+	{
+		glGenTextures(1, &amp;bufferTextureId_);
+		glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		init = true;
+	}
+	else
+		glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
 
-  if ((format != previousBufferTextureFormat_) ||
-      (internalFormat != previousBufferTextureInternalFormat_))
-    {
-      previousBufferTextureFormat_ = format;
-      previousBufferTextureInternalFormat_ = internalFormat;
-      init = true;
-    }
+	if ((format != previousBufferTextureFormat_) ||
+		(internalFormat != previousBufferTextureInternalFormat_))
+	{
+		previousBufferTextureFormat_ = format;
+		previousBufferTextureInternalFormat_ = internalFormat;
+		init = true;
+	}
 
-  if (init)
-    {
-      if (format == GL_NONE)
-	format = internalFormat;
+	if (init)
+	{
+		if (format == GL_NONE)
+			format = internalFormat;
 
-      glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, bufferTextureWidth_, bufferTextureHeight_, 0, format, GL_UNSIGNED_BYTE, NULL);
-    }
+		glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, bufferTextureWidth_, bufferTextureHeight_, 0, format, GL_UNSIGNED_BYTE, NULL);
+	}
 
-  glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width(), height());
+	glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width(), height());
 }
 
 /*! Returns the texture id of the texture created by copyBufferToTexture().
@@ -4048,8 +4056,8 @@
 glDeleteTextures() since then. */
 GLuint QGLViewer::bufferTextureId() const
 {
-  if (glIsTexture(bufferTextureId_))
-    return bufferTextureId_;
-  else
-    return 0;
+	if (glIsTexture(bufferTextureId_))
+		return bufferTextureId_;
+	else
+		return 0;
 }

Modified: trunk/lib/QGLViewer/qglviewer.cw
===================================================================
--- trunk/lib/QGLViewer/qglviewer.cw	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/qglviewer.cw	2008-07-18 06:54:48 UTC (rev 1434)
@@ -1,4 +1,4 @@
-&lt;!DOCTYPE CW&gt;&lt;CW&gt;
+-e &lt;!DOCTYPE CW&gt;&lt;CW&gt;
 &lt;customwidgets&gt;
   &lt;customwidget&gt;
    &lt;class&gt;QGLViewer&lt;/class&gt;
@@ -16,67 +16,67 @@
         &lt;data format=&quot;XPM.GZ&quot; length=&quot;3320&quot;&gt;789c5d56db521d3b0e7dcf5750d15b6a4aa7dbee76db35350f845b200142eec9a979902f1d20dcd9248153f3efe3ad65381ce82a6aaf962ccbd2d272fff162e5cbdbdd95177f3cbb5ec8e228ada443b95a79916f4e4f6ffffcef7ffe7af6bc1f577ab7d24ffd8a79feaf67cfa9baacec9d9f9525e0b547e060f108d075053497e5a39e4e71ae4f529c9ed873c3d543f1e513fb4ec3f54fe37f573c3fd8371bbeb70f0feb351ef19378570ff920dfdb8613f2a3aef9a739aa3ff693fa2896fb7ce22c8a4f1e30fcbfb478b19db7fb27a623c5d51bf9c9eb86fd3ca93fecd3ec1a7eafd8d4c7aaff4fc5beda9dda4f5b7e23b05cb6fd86e67fd8b0993bc5dfdb7a330fba7e577198ed3c2afefc705eaff9aeb5f399a2f56552dc9554709e77cdde15d4fb25f22f65eed5fff609de58e252ff66d00ae7b7f551cc1fdafe01f524ece74a2cda2fd1f3965c42db7fa7adefb15e2e14f7c537fb6fc5e37d3de8f001eb79e993c64b458af6934e9add36ff6fedbc5d417d6f14a75cb2d687355ee973869db75bbc5082fa47d43f878cf36a3fb3c95d413d0e1a0ee01369fdcb54e3c17ed3e2a70c7ebf512c7505f8c82d1f9bc0bff516cf16d453e731f749b2e6c3ca9f2cb96bf9607e724a0978bfe198b0ffa4fe293bf49767d4e7!
 de4ebfd43ed5f3207ed0fc4ccd1ffd3b57ec92cb8877a6eb876423f8857e8ec924cce7b8c4359b82f3b2ce738c696af3b507bed60142bf71de2edaa8fce682798941307f3de62b26d178b20ffe45dfb0f2b30cd10af8bbd0fd72ac29a81dfc7771143d1f7dd4fc6ccc09fdd7fea62c11f9f01df6171f747e45f52ef6b5bda807f42e4a68f66df04b0660563ec612fbac98a057494cd0f351403fa58be0efd61207176cc35abf1acd04d4f35871aa58eda2fc4931580ffdd1f948bd4f1eebf7c09f1004fa68916f08cd1e9bddb57ab816df0af8a07c0d93cf09f97f407e7e065fe40af3eb2bc5353fd50f1f8389e897209e371e7cda6af15352bd22ad57f03e259d17be403f6bb9c1871fd037ef279d5f567d49a3b701eba10fd17b87793a6ef98e19fc79a5b8da23f800fe8877cd5fe387eca5f92b5f829966f08db4ff699ae680f93f83ff3478f41ff32355e0d10fc5719c6a0715eb3c85e2b2c3fa3bccdf641ce647edd1b83c819fb82fcc6446e887de3fd1bb2a80eaaffa95baa9f3e0d757b5d7ebc343afa0d79d0b03d6ebbc8b75cea37ee8ff746f67d54799c6ecd03f9d87d04f9270bfe8bc87610c13eaf316faeccc00fe1ee0fcae1fc007e55b2a63a5acdad7d19f2ac0c85ff91aede85b3cbfc4cbea45f46355ed53dd0ffaa07c9630dcd757fb53e6b1b3d037d53f378d!
 5d443f946f7118eb878e62ad8fc421363ee9fd18dd602cea013deb86be87fe!
 0af46170
06fdc37d350e83c17eba5e64b00efecaafec6c825db4fec5d6f1017f36509fa1eb510fe58f94a177e89ff26faa84b3d08f0df0cf84b61ef5169b7accab07bfede0d01fad570ed6c02ed7b86f2ac6f9353f6b8d057f44f5ca75a61f70ffa9befacec808bc89fcccd4eb7cc916f4d14c1df47b15fa6e5287fe35fdb5a643fec7e05ffd3c01bf0cf8626d87fb017a3ed9bed3fd08765f31ecf8dea9e7013e583c7e98583872aabf32179e1f7bf0773ee4233ee61f7cc2a7159ff1395fc0832ff9aafebfe605dff04ffec5bff9b6e23b5ee5979ae51aaff3066ff216bfe26ddee1d7fc8677abc71eeff35bdcebfc8edff307fec89ff8337fe1affc8dbbead1b3613069e0911d4fec3910139150a49a29652ad4be75e9908ee8987ed0497d7f4a6774becc8d2ee892aed4e39a1674433fe917fda65bbaa3557a593dd7689d36681367a12d7a45dbb443afe90dedd2deb21ab44f6fe980de358ff7f4813ed227fa4c5fe82b7dab6f3aeac990e5745f311a68244713790a7c79b01096ca6a89078bbf6b2af523a37e46cdf2bdfe3e942339961f72f20f8f53399373b9a8bf2ee54aae652137cbf78ffb223fe597fc965bb9935579296b74fdd4a3faaccb866cca96bc926dd9c1bb271eafe58decca9eec2f33681efffbf7b3ff03e2d71717&lt;/data&gt;
     &lt;/pixmap&gt;
      &lt;signal&gt; animateNeeded() &lt;/signal&gt;
-     &lt;signal&gt; axisIsDrawnChanged(bool) &lt;/signal&gt;
-     &lt;signal&gt; cameraIsEditedChanged(bool) &lt;/signal&gt;
-     &lt;signal&gt; drawFinished(bool) &lt;/signal&gt;
+     &lt;signal&gt; axisIsDrawnChanged(bool drawn) &lt;/signal&gt;
+     &lt;signal&gt; cameraIsEditedChanged(bool edited) &lt;/signal&gt;
+     &lt;signal&gt; drawFinished(bool automatic) &lt;/signal&gt;
      &lt;signal&gt; drawNeeded() &lt;/signal&gt;
-     &lt;signal&gt; FPSIsDisplayedChanged(bool) &lt;/signal&gt;
-     &lt;signal&gt; gridIsDrawnChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; FPSIsDisplayedChanged(bool displayed) &lt;/signal&gt;
+     &lt;signal&gt; gridIsDrawnChanged(bool drawn) &lt;/signal&gt;
      &lt;signal&gt; helpRequired() &lt;/signal&gt;
      &lt;signal&gt; mouseGrabberChanged(qglviewer::MouseGrabber *mouseGrabber) &lt;/signal&gt;
      &lt;signal&gt; pointSelected(QMouseEvent *e) &lt;/signal&gt;
-     &lt;signal&gt; stereoChanged(bool) &lt;/signal&gt;
-     &lt;signal&gt; textIsEnabledChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; stereoChanged(bool on) &lt;/signal&gt;
+     &lt;signal&gt; textIsEnabledChanged(bool enabled) &lt;/signal&gt;
      &lt;signal&gt; viewerInitialized() &lt;/signal&gt;
      &lt;slot access=&quot;public&quot;&gt; aboutQGLViewer() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; animate() &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; copyBufferToTexture(GLint, GLenum format) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; copyBufferToTexture(GLint internalFormat, GLenum format) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; help() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; initFromDOMElement(QDomElement &amp;element) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; openSnapshotFormatDialog() &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; resize(int, int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; resize(int width, int height) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; restoreStateFromFile() &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(bool, bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(QString, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(bool automatic, bool overwrite) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(QString &amp;fileName, bool overwrite) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; saveStateToFile() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; select(QMouseEvent *event) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; select(QPoint) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; select(QPoint &amp;point) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setAnimationPeriod(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setAxisIsDrawn(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setAnimationPeriod(int period) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setAxisIsDrawn(bool draw) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setBackgroundColor(QColor &amp;color) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setCameraIsEdited(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setCameraIsEdited(bool edit) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setCamera(qglviewer::Camera *camera) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setForegroundColor(QColor &amp;color) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setFPSIsDisplayed(bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setFullScreen(bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setGridIsDrawn(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setFPSIsDisplayed(bool display) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setFullScreen(bool fullScreen) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setGridIsDrawn(bool draw) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setKeyDescription(int, QString) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setKeyDescription(int key, QString description) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setManipulatedFrame(qglviewer::ManipulatedFrame *frame) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setMouseBindingDescription(int, QString, bool, QtMouseButtons buttonsBefore) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int, ClickAction action, bool, QtMouseButtons buttonsBefore) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int, MouseHandler handler, MouseAction action, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBindingDescription(int state, QString description, bool doubleClick, QtMouseButtons buttonsBefore) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int state, ClickAction action, bool doubleClick, QtMouseButtons buttonsBefore) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setMouseGrabber(qglviewer::MouseGrabber *mouseGrabber) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setMouseTracking(bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setPathKey(int, int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseTracking(bool enable) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setPathKey(int key, int index) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setSceneBoundingBox(qglviewer::Vec &amp;min, qglviewer::Vec &amp;max) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; setSceneCenter(qglviewer::Vec &amp;center) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSceneRadius(float) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSelectBufferSize(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSelectedName(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSelectRegionHeight(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSelectRegionWidth(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setShortcut(KeyboardAction action, int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSnapshotCounter(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSnapshotFileName(QString) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSnapshotFormat(QString) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setSnapshotQuality(int) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setStateFileName(QString) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setStereoDisplay(bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setTextIsEnabled(bool) &lt;/slot&gt;
-     &lt;slot access=&quot;public&quot;&gt; setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSceneRadius(float radius) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectBufferSize(int size) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectedName(int id) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectRegionHeight(int height) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectRegionWidth(int width) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setShortcut(KeyboardAction action, int key) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotCounter(int counter) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotFileName(QString &amp;name) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotFormat(QString &amp;format) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotQuality(int quality) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setStateFileName(QString &amp;name) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setStereoDisplay(bool stereo) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setTextIsEnabled(bool enable) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint) &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; showEntireScene() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; startAnimation() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; stopAnimation() &lt;/slot&gt;
@@ -90,6 +90,6 @@
      &lt;slot access=&quot;public&quot;&gt; toggleStereoDisplay() &lt;/slot&gt;
      &lt;slot access=&quot;public&quot;&gt; toggleTextIsEnabled() &lt;/slot&gt;
      &lt;slot access=&quot;protected&quot;&gt; setAutoBufferSwap(bool on) &lt;/slot&gt;
-  &lt;/customwidget&gt;
+-e   &lt;/customwidget&gt;
 &lt;/customwidgets&gt;
 &lt;/CW&gt;

Modified: trunk/lib/QGLViewer/qglviewer.h
===================================================================
--- trunk/lib/QGLViewer/qglviewer.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/qglviewer.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -37,11 +37,11 @@
 class QTabWidget;
 
 namespace qglviewer {
-  class MouseGrabber;
+	class MouseGrabber;
 }
 
 #if QT_VERSION &gt;= 0x040000
-  // Qt::ButtonState was split into Qt::KeyboardModifiers and Qt::MouseButtons in Qt 4.
+// Qt::ButtonState was split into Qt::KeyboardModifiers and Qt::MouseButtons in Qt 4.
 # define QtKeyboardModifiers Qt::KeyboardModifiers
 # define QtMouseButtons Qt::MouseButtons
 #else
@@ -50,1186 +50,1187 @@
 #endif
 
 /*! \brief A versatile 3D OpenGL viewer based on QGLWidget.
- \class QGLViewer qglviewer.h QGLViewer/qglviewer.h
+\class QGLViewer qglviewer.h QGLViewer/qglviewer.h
 
- It features many classical viewer functionalities, such as a camera trackball, manipulated objects,
- snapshot saving and much &lt;a href=&quot;../features.html&quot;&gt;more&lt;/a&gt;. Its main goal is to ease the development
+It features many classical viewer functionalities, such as a camera trackball, manipulated objects,
+snapshot saving and much &lt;a href=&quot;../features.html&quot;&gt;more&lt;/a&gt;. Its main goal is to ease the development
 of new 3D applications.
 
- New users should read the &lt;a href=&quot;../introduction.html&quot;&gt;introduction page&lt;/a&gt; to get familiar with
- important notions such as sceneRadius(), sceneCenter() and the world coordinate system. Try the
- numerous simple &lt;a href=&quot;../examples/index.html&quot;&gt;examples&lt;/a&gt; to discover the possibilities and
- understand how it works.
+New users should read the &lt;a href=&quot;../introduction.html&quot;&gt;introduction page&lt;/a&gt; to get familiar with
+important notions such as sceneRadius(), sceneCenter() and the world coordinate system. Try the
+numerous simple &lt;a href=&quot;../examples/index.html&quot;&gt;examples&lt;/a&gt; to discover the possibilities and
+understand how it works.
 
- &lt;h3&gt;Usage&lt;/h3&gt;
+&lt;h3&gt;Usage&lt;/h3&gt;
 
- To use a QGLViewer, derive you viewer class from the QGLViewer and overload its draw() virtual
- method. See the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
+To use a QGLViewer, derive you viewer class from the QGLViewer and overload its draw() virtual
+method. See the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
 
- An other option is to connect your drawing methods to the signals emitted by the QGLViewer (Qt's
- callback mechanism). See the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for a
- complete implementation.
+An other option is to connect your drawing methods to the signals emitted by the QGLViewer (Qt's
+callback mechanism). See the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for a
+complete implementation.
 
- \nosubgrouping */
+\nosubgrouping */
 class QGLVIEWER_EXPORT QGLViewer : public QGLWidget
 {
-  Q_OBJECT
+	Q_OBJECT
 
 public:
-  // Complete implementation is provided so that the constructor is defined with QT3_SUPPORT when .h is included.
-  // (Would not be available otherwise since lib is compiled without QT3_SUPPORT).
+	// Complete implementation is provided so that the constructor is defined with QT3_SUPPORT when .h is included.
+	// (Would not be available otherwise since lib is compiled without QT3_SUPPORT).
 #if QT_VERSION &lt; 0x040000 || defined QT3_SUPPORT
-  explicit QGLViewer(QWidget* parent=NULL, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
-  : QGLWidget(parent, name, shareWidget, flags)
-  { defaultConstructor(); }
+	explicit QGLViewer(QWidget* parent=NULL, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
+		: QGLWidget(parent, name, shareWidget, flags)
+	{ defaultConstructor(); }
 
-  explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const char* name=0, const QGLWidget* shareWidget=0,Qt::WFlags flags=0)
-  : QGLWidget(format, parent, name, shareWidget, flags)
-  { defaultConstructor(); }
+	explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const char* name=0, const QGLWidget* shareWidget=0,Qt::WFlags flags=0)
+		: QGLWidget(format, parent, name, shareWidget, flags)
+	{ defaultConstructor(); }
 
-  QGLViewer(QGLContext* context, QWidget* parent, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
+	QGLViewer(QGLContext* context, QWidget* parent, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
 # if QT_VERSION &gt;= 0x030200
-  : QGLWidget(context, parent, name, shareWidget, flags) {
+		: QGLWidget(context, parent, name, shareWidget, flags) {
 # else
-// MOC_SKIP_BEGIN
-  : QGLWidget(parent, name, shareWidget, flags) {
-    Q_UNUSED(context);
-// MOC_SKIP_END
+		// MOC_SKIP_BEGIN
+		: QGLWidget(parent, name, shareWidget, flags) {
+			Q_UNUSED(context);
+			// MOC_SKIP_END
 # endif
-  defaultConstructor(); }
+			defaultConstructor(); }
 #endif
 
 #if QT_VERSION &gt;= 0x040000
-  explicit QGLViewer(QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
-  explicit QGLViewer(QGLContext *context, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
-  explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+	explicit QGLViewer(QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+	explicit QGLViewer(QGLContext *context, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+	explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
 #endif
 
-  virtual ~QGLViewer();
+	virtual ~QGLViewer();
 
-  /*! @name Display of visual hints */
-  //@{
+	/*! @name Display of visual hints */
+	//@{
 public:
-  /*! Returns \c true if the world axis is drawn by the viewer.
+	/*! Returns \c true if the world axis is drawn by the viewer.
 
-  Set by setAxisIsDrawn() or toggleAxisIsDrawn(). Default value is \c false. */
-  bool axisIsDrawn() const { return axisIsDrawn_; };
-  /*! Returns \c true if a XY grid is drawn by the viewer.
+	Set by setAxisIsDrawn() or toggleAxisIsDrawn(). Default value is \c false. */
+	bool axisIsDrawn() const { return axisIsDrawn_; };
+	/*! Returns \c true if a XY grid is drawn by the viewer.
 
-  Set by setGridIsDrawn() or toggleGridIsDrawn(). Default value is \c false. */
-  bool gridIsDrawn() const { return gridIsDrawn_; };
-  /*! Returns \c true if the viewer displays the current frame rate (Frames Per Second).
+	Set by setGridIsDrawn() or toggleGridIsDrawn(). Default value is \c false. */
+	bool gridIsDrawn() const { return gridIsDrawn_; };
+	/*! Returns \c true if the viewer displays the current frame rate (Frames Per Second).
 
-  Use QApplication::setFont() to define the display font (see drawText()).
+	Use QApplication::setFont() to define the display font (see drawText()).
 
-  Set by setFPSIsDisplayed() or toggleFPSIsDisplayed(). Use currentFPS() to get the current FPS.
-  Default value is \c false. */
-  bool FPSIsDisplayed() const { return FPSIsDisplayed_; };
-  /*! Returns \c true if text display (see drawText()) is enabled.
+	Set by setFPSIsDisplayed() or toggleFPSIsDisplayed(). Use currentFPS() to get the current FPS.
+	Default value is \c false. */
+	bool FPSIsDisplayed() const { return FPSIsDisplayed_; };
+	/*! Returns \c true if text display (see drawText()) is enabled.
 
-  Set by setTextIsEnabled() or toggleTextIsEnabled(). This feature conveniently removes all the
-  possibly displayed text, cleaning display. Default value is \c true. */
-  bool textIsEnabled() const { return textIsEnabled_; };
+	Set by setTextIsEnabled() or toggleTextIsEnabled(). This feature conveniently removes all the
+	possibly displayed text, cleaning display. Default value is \c true. */
+	bool textIsEnabled() const { return textIsEnabled_; };
 
-  /*! Returns \c true if the camera() is being edited in the viewer.
+	/*! Returns \c true if the camera() is being edited in the viewer.
 
-  Set by setCameraIsEdited() or toggleCameraIsEdited(). Default value is \p false.
+	Set by setCameraIsEdited() or toggleCameraIsEdited(). Default value is \p false.
 
-  The current implementation is limited: the defined camera() paths (see
-  qglviewer::Camera::keyFrameInterpolator()) are simply displayed using
-  qglviewer::Camera::drawAllPaths(). Actual camera and path edition will be implemented in the
-  future. */
-  bool cameraIsEdited() const { return cameraIsEdited_; }
+	The current implementation is limited: the defined camera() paths (see
+	qglviewer::Camera::keyFrameInterpolator()) are simply displayed using
+	qglviewer::Camera::drawAllPaths(). Actual camera and path edition will be implemented in the
+	future. */
+	bool cameraIsEdited() const { return cameraIsEdited_; }
 
 
-public slots:
-  /*! Sets the state of axisIsDrawn(). Emits the axisIsDrawnChanged() signal. See also toggleAxisIsDrawn(). */
-  void setAxisIsDrawn(bool draw=true) { axisIsDrawn_ = draw; emit axisIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
-  /*! Sets the state of gridIsDrawn(). Emits the gridIsDrawnChanged() signal. See also toggleGridIsDrawn(). */
-  void setGridIsDrawn(bool draw=true) { gridIsDrawn_ = draw; emit gridIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
-  /*! Sets the state of FPSIsDisplayed(). Emits the FPSIsDisplayedChanged() signal. See also toggleFPSIsDisplayed(). */
-  void setFPSIsDisplayed(bool display=true) { FPSIsDisplayed_ = display; emit FPSIsDisplayedChanged(display); if (updateGLOK_) updateGL(); };
-  /*! Sets the state of textIsEnabled(). Emits the textIsEnabledChanged() signal. See also toggleTextIsEnabled(). */
-  void setTextIsEnabled(bool enable=true) { textIsEnabled_ = enable; emit textIsEnabledChanged(enable); if (updateGLOK_) updateGL(); };
-  void setCameraIsEdited(bool edit=true);
+	public slots:
+		/*! Sets the state of axisIsDrawn(). Emits the axisIsDrawnChanged() signal. See also toggleAxisIsDrawn(). */
+		void setAxisIsDrawn(bool draw=true) { axisIsDrawn_ = draw; emit axisIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
+		/*! Sets the state of gridIsDrawn(). Emits the gridIsDrawnChanged() signal. See also toggleGridIsDrawn(). */
+		void setGridIsDrawn(bool draw=true) { gridIsDrawn_ = draw; emit gridIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
+		/*! Sets the state of FPSIsDisplayed(). Emits the FPSIsDisplayedChanged() signal. See also toggleFPSIsDisplayed(). */
+		void setFPSIsDisplayed(bool display=true) { FPSIsDisplayed_ = display; emit FPSIsDisplayedChanged(display); if (updateGLOK_) updateGL(); };
+		/*! Sets the state of textIsEnabled(). Emits the textIsEnabledChanged() signal. See also toggleTextIsEnabled(). */
+		void setTextIsEnabled(bool enable=true) { textIsEnabled_ = enable; emit textIsEnabledChanged(enable); if (updateGLOK_) updateGL(); };
+		void setCameraIsEdited(bool edit=true);
 
-  /*! Toggles the state of axisIsDrawn(). See also setAxisIsDrawn(). */
-  void toggleAxisIsDrawn() { setAxisIsDrawn(!axisIsDrawn()); };
-  /*! Toggles the state of gridIsDrawn(). See also setGridIsDrawn(). */
-  void toggleGridIsDrawn() { setGridIsDrawn(!gridIsDrawn()); };
-  /*! Toggles the state of FPSIsDisplayed(). See also setFPSIsDisplayed(). */
-  void toggleFPSIsDisplayed() { setFPSIsDisplayed(!FPSIsDisplayed()); };
-  /*! Toggles the state of textIsEnabled(). See also setTextIsEnabled(). */
-  void toggleTextIsEnabled() { setTextIsEnabled(!textIsEnabled()); };
-  /*! Toggles the state of cameraIsEdited(). See also setCameraIsEdited(). */
-  void toggleCameraIsEdited() { setCameraIsEdited(!cameraIsEdited()); };
-  //@}
+		/*! Toggles the state of axisIsDrawn(). See also setAxisIsDrawn(). */
+		void toggleAxisIsDrawn() { setAxisIsDrawn(!axisIsDrawn()); };
+		/*! Toggles the state of gridIsDrawn(). See also setGridIsDrawn(). */
+		void toggleGridIsDrawn() { setGridIsDrawn(!gridIsDrawn()); };
+		/*! Toggles the state of FPSIsDisplayed(). See also setFPSIsDisplayed(). */
+		void toggleFPSIsDisplayed() { setFPSIsDisplayed(!FPSIsDisplayed()); };
+		/*! Toggles the state of textIsEnabled(). See also setTextIsEnabled(). */
+		void toggleTextIsEnabled() { setTextIsEnabled(!textIsEnabled()); };
+		/*! Toggles the state of cameraIsEdited(). See also setCameraIsEdited(). */
+		void toggleCameraIsEdited() { setCameraIsEdited(!cameraIsEdited()); };
+		//@}
 
 
-  /*! @name Viewer's colors */
-  //@{
+		/*! @name Viewer's colors */
+		//@{
 public:
-  /*! Returns the background color of the viewer.
+	/*! Returns the background color of the viewer.
 
-  This method is provided for convenience since the background color is an OpenGL state variable
-  set with \c glClearColor(). However, this internal representation has the advantage that it is
-  saved (resp. restored) with saveStateToFile() (resp. restoreStateFromFile()).
+	This method is provided for convenience since the background color is an OpenGL state variable
+	set with \c glClearColor(). However, this internal representation has the advantage that it is
+	saved (resp. restored) with saveStateToFile() (resp. restoreStateFromFile()).
 
-  Use setBackgroundColor() to define and activate a background color.
+	Use setBackgroundColor() to define and activate a background color.
 
-  \attention Each QColor component is an integer ranging from 0 to 255. This differs from the float
-  values used by \c glClearColor() which are in the 0.0-1.0 range. Default value is (51, 51, 51)
-  (dark gray). You may have to change foregroundColor() accordingly.
+	\attention Each QColor component is an integer ranging from 0 to 255. This differs from the float
+	values used by \c glClearColor() which are in the 0.0-1.0 range. Default value is (51, 51, 51)
+	(dark gray). You may have to change foregroundColor() accordingly.
 
-  \attention This method does not return the current OpenGL clear color as \c glGet() does. Instead,
-  it returns the QGLViewer internal variable. If you directly use \c glClearColor() or \c
-  qglClearColor() instead of setBackgroundColor(), the two results will differ. */
-  QColor backgroundColor() const { return backgroundColor_; };
+	\attention This method does not return the current OpenGL clear color as \c glGet() does. Instead,
+	it returns the QGLViewer internal variable. If you directly use \c glClearColor() or \c
+	qglClearColor() instead of setBackgroundColor(), the two results will differ. */
+	QColor backgroundColor() const { return backgroundColor_; };
 
-  /*! Returns the foreground color used by the viewer.
+	/*! Returns the foreground color used by the viewer.
 
-  This color is used when FPSIsDisplayed(), gridIsDrawn(), to display the camera paths when the
-  cameraIsEdited().
+	This color is used when FPSIsDisplayed(), gridIsDrawn(), to display the camera paths when the
+	cameraIsEdited().
 
-  \attention Each QColor component is an integer in the range 0-255. This differs from the float
-  values used by \c glColor3f() which are in the range 0-1. Default value is (180, 180, 180) (light
-  gray).
+	\attention Each QColor component is an integer in the range 0-255. This differs from the float
+	values used by \c glColor3f() which are in the range 0-1. Default value is (180, 180, 180) (light
+	gray).
 
-  Use \c qglColor(foregroundColor()) to set the current OpenGL color to the foregroundColor().
+	Use \c qglColor(foregroundColor()) to set the current OpenGL color to the foregroundColor().
 
-  See also backgroundColor(). */
-  QColor foregroundColor() const { return foregroundColor_; };
-public slots:
-/*! Sets the backgroundColor() of the viewer and calls \c qglClearColor(). See also
-  setForegroundColor(). */
-  void setBackgroundColor(const QColor&amp; color) { backgroundColor_=color; qglClearColor(color); };
-  /*! Sets the foregroundColor() of the viewer, used to draw visual hints. See also setBackgroundColor(). */
-  void setForegroundColor(const QColor&amp; color) { foregroundColor_ = color; };
-  //@}
+	See also backgroundColor(). */
+	QColor foregroundColor() const { return foregroundColor_; };
+	public slots:
+		/*! Sets the backgroundColor() of the viewer and calls \c qglClearColor(). See also
+		setForegroundColor(). */
+		void setBackgroundColor(const QColor&amp; color) { backgroundColor_=color; qglClearColor(color); };
+		/*! Sets the foregroundColor() of the viewer, used to draw visual hints. See also setBackgroundColor(). */
+		void setForegroundColor(const QColor&amp; color) { foregroundColor_ = color; };
+		//@}
 
 
-  /*! @name Scene dimensions */
-  //@{
+		/*! @name Scene dimensions */
+		//@{
 public:
-  /*! Returns the scene radius.
+	/*! Returns the scene radius.
 
-  The entire displayed scene should be included in a sphere of radius sceneRadius(), centered on
-  sceneCenter().
+	The entire displayed scene should be included in a sphere of radius sceneRadius(), centered on
+	sceneCenter().
 
-  This approximate value is used by the camera() to set qglviewer::Camera::zNear() and
-  qglviewer::Camera::zFar(). It is also used to showEntireScene() or to scale the world axis
-  display..
+	This approximate value is used by the camera() to set qglviewer::Camera::zNear() and
+	qglviewer::Camera::zFar(). It is also used to showEntireScene() or to scale the world axis
+	display..
 
-  Default value is 1.0. This method is equivalent to camera()-&gt;sceneRadius(). See
-  setSceneRadius(). */
-  float sceneRadius() const { return camera()-&gt;sceneRadius(); }
-  /*! Returns the scene center, defined in world coordinates.
+	Default value is 1.0. This method is equivalent to camera()-&gt;sceneRadius(). See
+	setSceneRadius(). */
+	float sceneRadius() const { return camera()-&gt;sceneRadius(); }
+	/*! Returns the scene center, defined in world coordinates.
 
-  See sceneRadius() for details.
+	See sceneRadius() for details.
 
-  Default value is (0,0,0). Simply a wrapper for camera()-&gt;sceneCenter(). Set using
-  setSceneCenter().
+	Default value is (0,0,0). Simply a wrapper for camera()-&gt;sceneCenter(). Set using
+	setSceneCenter().
 
-  Do not mismatch this value (that only depends on the scene) with the qglviewer::Camera::revolveAroundPoint(). */
-  qglviewer::Vec sceneCenter() const { return camera()-&gt;sceneCenter(); }
+	Do not mismatch this value (that only depends on the scene) with the qglviewer::Camera::revolveAroundPoint(). */
+	qglviewer::Vec sceneCenter() const { return camera()-&gt;sceneCenter(); }
 
-public slots:
-  /*! Sets the sceneRadius().
+	public slots:
+		/*! Sets the sceneRadius().
 
-  The camera() qglviewer::Camera::flySpeed() is set to 1% of this value by this method. Simple
-  wrapper around camera()-&gt;setSceneRadius(). */
-  virtual void setSceneRadius(float radius) { camera()-&gt;setSceneRadius(radius); }
+		The camera() qglviewer::Camera::flySpeed() is set to 1% of this value by this method. Simple
+		wrapper around camera()-&gt;setSceneRadius(). */
+		virtual void setSceneRadius(float radius) { camera()-&gt;setSceneRadius(radius); }
 
-  /*! Sets the sceneCenter(), defined in world coordinates.
+		/*! Sets the sceneCenter(), defined in world coordinates.
 
-  \attention The qglviewer::Camera::revolveAroundPoint() is set to the sceneCenter() value by this
-  method. */
-  virtual void setSceneCenter(const qglviewer::Vec&amp; center) { camera()-&gt;setSceneCenter(center); }
+		\attention The qglviewer::Camera::revolveAroundPoint() is set to the sceneCenter() value by this
+		method. */
+		virtual void setSceneCenter(const qglviewer::Vec&amp; center) { camera()-&gt;setSceneCenter(center); }
 
-  /*! Convenient way to call setSceneCenter() and setSceneRadius() from a (world axis aligned) bounding box of the scene.
+		/*! Convenient way to call setSceneCenter() and setSceneRadius() from a (world axis aligned) bounding box of the scene.
 
-  This is equivalent to:
-  \code
-  setSceneCenter((m+M)/2.0);
-  setSceneRadius(0.5*(M-m).norm());
-  \endcode */
-  void setSceneBoundingBox(const qglviewer::Vec&amp; min, const qglviewer::Vec&amp; max) { camera()-&gt;setSceneBoundingBox(min,max); }
+		This is equivalent to:
+		\code
+		setSceneCenter((m+M)/2.0);
+		setSceneRadius(0.5*(M-m).norm());
+		\endcode */
+		void setSceneBoundingBox(const qglviewer::Vec&amp; min, const qglviewer::Vec&amp; max) { camera()-&gt;setSceneBoundingBox(min,max); }
 
-  /*! Moves the camera so that the entire scene is visible.
+		/*! Moves the camera so that the entire scene is visible.
 
-  Simple wrapper around qglviewer::Camera::showEntireScene(). */
-  void showEntireScene() { camera()-&gt;showEntireScene(); if (updateGLOK_) updateGL(); }
-  //@}
+		Simple wrapper around qglviewer::Camera::showEntireScene(). */
+		void showEntireScene() { camera()-&gt;showEntireScene(); if (updateGLOK_) updateGL(); }
+		//@}
 
 
-  /*! @name Associated objects */
-  //@{
+		/*! @name Associated objects */
+		//@{
 public:
-  /*! Returns the associated qglviewer::Camera, never \c NULL. */
-  qglviewer::Camera* camera() const { return camera_; };
+	/*! Returns the associated qglviewer::Camera, never \c NULL. */
+	qglviewer::Camera* camera() const { return camera_; };
 
-  /*! Returns the viewer's qglviewer::ManipulatedFrame.
+	/*! Returns the viewer's qglviewer::ManipulatedFrame.
 
-  This qglviewer::ManipulatedFrame can be moved with the mouse when the associated mouse bindings
-  are used (default is when pressing the \c Control key with any mouse button). Use
-  setMouseBinding() to define new bindings.
+	This qglviewer::ManipulatedFrame can be moved with the mouse when the associated mouse bindings
+	are used (default is when pressing the \c Control key with any mouse button). Use
+	setMouseBinding() to define new bindings.
 
-  See the &lt;a href=&quot;../examples/manipulatedFrame.html&quot;&gt;manipulatedFrame example&lt;/a&gt; for a complete
-  implementation.
+	See the &lt;a href=&quot;../examples/manipulatedFrame.html&quot;&gt;manipulatedFrame example&lt;/a&gt; for a complete
+	implementation.
 
-  Default value is \c NULL, meaning that no qglviewer::ManipulatedFrame is set. */
-  qglviewer::ManipulatedFrame* manipulatedFrame() const { return manipulatedFrame_; };
+	Default value is \c NULL, meaning that no qglviewer::ManipulatedFrame is set. */
+	qglviewer::ManipulatedFrame* manipulatedFrame() const { return manipulatedFrame_; };
 
-public slots:
-  void setCamera(qglviewer::Camera* const camera);
-  void setManipulatedFrame(qglviewer::ManipulatedFrame* frame);
-  //@}
+	public slots:
+		void setCamera(qglviewer::Camera* const camera);
+		void setManipulatedFrame(qglviewer::ManipulatedFrame* frame);
+		//@}
 
 
-  /*! @name Mouse grabbers */
-  //@{
+		/*! @name Mouse grabbers */
+		//@{
 public:
-  /*! Returns the current qglviewer::MouseGrabber, or \c NULL if no qglviewer::MouseGrabber
-  currently grabs mouse events.
+	/*! Returns the current qglviewer::MouseGrabber, or \c NULL if no qglviewer::MouseGrabber
+	currently grabs mouse events.
 
-  When qglviewer::MouseGrabber::grabsMouse(), the different mouse events are sent to the
-  mouseGrabber() instead of their usual targets (camera() or manipulatedFrame()).
+	When qglviewer::MouseGrabber::grabsMouse(), the different mouse events are sent to the
+	mouseGrabber() instead of their usual targets (camera() or manipulatedFrame()).
 
-  See the qglviewer::MouseGrabber documentation for details on MouseGrabber's mode of operation.
+	See the qglviewer::MouseGrabber documentation for details on MouseGrabber's mode of operation.
 
-  In order to use MouseGrabbers, you need to enable mouse tracking (so that mouseMoveEvent() is
-  called even when no mouse button is pressed). Add this line in init() or in your viewer
-  constructor:
-  \code
-  setMouseTracking(true);
-  \endcode
-  Note that mouse tracking is disabled by default. Use QWidget::hasMouseTracking() to
-  retrieve current state. */
-  qglviewer::MouseGrabber* mouseGrabber() const { return mouseGrabber_; };
+	In order to use MouseGrabbers, you need to enable mouse tracking (so that mouseMoveEvent() is
+	called even when no mouse button is pressed). Add this line in init() or in your viewer
+	constructor:
+	\code
+	setMouseTracking(true);
+	\endcode
+	Note that mouse tracking is disabled by default. Use QWidget::hasMouseTracking() to
+	retrieve current state. */
+	qglviewer::MouseGrabber* mouseGrabber() const { return mouseGrabber_; };
 
-  void setMouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber, bool enabled=true);
-  /*! Returns \c true if \p mouseGrabber is enabled.
+	void setMouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber, bool enabled=true);
+	/*! Returns \c true if \p mouseGrabber is enabled.
 
-  Default value is \c true for all MouseGrabbers. When set to \c false using
-  setMouseGrabberIsEnabled(), the specified \p mouseGrabber will never become the mouseGrabber() of
-  this QGLViewer. This is useful when you use several viewers: some MouseGrabbers may only have a
-  meaning for some specific viewers and should not be selectable in others.
+	Default value is \c true for all MouseGrabbers. When set to \c false using
+	setMouseGrabberIsEnabled(), the specified \p mouseGrabber will never become the mouseGrabber() of
+	this QGLViewer. This is useful when you use several viewers: some MouseGrabbers may only have a
+	meaning for some specific viewers and should not be selectable in others.
 
-  You can also use qglviewer::MouseGrabber::removeFromMouseGrabberPool() to completely disable a
-  MouseGrabber in all the QGLViewers. */
-  bool mouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber) { return !disabledMouseGrabbers_.contains(reinterpret_cast&lt;size_t&gt;(mouseGrabber)); };
-public slots:
-  void setMouseGrabber(qglviewer::MouseGrabber* mouseGrabber);
-  //@}
+	You can also use qglviewer::MouseGrabber::removeFromMouseGrabberPool() to completely disable a
+	MouseGrabber in all the QGLViewers. */
+	bool mouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber) { return !disabledMouseGrabbers_.contains(reinterpret_cast&lt;size_t&gt;(mouseGrabber)); };
+	public slots:
+		void setMouseGrabber(qglviewer::MouseGrabber* mouseGrabber);
+		//@}
 
 
-  /*! @name State of the viewer */
-  //@{
+		/*! @name State of the viewer */
+		//@{
 public:
-  /*! Returns the aspect ratio of the viewer's widget (width() / height()). */
-  float aspectRatio() const { return static_cast&lt;float&gt;(width())/static_cast&lt;float&gt;(height()); };
-  /*! Returns the current averaged viewer frame rate.
+	/*! Returns the aspect ratio of the viewer's widget (width() / height()). */
+	float aspectRatio() const { return static_cast&lt;float&gt;(width())/static_cast&lt;float&gt;(height()); };
+	/*! Returns the current averaged viewer frame rate.
 
-  This value is computed and averaged over 20 successive frames. It only changes every 20 draw()
-  (previously computed value is otherwise returned).
+	This value is computed and averaged over 20 successive frames. It only changes every 20 draw()
+	(previously computed value is otherwise returned).
 
-  This method is useful for true real-time applications that may adapt their computational load
-  accordingly in order to maintain a given frequency.
+	This method is useful for true real-time applications that may adapt their computational load
+	accordingly in order to maintain a given frequency.
 
-  This value is meaningful only when draw() is regularly called, either using a \c QTimer, when
-  animationIsStarted() or when the camera is manipulated with the mouse.  */
-  float currentFPS() { return f_p_s_; };
-  /*! Returns \c true if the viewer is in fullScreen mode.
+	This value is meaningful only when draw() is regularly called, either using a \c QTimer, when
+	animationIsStarted() or when the camera is manipulated with the mouse.  */
+	float currentFPS() { return f_p_s_; };
+	/*! Returns \c true if the viewer is in fullScreen mode.
 
-  Default value is \c false. Set by setFullScreen() or toggleFullScreen().
+	Default value is \c false. Set by setFullScreen() or toggleFullScreen().
 
-  Note that if the QGLViewer is embedded in an other QWidget, it returns \c true when the top level
-  widget is in full screen mode. */
-  bool isFullScreen() const { return fullScreen_; };
-  /*! Returns \c true if the viewer displays in stereo.
+	Note that if the QGLViewer is embedded in an other QWidget, it returns \c true when the top level
+	widget is in full screen mode. */
+	bool isFullScreen() const { return fullScreen_; };
+	/*! Returns \c true if the viewer displays in stereo.
 
-  The QGLViewer object must be created with a stereo format to handle stereovision:
-  \code
-  QGLFormat format;
-  format.setStereoDisplay( TRUE );
-  QGLViewer viewer(format);
-  \endcode
-  The hardware needs to support stereo display. Try the &lt;a
-  href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt; to check.
+	The QGLViewer object must be created with a stereo format to handle stereovision:
+	\code
+	QGLFormat format;
+	format.setStereoDisplay( TRUE );
+	QGLViewer viewer(format);
+	\endcode
+	The hardware needs to support stereo display. Try the &lt;a
+	href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt; to check.
 
-  Set by setStereoDisplay() or toggleStereoDisplay(). Default value is \c false.
+	Set by setStereoDisplay() or toggleStereoDisplay(). Default value is \c false.
 
-  Stereo is performed using the Parallel axis asymmetric frustum perspective projection method.
-  See Camera::loadProjectionMatrixStereo() and Camera::loadModelViewMatrixStereo().
+	Stereo is performed using the Parallel axis asymmetric frustum perspective projection method.
+	See Camera::loadProjectionMatrixStereo() and Camera::loadModelViewMatrixStereo().
 
-  The stereo parameters are defined by the camera(). See qglviewer::Camera::setIODistance(),
-  qglviewer::Camera::setPhysicalDistanceToScreen(),
-  qglviewer::Camera::setPhysicalScreenWidth() and
-  qglviewer::Camera::setFocusDistance(). */
-  bool displaysInStereo() const { return stereo_; }
-  /*! Returns the recommended size for the QGLViewer. Default value is 600x400 pixels. */
-  virtual QSize sizeHint() const { return QSize(600, 400); }
+	The stereo parameters are defined by the camera(). See qglviewer::Camera::setIODistance(),
+	qglviewer::Camera::setPhysicalDistanceToScreen(),
+	qglviewer::Camera::setPhysicalScreenWidth() and
+	qglviewer::Camera::setFocusDistance(). */
+	bool displaysInStereo() const { return stereo_; }
+	/*! Returns the recommended size for the QGLViewer. Default value is 600x400 pixels. */
+	virtual QSize sizeHint() const { return QSize(600, 400); }
 
-public slots:
-  void setFullScreen(bool fullScreen=true);
-  void setStereoDisplay(bool stereo=true);
-  /*! Toggles the state of isFullScreen(). See also setFullScreen(). */
-  void toggleFullScreen() { setFullScreen(!isFullScreen()); };
-  /*! Toggles the state of displaysInStereo(). See setStereoDisplay(). */
-  void toggleStereoDisplay() { setStereoDisplay(!stereo_); };
-  void toggleCameraMode();
+	public slots:
+		void setFullScreen(bool fullScreen=true);
+		void setStereoDisplay(bool stereo=true);
+		/*! Toggles the state of isFullScreen(). See also setFullScreen(). */
+		void toggleFullScreen() { setFullScreen(!isFullScreen()); };
+		/*! Toggles the state of displaysInStereo(). See setStereoDisplay(). */
+		void toggleStereoDisplay() { setStereoDisplay(!stereo_); };
+		void toggleCameraMode();
 
 private:
-  bool cameraIsInRevolveMode() const;
-  //@}
+	bool cameraIsInRevolveMode() const;
+	//@}
 
 
-  /*! @name Display methods */
-  //@{
+	/*! @name Display methods */
+	//@{
 public:
-  static void drawArrow(float length=1.0f, float radius=-1.0f, int nbSubdivisions=12);
-  static void drawArrow(const qglviewer::Vec&amp; from, const qglviewer::Vec&amp; to, float radius=-1.0f, int nbSubdivisions=12);
-  static void drawAxis(float length=1.0f);
-  static void drawGrid(float size=1.0f, int nbSubdivisions=10);
+	static void drawArrow(float length=1.0f, float radius=-1.0f, int nbSubdivisions=12);
+	static void drawArrow(const qglviewer::Vec&amp; from, const qglviewer::Vec&amp; to, float radius=-1.0f, int nbSubdivisions=12);
+	static void drawAxis(float length=1.0f);
+	static void drawGrid(float size=1.0f, int nbSubdivisions=10);
 
-  virtual void startScreenCoordinatesSystem(bool upward=false) const;
-  virtual void stopScreenCoordinatesSystem() const;
+	virtual void startScreenCoordinatesSystem(bool upward=false) const;
+	virtual void stopScreenCoordinatesSystem() const;
 
-  void drawText(int x, int y, const QString&amp; text, const QFont&amp; fnt=QFont());
-  void displayMessage(const QString&amp; message, int delay=2000);
-  // void draw3DText(const qglviewer::Vec&amp; pos, const qglviewer::Vec&amp; normal, const QString&amp; string, GLfloat height=0.1f);
+	void drawText(int x, int y, const QString&amp; text, const QFont&amp; fnt=QFont());
+	void displayMessage(const QString&amp; message, int delay=2000);
+	// void draw3DText(const qglviewer::Vec&amp; pos, const qglviewer::Vec&amp; normal, const QString&amp; string, GLfloat height=0.1f);
 
 protected:
-  virtual void drawLight(GLenum light, float scale = 1.0f) const;
+	virtual void drawLight(GLenum light, float scale = 1.0f) const;
 
 private:
-  void displayFPS();
-  /*! Vectorial rendering callback method. */
-  void drawVectorial() { paintGL(); };
+	void displayFPS();
+	/*! Vectorial rendering callback method. */
+	void drawVectorial() { paintGL(); };
 
 #ifndef DOXYGEN
-  friend void drawVectorial(void* param);
+	friend void drawVectorial(void* param);
 #endif
-  //@}
+	//@}
 
 
 #ifdef DOXYGEN
-  /*! @name Useful inherited methods */
-  //@{
+	/*! @name Useful inherited methods */
+	//@{
 public:
-  /*! Returns viewer's widget width (in pixels). See QGLWidget documentation. */
-  int width() const;
-  /*! Returns viewer's widget height (in pixels). See QGLWidget documentation. */
-  int height() const;
-  /*! Updates the display. Do not call draw() directly, use this method instead. See QGLWidget documentation. */
-  virtual void updateGL();
-  /*! Converts \p image into the unnamed format expected by OpenGL methods such as glTexImage2D().
-    See QGLWidget documentation. */
-  static QImage convertToGLFormat(const QImage &amp; image);
-  /*! Calls \c glColor3. See QGLWidget::qglColor(). */
-  void qglColor(const QColor&amp; color) const;
-  /*! Calls \c glClearColor. See QGLWidget documentation. */
-  void qglClearColor(const QColor&amp; color) const;
-  /*! Returns \c true if the widget has a valid GL rendering context. See QGLWidget
-    documentation. */
-  bool isValid() const;
-  /*! Returns \c true if display list sharing with another QGLWidget was requested in the
-    constructor. See QGLWidget documentation. */
-  bool isSharing() const;
-  /*! Makes this widget's rendering context the current OpenGL rendering context. Useful with
-    several viewers. See QGLWidget documentation. */
-  virtual void makeCurrent();
-  /*! Returns \c true if mouseMoveEvent() is called even when no mouse button is pressed.
+	/*! Returns viewer's widget width (in pixels). See QGLWidget documentation. */
+	int width() const;
+	/*! Returns viewer's widget height (in pixels). See QGLWidget documentation. */
+	int height() const;
+	/*! Updates the display. Do not call draw() directly, use this method instead. See QGLWidget documentation. */
+	virtual void updateGL();
+	/*! Converts \p image into the unnamed format expected by OpenGL methods such as glTexImage2D().
+	See QGLWidget documentation. */
+	static QImage convertToGLFormat(const QImage &amp; image);
+	/*! Calls \c glColor3. See QGLWidget::qglColor(). */
+	void qglColor(const QColor&amp; color) const;
+	/*! Calls \c glClearColor. See QGLWidget documentation. */
+	void qglClearColor(const QColor&amp; color) const;
+	/*! Returns \c true if the widget has a valid GL rendering context. See QGLWidget
+	documentation. */
+	bool isValid() const;
+	/*! Returns \c true if display list sharing with another QGLWidget was requested in the
+	constructor. See QGLWidget documentation. */
+	bool isSharing() const;
+	/*! Makes this widget's rendering context the current OpenGL rendering context. Useful with
+	several viewers. See QGLWidget documentation. */
+	virtual void makeCurrent();
+	/*! Returns \c true if mouseMoveEvent() is called even when no mouse button is pressed.
 
-  You need to setMouseTracking() to \c true in order to use MouseGrabber (see mouseGrabber()). See
-  details in the QWidget documentation. */
-  bool hasMouseTracking () const;
-public slots:
-  /*! Resizes the widget to size \p width by \p height pixels. See also width() and height(). */
-  virtual void resize(int width, int height);
-  /*! Sets the hasMouseTracking() value. */
-  virtual void setMouseTracking(bool enable);
+	You need to setMouseTracking() to \c true in order to use MouseGrabber (see mouseGrabber()). See
+	details in the QWidget documentation. */
+	bool hasMouseTracking () const;
+	public slots:
+		/*! Resizes the widget to size \p width by \p height pixels. See also width() and height(). */
+		virtual void resize(int width, int height);
+		/*! Sets the hasMouseTracking() value. */
+		virtual void setMouseTracking(bool enable);
 protected:
-  /*! Returns \c true when buffers are automatically swapped (default). See details in the QGLWidget
-  documentation. */
-  bool autoBufferSwap() const;
-protected slots:
-  /*! Sets the autoBufferSwap() value. */
-  void setAutoBufferSwap(bool on);
-  //@}
+	/*! Returns \c true when buffers are automatically swapped (default). See details in the QGLWidget
+	documentation. */
+	bool autoBufferSwap() const;
+	protected slots:
+		/*! Sets the autoBufferSwap() value. */
+		void setAutoBufferSwap(bool on);
+		//@}
 #endif
 
 
-  /*! @name Snapshots */
-  //@{
+		/*! @name Snapshots */
+		//@{
 public:
 #if QT_VERSION &lt; 0x030000
-  virtual QImage grabFrameBuffer(bool withAlpha=false);
+	virtual QImage grabFrameBuffer(bool withAlpha=false);
 #endif
-  /*! Returns the snapshot file name used by saveSnapshot().
+	/*! Returns the snapshot file name used by saveSnapshot().
 
-  This value is used in \p automatic mode (see saveSnapshot()). A dialog is otherwise popped-up to
-  set it.
+	This value is used in \p automatic mode (see saveSnapshot()). A dialog is otherwise popped-up to
+	set it.
 
-  You can also directly provide a file name using saveSnapshot(const QString&amp;, bool).
+	You can also directly provide a file name using saveSnapshot(const QString&amp;, bool).
 
-  If the file name is relative, the current working directory at the moment of the method call is
-  used. Set using setSnapshotFileName(). */
-  const QString&amp; snapshotFileName() const { return snapshotFileName_; };
+	If the file name is relative, the current working directory at the moment of the method call is
+	used. Set using setSnapshotFileName(). */
+	const QString&amp; snapshotFileName() const { return snapshotFileName_; };
 #ifndef DOXYGEN
-  const QString&amp; snapshotFilename() const;
+	const QString&amp; snapshotFilename() const;
 #endif
-  /*! Returns the snapshot file format used by saveSnapshot().
+	/*! Returns the snapshot file format used by saveSnapshot().
 
-  This value is used when saveSnapshot() is passed the \p automatic flag. It is defined using a
-  saveAs pop-up dialog otherwise.
+	This value is used when saveSnapshot() is passed the \p automatic flag. It is defined using a
+	saveAs pop-up dialog otherwise.
 
-  The available formats are those handled by Qt. Classical values are \c &quot;JPEG&quot;, \c &quot;PNG&quot;,
-  \c &quot;PPM, \c &quot;BMP&quot;. Use the following code to get the actual list:
-  \code
-  QList&lt;QByteArray&gt; formatList = QImageReader::supportedImageFormats();
-  // or with Qt version 2 or 3:
-  QStringList formatList = QImage::outputFormatList();
-  \endcode
+	The available formats are those handled by Qt. Classical values are \c &quot;JPEG&quot;, \c &quot;PNG&quot;,
+	\c &quot;PPM, \c &quot;BMP&quot;. Use the following code to get the actual list:
+	\code
+	QList&lt;QByteArray&gt; formatList = QImageReader::supportedImageFormats();
+	// or with Qt version 2 or 3:
+	QStringList formatList = QImage::outputFormatList();
+	\endcode
 
-  If the library was compiled with the vectorial rendering option (default), three additional
-  vectorial formats are available: \c &quot;EPS&quot;, \c &quot;PS&quot; and \c &quot;XFIG&quot;. \c &quot;SVG&quot; and \c &quot;PDF&quot; formats
-  should soon be available. The &lt;a href=&quot;<A HREF="http://artis.imag.fr/Software/VRender">http://artis.imag.fr/Software/VRender</A>&quot;&gt;VRender library&lt;/a&gt;
-  was created by Cyril Soler.
+	If the library was compiled with the vectorial rendering option (default), three additional
+	vectorial formats are available: \c &quot;EPS&quot;, \c &quot;PS&quot; and \c &quot;XFIG&quot;. \c &quot;SVG&quot; and \c &quot;PDF&quot; formats
+	should soon be available. The &lt;a href=&quot;<A HREF="http://artis.imag.fr/Software/VRender">http://artis.imag.fr/Software/VRender</A>&quot;&gt;VRender library&lt;/a&gt;
+	was created by Cyril Soler.
 
-  Note that the VRender library has some limitations: vertex shader effects are not reproduced and
-  \c PASS_THROUGH tokens are not handled so one can not change point and line size in the middle of
-  a drawing.
+	Note that the VRender library has some limitations: vertex shader effects are not reproduced and
+	\c PASS_THROUGH tokens are not handled so one can not change point and line size in the middle of
+	a drawing.
 
-  Default value is the first supported among &quot;JPEG, PNG, EPS, PS, PPM, BMP&quot;, in that order.
+	Default value is the first supported among &quot;JPEG, PNG, EPS, PS, PPM, BMP&quot;, in that order.
 
-  This value is set using setSnapshotFormat() or with openSnapshotFormatDialog().
+	This value is set using setSnapshotFormat() or with openSnapshotFormatDialog().
 
-  \attention No verification is performed on the provided format validity. The next call to
-  saveSnapshot() may fail if the format string is not supported. */
-  const QString&amp; snapshotFormat() const { return snapshotFormat_; };
-  /*! Returns the value of the counter used to name snapshots in saveSnapshot() when \p automatic is
-    \c true.
+	\attention No verification is performed on the provided format validity. The next call to
+	saveSnapshot() may fail if the format string is not supported. */
+	const QString&amp; snapshotFormat() const { return snapshotFormat_; };
+	/*! Returns the value of the counter used to name snapshots in saveSnapshot() when \p automatic is
+	\c true.
 
-  Set using setSnapshotCounter(). Default value is 0, and it is incremented after each \p automatic
-  snapshot. See saveSnapshot() for details. */
-  int snapshotCounter() const { return snapshotCounter_; };
-  /*! Defines the image quality of the snapshots produced with saveSnapshot().
+	Set using setSnapshotCounter(). Default value is 0, and it is incremented after each \p automatic
+	snapshot. See saveSnapshot() for details. */
+	int snapshotCounter() const { return snapshotCounter_; };
+	/*! Defines the image quality of the snapshots produced with saveSnapshot().
 
-  Values must be in the range -1..100. Use 0 for lowest quality and 100 for highest quality (and
-  larger files). -1 means use Qt default quality. Default value is 95.
+	Values must be in the range -1..100. Use 0 for lowest quality and 100 for highest quality (and
+	larger files). -1 means use Qt default quality. Default value is 95.
 
-  Set using setSnapshotQuality(). See also the QImage::save() documentation.
+	Set using setSnapshotQuality(). See also the QImage::save() documentation.
 
-  \note This value has no impact on the images produced in vectorial format. */
-  int snapshotQuality() { return snapshotQuality_; };
+	\note This value has no impact on the images produced in vectorial format. */
+	int snapshotQuality() { return snapshotQuality_; };
 
-  // Qt 2.3 does not support double default value parameters in slots.
-  // Remove &quot;slots&quot; from the following line to compile with Qt 2.3
-public slots:
-  void saveSnapshot(bool automatic=true, bool overwrite=false);
+	// Qt 2.3 does not support double default value parameters in slots.
+	// Remove &quot;slots&quot; from the following line to compile with Qt 2.3
+	public slots:
+		void saveSnapshot(bool automatic=true, bool overwrite=false);
 
-public slots:
-  void saveSnapshot(const QString&amp; fileName, bool overwrite=false);
-  void setSnapshotFileName(const QString&amp; name);
+		public slots:
+			void saveSnapshot(const QString&amp; fileName, bool overwrite=false);
+			void setSnapshotFileName(const QString&amp; name);
 
-  /*! Sets the snapshotFormat(). */
-  void setSnapshotFormat(const QString&amp; format) { snapshotFormat_ = format; };
-  /*! Sets the snapshotCounter(). */
-  void setSnapshotCounter(int counter) { snapshotCounter_ = counter; };
-  /*! Sets the snapshotQuality(). */
-  void setSnapshotQuality(int quality) { snapshotQuality_ = quality; };
-  bool openSnapshotFormatDialog();
+			/*! Sets the snapshotFormat(). */
+			void setSnapshotFormat(const QString&amp; format) { snapshotFormat_ = format; };
+			/*! Sets the snapshotCounter(). */
+			void setSnapshotCounter(int counter) { snapshotCounter_ = counter; };
+			/*! Sets the snapshotQuality(). */
+			void setSnapshotQuality(int quality) { snapshotQuality_ = quality; };
+			bool openSnapshotFormatDialog();
 
 private:
-  bool saveImageSnapshot(const QString&amp; fileName);
-  //@}
+	bool saveImageSnapshot(const QString&amp; fileName);
+	//@}
 
 
-  /*! @name Buffer to texture */
-  //@{
+	/*! @name Buffer to texture */
+	//@{
 public:
-  GLuint bufferTextureId() const;
-  /*! Returns the texture coordinate corresponding to the u extremum of the bufferTexture.
+	GLuint bufferTextureId() const;
+	/*! Returns the texture coordinate corresponding to the u extremum of the bufferTexture.
 
-  The bufferTexture is created by copyBufferToTexture(). The texture size has powers of two
-  dimensions and the buffer image hence only fills a part of it. This value corresponds to the u
-  coordinate of the extremum right side of the buffer image.
+	The bufferTexture is created by copyBufferToTexture(). The texture size has powers of two
+	dimensions and the buffer image hence only fills a part of it. This value corresponds to the u
+	coordinate of the extremum right side of the buffer image.
 
-  Use (0,0) to (bufferTextureMaxU(), bufferTextureMaxV()) texture coordinates to map the entire
-  texture on a quad. */
-  float bufferTextureMaxU() const { return bufferTextureMaxU_; };
-  /*! Same as bufferTextureMaxU(), but for the v texture coordinate. */
-  float bufferTextureMaxV() const { return bufferTextureMaxV_; };
-public slots:
-  void copyBufferToTexture(GLint internalFormat, GLenum format=GL_NONE);
-  //@}
+	Use (0,0) to (bufferTextureMaxU(), bufferTextureMaxV()) texture coordinates to map the entire
+	texture on a quad. */
+	float bufferTextureMaxU() const { return bufferTextureMaxU_; };
+	/*! Same as bufferTextureMaxU(), but for the v texture coordinate. */
+	float bufferTextureMaxV() const { return bufferTextureMaxV_; };
+	public slots:
+		void copyBufferToTexture(GLint internalFormat, GLenum format=GL_NONE);
+		//@}
 
-  /*! @name Animation */
-  //@{
+		/*! @name Animation */
+		//@{
 public:
-  /*! Return \c true when the animation loop is started.
+	/*! Return \c true when the animation loop is started.
 
-  During animation, an infinite loop calls animate() and draw() and then waits for animationPeriod()
-  milliseconds before calling animate() and draw() again. And again.
+	During animation, an infinite loop calls animate() and draw() and then waits for animationPeriod()
+	milliseconds before calling animate() and draw() again. And again.
 
-  Use startAnimation(), stopAnimation() or toggleAnimation() to change this value.
+	Use startAnimation(), stopAnimation() or toggleAnimation() to change this value.
 
-  See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for illustration. */
-  bool animationIsStarted() const { return animationStarted_; };
-  /*! The animation loop period, in milliseconds.
+	See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for illustration. */
+	bool animationIsStarted() const { return animationStarted_; };
+	/*! The animation loop period, in milliseconds.
 
-  When animationIsStarted(), this is delay waited after draw() to call animate() and draw() again.
-  Default value is 40 milliseconds (25 Hz).
+	When animationIsStarted(), this is delay waited after draw() to call animate() and draw() again.
+	Default value is 40 milliseconds (25 Hz).
 
-  This value will define the currentFPS() when animationIsStarted() (provided that your animate()
-  and draw() methods are fast enough).
+	This value will define the currentFPS() when animationIsStarted() (provided that your animate()
+	and draw() methods are fast enough).
 
-  If you want to know the maximum possible frame rate of your machine on a given scene,
-  setAnimationPeriod() to \c 0, and startAnimation() (keyboard shortcut is \c Enter). The display
-  will then be updated as often as possible, and the frame rate will be meaningful.
+	If you want to know the maximum possible frame rate of your machine on a given scene,
+	setAnimationPeriod() to \c 0, and startAnimation() (keyboard shortcut is \c Enter). The display
+	will then be updated as often as possible, and the frame rate will be meaningful.
 
-  \note This value is taken into account only the next time you call startAnimation(). If
-  animationIsStarted(), you should stopAnimation() first. */
-  int animationPeriod() const { return animationPeriod_; };
+	\note This value is taken into account only the next time you call startAnimation(). If
+	animationIsStarted(), you should stopAnimation() first. */
+	int animationPeriod() const { return animationPeriod_; };
 
-public slots:
-  /*! Sets the animationPeriod(), in milliseconds. */
-  void setAnimationPeriod(int period) { animationPeriod_ = period; };
-  virtual void startAnimation();
-  virtual void stopAnimation();
-  /*! Scene animation method.
+	public slots:
+		/*! Sets the animationPeriod(), in milliseconds. */
+		void setAnimationPeriod(int period) { animationPeriod_ = period; };
+		virtual void startAnimation();
+		virtual void stopAnimation();
+		/*! Scene animation method.
 
-  When animationIsStarted(), this method is in charge of the scene update before each draw().
-  Overload it to define how your scene evolves over time. The time should either be regularly
-  incremented in this method (frame-rate independent animation) or computed from actual time (for
-  instance using QTime::elapsed()) for real-time animations.
+		When animationIsStarted(), this method is in charge of the scene update before each draw().
+		Overload it to define how your scene evolves over time. The time should either be regularly
+		incremented in this method (frame-rate independent animation) or computed from actual time (for
+		instance using QTime::elapsed()) for real-time animations.
 
-  Note that KeyFrameInterpolator (which regularly updates a Frame) do not use this method but rather
-  rely on a QTimer signal-slot mechanism.
+		Note that KeyFrameInterpolator (which regularly updates a Frame) do not use this method but rather
+		rely on a QTimer signal-slot mechanism.
 
-  See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for an illustration. */
-  virtual void animate() { emit animateNeeded(); };
-  /*! Calls startAnimation() or stopAnimation(), depending on animationIsStarted(). */
-  void toggleAnimation() { if (animationIsStarted()) stopAnimation(); else startAnimation(); };
-  //@}
+		See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for an illustration. */
+		virtual void animate() { emit animateNeeded(); };
+		/*! Calls startAnimation() or stopAnimation(), depending on animationIsStarted(). */
+		void toggleAnimation() { if (animationIsStarted()) stopAnimation(); else startAnimation(); };
+		//@}
 
 public:
-  signals:
-  /*! Signal emitted by the default init() method.
+signals:
+	/*! Signal emitted by the default init() method.
 
-  Connect this signal to the methods that need to be called to initialize your viewer or overload init(). */
-  void viewerInitialized();
+	Connect this signal to the methods that need to be called to initialize your viewer or overload init(). */
+	void viewerInitialized();
 
-  /*! Signal emitted by the default draw() method.
+	/*! Signal emitted by the default draw() method.
 
-  Connect this signal to your main drawing method or overload draw(). See the &lt;a
-  href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for an illustration. */
-  void drawNeeded();
+	Connect this signal to your main drawing method or overload draw(). See the &lt;a
+	href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for an illustration. */
+	void drawNeeded();
 
-  /*! Signal emitted at the end of the QGLViewer::paintGL() method, when frame is drawn.
+	/*! Signal emitted at the end of the QGLViewer::paintGL() method, when frame is drawn.
 
-  Can be used to notify an image grabbing process that the image is ready. A typical example is to
-  connect this signal to the saveSnapshot() method, so that a (numbered) snapshot is generated after
-  each new display, in order to create a movie:
-  \code
-  connect(viewer, SIGNAL(drawFinished(bool)), SLOT(saveSnapshot(bool)));
-  \endcode
+	Can be used to notify an image grabbing process that the image is ready. A typical example is to
+	connect this signal to the saveSnapshot() method, so that a (numbered) snapshot is generated after
+	each new display, in order to create a movie:
+	\code
+	connect(viewer, SIGNAL(drawFinished(bool)), SLOT(saveSnapshot(bool)));
+	\endcode
 
-  The \p automatic bool variable is always \c true and has been added so that the signal can be
-  connected to saveSnapshot() with an \c automatic value set to \c true. */
-  void drawFinished(bool automatic);
+	The \p automatic bool variable is always \c true and has been added so that the signal can be
+	connected to saveSnapshot() with an \c automatic value set to \c true. */
+	void drawFinished(bool automatic);
 
-  /*! Signal emitted by the default animate() method.
+	/*! Signal emitted by the default animate() method.
 
-  Connect this signal to your scene animation method or overload animate(). */
-  void animateNeeded();
+	Connect this signal to your scene animation method or overload animate(). */
+	void animateNeeded();
 
-  /*! Signal emitted by the default QGLViewer::help() method.
+	/*! Signal emitted by the default QGLViewer::help() method.
 
-  Connect this signal to your own help method or overload help(). */
-  void helpRequired();
+	Connect this signal to your own help method or overload help(). */
+	void helpRequired();
 
-  /*! This signal is emitted whenever axisIsDrawn() changes value. */
-  void axisIsDrawnChanged(bool drawn);
-  /*! This signal is emitted whenever gridIsDrawn() changes value. */
-  void gridIsDrawnChanged(bool drawn);
-  /*! This signal is emitted whenever FPSIsDisplayed() changes value. */
-  void FPSIsDisplayedChanged(bool displayed);
-  /*! This signal is emitted whenever textIsEnabled() changes value. */
-  void textIsEnabledChanged(bool enabled);
-  /*! This signal is emitted whenever cameraIsEdited() changes value.. */
-  void cameraIsEditedChanged(bool edited);
-  /*! This signal is emitted whenever displaysInStereo() changes value. */
-  void stereoChanged(bool on);
-  /*! Signal emitted by select().
+	/*! This signal is emitted whenever axisIsDrawn() changes value. */
+	void axisIsDrawnChanged(bool drawn);
+	/*! This signal is emitted whenever gridIsDrawn() changes value. */
+	void gridIsDrawnChanged(bool drawn);
+	/*! This signal is emitted whenever FPSIsDisplayed() changes value. */
+	void FPSIsDisplayedChanged(bool displayed);
+	/*! This signal is emitted whenever textIsEnabled() changes value. */
+	void textIsEnabledChanged(bool enabled);
+	/*! This signal is emitted whenever cameraIsEdited() changes value.. */
+	void cameraIsEditedChanged(bool edited);
+	/*! This signal is emitted whenever displaysInStereo() changes value. */
+	void stereoChanged(bool on);
+	/*! Signal emitted by select().
 
-  Connect this signal to your selection method or overload select(), or more probably simply
-  drawWithNames(). */
-  void pointSelected(const QMouseEvent* e);
+	Connect this signal to your selection method or overload select(), or more probably simply
+	drawWithNames(). */
+	void pointSelected(const QMouseEvent* e);
 
-  /*! Signal emitted by setMouseGrabber() when the mouseGrabber() is changed.
+	/*! Signal emitted by setMouseGrabber() when the mouseGrabber() is changed.
 
-  \p mouseGrabber is a pointer to the new MouseGrabber. Note that this signal is emitted with a \c
-  NULL parameter each time a MouseGrabber stops grabbing mouse. */
-  void mouseGrabberChanged(qglviewer::MouseGrabber* mouseGrabber);
+	\p mouseGrabber is a pointer to the new MouseGrabber. Note that this signal is emitted with a \c
+	NULL parameter each time a MouseGrabber stops grabbing mouse. */
+	void mouseGrabberChanged(qglviewer::MouseGrabber* mouseGrabber);
 
-  /*! @name Help window */
-  //@{
+	/*! @name Help window */
+	//@{
 public:
-  /*! Returns the QString displayed in the help() window main tab.
+	/*! Returns the QString displayed in the help() window main tab.
 
-  Overload this method to define your own help string, which should shortly describe your
-  application and explain how it works. Rich-text (HTML) tags can be used (see QStyleSheet()
-  documentation for available tags):
-  \code
-  QString myViewer::helpString() const
-  {
-  QString text(&quot;&lt;h2&gt;M y V i e w e r&lt;/h2&gt;&quot;);
-  text += &quot;Displays a &lt;b&gt;Scene&lt;/b&gt; using OpenGL. Move the camera using the mouse.&quot;;
-  return text;
-  }
-  \endcode
+	Overload this method to define your own help string, which should shortly describe your
+	application and explain how it works. Rich-text (HTML) tags can be used (see QStyleSheet()
+	documentation for available tags):
+	\code
+	QString myViewer::helpString() const
+	{
+	QString text(&quot;&lt;h2&gt;M y V i e w e r&lt;/h2&gt;&quot;);
+	text += &quot;Displays a &lt;b&gt;Scene&lt;/b&gt; using OpenGL. Move the camera using the mouse.&quot;;
+	return text;
+	}
+	\endcode
 
-  See also mouseString() and keyboardString(). */
-  virtual QString helpString() const { return QString(&quot;No help available.&quot;); };
+	See also mouseString() and keyboardString(). */
+	virtual QString helpString() const { return tr(&quot;No help available.&quot;); };
 
-  virtual QString mouseString() const;
-  virtual QString keyboardString() const;
+	virtual QString mouseString() const;
+	virtual QString keyboardString() const;
 
 #ifndef DOXYGEN
-  /*! This method is deprecated, use mouseString() instead. */
-  virtual QString mouseBindingsString () const { return mouseString(); }
-  /*! This method is deprecated, use keyboardString() instead. */
-  virtual QString shortcutBindingsString () const { return keyboardString(); }
+	/*! This method is deprecated, use mouseString() instead. */
+	virtual QString mouseBindingsString () const { return mouseString(); }
+	/*! This method is deprecated, use keyboardString() instead. */
+	virtual QString shortcutBindingsString () const { return keyboardString(); }
 #endif
 
-public slots:
-  virtual void help();
-  virtual void aboutQGLViewer();
+	public slots:
+		virtual void help();
+		virtual void aboutQGLViewer();
 
 protected:
-  /*! Returns a pointer to the help widget.
+	/*! Returns a pointer to the help widget.
 
-  Use this only if you want to directly modify the help widget. Otherwise use helpString(),
-  setKeyDescription() and setMouseBindingDescription() to customize the text displayed in the help
-  window tabs. */
-  QTabWidget* helpWidget() { return helpWidget_; }
-  //@}
+	Use this only if you want to directly modify the help widget. Otherwise use helpString(),
+	setKeyDescription() and setMouseBindingDescription() to customize the text displayed in the help
+	window tabs. */
+	QTabWidget* helpWidget() { return helpWidget_; }
+	//@}
 
 
-  /*! @name Drawing methods */
-  //@{
+	/*! @name Drawing methods */
+	//@{
 protected:
-  virtual void resizeGL(int width, int height);
-  virtual void initializeGL();
+	virtual void resizeGL(int width, int height);
+	virtual void initializeGL();
 
-  /*! Initializes the viewer OpenGL context.
+	/*! Initializes the viewer OpenGL context.
 
-  This method is called before the first drawing and should be overloaded to initialize some of the
-  OpenGL flags. The default implementation is empty. See initializeGL().
+	This method is called before the first drawing and should be overloaded to initialize some of the
+	OpenGL flags. The default implementation is empty. See initializeGL().
 
-  Typical usage include camera() initialization (showEntireScene()), previous viewer state
-  restoration (restoreStateFromFile()), OpenGL state modification and display list creation.
+	Typical usage include camera() initialization (showEntireScene()), previous viewer state
+	restoration (restoreStateFromFile()), OpenGL state modification and display list creation.
 
-  Note that initializeGL() modifies the standard OpenGL context. These values can be restored back
-  in this method.
+	Note that initializeGL() modifies the standard OpenGL context. These values can be restored back
+	in this method.
 
-  \attention You should not call updateGL() (or any method that calls it) in this method, as it will
-  result in an infinite loop. The different QGLViewer set methods (setAxisIsDrawn(),
-  setFPSIsDisplayed()...) are protected against this problem and can safely be called.
+	\attention You should not call updateGL() (or any method that calls it) in this method, as it will
+	result in an infinite loop. The different QGLViewer set methods (setAxisIsDrawn(),
+	setFPSIsDisplayed()...) are protected against this problem and can safely be called.
 
-  \note All the OpenGL specific initializations must be done in this method: the OpenGL context is
-  not yet available in your viewer constructor. */
-  virtual void init() { emit viewerInitialized(); };
+	\note All the OpenGL specific initializations must be done in this method: the OpenGL context is
+	not yet available in your viewer constructor. */
+	virtual void init() { emit viewerInitialized(); };
 
-  virtual void paintGL();
-  virtual void preDraw();
-  virtual void preDrawStereo(bool leftBuffer=true);
+	virtual void paintGL();
+	virtual void preDraw();
+	virtual void preDrawStereo(bool leftBuffer=true);
 
-  /*! The core method of the viewer, that draws the scene.
+	/*! The core method of the viewer, that draws the scene.
 
-  If you build a class that inherits from QGLViewer, this is the method you want to overload. See
-  the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
+	If you build a class that inherits from QGLViewer, this is the method you want to overload. See
+	the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
 
-  The camera modelView matrix set in preDraw() converts from the world to the camera coordinate
-  systems. Vertices given in draw() can then be considered as being given in the world coordinate
-  system. The camera is moved in this world using the mouse. This representation is much more
-  intuitive than the default camera-centric OpenGL standard.
+	The camera modelView matrix set in preDraw() converts from the world to the camera coordinate
+	systems. Vertices given in draw() can then be considered as being given in the world coordinate
+	system. The camera is moved in this world using the mouse. This representation is much more
+	intuitive than the default camera-centric OpenGL standard.
 
-  \attention The \c GL_PROJECTION matrix should not be modified by this method, to correctly display
-  visual hints (axis, grid, FPS...) in postDraw(). Use push/pop or call
-  camera()-&gt;loadProjectionMatrix() at the end of draw() if you need to change the projection matrix
-  (unlikely). On the other hand, the \c GL_MODELVIEW matrix can be modified and left in a arbitrary
-  state. */
-  virtual void draw() {};
-  virtual void fastDraw();
-  virtual void postDraw();
-  //@}
+	\attention The \c GL_PROJECTION matrix should not be modified by this method, to correctly display
+	visual hints (axis, grid, FPS...) in postDraw(). Use push/pop or call
+	camera()-&gt;loadProjectionMatrix() at the end of draw() if you need to change the projection matrix
+	(unlikely). On the other hand, the \c GL_MODELVIEW matrix can be modified and left in a arbitrary
+	state. */
+	virtual void draw() {};
+	virtual void fastDraw();
+	virtual void postDraw();
+	//@}
 
-  /*! @name Mouse, keyboard and event handlers */
-  //@{
+	/*! @name Mouse, keyboard and event handlers */
+	//@{
 protected:
-  virtual void mousePressEvent(QMouseEvent *);
-  virtual void mouseMoveEvent(QMouseEvent *);
-  virtual void mouseReleaseEvent(QMouseEvent *);
-  virtual void mouseDoubleClickEvent(QMouseEvent *);
-  virtual void wheelEvent(QWheelEvent *);
-  virtual void keyPressEvent(QKeyEvent *);
-  virtual void timerEvent(QTimerEvent *);
-  virtual void closeEvent(QCloseEvent *);
-  //@}
+	virtual void mousePressEvent(QMouseEvent *);
+	virtual void mouseMoveEvent(QMouseEvent *);
+	virtual void mouseReleaseEvent(QMouseEvent *);
+	virtual void mouseDoubleClickEvent(QMouseEvent *);
+	virtual void wheelEvent(QWheelEvent *);
+	virtual void keyPressEvent(QKeyEvent *);
+	virtual void timerEvent(QTimerEvent *);
+	virtual void closeEvent(QCloseEvent *);
+	//@}
 
-  /*! @name Object selection */
-  //@{
+	/*! @name Object selection */
+	//@{
 public:
-  /*! Returns the name (an integer value) of the entity that was last selected by select(). This
-    value is set by endSelection(). See the select() documentation for details.
+	/*! Returns the name (an integer value) of the entity that was last selected by select(). This
+	value is set by endSelection(). See the select() documentation for details.
 
-    As a convention, this method returns -1 if the selectBuffer() was empty, meaning that no object
-    was selected.
+	As a convention, this method returns -1 if the selectBuffer() was empty, meaning that no object
+	was selected.
 
-    Return value is -1 before the first call to select(). This value is modified using setSelectedName(). */
-  int selectedName() const { return selectedObjectId_; };
-  /*! Returns the selectBuffer() size.
+	Return value is -1 before the first call to select(). This value is modified using setSelectedName(). */
+	int selectedName() const { return selectedObjectId_; };
+	/*! Returns the selectBuffer() size.
 
-  See the select() documentation for details. Use setSelectBufferSize() to change this value.
+	See the select() documentation for details. Use setSelectBufferSize() to change this value.
 
-  Default value is 4000 (i.e. 1000 objects in selection region, since each object pushes 4 values).
-  This size should be over estimated to prevent a buffer overflow when many objects are drawn under
-  the mouse cursor. */
-  int selectBufferSize() const { return selectBufferSize_; };
+	Default value is 4000 (i.e. 1000 objects in selection region, since each object pushes 4 values).
+	This size should be over estimated to prevent a buffer overflow when many objects are drawn under
+	the mouse cursor. */
+	int selectBufferSize() const { return selectBufferSize_; };
 
-  /*! Returns the width (in pixels) of a selection frustum, centered on the mouse cursor, that is
-    used to select objects.
+	/*! Returns the width (in pixels) of a selection frustum, centered on the mouse cursor, that is
+	used to select objects.
 
-    The height of the selection frustum is defined by selectRegionHeight().
+	The height of the selection frustum is defined by selectRegionHeight().
 
-    The objects that will be drawn in this region by drawWithNames() will be recorded in the
-    selectBuffer(). endSelection() then analyzes this buffer and setSelectedName() to the name of the
-    closest object. See the gluPickMatrix() documentation for details.
+	The objects that will be drawn in this region by drawWithNames() will be recorded in the
+	selectBuffer(). endSelection() then analyzes this buffer and setSelectedName() to the name of the
+	closest object. See the gluPickMatrix() documentation for details.
 
-    The default value is 3, which is adapted to standard applications. A smaller value results in a
-    more precise selection but the user has to be careful for small feature selection.
+	The default value is 3, which is adapted to standard applications. A smaller value results in a
+	more precise selection but the user has to be careful for small feature selection.
 
-    See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for an illustration. */
-  int selectRegionWidth() const { return selectRegionWidth_; };
-  /*! See the selectRegionWidth() documentation. Default value is 3 pixels. */
-  int selectRegionHeight() const { return selectRegionHeight_; };
+	See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for an illustration. */
+	int selectRegionWidth() const { return selectRegionWidth_; };
+	/*! See the selectRegionWidth() documentation. Default value is 3 pixels. */
+	int selectRegionHeight() const { return selectRegionHeight_; };
 
-  /*! Returns a pointer to an array of \c GLuint.
+	/*! Returns a pointer to an array of \c GLuint.
 
-  This buffer is used by the \c GL_SELECT mode in select() to perform object selection. The buffer
-  size can be modified using setSelectBufferSize(). If you overload endSelection(), you will analyze
-  the content of this buffer. See the \c glSelectBuffer() man page for details. */
-  GLuint* selectBuffer() { return selectBuffer_; };
+	This buffer is used by the \c GL_SELECT mode in select() to perform object selection. The buffer
+	size can be modified using setSelectBufferSize(). If you overload endSelection(), you will analyze
+	the content of this buffer. See the \c glSelectBuffer() man page for details. */
+	GLuint* selectBuffer() { return selectBuffer_; };
 
-public slots:
-  virtual void select(const QMouseEvent* event);
-  virtual void select(const QPoint&amp; point);
+	public slots:
+		virtual void select(const QMouseEvent* event);
+		virtual void select(const QPoint&amp; point);
 
-  void setSelectBufferSize(int size);
-  /*! Sets the selectRegionWidth(). */
-  void setSelectRegionWidth(int width) { selectRegionWidth_ = width; };
-  /*! Sets the selectRegionHeight(). */
-  void setSelectRegionHeight(int height) { selectRegionHeight_ = height; };
-  /*! Set the selectedName() value.
+		void setSelectBufferSize(int size);
+		/*! Sets the selectRegionWidth(). */
+		void setSelectRegionWidth(int width) { selectRegionWidth_ = width; };
+		/*! Sets the selectRegionHeight(). */
+		void setSelectRegionHeight(int height) { selectRegionHeight_ = height; };
+		/*! Set the selectedName() value.
 
-  Used in endSelection() during a selection. You should only call this method if you overload the
-  endSelection() method. */
-  void setSelectedName(int id) { selectedObjectId_=id; };
+		Used in endSelection() during a selection. You should only call this method if you overload the
+		endSelection() method. */
+		void setSelectedName(int id) { selectedObjectId_=id; };
 
 protected:
-  virtual void beginSelection(const QPoint&amp; point);
-  /*! This method is called by select() and should draw selectable entities.
+	virtual void beginSelection(const QPoint&amp; point);
+	/*! This method is called by select() and should draw selectable entities.
 
-  Default implementation is empty. Overload and draw the different elements of your scene you want
-  to be able to select. The default select() implementation relies on the \c GL_SELECT, and requires
-  that each selectable element is drawn within a \c glPushName() - \c glPopName() block. A typical
-  usage would be (see the &lt;a href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt;):
-  \code
-  void Viewer::drawWithNames()
-  {
-    for (int i=0; i&lt;nbObjects; ++i)
-    {
-      glPushName(i);
-      object(i)-&gt;draw();
-      glPopName();
-    }
-  }
-  \endcode
+	Default implementation is empty. Overload and draw the different elements of your scene you want
+	to be able to select. The default select() implementation relies on the \c GL_SELECT, and requires
+	that each selectable element is drawn within a \c glPushName() - \c glPopName() block. A typical
+	usage would be (see the &lt;a href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt;):
+	\code
+	void Viewer::drawWithNames()
+	{
+	for (int i=0; i&lt;nbObjects; ++i)
+	{
+	glPushName(i);
+	object(i)-&gt;draw();
+	glPopName();
+	}
+	}
+	\endcode
 
-  The resulting selected name is computed by endSelection(), which setSelectedName() to the integer
-  id pushed by this method (a value of -1 means no selection). Use selectedName() to update your
-  selection, probably in the postSelection() method.
+	The resulting selected name is computed by endSelection(), which setSelectedName() to the integer
+	id pushed by this method (a value of -1 means no selection). Use selectedName() to update your
+	selection, probably in the postSelection() method.
 
-  \attention If your selected objects are points, do not use \c glBegin(GL_POINTS); and \c glVertex3fv()
-  in the above \c draw() method (not compatible with raster mode): use \c glRasterPos3fv() instead. */
-  virtual void drawWithNames() {};
-  virtual void endSelection(const QPoint&amp; point);
-  /*! This method is called at the end of the select() procedure. It should finalize the selection
-    process and update the data structure/interface/computation/display... according to the newly
-    selected entity.
+	\attention If your selected objects are points, do not use \c glBegin(GL_POINTS); and \c glVertex3fv()
+	in the above \c draw() method (not compatible with raster mode): use \c glRasterPos3fv() instead. */
+	virtual void drawWithNames() {};
+	virtual void endSelection(const QPoint&amp; point);
+	/*! This method is called at the end of the select() procedure. It should finalize the selection
+	process and update the data structure/interface/computation/display... according to the newly
+	selected entity.
 
-    The default implementation is empty. Overload this method if needed, and use selectedName() to
-    retrieve the selected entity name (returns -1 if no object was selected). See the &lt;a
-    href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration. */
-  virtual void postSelection(const QPoint&amp; point) { Q_UNUSED(point); };
-  //@}
+	The default implementation is empty. Overload this method if needed, and use selectedName() to
+	retrieve the selected entity name (returns -1 if no object was selected). See the &lt;a
+	href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration. */
+	virtual void postSelection(const QPoint&amp; point) { Q_UNUSED(point); };
+	//@}
 
 
-  /*! @name Keyboard customization */
-  //@{
+	/*! @name Keyboard customization */
+	//@{
 protected:
-  /*! Defines the different actions that can be associated with a keyboard shortcut using
-    setShortcut().
+	/*! Defines the different actions that can be associated with a keyboard shortcut using
+	setShortcut().
 
-    See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
-  enum KeyboardAction { DRAW_AXIS, DRAW_GRID, DISPLAY_FPS, ENABLE_TEXT, EXIT_VIEWER,
-			SAVE_SCREENSHOT, CAMERA_MODE, FULL_SCREEN, STEREO, ANIMATION, HELP, EDIT_CAMERA,
-			MOVE_CAMERA_LEFT, MOVE_CAMERA_RIGHT, MOVE_CAMERA_UP, MOVE_CAMERA_DOWN,
-			INCREASE_FLYSPEED, DECREASE_FLYSPEED };
+	See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
+	enum KeyboardAction { DRAW_AXIS, DRAW_GRID, DISPLAY_FPS, ENABLE_TEXT, EXIT_VIEWER,
+		SAVE_SCREENSHOT, CAMERA_MODE, FULL_SCREEN, STEREO, ANIMATION, HELP, EDIT_CAMERA,
+		MOVE_CAMERA_LEFT, MOVE_CAMERA_RIGHT, MOVE_CAMERA_UP, MOVE_CAMERA_DOWN,
+		INCREASE_FLYSPEED, DECREASE_FLYSPEED };
 public:
-  int shortcut(KeyboardAction action) const;
+	int shortcut(KeyboardAction action) const;
 #ifndef DOXYGEN
-  // QGLViewer 1.x
-  int keyboardAccelerator(KeyboardAction action) const;
-  Qt::Key keyFrameKey(int index) const;
-  QtKeyboardModifiers playKeyFramePathStateKey() const;
-  // QGLViewer 2.0 without Qt4 support
-  QtKeyboardModifiers addKeyFrameStateKey() const;
-  QtKeyboardModifiers playPathStateKey() const;
+	// QGLViewer 1.x
+	int keyboardAccelerator(KeyboardAction action) const;
+	Qt::Key keyFrameKey(int index) const;
+	QtKeyboardModifiers playKeyFramePathStateKey() const;
+	// QGLViewer 2.0 without Qt4 support
+	QtKeyboardModifiers addKeyFrameStateKey() const;
+	QtKeyboardModifiers playPathStateKey() const;
 #endif
-  Qt::Key pathKey(int index) const;
-  QtKeyboardModifiers addKeyFrameKeyboardModifiers() const;
-  QtKeyboardModifiers playPathKeyboardModifiers() const;
+	Qt::Key pathKey(int index) const;
+	QtKeyboardModifiers addKeyFrameKeyboardModifiers() const;
+	QtKeyboardModifiers playPathKeyboardModifiers() const;
 
-public slots:
-  void setShortcut(KeyboardAction action, int key);
+	public slots:
+		void setShortcut(KeyboardAction action, int key);
 #ifndef DOXYGEN
-  void setKeyboardAccelerator(KeyboardAction action, int key);
+		void setKeyboardAccelerator(KeyboardAction action, int key);
 #endif
-  void setKeyDescription(int key, QString description);
+		void setKeyDescription(int key, QString description);
 
-  // Key Frames shortcut keys
+		// Key Frames shortcut keys
 #ifndef DOXYGEN
-  // QGLViewer 1.x compatibility methods
-  virtual void setKeyFrameKey(int index, int key);
-  virtual void setPlayKeyFramePathStateKey(int buttonState);
-  // QGLViewer 2.0 without Qt4 support
-  virtual void setPlayPathStateKey(int buttonState);
-  virtual void setAddKeyFrameStateKey(int buttonState);
+		// QGLViewer 1.x compatibility methods
+		virtual void setKeyFrameKey(int index, int key);
+		virtual void setPlayKeyFramePathStateKey(int buttonState);
+		// QGLViewer 2.0 without Qt4 support
+		virtual void setPlayPathStateKey(int buttonState);
+		virtual void setAddKeyFrameStateKey(int buttonState);
 #endif
-  virtual void setPathKey(int key, int index = 0);
-  virtual void setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers);
-  virtual void setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers);
-  //@}
+		virtual void setPathKey(int key, int index = 0);
+		virtual void setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers);
+		virtual void setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers);
+		//@}
 
 
-  /*! @name Mouse customization */
-  //@{
+		/*! @name Mouse customization */
+		//@{
 protected:
-  /*! Defines the different mouse handlers: camera() or manipulatedFrame().
+	/*! Defines the different mouse handlers: camera() or manipulatedFrame().
 
-  Used by setMouseBinding(), setMouseBinding(int, ClickAction, bool, int) and setWheelBinding() to
-  define which handler receives the mouse events. */
-  enum MouseHandler { CAMERA, FRAME };
+	Used by setMouseBinding(), setMouseBinding(int, ClickAction, bool, int) and setWheelBinding() to
+	define which handler receives the mouse events. */
+	enum MouseHandler { CAMERA, FRAME };
 
-  /*! Defines the possible actions that can be binded to a mouse click using
-  setMouseBinding(int,ClickAction,bool,int).
+	/*! Defines the possible actions that can be binded to a mouse click using
+	setMouseBinding(int,ClickAction,bool,int).
 
-  See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. */
-  enum ClickAction { NO_CLICK_ACTION, ZOOM_ON_PIXEL, ZOOM_TO_FIT, SELECT, RAP_FROM_PIXEL, RAP_IS_CENTER,
-		     CENTER_FRAME, CENTER_SCENE, SHOW_ENTIRE_SCENE, ALIGN_FRAME, ALIGN_CAMERA };
+	See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. */
+	enum ClickAction { NO_CLICK_ACTION, ZOOM_ON_PIXEL, ZOOM_TO_FIT, SELECT, RAP_FROM_PIXEL, RAP_IS_CENTER,
+		CENTER_FRAME, CENTER_SCENE, SHOW_ENTIRE_SCENE, ALIGN_FRAME, ALIGN_CAMERA };
 
 #ifndef DOXYGEN
-  // So that it can be used in ManipulatedFrame and ManipulatedCameraFrame.
+	// So that it can be used in ManipulatedFrame and ManipulatedCameraFrame.
 public:
 #endif
 
-  /*! Defines the possible actions that can be binded to a mouse motion (a click, followed by a
-  mouse displacement).
+	/*! Defines the possible actions that can be binded to a mouse motion (a click, followed by a
+	mouse displacement).
 
-  These actions may be binded to the camera() or to the manipulatedFrame() (see QGLViewer::MouseHandler) using
-  setMouseBinding(). */
-  enum MouseAction { NO_MOUSE_ACTION,
-		     ROTATE, ZOOM, TRANSLATE,
-		     MOVE_FORWARD, LOOK_AROUND, MOVE_BACKWARD,
-		     SCREEN_ROTATE, ROLL, DRIVE,
-		     SCREEN_TRANSLATE, ZOOM_ON_REGION };
+	These actions may be binded to the camera() or to the manipulatedFrame() (see QGLViewer::MouseHandler) using
+	setMouseBinding(). */
+	enum MouseAction { NO_MOUSE_ACTION,
+		ROTATE, ZOOM, TRANSLATE,
+		MOVE_FORWARD, LOOK_AROUND, MOVE_BACKWARD,
+		SCREEN_ROTATE, ROLL, DRIVE,
+		SCREEN_TRANSLATE, ZOOM_ON_REGION };
 
 #ifdef DOXYGEN
 public:
 #endif
 
-  MouseAction mouseAction(int state) const;
-  int mouseHandler(int state) const;
-  int mouseButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
-  ClickAction clickAction(int state, bool doubleClick, QtMouseButtons buttonsBefore) const;
-  void getClickButtonState(ClickAction action, int&amp; state, bool&amp; doubleClick, QtMouseButtons&amp; buttonsBefore) const;
+	MouseAction mouseAction(int state) const;
+	int mouseHandler(int state) const;
+	int mouseButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
+	ClickAction clickAction(int state, bool doubleClick, QtMouseButtons buttonsBefore) const;
+	void getClickButtonState(ClickAction action, int&amp; state, bool&amp; doubleClick, QtMouseButtons&amp; buttonsBefore) const;
 
-  MouseAction wheelAction(QtKeyboardModifiers modifiers) const;
-  int wheelHandler(QtKeyboardModifiers modifiers) const;
-  int wheelButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
+	MouseAction wheelAction(QtKeyboardModifiers modifiers) const;
+	int wheelHandler(QtKeyboardModifiers modifiers) const;
+	int wheelButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
 
-public slots:
-  void setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint=true);
+	public slots:
+		void setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint=true);
 #if QT_VERSION &lt; 0x030000
-  // Two slots cannot have the same name or two default parameters with Qt 2.3.
+		// Two slots cannot have the same name or two default parameters with Qt 2.3.
 public:
 #endif
-  void setMouseBinding(int state, ClickAction action, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
-  void setMouseBindingDescription(int state, QString description, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
+	void setMouseBinding(int state, ClickAction action, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
+	void setMouseBindingDescription(int state, QString description, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
 #if QT_VERSION &lt; 0x030000
-public slots:
+	public slots:
 #endif
-  void setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint=true);
-  void setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers);
+		void setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint=true);
+		void setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers);
 #ifndef DOXYGEN
-  void setHandlerStateKey(MouseHandler handler, int buttonState);
-  void setMouseStateKey(MouseHandler handler, int buttonState);
+		void setHandlerStateKey(MouseHandler handler, int buttonState);
+		void setMouseStateKey(MouseHandler handler, int buttonState);
 #endif
 
 private:
-  static QString mouseActionString(QGLViewer::MouseAction ma);
-  static QString clickActionString(QGLViewer::ClickAction ca);
-  //@}
+	static QString mouseActionString(QGLViewer::MouseAction ma);
+	static QString clickActionString(QGLViewer::ClickAction ca);
+	//@}
 
 
-  /*! @name State persistence */
-  //@{
+	/*! @name State persistence */
+	//@{
 public:
-  QString stateFileName() const;
-  virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+	QString stateFileName() const;
+	virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
 
-public slots:
-  virtual void initFromDOMElement(const QDomElement&amp; element);
-  virtual void saveStateToFile(); // cannot be const because of QMessageBox
-  virtual bool restoreStateFromFile();
+	public slots:
+		virtual void initFromDOMElement(const QDomElement&amp; element);
+		virtual void saveStateToFile(); // cannot be const because of QMessageBox
+		virtual bool restoreStateFromFile();
 
-  /*! Defines the stateFileName() used by saveStateToFile() and restoreStateFromFile().
+		/*! Defines the stateFileName() used by saveStateToFile() and restoreStateFromFile().
 
-  The file name can have an optional prefix directory (no prefix meaning current directory). If the
-  directory does not exist, it will be created by saveStateToFile().
+		The file name can have an optional prefix directory (no prefix meaning current directory). If the
+		directory does not exist, it will be created by saveStateToFile().
 
-  \code
-  // Name depends on the displayed 3D model. Saved in current directory.
-  setStateFileName(3DModelName() + &quot;.xml&quot;);
+		\code
+		// Name depends on the displayed 3D model. Saved in current directory.
+		setStateFileName(3DModelName() + &quot;.xml&quot;);
 
-  // Files are stored in a dedicated directory under user's home directory.
-  setStateFileName(QDir::homeDirPath + &quot;/.config/myApp.xml&quot;);
-  \endcode */
-  void setStateFileName(const QString&amp; name) { stateFileName_ = name; };
+		// Files are stored in a dedicated directory under user's home directory.
+		setStateFileName(QDir::homeDirPath + &quot;/.config/myApp.xml&quot;);
+		\endcode */
+		void setStateFileName(const QString&amp; name) { stateFileName_ = name; };
 
 #ifndef DOXYGEN
-  void saveToFile(const QString&amp; fileName=QString::null);
-  bool restoreFromFile(const QString&amp; fileName=QString::null);
+		void saveToFile(const QString&amp; fileName=QString::null);
+		bool restoreFromFile(const QString&amp; fileName=QString::null);
 #endif
 
 private:
-  static void saveStateToFileForAllViewers();
-  //@}
+	static void saveStateToFileForAllViewers();
+	//@}
 
 
-  /*! @name QGLViewer pool */
-  //@{
+	/*! @name QGLViewer pool */
+	//@{
 public:
-  /*! Returns a \c QList (see Qt documentation) that contains pointers to all the created
-  QGLViewers.
+	/*! Returns a \c QList (see Qt documentation) that contains pointers to all the created
+	QGLViewers. Note that this list may contain \c NULL pointers if the associated viewer has been deleted.
 
-  Can be useful to apply a method or to connect a signal to all the viewers.
+	Can be useful to apply a method or to connect a signal to all the viewers.
 
-  \attention With Qt version 3, this method returns a \c QPtrList instead. Use a \c QPtrListIterator
-  to iterate on the list:
-  \code
-  QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
-  for (QGLViewer* viewer; (viewer = it.current()) != NULL; ++it)
-  connect(myObject, SIGNAL(mySignal), viewer, SLOT(updateGL()));
-  \endcode */
+	\attention With Qt version 3, this method returns a \c QPtrList instead. Use a \c QPtrListIterator
+	to iterate on the list:
+	\code
+	QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
+	for (QGLViewer* viewer; (viewer = it.current()) != NULL; ++it)
+	connect(myObject, SIGNAL(mySignal), viewer, SLOT(updateGL()));
+	\endcode */
 #if QT_VERSION &gt;= 0x040000
-  static const QList&lt;QGLViewer*&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
+	static const QList&lt;QGLViewer*&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
 #else
-  static const QPtrList&lt;QGLViewer&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
+	static const QPtrList&lt;QGLViewer&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
 #endif
 
 
-  /*! Returns the index of the QGLViewer \p viewer in the QGLViewerPool(). This index in unique and
-  can be used to identify the different created QGLViewers (see stateFileName() for an application
-  example).
+	/*! Returns the index of the QGLViewer \p viewer in the QGLViewerPool(). This index in unique and
+	can be used to identify the different created QGLViewers (see stateFileName() for an application
+	example).
 
-  When a QGLViewer is deleted, the following QGLViewers' indexes are shifted down. Returns -1 if the
-  QGLViewer could not be found (which should not be possible). */
+	When a QGLViewer is deleted, the following QGLViewers' indexes are shifted down. Returns -1 if the
+	QGLViewer could not be found (which should not be possible). */
 #if QT_VERSION &gt;= 0x040000
-  static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.indexOf(const_cast&lt;QGLViewer*&gt;(viewer)); };
+	static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.indexOf(const_cast&lt;QGLViewer*&gt;(viewer)); };
 #else
-  static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.find(viewer); };
+	static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.find(viewer); };
 #endif
-  //@}
+	//@}
 
 #ifndef DOXYGEN
-  /*! @name Visual hints */
-  //@{
+	/*! @name Visual hints */
+	//@{
 public:
-  virtual void setVisualHintsMask(int mask, int delay = 2000);
-  virtual void drawVisualHints();
+	virtual void setVisualHintsMask(int mask, int delay = 2000);
+	virtual void drawVisualHints();
 
-public slots:
-  virtual void resetVisualHints();
-  //@}
+	public slots:
+		virtual void resetVisualHints();
+		//@}
 #endif
 
-private slots:
-  // Patch for a Qt bug with fullScreen on startup
-  void delayedFullScreen() { move(prevPos_); setFullScreen(); };
-  void hideMessage();
+		private slots:
+			// Patch for a Qt bug with fullScreen on startup
+			void delayedFullScreen() { move(prevPos_); setFullScreen(); };
+			void hideMessage();
 
 private:
-  // Copy constructor and operator= are declared private and undefined
-  // Prevents everyone from trying to use them
-  QGLViewer(const QGLViewer&amp; v);
-  QGLViewer&amp; operator=(const QGLViewer&amp; v);
+	// Copy constructor and operator= are declared private and undefined
+	// Prevents everyone from trying to use them
+	QGLViewer(const QGLViewer&amp; v);
+	QGLViewer&amp; operator=(const QGLViewer&amp; v);
 
-  // Set parameters to their default values. Called by the constructors.
-  void defaultConstructor();
+	// Set parameters to their default values. Called by the constructors.
+	void defaultConstructor();
 
-  void handleKeyboardAction(KeyboardAction id);
+	void handleKeyboardAction(KeyboardAction id);
 
-  // C a m e r a
-  qglviewer::Camera* camera_;
-  bool cameraIsEdited_;
-  float previousCameraZClippingCoefficient_;
-  int previousPathId_; // Double key press recognition
-  void connectAllCameraKFIInterpolatedSignals(bool connection=true);
+	// C a m e r a
+	qglviewer::Camera* camera_;
+	bool cameraIsEdited_;
+	float previousCameraZClippingCoefficient_;
+	int previousPathId_; // Double key press recognition
+	void connectAllCameraKFIInterpolatedSignals(bool connection=true);
 
-  // C o l o r s
-  QColor backgroundColor_, foregroundColor_;
+	// C o l o r s
+	QColor backgroundColor_, foregroundColor_;
 
-  // D i s p l a y    f l a g s
-  bool axisIsDrawn_;	// world axis
-  bool gridIsDrawn_;	// world XY grid
-  bool FPSIsDisplayed_;	// Frame Per Seconds
-  bool textIsEnabled_;	// drawText() actually draws text or not
-  bool stereo_;		// stereo display
-  bool fullScreen_;	// full screen mode
-  QPoint prevPos_;	// Previous window position, used for full screen mode
+	// D i s p l a y    f l a g s
+	bool axisIsDrawn_;	// world axis
+	bool gridIsDrawn_;	// world XY grid
+	bool FPSIsDisplayed_;	// Frame Per Seconds
+	bool textIsEnabled_;	// drawText() actually draws text or not
+	bool stereo_;		// stereo display
+	bool fullScreen_;	// full screen mode
+	QPoint prevPos_;	// Previous window position, used for full screen mode
 
-  // A n i m a t i o n
-  bool animationStarted_; // animation mode started
-  int animationPeriod_;   // period in msecs
-  int animationTimerId_;
+	// A n i m a t i o n
+	bool animationStarted_; // animation mode started
+	int animationPeriod_;   // period in msecs
+	int animationTimerId_;
 
-  // F P S    d i s p l a y
-  QTime fpsTime_;
-  unsigned int fpsCounter_;
-  QString fpsString_;
-  float f_p_s_;
+	// F P S    d i s p l a y
+	QTime fpsTime_;
+	unsigned int fpsCounter_;
+	QString fpsString_;
+	float f_p_s_;
 
-  // M e s s a g e s
-  QString message_;
-  bool displayMessage_;
-  QTimer messageTimer_;
+	// M e s s a g e s
+	QString message_;
+	bool displayMessage_;
+	QTimer messageTimer_;
 
-  // M a n i p u l a t e d    f r a m e
-  qglviewer::ManipulatedFrame* manipulatedFrame_;
-  bool manipulatedFrameIsACamera_;
+	// M a n i p u l a t e d    f r a m e
+	qglviewer::ManipulatedFrame* manipulatedFrame_;
+	bool manipulatedFrameIsACamera_;
 
-  // M o u s e   G r a b b e r
-  qglviewer::MouseGrabber* mouseGrabber_;
-  bool mouseGrabberIsAManipulatedFrame_;
-  bool mouseGrabberIsAManipulatedCameraFrame_;
-  QMap&lt;size_t, bool&gt; disabledMouseGrabbers_;
+	// M o u s e   G r a b b e r
+	qglviewer::MouseGrabber* mouseGrabber_;
+	bool mouseGrabberIsAManipulatedFrame_;
+	bool mouseGrabberIsAManipulatedCameraFrame_;
+	QMap&lt;size_t, bool&gt; disabledMouseGrabbers_;
 
-  // S e l e c t i o n
-  int selectRegionWidth_, selectRegionHeight_;
-  int selectBufferSize_;
-  GLuint* selectBuffer_;
-  int selectedObjectId_;
+	// S e l e c t i o n
+	int selectRegionWidth_, selectRegionHeight_;
+	int selectBufferSize_;
+	GLuint* selectBuffer_;
+	int selectedObjectId_;
 
-  // V i s u a l   h i n t s
-  int visualHint_;
+	// V i s u a l   h i n t s
+	int visualHint_;
 
-  // S h o r t c u t   k e y s
-  void setDefaultShortcuts();
-  QString cameraPathKeysString() const;
-  QMap&lt;KeyboardAction, QString&gt; keyboardActionDescription_;
-  QMap&lt;KeyboardAction, int&gt; keyboardBinding_;
-  QMap&lt;int, QString&gt; keyDescription_;
+	// S h o r t c u t   k e y s
+	void setDefaultShortcuts();
+	QString cameraPathKeysString() const;
+	QMap&lt;KeyboardAction, QString&gt; keyboardActionDescription_;
+	QMap&lt;KeyboardAction, int&gt; keyboardBinding_;
+	QMap&lt;int, QString&gt; keyDescription_;
 
-  // K e y   F r a m e s   s h o r t c u t s
-  QMap&lt;Qt::Key, int&gt; pathIndex_;
-  QtKeyboardModifiers addKeyFrameKeyboardModifiers_, playPathKeyboardModifiers_;
+	// K e y   F r a m e s   s h o r t c u t s
+	QMap&lt;Qt::Key, int&gt; pathIndex_;
+	QtKeyboardModifiers addKeyFrameKeyboardModifiers_, playPathKeyboardModifiers_;
 
-  // B u f f e r   T e x t u r e
-  GLuint bufferTextureId_;
-  float bufferTextureMaxU_, bufferTextureMaxV_;
-  int bufferTextureWidth_, bufferTextureHeight_;
-  unsigned int previousBufferTextureFormat_;
-  int previousBufferTextureInternalFormat_;
+	// B u f f e r   T e x t u r e
+	GLuint bufferTextureId_;
+	float bufferTextureMaxU_, bufferTextureMaxV_;
+	int bufferTextureWidth_, bufferTextureHeight_;
+	unsigned int previousBufferTextureFormat_;
+	int previousBufferTextureInternalFormat_;
 
 #ifndef DOXYGEN
-  // M o u s e   a c t i o n s
-  struct MouseActionPrivate {
-    MouseHandler handler;
-    MouseAction action;
-    bool withConstraint;
-  };
+	// M o u s e   a c t i o n s
+	struct MouseActionPrivate {
+		MouseHandler handler;
+		MouseAction action;
+		bool withConstraint;
+	};
 
-  // C l i c k   a c t i o n s
-  struct ClickActionPrivate {
-    QtKeyboardModifiers modifiers;
-    QtMouseButtons button;
-    bool doubleClick;
-    QtMouseButtons buttonsBefore; // only defined when doubleClick is true
+	// C l i c k   a c t i o n s
+	struct ClickActionPrivate {
+		QtKeyboardModifiers modifiers;
+		QtMouseButtons button;
+		bool doubleClick;
+		QtMouseButtons buttonsBefore; // only defined when doubleClick is true
 
-    // This sort order in used in mouseString() to displays sorted mouse bindings
-    bool operator&lt;(const ClickActionPrivate&amp; cap) const
-    {
-      if (buttonsBefore != cap.buttonsBefore)
-	return buttonsBefore &lt; cap.buttonsBefore;
-      else
-	if (modifiers != cap.modifiers)
-	  return modifiers &lt; cap.modifiers;
-	else
-	  if (button != cap.button)
-	    return button &lt; cap.button;
-	  else
-	    return !doubleClick &amp;&amp; cap.doubleClick;
-    }
-  };
+		// This sort order in used in mouseString() to displays sorted mouse bindings
+		bool operator&lt;(const ClickActionPrivate&amp; cap) const
+		{
+			if (buttonsBefore != cap.buttonsBefore)
+				return buttonsBefore &lt; cap.buttonsBefore;
+			else
+				if (modifiers != cap.modifiers)
+					return modifiers &lt; cap.modifiers;
+				else
+					if (button != cap.button)
+						return button &lt; cap.button;
+					else
+						return !doubleClick &amp;&amp; cap.doubleClick;
+		}
+	};
 #endif
+    static QString formatClickActionPrivate(ClickActionPrivate cap);
 
-  QMap&lt;ClickActionPrivate, QString&gt; mouseDescription_;
+	QMap&lt;ClickActionPrivate, QString&gt; mouseDescription_;
 
-  void setDefaultMouseBindings();
-  void performClickAction(ClickAction ca, const QMouseEvent* const e);
-  QMap&lt;int, MouseActionPrivate&gt; mouseBinding_;
-  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; wheelBinding_;
-  QMap&lt;ClickActionPrivate, ClickAction&gt; clickBinding_;
+	void setDefaultMouseBindings();
+	void performClickAction(ClickAction ca, const QMouseEvent* const e);
+	QMap&lt;int, MouseActionPrivate&gt; mouseBinding_;
+	QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; wheelBinding_;
+	QMap&lt;ClickActionPrivate, ClickAction&gt; clickBinding_;
 
-  // S n a p s h o t s
-  void initializeSnapshotFormats();
-  QString snapshotFileName_, snapshotFormat_;
-  int snapshotCounter_, snapshotQuality_;
+	// S n a p s h o t s
+	void initializeSnapshotFormats();
+	QString snapshotFileName_, snapshotFormat_;
+	int snapshotCounter_, snapshotQuality_;
 
-  // Q G L V i e w e r   p o o l
+	// Q G L V i e w e r   p o o l
 #if QT_VERSION &gt;= 0x040000
-  static QList&lt;QGLViewer*&gt; QGLViewerPool_;
+	static QList&lt;QGLViewer*&gt; QGLViewerPool_;
 #else
-  static QPtrList&lt;QGLViewer&gt; QGLViewerPool_;
+	static QPtrList&lt;QGLViewer&gt; QGLViewerPool_;
 #endif
 
-  // S t a t e   F i l e
-  QString stateFileName_;
+	// S t a t e   F i l e
+	QString stateFileName_;
 
-  // H e l p   w i n d o w
-  QTabWidget* helpWidget_;
+	// H e l p   w i n d o w
+	QTabWidget* helpWidget_;
 
-  // I n t e r n a l   d e b u g
-  bool updateGLOK_;
+	// I n t e r n a l   d e b u g
+	bool updateGLOK_;
 };
 
-#undef DEBUG
+#ifdef DEBUG
+	#undef DEBUG
+#endif
 
 #endif // QGLVIEWER_QGLVIEWER_H
-
-

Added: trunk/lib/QGLViewer/qglviewer_fr.ts
===================================================================
--- trunk/lib/QGLViewer/qglviewer_fr.ts	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/qglviewer_fr.ts	2008-07-18 06:54:48 UTC (rev 1434)
@@ -0,0 +1,721 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;!DOCTYPE TS&gt;&lt;TS version=&quot;1.1&quot; language=&quot;fr&quot;&gt;
+&lt;defaultcodec&gt;&lt;/defaultcodec&gt;
+&lt;context&gt;
+    &lt;name&gt;ImageInterface&lt;/name&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;13&quot;/&gt;
+        &lt;source&gt;Image settings&lt;/source&gt;
+        &lt;translation&gt;R&#233;glages d&apos;image&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;54&quot;/&gt;
+        &lt;source&gt;Width&lt;/source&gt;
+        &lt;translation&gt;Largeur&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;100&quot;/&gt;
+        &lt;source&gt; px&lt;/source&gt;
+        &lt;translation&gt; px&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;61&quot;/&gt;
+        &lt;source&gt;Width of the image (in pixels)&lt;/source&gt;
+        &lt;translation&gt;Largeur de l&apos;image (en pixels)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;90&quot;/&gt;
+        &lt;source&gt;Height&lt;/source&gt;
+        &lt;translation&gt;Hauteur&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;97&quot;/&gt;
+        &lt;source&gt;Height of the image (in pixels)&lt;/source&gt;
+        &lt;translation&gt;Hauteur de l&apos;image (en pixels)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;132&quot;/&gt;
+        &lt;source&gt;Image quality&lt;/source&gt;
+        &lt;translation&gt;Qualit&#233; d&apos;image&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;139&quot;/&gt;
+        &lt;source&gt;Between 0 (smallest files) and 100 (highest quality)&lt;/source&gt;
+        &lt;translation&gt;Entre 0 (taille de fichier minimale) et 100 (qualit&#233; maximale)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;184&quot;/&gt;
+        &lt;source&gt;Oversampling&lt;/source&gt;
+        &lt;translation&gt;Sur&#233;chantillonage&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;194&quot;/&gt;
+        &lt;source&gt;x &lt;/source&gt;
+        &lt;translation&gt;x &lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;191&quot;/&gt;
+        &lt;source&gt;Antialiases image (when larger then 1.0)&lt;/source&gt;
+        &lt;translation&gt;Anti-alliassage de l&apos;image (si sup&#233;rieur &#224; 1.0)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;234&quot;/&gt;
+        &lt;source&gt;Use white background&lt;/source&gt;
+        &lt;translation&gt;Fond blanc&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;231&quot;/&gt;
+        &lt;source&gt;Use white as background color&lt;/source&gt;
+        &lt;translation&gt;Mettre du blanc en couleur de fond&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;244&quot;/&gt;
+        &lt;source&gt;Expand frustum if needed&lt;/source&gt;
+        &lt;translation&gt;Etendre la pyramide de vue ( frustum) si n&#233;cessaire&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;241&quot;/&gt;
+        &lt;source&gt;When image aspect ratio differs from viewer&apos;s one, expand frustum as needed. Fits inside current frustum otherwise.&lt;/source&gt;
+        &lt;translation&gt;Lorsque le rapport de dimensions de l&apos;image diff&#232;re de celui de la fen&#234;tre, &#233;tendre la pyramide de vue (frustum) en cons&#233;quence. L&apos;image est ajust&#233;e &#224; l&apos;int&#233;rieur de la vue actuelle sinon. &lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;294&quot;/&gt;
+        &lt;source&gt;OK&lt;/source&gt;
+        &lt;translation&gt;Ok&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;ImageInterface.Qt4.ui&quot; line=&quot;301&quot;/&gt;
+        &lt;source&gt;Cancel&lt;/source&gt;
+        &lt;translation&gt;Annuler&lt;/translation&gt;
+    &lt;/message&gt;
+&lt;/context&gt;
+&lt;context&gt;
+    &lt;name&gt;QGLViewer&lt;/name&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;114&quot;/&gt;
+        &lt;source&gt;snapshot&lt;/source&gt;
+        &lt;comment&gt;Default snapshot file name&lt;/comment&gt;
+        &lt;translation&gt;capture&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;478&quot;/&gt;
+        &lt;source&gt;%1Hz&lt;/source&gt;
+        &lt;comment&gt;Frames per seconds, in Hertz&lt;/comment&gt;
+        &lt;translation&gt;%1Hz&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;291&quot;/&gt;
+        &lt;source&gt;About libQGLViewer&lt;/source&gt;
+        &lt;comment&gt;About message box title&lt;/comment&gt;
+        &lt;translation&gt;A propos de libQGLViewer&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;584&quot;/&gt;
+        &lt;source&gt;Toggles the display of the FPS&lt;/source&gt;
+        &lt;comment&gt;DISPLAY_FPS action description&lt;/comment&gt;
+        &lt;translation&gt;Active ou non l&apos;affichage de la fr&#233;quence d&apos;affiichage&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;585&quot;/&gt;
+        &lt;source&gt;Saves a screenshot&lt;/source&gt;
+        &lt;comment&gt;SAVE_SCREENSHOT action description&lt;/comment&gt;
+        &lt;translation&gt;Sauvegarde une capture d&apos;&#233;cran&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;586&quot;/&gt;
+        &lt;source&gt;Toggles full screen display&lt;/source&gt;
+        &lt;comment&gt;FULL_SCREEN action description&lt;/comment&gt;
+        &lt;translation&gt;Passe ou non en mode plein &#233;cran&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;587&quot;/&gt;
+        &lt;source&gt;Toggles the display of the world axis&lt;/source&gt;
+        &lt;comment&gt;DRAW_AXIS action description&lt;/comment&gt;
+        &lt;translation&gt;Affiche ou non le rep&#232;re du monde&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;588&quot;/&gt;
+        &lt;source&gt;Toggles the display of the XY grid&lt;/source&gt;
+        &lt;comment&gt;DRAW_GRID action description&lt;/comment&gt;
+        &lt;translation&gt;Affiche ou non la grille XY&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;589&quot;/&gt;
+        &lt;source&gt;Changes camera mode (revolve or fly)&lt;/source&gt;
+        &lt;comment&gt;CAMERA_MODE action description&lt;/comment&gt;
+        &lt;translation&gt;Change le mode de la cam&#233;ra (observateur ou vol)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;590&quot;/&gt;
+        &lt;source&gt;Toggles stereo display&lt;/source&gt;
+        &lt;comment&gt;STEREO action description&lt;/comment&gt;
+        &lt;translation&gt;Affiche ou non en st&#233;r&#233;o&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;591&quot;/&gt;
+        &lt;source&gt;Opens this help window&lt;/source&gt;
+        &lt;comment&gt;HELP action description&lt;/comment&gt;
+        &lt;translation&gt;Ouvre la fen&#234;tre d&apos;aide&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;592&quot;/&gt;
+        &lt;source&gt;Starts/stops the animation&lt;/source&gt;
+        &lt;comment&gt;ANIMATION action description&lt;/comment&gt;
+        &lt;translation&gt;D&#233;marre/arr&#234;te l&apos;animation&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;593&quot;/&gt;
+        &lt;source&gt;Toggles camera paths display&lt;/source&gt;
+        &lt;comment&gt;EDIT_CAMERA action description&lt;/comment&gt;
+        &lt;translation&gt;Affiche ou non les chemins de cam&#233;ra&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;594&quot;/&gt;
+        &lt;source&gt;Toggles the display of the text&lt;/source&gt;
+        &lt;comment&gt;ENABLE_TEXT action description&lt;/comment&gt;
+        &lt;translation&gt;Affiche ou non les textes&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;595&quot;/&gt;
+        &lt;source&gt;Exits program&lt;/source&gt;
+        &lt;comment&gt;EXIT_VIEWER action description&lt;/comment&gt;
+        &lt;translation&gt;Quitte l&apos;application&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;596&quot;/&gt;
+        &lt;source&gt;Moves camera left&lt;/source&gt;
+        &lt;comment&gt;MOVE_CAMERA_LEFT action description&lt;/comment&gt;
+        &lt;translation&gt;D&#233;place la cam&#233;ra sur la gauche&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;597&quot;/&gt;
+        &lt;source&gt;Moves camera right&lt;/source&gt;
+        &lt;comment&gt;MOVE_CAMERA_RIGHT action description&lt;/comment&gt;
+        &lt;translation&gt;D&#233;place la cam&#233;ra sur la droite&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;598&quot;/&gt;
+        &lt;source&gt;Moves camera up&lt;/source&gt;
+        &lt;comment&gt;MOVE_CAMERA_UP action description&lt;/comment&gt;
+        &lt;translation&gt;D&#233;place la cam&#233;ra vers le haut&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;599&quot;/&gt;
+        &lt;source&gt;Moves camera down&lt;/source&gt;
+        &lt;comment&gt;MOVE_CAMERA_DOWN action description&lt;/comment&gt;
+        &lt;translation&gt;D&#233;place la cam&#233;ra vers le bas&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;600&quot;/&gt;
+        &lt;source&gt;Increases fly speed&lt;/source&gt;
+        &lt;comment&gt;INCREASE_FLYSPEED action description&lt;/comment&gt;
+        &lt;translation&gt;Augmente la vitesse de vol&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;601&quot;/&gt;
+        &lt;source&gt;Decreases fly speed&lt;/source&gt;
+        &lt;comment&gt;DECREASE_FLYSPEED action description&lt;/comment&gt;
+        &lt;translation&gt;Diminue la vitesse de vol&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1759&quot;/&gt;
+        &lt;source&gt;Stereo not supported&lt;/source&gt;
+        &lt;comment&gt;Message box window title&lt;/comment&gt;
+        &lt;translation&gt;St&#233;r&#233;o non support&#233;e&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1759&quot;/&gt;
+        &lt;source&gt;Stereo is not supported on this display.&lt;/source&gt;
+        &lt;translation&gt;Affichage en st&#233;r&#233;o non support&#233; sur cette machine.&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1835&quot;/&gt;
+        &lt;source&gt;(no button)&lt;/source&gt;
+        &lt;translation&gt;(pas de bouton)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;295&quot;/&gt;
+        &lt;source&gt;libQGLViewer, version %1.&lt;br&gt;A versatile 3D viewer based on OpenGL and Qt.&lt;br&gt;Copyright 2002-%2 Gilles Debunne.&lt;br&gt;&lt;code&gt;%3&lt;/code&gt;&lt;/source&gt;
+        &lt;translation&gt;libQGLViewer, version %1.&lt;br&gt;Un visualiseur 3D g&#233;n&#233;rique bas&#233; sur OpenGL et Qt.&lt;br&gt;Copyright 2002-%2 Gilles Debunne.&lt;br&gt;&lt;code&gt;%3&lt;/code&gt;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1855&quot;/&gt;
+        &lt;source&gt;Rotates&lt;/source&gt;
+        &lt;comment&gt;ROTATE mouse action&lt;/comment&gt;
+        &lt;translation&gt;Tourne&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1856&quot;/&gt;
+        &lt;source&gt;Zooms&lt;/source&gt;
+        &lt;comment&gt;ZOOM mouse action&lt;/comment&gt;
+        &lt;translation&gt;Zoome&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1857&quot;/&gt;
+        &lt;source&gt;Translates&lt;/source&gt;
+        &lt;comment&gt;TRANSLATE mouse action&lt;/comment&gt;
+        &lt;translation&gt;Translate&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1860&quot;/&gt;
+        &lt;source&gt;Moves backward&lt;/source&gt;
+        &lt;comment&gt;MOVE_BACKWARD mouse action&lt;/comment&gt;
+        &lt;translation&gt;Recule&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1864&quot;/&gt;
+        &lt;source&gt;Horizontally/Vertically translates&lt;/source&gt;
+        &lt;comment&gt;SCREEN_TRANSLATE mouse action&lt;/comment&gt;
+        &lt;translation&gt;Translate horizontalement/verticalement&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1858&quot;/&gt;
+        &lt;source&gt;Moves forward&lt;/source&gt;
+        &lt;comment&gt;MOVE_FORWARD mouse action&lt;/comment&gt;
+        &lt;translation&gt;Avance&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1859&quot;/&gt;
+        &lt;source&gt;Looks around&lt;/source&gt;
+        &lt;comment&gt;LOOK_AROUND mouse action&lt;/comment&gt;
+        &lt;translation&gt;Regarde&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1861&quot;/&gt;
+        &lt;source&gt;Rotates in screen plane&lt;/source&gt;
+        &lt;comment&gt;SCREEN_ROTATE mouse action&lt;/comment&gt;
+        &lt;translation&gt;Pivote dans le plan &#233;cran&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1862&quot;/&gt;
+        &lt;source&gt;Rolls&lt;/source&gt;
+        &lt;comment&gt;ROLL mouse action&lt;/comment&gt;
+        &lt;translation&gt;Pivote&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1863&quot;/&gt;
+        &lt;source&gt;Drives&lt;/source&gt;
+        &lt;comment&gt;DRIVE mouse action&lt;/comment&gt;
+        &lt;translation&gt;Avance&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1865&quot;/&gt;
+        &lt;source&gt;Zooms on region for&lt;/source&gt;
+        &lt;comment&gt;ZOOM_ON_REGION mouse action&lt;/comment&gt;
+        &lt;translation&gt;Zoome sur la r&#233;gion pour&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1875&quot;/&gt;
+        &lt;source&gt;Zooms on pixel&lt;/source&gt;
+        &lt;comment&gt;ZOOM_ON_PIXEL click action&lt;/comment&gt;
+        &lt;translation&gt;Zoome sur le pixel&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1876&quot;/&gt;
+        &lt;source&gt;Zooms to fit scene&lt;/source&gt;
+        &lt;comment&gt;ZOOM_TO_FIT click action&lt;/comment&gt;
+        &lt;translation&gt;Zoome pour ajuster &#224; la sc&#232;ne&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1877&quot;/&gt;
+        &lt;source&gt;Selects&lt;/source&gt;
+        &lt;comment&gt;SELECT click action&lt;/comment&gt;
+        &lt;translation&gt;S&#233;lectionne&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1878&quot;/&gt;
+        &lt;source&gt;Sets revolve around point&lt;/source&gt;
+        &lt;comment&gt;RAP_FROM_PIXEL click action&lt;/comment&gt;
+        &lt;translation&gt;D&#233;finit le point de rotation&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1879&quot;/&gt;
+        &lt;source&gt;Resets revolve around point&lt;/source&gt;
+        &lt;comment&gt;RAP_IS_CENTER click action&lt;/comment&gt;
+        &lt;translation&gt;Restaure le point de rotation&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1880&quot;/&gt;
+        &lt;source&gt;Centers frame&lt;/source&gt;
+        &lt;comment&gt;CENTER_FRAME click action&lt;/comment&gt;
+        &lt;translation&gt;Centre le rep&#232;re manipul&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1881&quot;/&gt;
+        &lt;source&gt;Centers scene&lt;/source&gt;
+        &lt;comment&gt;CENTER_SCENE click action&lt;/comment&gt;
+        &lt;translation&gt;Centre la sc&#232;ne&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1882&quot;/&gt;
+        &lt;source&gt;Shows entire scene&lt;/source&gt;
+        &lt;comment&gt;SHOW_ENTIRE_SCENE click action&lt;/comment&gt;
+        &lt;translation&gt;Affiche toute la sc&#232;ne&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1883&quot;/&gt;
+        &lt;source&gt;Aligns frame&lt;/source&gt;
+        &lt;comment&gt;ALIGN_FRAME click action&lt;/comment&gt;
+        &lt;translation&gt;Aligne le rep&#232;re manipul&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1884&quot;/&gt;
+        &lt;source&gt;Aligns camera&lt;/source&gt;
+        &lt;comment&gt;ALIGN_CAMERA click action&lt;/comment&gt;
+        &lt;translation&gt;Aligne la cam&#233;ra&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2242&quot;/&gt;
+        &lt;source&gt;Camera paths are controlled using %1 (noted &lt;i&gt;Fx&lt;/i&gt; below):&lt;/source&gt;
+        &lt;comment&gt;Help window key tab camera keys&lt;/comment&gt;
+        &lt;translation&gt;Les chemins de cam&#233;ra sont contr&#244;l&#233;s avec %1 (not&#233; &lt;i&gt;Fx&lt;/i&gt; ci-dessous) :&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2206&quot;/&gt;
+        &lt;source&gt;Key(s)&lt;/source&gt;
+        &lt;comment&gt;Keys column header in help window mouse tab&lt;/comment&gt;
+        &lt;translation&gt;Touche(s)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2206&quot;/&gt;
+        &lt;source&gt;Description&lt;/source&gt;
+        &lt;comment&gt;Description column header in help window mouse tab&lt;/comment&gt;
+        &lt;translation&gt;Description&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2223&quot;/&gt;
+        &lt;source&gt;Standard viewer keys&lt;/source&gt;
+        &lt;comment&gt;In help window keys tab&lt;/comment&gt;
+        &lt;translation&gt;Raccourcis standards&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2247&quot;/&gt;
+        &lt;source&gt;Fx&lt;/source&gt;
+        &lt;comment&gt;Generic function key (F1..F12)&lt;/comment&gt;
+        &lt;translation&gt;Fx&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2244&quot;/&gt;
+        &lt;source&gt;Plays path (or resets saved position)&lt;/source&gt;
+        &lt;translation&gt;Joue le chemin (ou restaure la position sauvegard&#233;e)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2246&quot;/&gt;
+        &lt;source&gt;Adds a key frame to path (or defines a position)&lt;/source&gt;
+        &lt;translation&gt;Ajoute une position clef au chemin (ou d&#233;finit une position)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2248&quot;/&gt;
+        &lt;source&gt;Deletes path (or saved position)&lt;/source&gt;
+        &lt;translation&gt;Supprime le chemin (ou la position)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1984&quot;/&gt;
+        &lt;source&gt;Button(s)&lt;/source&gt;
+        &lt;comment&gt;Buttons column header in help window mouse tab&lt;/comment&gt;
+        &lt;translation&gt;Bouton(s)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2005&quot;/&gt;
+        &lt;source&gt;Standard mouse bindings&lt;/source&gt;
+        &lt;comment&gt;In help window mouse tab&lt;/comment&gt;
+        &lt;translation&gt;Actions souris standards&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1894&quot;/&gt;
+        &lt;source&gt;Wheel&lt;/source&gt;
+        &lt;comment&gt;Mouse wheel&lt;/comment&gt;
+        &lt;translation&gt;Molette&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2273&quot;/&gt;
+        &lt;source&gt;&amp;Help&lt;/source&gt;
+        &lt;comment&gt;Help window tab title&lt;/comment&gt;
+        &lt;translation&gt;&amp;Aide&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2273&quot;/&gt;
+        &lt;source&gt;&amp;Keyboard&lt;/source&gt;
+        &lt;comment&gt;Help window tab title&lt;/comment&gt;
+        &lt;translation&gt;&amp;Clavier&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2273&quot;/&gt;
+        &lt;source&gt;&amp;Mouse&lt;/source&gt;
+        &lt;comment&gt;Help window tab title&lt;/comment&gt;
+        &lt;translation&gt;&amp;Souris&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2282&quot;/&gt;
+        &lt;source&gt;Help&lt;/source&gt;
+        &lt;comment&gt;Help window title&lt;/comment&gt;
+        &lt;translation&gt;Aide&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2286&quot;/&gt;
+        &lt;source&gt;About&lt;/source&gt;
+        &lt;comment&gt;About button in help window&lt;/comment&gt;
+        &lt;translation&gt;A propos&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2437&quot;/&gt;
+        &lt;source&gt;Path %1 deleted&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Chemin %1 supprim&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2439&quot;/&gt;
+        &lt;source&gt;Position %1 deleted&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Position %1 supprim&#233;e&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2451&quot;/&gt;
+        &lt;source&gt;Path %1, position %2 added&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Chemin %1, position %2 ajout&#233;e&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2453&quot;/&gt;
+        &lt;source&gt;Position %1 saved&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Position %1 sauvegard&#233;e&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2480&quot;/&gt;
+        &lt;source&gt;Camera in revolve around mode&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Cam&#233;ra en mode observateur&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2480&quot;/&gt;
+        &lt;source&gt;Camera in fly mode&lt;/source&gt;
+        &lt;comment&gt;Feedback message&lt;/comment&gt;
+        &lt;translation&gt;Cam&#233;ra en mode vol&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3616&quot;/&gt;
+        &lt;source&gt;Save to file error&lt;/source&gt;
+        &lt;comment&gt;Message box window title&lt;/comment&gt;
+        &lt;translation&gt;Erreur lors de la sauvegarde&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3574&quot;/&gt;
+        &lt;source&gt;State file name (%1) references a directory instead of a file.&lt;/source&gt;
+        &lt;translation&gt;Le nom du fichier d&apos;&#233;tat (%1) r&#233;f&#233;rence un r&#233;p&#233;rtoire et non un fichier.&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3592&quot;/&gt;
+        &lt;source&gt;Unable to create directory %1&lt;/source&gt;
+        &lt;translation&gt;Le r&#233;p&#233;rtoire %1 ne peut &#234;tre cr&#233;&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3616&quot;/&gt;
+        &lt;source&gt;Unable to save to file %1&lt;/source&gt;
+        &lt;translation&gt;Impossible de sauvegarder le fichier %1&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3655&quot;/&gt;
+        &lt;source&gt;Problem in state restoration&lt;/source&gt;
+        &lt;comment&gt;Message box window title&lt;/comment&gt;
+        &lt;translation&gt;Probl&#232;me lors de la restauration de l&apos;&#233;tat&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3655&quot;/&gt;
+        &lt;source&gt;File %1 is not readable.&lt;/source&gt;
+        &lt;translation&gt;Le fichier %1 n&apos;est pas lisible.&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3678&quot;/&gt;
+        &lt;source&gt;Open file error&lt;/source&gt;
+        &lt;comment&gt;Message box window title&lt;/comment&gt;
+        &lt;translation&gt;Erreur d&apos;ouverture de fichier&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;3678&quot;/&gt;
+        &lt;source&gt;Unable to open file %1&lt;/source&gt;
+        &lt;translation&gt;Le fichier %1 ne peut &#234;tre ouvert&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1829&quot;/&gt;
+        &lt;source&gt;Ctrl+&lt;/source&gt;
+        &lt;comment&gt;Modifier key&lt;/comment&gt;
+        &lt;translation&gt;Ctrl+&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1830&quot;/&gt;
+        &lt;source&gt;Alt+&lt;/source&gt;
+        &lt;comment&gt;Modifier key&lt;/comment&gt;
+        &lt;translation&gt;Alt+&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1831&quot;/&gt;
+        &lt;source&gt;Shift+&lt;/source&gt;
+        &lt;comment&gt;Modifier key&lt;/comment&gt;
+        &lt;translation&gt;Shift+&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1833&quot;/&gt;
+        &lt;source&gt;Meta+&lt;/source&gt;
+        &lt;comment&gt;Modifier key&lt;/comment&gt;
+        &lt;translation&gt;M&#233;ta+&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1844&quot;/&gt;
+        &lt;source&gt;Left&lt;/source&gt;
+        &lt;comment&gt;left mouse button&lt;/comment&gt;
+        &lt;translation&gt;Gauche&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1845&quot;/&gt;
+        &lt;source&gt;Middle&lt;/source&gt;
+        &lt;comment&gt;middle mouse button&lt;/comment&gt;
+        &lt;translation&gt;Milieu&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1846&quot;/&gt;
+        &lt;source&gt;Right&lt;/source&gt;
+        &lt;comment&gt;right mouse button&lt;/comment&gt;
+        &lt;translation&gt;Droit&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1895&quot;/&gt;
+        &lt;source&gt; double click&lt;/source&gt;
+        &lt;comment&gt;Suffix after mouse button&lt;/comment&gt;
+        &lt;translation&gt;Double clic &lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2050&quot;/&gt;
+        &lt;source&gt;camera&lt;/source&gt;
+        &lt;comment&gt;Suffix after action&lt;/comment&gt;
+        &lt;translation&gt;la cam&#233;ra&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;2051&quot;/&gt;
+        &lt;source&gt;manipulated frame&lt;/source&gt;
+        &lt;comment&gt;Suffix after action&lt;/comment&gt;
+        &lt;translation&gt;le rep&#232;re manipul&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1896&quot;/&gt;
+        &lt;source&gt; with &lt;/source&gt;
+        &lt;comment&gt;As in : Left button with Ctrl pressed&lt;/comment&gt;
+        &lt;translation&gt; avec &lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1898&quot;/&gt;
+        &lt;source&gt; pressed&lt;/source&gt;
+        &lt;comment&gt;As in : Left button with Ctrl pressed&lt;/comment&gt;
+        &lt;translation&gt; enfonc&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.cpp&quot; line=&quot;1893&quot;/&gt;
+        &lt;source&gt;%1%2%3%4%5%6&lt;/source&gt;
+        &lt;comment&gt;Modifier / button or wheel / double click / with / button / pressed&lt;/comment&gt;
+        &lt;translation&gt;%1%3%2%4%5%6&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;qglviewer.h&quot; line=&quot;670&quot;/&gt;
+        &lt;source&gt;No help available.&lt;/source&gt;
+        &lt;translation&gt;Pas d&apos;aide disponible.&lt;/translation&gt;
+    &lt;/message&gt;
+&lt;/context&gt;
+&lt;context&gt;
+    &lt;name&gt;VRenderInterface&lt;/name&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;13&quot;/&gt;
+        &lt;source&gt;Vectorial rendering options&lt;/source&gt;
+        &lt;translation&gt;Options de rendu vectoriel&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;37&quot;/&gt;
+        &lt;source&gt;Include hidden parts&lt;/source&gt;
+        &lt;translation&gt;Inclure les parties cach&#233;es&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;47&quot;/&gt;
+        &lt;source&gt;Cull back faces&lt;/source&gt;
+        &lt;translation&gt;Supprimer les faces arri&#232;res&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;44&quot;/&gt;
+        &lt;source&gt;Back faces (non clockwise point ordering) are removed from the output&lt;/source&gt;
+        &lt;translation&gt;Les  faces orient&#233;es vers l&apos;arri&#232;re (points ordonn&#233;s dans le sens anti-horaire) sont supprim&#233;es du r&#233;sultat (Back Face Culling)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;57&quot;/&gt;
+        &lt;source&gt;Black and white&lt;/source&gt;
+        &lt;translation&gt;Noir et blanc&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;54&quot;/&gt;
+        &lt;source&gt;Black and white rendering&lt;/source&gt;
+        &lt;translation&gt;Rendu en noir et blanc&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;67&quot;/&gt;
+        &lt;source&gt;Color background&lt;/source&gt;
+        &lt;translation&gt;Fond avec une couleur&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;64&quot;/&gt;
+        &lt;source&gt;Use current background color instead of white&lt;/source&gt;
+        &lt;translation&gt;Utiliser la couleur de fond actuelle &#224; la place du blanc&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;77&quot;/&gt;
+        &lt;source&gt;Tighten bounding box&lt;/source&gt;
+        &lt;translation&gt;Ajuster la bo&#238;te englobante&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;74&quot;/&gt;
+        &lt;source&gt;Fit output bounding box to current display&lt;/source&gt;
+        &lt;translation&gt;Ajuster la bo&#238;te englobante de la sortie &#224; ce qui est actuellement affich&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;111&quot;/&gt;
+        &lt;source&gt;Polygon depth sorting method&lt;/source&gt;
+        &lt;translation&gt;M&#233;thode de tri de la profondeur des polyg&#244;nes&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;118&quot;/&gt;
+        &lt;source&gt;No sorting&lt;/source&gt;
+        &lt;translation&gt;Pas de tri&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;128&quot;/&gt;
+        &lt;source&gt;Topological&lt;/source&gt;
+        &lt;translation&gt;Topologique&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;133&quot;/&gt;
+        &lt;source&gt;Advanced topological&lt;/source&gt;
+        &lt;translation&gt;Topologique avanc&#233;&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;176&quot;/&gt;
+        &lt;source&gt;Save&lt;/source&gt;
+        &lt;translation&gt;Sauvegarder&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;183&quot;/&gt;
+        &lt;source&gt;Cancel&lt;/source&gt;
+        &lt;translation&gt;Annuler&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;34&quot;/&gt;
+        &lt;source&gt;Hidden polygons are also included in the output (usually twice bigger)&lt;/source&gt;
+        &lt;translation&gt;Inclure les polyg&#244;nes cach&#233;s dans le r&#233;sultat (alors habituellement deux fois plus gros)&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;104&quot;/&gt;
+        &lt;source&gt;Sort method:&lt;/source&gt;
+        &lt;translation&gt;M&#233;thode de tri :&lt;/translation&gt;
+    &lt;/message&gt;
+    &lt;message&gt;
+        &lt;location filename=&quot;VRenderInterface.Qt4.ui&quot; line=&quot;123&quot;/&gt;
+        &lt;source&gt;BSP&lt;/source&gt;
+        &lt;translation&gt;BSP&lt;/translation&gt;
+    &lt;/message&gt;
+&lt;/context&gt;
+&lt;/TS&gt;

Modified: trunk/lib/QGLViewer/quaternion.cpp
===================================================================
--- trunk/lib/QGLViewer/quaternion.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/quaternion.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/quaternion.h
===================================================================
--- trunk/lib/QGLViewer/quaternion.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/quaternion.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 
@@ -31,281 +31,281 @@
 #include &lt;iostream&gt;
 
 namespace qglviewer {
-  /*! \brief The Quaternion class represents 3D rotations and orientations.
-  \class Quaternion quaternion.h QGLViewer/quaternion.h
+	/*! \brief The Quaternion class represents 3D rotations and orientations.
+	\class Quaternion quaternion.h QGLViewer/quaternion.h
 
-  The Quaternion is an appropriate (although not very intuitive) representation for 3D rotations and
-  orientations. Many tools are provided to ease the definition of a Quaternion: see constructors,
-  setAxisAngle(), setFromRotationMatrix(), setFromRotatedBasis().
+	The Quaternion is an appropriate (although not very intuitive) representation for 3D rotations and
+	orientations. Many tools are provided to ease the definition of a Quaternion: see constructors,
+	setAxisAngle(), setFromRotationMatrix(), setFromRotatedBasis().
 
-  You can apply the rotation represented by the Quaternion to 3D points using rotate() and
-  inverseRotate(). See also the Frame class that represents a coordinate system and provides other
-  conversion functions like Frame::coordinatesOf() and Frame::transformOf().
+	You can apply the rotation represented by the Quaternion to 3D points using rotate() and
+	inverseRotate(). See also the Frame class that represents a coordinate system and provides other
+	conversion functions like Frame::coordinatesOf() and Frame::transformOf().
 
-  You can apply the Quaternion \c q rotation to the OpenGL matrices using:
-  \code
-  glMultMatrixd(q.matrix());
-  // equvalent to glRotate(q.angle()*180.0/M_PI, q.axis().x, q.axis().y, q.axis().z);
-  \endcode
+	You can apply the Quaternion \c q rotation to the OpenGL matrices using:
+	\code
+	glMultMatrixd(q.matrix());
+	// equvalent to glRotate(q.angle()*180.0/M_PI, q.axis().x, q.axis().y, q.axis().z);
+	\endcode
 
-  Quaternion is part of the \c qglviewer namespace, specify \c qglviewer::Quaternion or use the qglviewer
-  namespace: \code using namespace qglviewer; \endcode
+	Quaternion is part of the \c qglviewer namespace, specify \c qglviewer::Quaternion or use the qglviewer
+	namespace: \code using namespace qglviewer; \endcode
 
-  &lt;h3&gt;Internal representation&lt;/h3&gt;
+	&lt;h3&gt;Internal representation&lt;/h3&gt;
 
-  The internal representation of a Quaternion corresponding to a rotation around axis \c axis, with an angle
-  \c alpha is made of four doubles q[i]:
-  \code
-  {q[0],q[1],q[2]} = sin(alpha/2) * {axis[0],axis[1],axis[2]}
-  q[3] = cos(alpha/2)
-  \endcode
+	The internal representation of a Quaternion corresponding to a rotation around axis \c axis, with an angle
+	\c alpha is made of four doubles q[i]:
+	\code
+	{q[0],q[1],q[2]} = sin(alpha/2) * {axis[0],axis[1],axis[2]}
+	q[3] = cos(alpha/2)
+	\endcode
 
-  Note that certain implementations place the cosine term in first position (instead of last here).
+	Note that certain implementations place the cosine term in first position (instead of last here).
 
-  The Quaternion is always normalized, so that its inverse() is actually its conjugate.
+	The Quaternion is always normalized, so that its inverse() is actually its conjugate.
 
-  See also the Vec and Frame classes' documentations.
-  \nosubgrouping */
-class QGLVIEWER_EXPORT Quaternion
-{
-public:
-  /*! @name Defining a Quaternion */
-  //@{
-  /*! Default constructor, builds an identity rotation. */
-  Quaternion()
-  { q[0]=q[1]=q[2]=0.0;  q[3]=1.0; }
+	See also the Vec and Frame classes' documentations.
+	\nosubgrouping */
+	class QGLVIEWER_EXPORT Quaternion
+	{
+	public:
+		/*! @name Defining a Quaternion */
+		//@{
+		/*! Default constructor, builds an identity rotation. */
+		Quaternion()
+		{ q[0]=q[1]=q[2]=0.0;  q[3]=1.0; }
 
-  /*! Constructor from rotation axis (non null) and angle (in radians). See also setAxisAngle(). */
-  Quaternion(const Vec&amp; axis, double angle)
-  {
-    setAxisAngle(axis, angle);
-  }
+		/*! Constructor from rotation axis (non null) and angle (in radians). See also setAxisAngle(). */
+		Quaternion(const Vec&amp; axis, double angle)
+		{
+			setAxisAngle(axis, angle);
+		}
 
-  Quaternion(const Vec&amp; from, const Vec&amp; to);
+		Quaternion(const Vec&amp; from, const Vec&amp; to);
 
-  /*! Constructor from the four values of a Quaternion. First three values are axis*sin(angle/2) and
-    last one is cos(angle/2).
+		/*! Constructor from the four values of a Quaternion. First three values are axis*sin(angle/2) and
+		last one is cos(angle/2).
 
-  \attention The identity Quaternion is Quaternion(0,0,0,1) and \e not Quaternion(0,0,0,0) (which is
-  not unitary). The default Quaternion() creates such identity Quaternion. */
-  Quaternion(double q0, double q1, double q2, double q3)
-  { q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
+		\attention The identity Quaternion is Quaternion(0,0,0,1) and \e not Quaternion(0,0,0,0) (which is
+		not unitary). The default Quaternion() creates such identity Quaternion. */
+		Quaternion(double q0, double q1, double q2, double q3)
+		{ q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
 
-  /*! Copy constructor. */
-  Quaternion(const Quaternion&amp; Q)
-  { for (int i=0; i&lt;4; ++i) q[i] = Q.q[i]; }
+		/*! Copy constructor. */
+		Quaternion(const Quaternion&amp; Q)
+		{ for (int i=0; i&lt;4; ++i) q[i] = Q.q[i]; }
 
-  /*! Equal operator. */
-  Quaternion&amp; operator=(const Quaternion&amp; Q)
-  {
-    for (int i=0; i&lt;4; ++i)
-      q[i] = Q.q[i];
-    return (*this);
-  }
+		/*! Equal operator. */
+		Quaternion&amp; operator=(const Quaternion&amp; Q)
+		{
+			for (int i=0; i&lt;4; ++i)
+				q[i] = Q.q[i];
+			return (*this);
+		}
 
-  /*! Sets the Quaternion as a rotation of axis \p axis and angle \p angle (in radians).
+		/*! Sets the Quaternion as a rotation of axis \p axis and angle \p angle (in radians).
 
-  \p axis does not need to be normalized. A null \p axis will result in an identity Quaternion. */
-  void setAxisAngle(const Vec&amp; axis, double angle)
-  {
-    const double norm = axis.norm();
-    if (norm &lt; 1E-8)
-      {
-	// Null rotation
-	q[0] = 0.0;      q[1] = 0.0;      q[2] = 0.0;      q[3] = 1.0;
-      }
-    else
-      {
-	const double sin_half_angle = sin(angle / 2.0);
-	q[0] = sin_half_angle*axis[0]/norm;
-	q[1] = sin_half_angle*axis[1]/norm;
-	q[2] = sin_half_angle*axis[2]/norm;
-	q[3] = cos(angle / 2.0);
-      }
-  }
+		\p axis does not need to be normalized. A null \p axis will result in an identity Quaternion. */
+		void setAxisAngle(const Vec&amp; axis, double angle)
+		{
+			const double norm = axis.norm();
+			if (norm &lt; 1E-8)
+			{
+				// Null rotation
+				q[0] = 0.0;      q[1] = 0.0;      q[2] = 0.0;      q[3] = 1.0;
+			}
+			else
+			{
+				const double sin_half_angle = sin(angle / 2.0);
+				q[0] = sin_half_angle*axis[0]/norm;
+				q[1] = sin_half_angle*axis[1]/norm;
+				q[2] = sin_half_angle*axis[2]/norm;
+				q[3] = cos(angle / 2.0);
+			}
+		}
 
-  /*! Sets the Quaternion value. See the Quaternion(double, double, double, double) constructor documentation. */
-  void setValue(double q0, double q1, double q2, double q3)
-  { q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
+		/*! Sets the Quaternion value. See the Quaternion(double, double, double, double) constructor documentation. */
+		void setValue(double q0, double q1, double q2, double q3)
+		{ q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
 
 #ifndef DOXYGEN
-  void setFromRotationMatrix(const float m[3][3]);
-  void setFromRotatedBase(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
+		void setFromRotationMatrix(const float m[3][3]);
+		void setFromRotatedBase(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
 #endif
-  void setFromRotationMatrix(const double m[3][3]);
-  void setFromRotatedBasis(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
-  //@}
+		void setFromRotationMatrix(const double m[3][3]);
+		void setFromRotatedBasis(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
+		//@}
 
 
-  /*! @name Accessing values */
-  //@{
-  Vec axis() const;
-  float angle() const;
-  void getAxisAngle(Vec&amp; axis, float&amp; angle) const;
+		/*! @name Accessing values */
+		//@{
+		Vec axis() const;
+		float angle() const;
+		void getAxisAngle(Vec&amp; axis, float&amp; angle) const;
 
-  /*! Bracket operator, with a constant return value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
-  double operator[](int i) const { return q[i]; }
+		/*! Bracket operator, with a constant return value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
+		double operator[](int i) const { return q[i]; }
 
-  /*! Bracket operator returning an l-value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
-  double&amp; operator[](int i) { return q[i]; }
-  //@}
+		/*! Bracket operator returning an l-value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
+		double&amp; operator[](int i) { return q[i]; }
+		//@}
 
 
-  /*! @name Rotation computations */
-  //@{
-  /*! Returns the composition of the \p a and \p b rotations.
+		/*! @name Rotation computations */
+		//@{
+		/*! Returns the composition of the \p a and \p b rotations.
 
-  The order is important. When applied to a Vec \c v (see operator*(const Quaternion&amp;, const Vec&amp;)
-  and rotate()) the resulting Quaternion acts as if \p b was applied first and then \p a was
-  applied. This is obvious since the image \c v' of \p v by the composited rotation satisfies: \code
-  v'= (a*b) * v = a * (b*v) \endcode
+		The order is important. When applied to a Vec \c v (see operator*(const Quaternion&amp;, const Vec&amp;)
+		and rotate()) the resulting Quaternion acts as if \p b was applied first and then \p a was
+		applied. This is obvious since the image \c v' of \p v by the composited rotation satisfies: \code
+		v'= (a*b) * v = a * (b*v) \endcode
 
-  Note that a*b usually differs from b*a.
+		Note that a*b usually differs from b*a.
 
-  \attention For efficiency reasons, the resulting Quaternion is not normalized. Use normalize() in
-  case of numerical drift with small rotation composition. */
-  friend Quaternion operator*(const Quaternion&amp; a, const Quaternion&amp; b)
-  {
-    return Quaternion(a.q[3]*b.q[0] + b.q[3]*a.q[0] + a.q[1]*b.q[2] - a.q[2]*b.q[1],
-		      a.q[3]*b.q[1] + b.q[3]*a.q[1] + a.q[2]*b.q[0] - a.q[0]*b.q[2],
-		      a.q[3]*b.q[2] + b.q[3]*a.q[2] + a.q[0]*b.q[1] - a.q[1]*b.q[0],
-		      a.q[3]*b.q[3] - b.q[0]*a.q[0] - a.q[1]*b.q[1] - a.q[2]*b.q[2]);
-  }
+		\attention For efficiency reasons, the resulting Quaternion is not normalized. Use normalize() in
+		case of numerical drift with small rotation composition. */
+		friend Quaternion operator*(const Quaternion&amp; a, const Quaternion&amp; b)
+		{
+			return Quaternion(a.q[3]*b.q[0] + b.q[3]*a.q[0] + a.q[1]*b.q[2] - a.q[2]*b.q[1],
+				a.q[3]*b.q[1] + b.q[3]*a.q[1] + a.q[2]*b.q[0] - a.q[0]*b.q[2],
+				a.q[3]*b.q[2] + b.q[3]*a.q[2] + a.q[0]*b.q[1] - a.q[1]*b.q[0],
+				a.q[3]*b.q[3] - b.q[0]*a.q[0] - a.q[1]*b.q[1] - a.q[2]*b.q[2]);
+		}
 
-  /*! Quaternion rotation is composed with \p q.
+		/*! Quaternion rotation is composed with \p q.
 
-  See operator*(), since this is equivalent to \c this = \c this * \p q.
+		See operator*(), since this is equivalent to \c this = \c this * \p q.
 
-  \note For efficiency reasons, the resulting Quaternion is not normalized.
-  You may normalize() it after each application in case of numerical drift. */
-  Quaternion&amp; operator*=(const Quaternion &amp;q)
-  {
-    *this = (*this)*q;
-    return *this;
-  }
+		\note For efficiency reasons, the resulting Quaternion is not normalized.
+		You may normalize() it after each application in case of numerical drift. */
+		Quaternion&amp; operator*=(const Quaternion &amp;q)
+		{
+			*this = (*this)*q;
+			return *this;
+		}
 
-  /*! Returns the image of \p v by the rotation \p q.
+		/*! Returns the image of \p v by the rotation \p q.
 
-  Same as q.rotate(v). See rotate() and inverseRotate(). */
-  friend Vec operator*(const Quaternion&amp; q, const Vec&amp; v)
-  {
-    return q.rotate(v);
-  }
+		Same as q.rotate(v). See rotate() and inverseRotate(). */
+		friend Vec operator*(const Quaternion&amp; q, const Vec&amp; v)
+		{
+			return q.rotate(v);
+		}
 
-  Vec rotate(const Vec&amp; v) const;
-  Vec inverseRotate(const Vec&amp; v) const;
-  //@}
+		Vec rotate(const Vec&amp; v) const;
+		Vec inverseRotate(const Vec&amp; v) const;
+		//@}
 
 
-  /*! @name Inversion */
-  //@{
-  /*! Returns the inverse Quaternion (inverse rotation).
+		/*! @name Inversion */
+		//@{
+		/*! Returns the inverse Quaternion (inverse rotation).
 
-  Result has a negated axis() direction and the same angle(). A composition (see operator*()) of a
-  Quaternion and its inverse() results in an identity function.
+		Result has a negated axis() direction and the same angle(). A composition (see operator*()) of a
+		Quaternion and its inverse() results in an identity function.
 
-  Use invert() to actually modify the Quaternion. */
-  Quaternion inverse() const { return Quaternion(-q[0], -q[1], -q[2], q[3]); }
+		Use invert() to actually modify the Quaternion. */
+		Quaternion inverse() const { return Quaternion(-q[0], -q[1], -q[2], q[3]); }
 
-  /*! Inverses the Quaternion (same rotation angle(), but negated axis()).
+		/*! Inverses the Quaternion (same rotation angle(), but negated axis()).
 
-  See also inverse(). */
-  void invert() { q[0] = -q[0]; q[1] = -q[1]; q[2] = -q[2]; }
+		See also inverse(). */
+		void invert() { q[0] = -q[0]; q[1] = -q[1]; q[2] = -q[2]; }
 
-  /*! Negates all the coefficients of the Quaternion.
+		/*! Negates all the coefficients of the Quaternion.
 
-  This results in an other representation of the \e same rotation (opposite rotation angle, but with
-  a negated axis direction: the two cancel out). However, note that the results of axis() and
-  angle() are unchanged after a call to this method since angle() always returns a value in [0,pi].
+		This results in an other representation of the \e same rotation (opposite rotation angle, but with
+		a negated axis direction: the two cancel out). However, note that the results of axis() and
+		angle() are unchanged after a call to this method since angle() always returns a value in [0,pi].
 
-  This method is mainly useful for Quaternion interpolation, so that the spherical
-  interpolation takes the shortest path on the unit sphere. See slerp() for details. */
-  void negate() { invert(); q[3] = -q[3]; }
+		This method is mainly useful for Quaternion interpolation, so that the spherical
+		interpolation takes the shortest path on the unit sphere. See slerp() for details. */
+		void negate() { invert(); q[3] = -q[3]; }
 
-  /*! Normalizes the Quaternion coefficients.
+		/*! Normalizes the Quaternion coefficients.
 
-  This method should not need to be called since we only deal with unit Quaternions. This is however
-  useful to prevent numerical drifts, especially with small rotational increments. See also
-  normalized(). */
-  double normalize()
-  {
-    const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
-    for (int i=0; i&lt;4; ++i)
-      q[i] /= norm;
-    return norm;
-  }
+		This method should not need to be called since we only deal with unit Quaternions. This is however
+		useful to prevent numerical drifts, especially with small rotational increments. See also
+		normalized(). */
+		double normalize()
+		{
+			const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
+			for (int i=0; i&lt;4; ++i)
+				q[i] /= norm;
+			return norm;
+		}
 
-  /*! Returns a normalized version of the Quaternion.
+		/*! Returns a normalized version of the Quaternion.
 
-  See also normalize(). */
-  Quaternion normalized() const
-  {
-    double Q[4];
-    const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
-    for (int i=0; i&lt;4; ++i)
-      Q[i] = q[i] / norm;
-    return Quaternion(Q[0], Q[1], Q[2], Q[3]);
-  }
-//@}
+		See also normalize(). */
+		Quaternion normalized() const
+		{
+			double Q[4];
+			const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
+			for (int i=0; i&lt;4; ++i)
+				Q[i] = q[i] / norm;
+			return Quaternion(Q[0], Q[1], Q[2], Q[3]);
+		}
+		//@}
 
 
-  /*! @name Associated matrix */
-  //@{
-  const GLdouble* matrix() const;
-  void getMatrix(GLdouble m[4][4]) const;
-  void getMatrix(GLdouble m[16]) const;
+		/*! @name Associated matrix */
+		//@{
+		const GLdouble* matrix() const;
+		void getMatrix(GLdouble m[4][4]) const;
+		void getMatrix(GLdouble m[16]) const;
 
-  void getRotationMatrix(float m[3][3]) const;
+		void getRotationMatrix(float m[3][3]) const;
 
-  const GLdouble* inverseMatrix() const;
-  void getInverseMatrix(GLdouble m[4][4]) const;
-  void getInverseMatrix(GLdouble m[16]) const;
+		const GLdouble* inverseMatrix() const;
+		void getInverseMatrix(GLdouble m[4][4]) const;
+		void getInverseMatrix(GLdouble m[16]) const;
 
-  void getInverseRotationMatrix(float m[3][3]) const;
-  //@}
+		void getInverseRotationMatrix(float m[3][3]) const;
+		//@}
 
 
-  /*! @name Slerp interpolation */
-  //@{
-  static Quaternion slerp(const Quaternion&amp; a, const Quaternion&amp; b, float t, bool allowFlip=true);
-  static Quaternion squad(const Quaternion&amp; a, const Quaternion&amp; tgA, const Quaternion&amp; tgB, const Quaternion&amp; b, float t);
-  /*! Returns the &quot;dot&quot; product of \p a and \p b: a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]. */
-  static double dot(const Quaternion&amp; a, const Quaternion&amp; b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]; }
+		/*! @name Slerp interpolation */
+		//@{
+		static Quaternion slerp(const Quaternion&amp; a, const Quaternion&amp; b, float t, bool allowFlip=true);
+		static Quaternion squad(const Quaternion&amp; a, const Quaternion&amp; tgA, const Quaternion&amp; tgB, const Quaternion&amp; b, float t);
+		/*! Returns the &quot;dot&quot; product of \p a and \p b: a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]. */
+		static double dot(const Quaternion&amp; a, const Quaternion&amp; b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]; }
 
-  Quaternion log();
-  Quaternion exp();
-  static Quaternion lnDif(const Quaternion&amp; a, const Quaternion&amp; b);
-  static Quaternion squadTangent(const Quaternion&amp; before, const Quaternion&amp; center, const Quaternion&amp; after);
-  //@}
+		Quaternion log();
+		Quaternion exp();
+		static Quaternion lnDif(const Quaternion&amp; a, const Quaternion&amp; b);
+		static Quaternion squadTangent(const Quaternion&amp; before, const Quaternion&amp; center, const Quaternion&amp; after);
+		//@}
 
-  /*! @name Random Quaternion */
-  //@{
-  static Quaternion randomQuaternion();
-  //@}
+		/*! @name Random Quaternion */
+		//@{
+		static Quaternion randomQuaternion();
+		//@}
 
-  /*! @name XML representation */
-  //@{
-  explicit Quaternion(const QDomElement&amp; element);
-  QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
-  void initFromDOMElement(const QDomElement&amp; element);
-  //@}
+		/*! @name XML representation */
+		//@{
+		explicit Quaternion(const QDomElement&amp; element);
+		QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+		void initFromDOMElement(const QDomElement&amp; element);
+		//@}
 
 #ifdef DOXYGEN
-  /*! @name Output stream */
-  //@{
-  /*! Output stream operator. Enables debugging code like:
-  \code
-  Quaternion rot(...);
-  cout &lt;&lt; &quot;Rotation=&quot; &lt;&lt; rot &lt;&lt; endl;
-  \endcode */
-  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Vec&amp;);
-  //@}
+		/*! @name Output stream */
+		//@{
+		/*! Output stream operator. Enables debugging code like:
+		\code
+		Quaternion rot(...);
+		cout &lt;&lt; &quot;Rotation=&quot; &lt;&lt; rot &lt;&lt; endl;
+		\endcode */
+		std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Vec&amp;);
+		//@}
 #endif
 
-private:
-  /*! The internal data representation is private, use operator[] to access values. */
-  double q[4];
-};
+	private:
+		/*! The internal data representation is private, use operator[] to access values. */
+		double q[4];
+	};
 
 } // namespace
 

Modified: trunk/lib/QGLViewer/saveSnapshot.cpp
===================================================================
--- trunk/lib/QGLViewer/saveSnapshot.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/saveSnapshot.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/vec.cpp
===================================================================
--- trunk/lib/QGLViewer/vec.cpp	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/vec.cpp	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 

Modified: trunk/lib/QGLViewer/vec.h
===================================================================
--- trunk/lib/QGLViewer/vec.h	2008-07-18 06:36:09 UTC (rev 1433)
+++ trunk/lib/QGLViewer/vec.h	2008-07-18 06:54:48 UTC (rev 1434)
@@ -3,7 +3,7 @@
  Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
 
  This file is part of the QGLViewer library.
- Version 2.2.6-3, released on August 28, 2007.
+ Version 2.3.0, released on June 29, 2008.
 
  <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000393.html">[Yade-commits] r1433 - in trunk: extra gui/py gui/qt3	pkg/common/Engine/StandAloneEngine
</A></li>
	<LI>Next message: <A HREF="000395.html">[Yade-commits] r1435 - in trunk: core gui/py gui/qt3	pkg/common/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#394">[ date ]</a>
              <a href="thread.html#394">[ thread ]</a>
              <a href="subject.html#394">[ subject ]</a>
              <a href="author.html#394">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
