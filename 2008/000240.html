<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1274 - in trunk: . extra/clump extra/usct gui	gui/cmd gui/qt3 lib lib/QGLViewer lib/QGLViewer/VRender	pkg/common pkg/common/Engine/DeusExMachina	pkg/dem/Engine/DeusExMachina scripts
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1274%20-%20in%20trunk%3A%20.%20extra/clump%20extra/usct%20gui%0A%09gui/cmd%20gui/qt3%20lib%20lib/QGLViewer%20lib/QGLViewer/VRender%0A%09pkg/common%20pkg/common/Engine/DeusExMachina%0A%09pkg/dem/Engine/DeusExMachina%20scripts&In-Reply-To=%3C200803131914.m2DJEjfx015684%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000238.html">
   <LINK REL="Next"  HREF="000239.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1274 - in trunk: . extra/clump extra/usct gui	gui/cmd gui/qt3 lib lib/QGLViewer lib/QGLViewer/VRender	pkg/common pkg/common/Engine/DeusExMachina	pkg/dem/Engine/DeusExMachina scripts</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1274%20-%20in%20trunk%3A%20.%20extra/clump%20extra/usct%20gui%0A%09gui/cmd%20gui/qt3%20lib%20lib/QGLViewer%20lib/QGLViewer/VRender%0A%09pkg/common%20pkg/common/Engine/DeusExMachina%0A%09pkg/dem/Engine/DeusExMachina%20scripts&In-Reply-To=%3C200803131914.m2DJEjfx015684%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1274 - in trunk: . extra/clump extra/usct gui	gui/cmd gui/qt3 lib lib/QGLViewer lib/QGLViewer/VRender	pkg/common pkg/common/Engine/DeusExMachina	pkg/dem/Engine/DeusExMachina scripts">eudoxos at mail.berlios.de
       </A><BR>
    <I>Thu Mar 13 20:14:45 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000238.html">[Yade-commits] r1273 - in trunk: .	pkg/common/Engine/StandAloneEngine
</A></li>
        <LI>Next message: <A HREF="000239.html">[Yade-commits] r1275 - in trunk: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#240">[ date ]</a>
              <a href="thread.html#240">[ thread ]</a>
              <a href="subject.html#240">[ subject ]</a>
              <a href="author.html#240">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2008-03-13 20:14:29 +0100 (Thu, 13 Mar 2008)
New Revision: 1274

Added:
   trunk/gui/cmd/GLViewer4.cpp
   trunk/gui/cmd/GLViewer4.hpp
   trunk/lib/QGLViewer/
   trunk/lib/QGLViewer/ImageInterface.Qt3.cpp
   trunk/lib/QGLViewer/ImageInterface.Qt3.ui
   trunk/lib/QGLViewer/ImageInterface.Qt4.ui
   trunk/lib/QGLViewer/README
   trunk/lib/QGLViewer/VRender/
   trunk/lib/QGLViewer/VRender/AxisAlignedBox.h
   trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp
   trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp
   trunk/lib/QGLViewer/VRender/EPSExporter.cpp
   trunk/lib/QGLViewer/VRender/Exporter.cpp
   trunk/lib/QGLViewer/VRender/Exporter.h
   trunk/lib/QGLViewer/VRender/FIGExporter.cpp
   trunk/lib/QGLViewer/VRender/NVector3.cpp
   trunk/lib/QGLViewer/VRender/NVector3.h
   trunk/lib/QGLViewer/VRender/Optimizer.h
   trunk/lib/QGLViewer/VRender/ParserGL.cpp
   trunk/lib/QGLViewer/VRender/ParserGL.h
   trunk/lib/QGLViewer/VRender/Primitive.cpp
   trunk/lib/QGLViewer/VRender/Primitive.h
   trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp
   trunk/lib/QGLViewer/VRender/PrimitivePositioning.h
   trunk/lib/QGLViewer/VRender/SortMethod.h
   trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp
   trunk/lib/QGLViewer/VRender/Types.h
   trunk/lib/QGLViewer/VRender/VRender.cpp
   trunk/lib/QGLViewer/VRender/VRender.h
   trunk/lib/QGLViewer/VRender/Vector2.cpp
   trunk/lib/QGLViewer/VRender/Vector2.h
   trunk/lib/QGLViewer/VRender/Vector3.cpp
   trunk/lib/QGLViewer/VRender/Vector3.h
   trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp
   trunk/lib/QGLViewer/VRender/gpc.cpp
   trunk/lib/QGLViewer/VRender/gpc.h
   trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp
   trunk/lib/QGLViewer/VRenderInterface.Qt3.ui
   trunk/lib/QGLViewer/VRenderInterface.Qt4.ui
   trunk/lib/QGLViewer/camera.cpp
   trunk/lib/QGLViewer/camera.h
   trunk/lib/QGLViewer/config.h
   trunk/lib/QGLViewer/constraint.cpp
   trunk/lib/QGLViewer/constraint.h
   trunk/lib/QGLViewer/domUtils.h
   trunk/lib/QGLViewer/frame.cpp
   trunk/lib/QGLViewer/frame.h
   trunk/lib/QGLViewer/keyFrameInterpolator.cpp
   trunk/lib/QGLViewer/keyFrameInterpolator.h
   trunk/lib/QGLViewer/manipulatedCameraFrame.cpp
   trunk/lib/QGLViewer/manipulatedCameraFrame.h
   trunk/lib/QGLViewer/manipulatedFrame.cpp
   trunk/lib/QGLViewer/manipulatedFrame.h
   trunk/lib/QGLViewer/mouseGrabber.cpp
   trunk/lib/QGLViewer/mouseGrabber.h
   trunk/lib/QGLViewer/qglviewer-icon.xpm
   trunk/lib/QGLViewer/qglviewer.cpp
   trunk/lib/QGLViewer/qglviewer.cw
   trunk/lib/QGLViewer/qglviewer.h
   trunk/lib/QGLViewer/quaternion.cpp
   trunk/lib/QGLViewer/quaternion.h
   trunk/lib/QGLViewer/saveSnapshot.cpp
   trunk/lib/QGLViewer/vec.cpp
   trunk/lib/QGLViewer/vec.h
Removed:
   trunk/gui/qt3/GLEngineEditor.cpp
   trunk/gui/qt3/GLEngineEditor.cw
   trunk/gui/qt3/GLEngineEditor.hpp
   trunk/gui/qt3/GLSimulationPlayerViewer.cpp
   trunk/gui/qt3/GLSimulationPlayerViewer.cw
   trunk/gui/qt3/GLSimulationPlayerViewer.hpp
   trunk/gui/qt3/QtCodeGenerator.cpp
   trunk/gui/qt3/QtCodeGenerator.hpp
   trunk/gui/qt3/QtEngineEditor.cpp
   trunk/gui/qt3/QtEngineEditor.hpp
   trunk/gui/qt3/QtGeneratedCodeGenerator.ui
   trunk/gui/qt3/QtGeneratedEngineEditor.ui
   trunk/gui/qt3/QtGeneratedMetaDispatchingEngineProperties.ui
   trunk/gui/qt3/QtGeneratedPreferencesEditor.ui
   trunk/gui/qt3/QtGeneratedSimulationPlayer.ui
   trunk/gui/qt3/QtGeneratedSphericalDEMSimulator.ui
   trunk/gui/qt3/QtMetaDispatchingEngineProperties.cpp
   trunk/gui/qt3/QtMetaDispatchingEngineProperties.hpp
   trunk/gui/qt3/QtPreferencesEditor.cpp
   trunk/gui/qt3/QtPreferencesEditor.hpp
   trunk/gui/qt3/QtSimulationPlayer.cpp
   trunk/gui/qt3/QtSimulationPlayer.hpp
   trunk/gui/qt3/QtSphericalDEM.cpp
   trunk/gui/qt3/QtSphericalDEM.hpp
Modified:
   trunk/SConscript
   trunk/SConstruct
   trunk/extra/clump/Shop.cpp
   trunk/extra/clump/Shop.hpp
   trunk/extra/usct/UniaxialStrainControlledTest.cpp
   trunk/gui/SConscript
   trunk/gui/cmd/yadeControl.cpp
   trunk/gui/qt3/GLViewer.hpp
   trunk/lib/SConscript
   trunk/pkg/common/Engine/DeusExMachina/GravityEngine.cpp
   trunk/pkg/common/SConscript
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
   trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp
   trunk/scripts/default-test.py
Log:
1. BIG: Moved latest upstream qglviewer to our tree. If you REALLY need to use the packaged version, let me know. As of now, there is no way to do that.
2. BIG: Removed many (unfunctional) parts of the qt3 GUI, in the view of qt4 migration which will probably not happen. Maybe I removed too much (simulation player -- does it work?!), let me know in that case.
3. Experimental GLViewer support in python, disabled. (broken and needs qt4)
4. Misc fixes related to that and other small stuff.

Crash tests passing (except those 2, which is known).



Modified: trunk/SConscript
===================================================================
--- trunk/SConscript	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/SConscript	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,2 +1,2 @@
 Import('*')
-SConscript(dirs=env['yadeModules'])
+SConscript(dirs=env['yadeModules'],duplicate=1)

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/SConstruct	2008-03-13 19:14:29 UTC (rev 1274)
@@ -96,6 +96,7 @@
 	('CXXFLAGS','Additional compiler flags; you can use them for tuning like -march=pentium4.',None,None,Split), # not tested if really propagates
 	BoolOption('pretty',&quot;Don't show compiler command line (like the Linux kernel)&quot;,1),
 	BoolOption('useMiniWm3','use local miniWm3 library instead of Wm3Foundation',1),
+	#BoolOption('useLocalQGLViewer','use in-tree QGLViewer library instead of the one installed in system',1),
 )
 
 ### create THE environment
@@ -144,6 +145,7 @@
 buildInc='$buildDir/include/yade-$version'
 env.Append(CPPPATH=[buildInc])
 if env['useMiniWm3']: env.Append(CPPPATH=[buildInc+'/yade/lib-miniWm3'])
+#if env['useLocalQGLViewer']: env.Append(CPPPATH=[buildInc+'/yade/lib-QGLViewer'])
 
 if env.GetOption('clean'):
 	print &quot;Removing build directory `%s'&quot;%buildDir
@@ -240,13 +242,17 @@
 	if 'qt3' not in env['exclude']:
 		ok&amp;=conf.CheckQt(env['QTDIR'])
 		env.Tool('qt'); env.Replace(QT_LIB='qt-mt')
+		env['QGLVIEWER_LIB']='yade-QGLViewer';
 		# one or another (QGLViewer is upstream name, 3dviewer is (teomporary) workaround for clashing name with obsolete package once in debian)
 		# (this one has to be explicitly mentioned for each plugin that uses it, no autoadd)
-		if conf.CheckLibWithHeader('QGLViewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='QGLViewer'
-		elif conf.CheckLibWithHeader('qglviewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='qglviewer'
-		elif conf.CheckLibWithHeader('3dviewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='3dviewer'
-		else: ok=False
-	
+		#if env['useLocalQGLViewer']:
+		#	env['QGLVIEWER_LIB']='yade-QGLViewer';
+		#else:
+		#	if conf.CheckLibWithHeader('QGLViewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='QGLViewer'
+		#	elif conf.CheckLibWithHeader('qglviewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='qglviewer'
+		#	elif conf.CheckLibWithHeader('3dviewer','QGLViewer/qglviewer.h','c++','QGLViewer(1);'): env['QGLVIEWER_LIB']='3dviewer'
+		#	else: ok=False
+		#	if ok: print &quot;!!! WARNING\n!!! Using system QGLViewer is not very well tested \n!!! and if there is version mismatch, wrong headers may be included.\n!!! If you get mysterious crashes, look here for cause. &quot;
 
 	if not ok:
 		print &quot;\nOne of the essential libraries above was not found, unable to continue.\n\nCheck `%s' for possible causes, note that there are options that you may need to customize:\n\n&quot;%(buildDir+'/config.log')+opts.GenerateHelpText(env)

Modified: trunk/extra/clump/Shop.cpp
===================================================================
--- trunk/extra/clump/Shop.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/extra/clump/Shop.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -435,6 +435,633 @@
 }
 
 
+vector&lt;pair&lt;Vector3r,Real&gt; &gt; Shop::loadSpheresSmallSdecXyz(Vector3r&amp; minXYZ, Vector3r&amp; maxXYZ){
+	int i=0;
+	vector&lt;pair&lt;Vector3r,Real&gt; &gt; spheres;
+	while(Shop::smallSdecXyzData[i].r&lt;0){
+		Vector3r C(smallSdecXyzData[i].C0,smallSdecXyzData[i].C1,smallSdecXyzData[i].C2); Real r(smallSdecXyzData[i].r);
+		for(int j=0; j&lt;3; j++) { minXYZ[j]=(spheres.size()&gt;0?min(C[j]-r,minXYZ[j]):C[j]-r); maxXYZ[j]=(spheres.size()&gt;0?max(C[j]+r,maxXYZ[j]):C[j]+r);}
+		spheres.push_back(pair&lt;Vector3r,Real&gt;(C,r));
+	}
+	return spheres;
+}
+
+Shop::sphereGeomStruct Shop::smallSdecXyzData[]={
+	{0.027814,0.028311,0.053055,0.006921},
+	{0.040115,0.039488,0.051634,0.009072},
+	{0.014935,0.042338,0.065370,0.014248},
+	{0.040157,0.020724,0.049777,0.007933},
+	{0.054315,0.030277,0.034105,0.015247},
+	{0.084782,0.035042,0.040466,0.006506},
+	{0.063445,0.049730,0.067288,0.011911},
+	{0.068606,0.025283,0.065262,0.012022},
+	{0.088031,0.014291,0.039471,0.014521},
+	{0.116754,0.037915,0.051292,0.008274},
+	{0.100791,0.035164,0.067461,0.013108},
+	{0.114599,0.012268,0.055589,0.015359},
+	{0.138767,0.018895,0.036148,0.009280},
+	{0.145595,0.044496,0.031125,0.015939},
+	{0.132246,0.042180,0.051209,0.007763},
+	{0.143392,0.023461,0.060496,0.015920},
+	{0.171105,0.022212,0.032836,0.012108},
+	{0.181104,0.037549,0.046727,0.010873},
+	{0.166356,0.047869,0.055943,0.008384},
+	{0.182075,0.018453,0.050915,0.008701},
+	{0.199011,0.025231,0.029222,0.016017},
+	{0.223922,0.034850,0.046495,0.009033},
+	{0.201425,0.039383,0.074087,0.010160},
+	{0.208859,0.020393,0.059165,0.015109},
+	{0.247185,0.029358,0.040632,0.009137},
+	{0.256247,0.054160,0.035898,0.007448},
+	{0.241821,0.048789,0.051785,0.013900},
+	{0.262536,0.027938,0.052724,0.007258},
+	{0.266457,0.015729,0.044737,0.007849},
+	{0.300361,0.040203,0.038619,0.010238},
+	{0.269716,0.038512,0.048249,0.006284},
+	{0.284778,0.015856,0.057268,0.010625},
+	{0.308568,0.015046,0.037486,0.015678},
+	{0.324288,0.040734,0.028459,0.015762},
+	{0.312379,0.037454,0.070796,0.013332},
+	{0.325630,0.017879,0.071709,0.009211},
+	{0.337472,0.021731,0.049983,0.015831},
+	{0.363910,0.040206,0.054198,0.013145},
+	{0.347960,0.050663,0.050631,0.006258},
+	{0.353319,0.027257,0.066410,0.007567},
+	{0.382606,0.035870,0.041879,0.009000},
+	{0.403064,0.040715,0.052848,0.013380},
+	{0.378583,0.049140,0.071144,0.009526},
+	{0.392096,0.013326,0.048449,0.016326},
+	{0.419694,0.020328,0.050734,0.012238},
+	{0.435554,0.040547,0.055823,0.013440},
+	{0.416138,0.032889,0.071377,0.008786},
+	{0.438445,0.022231,0.064865,0.007190},
+	{0.449096,0.034012,0.035415,0.006513},
+	{0.465516,0.041105,0.049831,0.016459},
+	{0.451849,0.034788,0.071794,0.010092},
+	{0.470798,0.014474,0.061308,0.013016},
+	{0.022520,0.051083,0.034275,0.015762},
+	{0.051991,0.077988,0.036367,0.009543},
+	{0.020986,0.077522,0.050688,0.015394},
+	{0.045377,0.061146,0.050244,0.013259},
+	{0.070165,0.058855,0.037378,0.014762},
+	{0.079072,0.088030,0.037625,0.009745},
+	{0.070175,0.083486,0.059729,0.008680},
+	{0.080809,0.052527,0.057405,0.008263},
+	{0.102876,0.053069,0.047621,0.012600},
+	{0.129932,0.071275,0.041493,0.015762},
+	{0.100905,0.082761,0.049471,0.015577},
+	{0.114885,0.069784,0.065561,0.008883},
+	{0.124029,0.048642,0.037433,0.006910},
+	{0.151400,0.072980,0.032672,0.007510},
+	{0.125754,0.087963,0.056533,0.007065},
+	{0.151978,0.057727,0.065740,0.009624},
+	{0.170038,0.050106,0.034273,0.009151},
+	{0.180330,0.067662,0.044758,0.013741},
+	{0.163195,0.080867,0.050099,0.008542},
+	{0.193257,0.052669,0.058994,0.009924},
+	{0.213500,0.053456,0.046639,0.012293},
+	{0.214894,0.078031,0.032394,0.009344},
+	{0.204112,0.073752,0.062427,0.013778},
+	{0.209893,0.055436,0.071207,0.007226},
+	{0.229179,0.063602,0.037779,0.008378},
+	{0.253466,0.070318,0.046778,0.010045},
+	{0.243394,0.085523,0.061896,0.013644},
+	{0.268095,0.055682,0.049778,0.010865},
+	{0.272490,0.056346,0.032166,0.007300},
+	{0.293444,0.075937,0.050821,0.007124},
+	{0.268497,0.087864,0.061002,0.010071},
+	{0.285287,0.053447,0.056283,0.007652},
+	{0.303399,0.065465,0.032905,0.015762},
+	{0.331186,0.075873,0.030308,0.014024},
+	{0.305661,0.077322,0.067721,0.013776},
+	{0.321014,0.057758,0.055215,0.012434},
+	{0.340583,0.055745,0.032542,0.006766},
+	{0.363513,0.081185,0.053753,0.009367},
+	{0.342074,0.072811,0.056793,0.013501},
+	{0.362170,0.061143,0.054690,0.007397},
+	{0.370272,0.074686,0.039972,0.007302},
+	{0.402953,0.071810,0.034403,0.012804},
+	{0.382151,0.086219,0.067255,0.009054},
+	{0.382421,0.059723,0.048574,0.013805},
+	{0.418492,0.059752,0.050291,0.011257},
+	{0.431649,0.077456,0.029368,0.012777},
+	{0.423405,0.082143,0.054675,0.011680},
+	{0.438239,0.060029,0.044749,0.009130},
+	{0.451129,0.062181,0.031179,0.009710},
+	{0.479146,0.076782,0.041030,0.013576},
+	{0.450502,0.080910,0.050514,0.015762},
+	{0.469945,0.064905,0.054090,0.006331},
+	{0.013563,0.097184,0.042932,0.007007},
+	{0.045430,0.112786,0.026860,0.013686},
+	{0.026238,0.108238,0.071820,0.008664},
+	{0.045567,0.084792,0.054663,0.010547},
+	{0.055851,0.098322,0.045255,0.008878},
+	{0.092159,0.113570,0.039595,0.014076},
+	{0.042022,0.114607,0.055621,0.014833},
+	{0.076167,0.098666,0.069346,0.010212},
+	{0.091668,0.095217,0.029729,0.006767},
+	{0.114684,0.116416,0.048755,0.009589},
+	{0.101121,0.106787,0.066807,0.014051},
+	{0.117768,0.092385,0.068330,0.006541},
+	{0.136812,0.102557,0.043292,0.008163},
+	{0.140060,0.121797,0.037341,0.012236},
+	{0.129633,0.101076,0.058761,0.006790},
+	{0.148062,0.103611,0.061993,0.009901},
+	{0.154918,0.097447,0.035701,0.011902},
+	{0.173991,0.107853,0.041188,0.010506},
+	{0.163383,0.113509,0.070590,0.007969},
+	{0.183313,0.096713,0.054555,0.008896},
+	{0.193900,0.091794,0.032836,0.015762},
+	{0.221431,0.105734,0.041347,0.016142},
+	{0.210572,0.112748,0.064643,0.009085},
+	{0.220128,0.094827,0.066506,0.011310},
+	{0.244598,0.102360,0.048021,0.008201},
+	{0.260796,0.107346,0.041782,0.007826},
+	{0.247778,0.114675,0.056955,0.007342},
+	{0.263854,0.105240,0.057300,0.008131},
+	{0.275329,0.080384,0.035952,0.016171},
+	{0.282596,0.108994,0.045510,0.014327},
+	{0.273227,0.123662,0.063561,0.010354},
+	{0.286850,0.088067,0.054854,0.007260},
+	{0.305680,0.088521,0.040830,0.008724},
+	{0.323658,0.122036,0.045958,0.009372},
+	{0.305577,0.108660,0.055999,0.010069},
+	{0.326432,0.092403,0.071328,0.010172},
+	{0.332822,0.094105,0.046980,0.010736},
+	{0.360057,0.114979,0.050602,0.008675},
+	{0.345196,0.113199,0.049286,0.006350},
+	{0.359002,0.099534,0.049942,0.006821},
+	{0.379041,0.093289,0.031702,0.012829},
+	{0.380592,0.110656,0.050707,0.012044},
+	{0.372838,0.103784,0.069441,0.009079},
+	{0.398837,0.089939,0.069654,0.008117},
+	{0.404951,0.099259,0.042662,0.015929},
+	{0.430865,0.122250,0.034910,0.014087},
+	{0.408865,0.117363,0.058603,0.007815},
+	{0.433797,0.100725,0.068087,0.010539},
+	{0.451913,0.097993,0.031985,0.009479},
+	{0.468554,0.117154,0.051922,0.008497},
+	{0.450291,0.108384,0.052179,0.011764},
+	{0.468896,0.094189,0.071862,0.008497},
+	{0.017769,0.123023,0.046288,0.012482},
+	{0.039600,0.152973,0.031490,0.013071},
+	{0.022486,0.159910,0.058277,0.006730},
+	{0.053035,0.135514,0.059822,0.006873},
+	{0.060820,0.135597,0.032391,0.009756},
+	{0.075793,0.140311,0.044451,0.007184},
+	{0.059415,0.151698,0.048706,0.013209},
+	{0.075397,0.146441,0.067826,0.009066},
+	{0.096374,0.134144,0.029818,0.009090},
+	{0.114668,0.150443,0.049586,0.009896},
+	{0.098456,0.146495,0.056580,0.008196},
+	{0.115068,0.135950,0.063642,0.006871},
+	{0.120480,0.129505,0.039205,0.007619},
+	{0.156971,0.148691,0.034191,0.009631},
+	{0.137556,0.146645,0.052913,0.006461},
+	{0.141950,0.131573,0.059911,0.010688},
+	{0.168096,0.130776,0.044977,0.013464},
+	{0.181562,0.156313,0.051610,0.015347},
+	{0.157127,0.150002,0.051947,0.008174},
+	{0.193242,0.120660,0.050909,0.012412},
+	{0.201771,0.131287,0.031430,0.011359},
+	{0.221674,0.149773,0.053281,0.006817},
+	{0.205379,0.141341,0.053543,0.011532},
+	{0.224583,0.129576,0.068306,0.012332},
+	{0.238902,0.136528,0.043920,0.011950},
+	{0.258910,0.151108,0.049705,0.013475},
+	{0.232642,0.144977,0.060278,0.006814},
+	{0.257772,0.129747,0.049843,0.007917},
+	{0.272859,0.130994,0.031434,0.013547},
+	{0.298637,0.152991,0.041282,0.015762},
+	{0.278487,0.158034,0.062419,0.008408},
+	{0.294879,0.136446,0.061848,0.007854},
+	{0.305700,0.128154,0.049784,0.009982},
+	{0.317822,0.154906,0.054591,0.007666},
+	{0.313082,0.139892,0.064913,0.007314},
+	{0.318412,0.124214,0.060868,0.006584},
+	{0.345403,0.128047,0.055609,0.007438},
+	{0.364150,0.139196,0.044629,0.013056},
+	{0.335338,0.144636,0.042778,0.015825},
+	{0.370092,0.124629,0.059323,0.007443},
+	{0.381964,0.126156,0.033148,0.011118},
+	{0.405718,0.145022,0.044830,0.007344},
+	{0.384403,0.150897,0.061572,0.015826},
+	{0.394762,0.130323,0.049303,0.009909},
+	{0.418237,0.126941,0.051554,0.007327},
+	{0.427303,0.148241,0.032287,0.012279},
+	{0.408184,0.153492,0.057158,0.007815},
+	{0.434164,0.125257,0.064771,0.012118},
+	{0.445472,0.139238,0.049416,0.009855},
+	{0.469080,0.147719,0.054616,0.015762},
+	{0.446519,0.149106,0.070188,0.007289},
+	{0.463066,0.128741,0.072069,0.010712},
+	{0.030541,0.171854,0.034568,0.007470},
+	{0.036934,0.187996,0.038951,0.010436},
+	{0.017296,0.187394,0.069932,0.015775},
+	{0.045470,0.171678,0.064724,0.015762},
+	{0.056514,0.169207,0.032678,0.010404},
+	{0.079003,0.186246,0.029530,0.016079},
+	{0.059706,0.192913,0.050156,0.012943},
+	{0.081987,0.176494,0.057278,0.010079},
+	{0.098980,0.166199,0.053356,0.010173},
+	{0.117318,0.178623,0.040798,0.015290},
+	{0.102820,0.182572,0.068939,0.007422},
+	{0.119261,0.172887,0.062372,0.007118},
+	{0.134901,0.165613,0.030499,0.008886},
+	{0.147868,0.177545,0.033698,0.009023},
+	{0.136653,0.175577,0.056404,0.008907},
+	{0.141868,0.158596,0.054271,0.006316},
+	{0.165708,0.172844,0.039254,0.010243},
+	{0.182639,0.183677,0.050062,0.011541},
+	{0.165084,0.185889,0.065932,0.012227},
+	{0.180948,0.173447,0.066522,0.007376},
+	{0.196132,0.172251,0.035240,0.011530},
+	{0.227201,0.182137,0.045706,0.008997},
+	{0.204299,0.184844,0.052950,0.010342},
+	{0.225988,0.175305,0.062124,0.008828},
+	{0.237177,0.160547,0.051402,0.009195},
+	{0.261161,0.186504,0.033019,0.015762},
+	{0.241624,0.187436,0.069292,0.007769},
+	{0.257173,0.165912,0.069549,0.008701},
+	{0.275377,0.158582,0.034952,0.008984},
+	{0.288726,0.191148,0.034408,0.009808},
+	{0.271403,0.185700,0.067431,0.011799},
+	{0.284218,0.172191,0.051535,0.010347},
+	{0.306049,0.174027,0.032682,0.007870},
+	{0.316942,0.179608,0.046528,0.010610},
+	{0.313026,0.194025,0.059273,0.009027},
+	{0.316419,0.168708,0.067588,0.006369},
+	{0.344253,0.166378,0.030810,0.010546},
+	{0.367887,0.186357,0.033459,0.007112},
+	{0.358319,0.179340,0.050728,0.013841},
+	{0.366596,0.160155,0.045909,0.007602},
+	{0.383817,0.160452,0.034727,0.012399},
+	{0.396469,0.185253,0.029237,0.015979},
+	{0.377815,0.185629,0.073245,0.013364},
+	{0.396205,0.166460,0.049105,0.007346},
+	{0.413309,0.167440,0.053605,0.007275},
+	{0.434009,0.184506,0.031699,0.013620},
+	{0.411121,0.187057,0.053929,0.011981},
+	{0.435082,0.168647,0.049551,0.010284},
+	{0.451053,0.158269,0.035414,0.012610},
+	{0.470872,0.191256,0.051955,0.013847},
+	{0.447897,0.178522,0.059981,0.008314},
+	{0.465203,0.170594,0.069944,0.011281},
+	{0.018220,0.199513,0.032480,0.012472},
+	{0.043929,0.213054,0.038912,0.014059},
+	{0.022453,0.225231,0.059937,0.012276},
+	{0.039438,0.194934,0.058858,0.008970},
+	{0.062291,0.203776,0.030515,0.008161},
+	{0.067233,0.212277,0.050888,0.007657},
+	{0.063555,0.218942,0.074236,0.011822},
+	{0.086676,0.195765,0.056391,0.009775},
+	{0.100062,0.203963,0.032083,0.010760},
+	{0.123439,0.223656,0.039869,0.007878},
+	{0.087363,0.218666,0.047798,0.013687},
+	{0.109855,0.201133,0.048087,0.008215},
+	{0.129021,0.205306,0.043706,0.011683},
+	{0.157516,0.221570,0.036912,0.010458},
+	{0.126303,0.227505,0.059162,0.010490},
+	{0.143861,0.194185,0.066210,0.010561},
+	{0.172910,0.201043,0.033978,0.013203},
+	{0.185035,0.221440,0.045513,0.013181},
+	{0.168070,0.220355,0.072675,0.009360},
+	{0.180093,0.198384,0.061991,0.007046},
+	{0.208314,0.209539,0.044961,0.009495},
+	{0.220276,0.226073,0.034315,0.013522},
+	{0.202082,0.218715,0.068875,0.006812},
+	{0.227664,0.201788,0.056524,0.012609},
+	{0.232983,0.200019,0.028712,0.015762},
+	{0.256565,0.219723,0.031699,0.007469},
+	{0.227652,0.224321,0.057241,0.006644},
+	{0.254299,0.203686,0.071224,0.012930},
+	{0.262164,0.203438,0.047374,0.006460},
+	{0.291834,0.224737,0.049349,0.006948},
+	{0.268860,0.219381,0.069067,0.007715},
+	{0.289943,0.200233,0.060624,0.012722},
+	{0.301505,0.208536,0.039247,0.012306},
+	{0.322382,0.217100,0.051740,0.012086},
+	{0.314574,0.219134,0.070936,0.007251},
+	{0.325878,0.206084,0.069072,0.007512},
+	{0.344014,0.201827,0.047775,0.012892},
+	{0.351810,0.217320,0.036368,0.007867},
+	{0.338587,0.227804,0.063659,0.010701},
+	{0.356571,0.197024,0.069754,0.008434},
+	{0.376453,0.200295,0.047115,0.014105},
+	{0.394956,0.226437,0.029396,0.010725},
+	{0.378323,0.226833,0.061314,0.014536},
+	{0.389287,0.205171,0.066511,0.007194},
+	{0.416665,0.206194,0.024533,0.013492},
+	{0.438684,0.208898,0.032405,0.009490},
+	{0.404012,0.213687,0.050773,0.015762},
+	{0.439529,0.206631,0.054037,0.011117},
+	{0.452197,0.194638,0.042409,0.007397},
+	{0.478578,0.218454,0.044278,0.008032},
+	{0.461476,0.216922,0.055979,0.012027},
+	{0.472499,0.206672,0.070146,0.008643},
+	{0.031034,0.238557,0.044665,0.009415},
+	{0.046212,0.247434,0.048494,0.008580},
+	{0.029656,0.251629,0.061475,0.011572},
+	{0.046678,0.229877,0.059527,0.012161},
+	{0.060543,0.228584,0.035366,0.008957},
+	{0.081148,0.255496,0.031889,0.011593},
+	{0.066991,0.258165,0.055249,0.015762},
+	{0.078630,0.234901,0.067187,0.009147},
+	{0.093096,0.239315,0.031956,0.008521},
+	{0.123349,0.260861,0.042759,0.012372},
+	{0.097630,0.259258,0.071577,0.008194},
+	{0.104871,0.242539,0.055778,0.015789},
+	{0.130936,0.239003,0.044952,0.008368},
+	{0.153591,0.241938,0.041655,0.008205},
+	{0.143130,0.253503,0.053056,0.011112},
+	{0.158308,0.235817,0.066131,0.006732},
+	{0.169649,0.237061,0.031901,0.009847},
+	{0.177988,0.267639,0.051141,0.008419},
+	{0.168590,0.251903,0.050804,0.009913},
+	{0.187601,0.240303,0.056261,0.008679},
+	{0.202598,0.238631,0.030252,0.008355},
+	{0.221493,0.253090,0.049019,0.008616},
+	{0.198234,0.260140,0.040252,0.015762},
+	{0.221897,0.228125,0.071226,0.008950},
+	{0.236460,0.237179,0.031506,0.006307},
+	{0.246367,0.254381,0.050248,0.011434},
+	{0.230061,0.245247,0.060087,0.007429},
+	{0.243784,0.239481,0.061145,0.007205},
+	{0.270130,0.238534,0.030357,0.015762},
+	{0.292685,0.259379,0.051551,0.008561},
+	{0.270568,0.256201,0.053461,0.012554},
+	{0.288088,0.246768,0.065776,0.009704},
+	{0.307205,0.228427,0.050927,0.006869},
+	{0.321366,0.246094,0.045009,0.011972},
+	{0.314218,0.248123,0.067437,0.006555},
+	{0.317918,0.234420,0.056996,0.005112},
+	{0.345996,0.237475,0.032189,0.012907},
+	{0.358078,0.266408,0.046713,0.010906},
+	{0.341845,0.249863,0.050455,0.009550},
+	{0.352246,0.244796,0.066207,0.009874},
+	{0.370773,0.231259,0.033624,0.012678},
+	{0.389736,0.252726,0.029076,0.015191},
+	{0.374368,0.254883,0.060882,0.013568},
+	{0.399580,0.236433,0.066670,0.009396},
+	{0.419086,0.229820,0.030486,0.008709},
+	{0.431898,0.253013,0.026908,0.014166},
+	{0.424434,0.259566,0.058997,0.006353},
+	{0.425774,0.238512,0.052362,0.015762},
+	{0.449984,0.229928,0.034152,0.014447},
+	{0.468335,0.247681,0.035305,0.009986},
+	{0.446284,0.265609,0.058199,0.014044},
+	{0.479957,0.238820,0.056505,0.015762},
+	{0.016058,0.272296,0.031907,0.015903},
+	{0.043188,0.296346,0.035622,0.013645},
+	{0.020265,0.293955,0.054775,0.015873},
+	{0.041510,0.268037,0.070523,0.007849},
+	{0.062225,0.280373,0.040949,0.011078},
+	{0.086682,0.281592,0.035069,0.013702},
+	{0.069169,0.284177,0.059909,0.009020},
+	{0.085718,0.266880,0.066273,0.006910},
+	{0.097403,0.266171,0.048894,0.009477},
+	{0.107654,0.281428,0.038660,0.007576},
+	{0.088316,0.284050,0.066490,0.010354},
+	{0.113503,0.280552,0.060462,0.015014},
+	{0.122859,0.278804,0.036141,0.006759},
+	{0.142878,0.297979,0.037101,0.011706},
+	{0.133777,0.283064,0.049774,0.007955},
+	{0.154649,0.263474,0.065692,0.007507},
+	{0.169175,0.273460,0.031813,0.013607},
+	{0.179325,0.294941,0.051789,0.010091},
+	{0.165815,0.277188,0.064486,0.010220},
+	{0.192842,0.268948,0.065506,0.008519},
+	{0.203664,0.282860,0.030067,0.008961},
+	{0.221520,0.290705,0.031569,0.010600},
+	{0.204075,0.289620,0.057034,0.015762},
+	{0.217062,0.273218,0.067345,0.007561},
+	{0.236623,0.274054,0.029708,0.008988},
+	{0.259386,0.293049,0.032016,0.011916},
+	{0.240332,0.286268,0.050913,0.015762},
+	{0.252585,0.269128,0.068044,0.010690},
+	{0.277228,0.263086,0.036137,0.007242},
+	{0.297808,0.298823,0.038507,0.011507},
+	{0.273109,0.288314,0.070360,0.007871},
+	{0.283880,0.280089,0.053191,0.014002},
+	{0.311353,0.272674,0.042400,0.016116},
+	{0.318185,0.295940,0.050900,0.009579},
+	{0.300031,0.294218,0.056245,0.006682},
+	{0.324041,0.283074,0.063804,0.007747},
+	{0.338338,0.274337,0.045421,0.010405},
+	{0.366658,0.294673,0.036475,0.013011},
+	{0.345468,0.300165,0.061263,0.006730},
+	{0.371053,0.276011,0.062724,0.007746},
+	{0.382159,0.266197,0.045056,0.007040},
+	{0.385302,0.283479,0.044022,0.010008},
+	{0.382756,0.291084,0.070614,0.012573},
+	{0.403108,0.264928,0.054184,0.015762},
+	{0.419100,0.274729,0.031563,0.011467},
+	{0.437640,0.289426,0.049922,0.012611},
+	{0.416213,0.289680,0.065434,0.013463},
+	{0.425331,0.272106,0.052713,0.007637},
+	{0.454008,0.282624,0.038875,0.008275},
+	{0.483070,0.298139,0.038400,0.016342},
+	{0.446217,0.292641,0.069129,0.007245},
+	{0.473937,0.269688,0.049149,0.015337},
+	{0.027818,0.310268,0.030259,0.007775},
+	{0.037764,0.320592,0.051731,0.008781},
+	{0.016776,0.324398,0.064621,0.015762},
+	{0.043065,0.304671,0.073634,0.008404},
+	{0.060248,0.307914,0.031150,0.007448},
+	{0.077271,0.327681,0.031663,0.013927},
+	{0.055259,0.322950,0.050938,0.008327},
+	{0.079365,0.305257,0.051792,0.015762},
+	{0.095660,0.308012,0.031429,0.010463},
+	{0.103681,0.332264,0.031625,0.012290},
+	{0.089797,0.330875,0.053651,0.011579},
+	{0.102216,0.307408,0.054272,0.006891},
+	{0.135063,0.305375,0.051629,0.006373},
+	{0.146687,0.332542,0.040487,0.015166},
+	{0.119733,0.321591,0.052005,0.015762},
+	{0.139154,0.311001,0.062753,0.006747},
+	{0.166611,0.304212,0.025702,0.013467},
+	{0.179450,0.331099,0.030605,0.013540},
+	{0.168140,0.316792,0.050046,0.012886},
+	{0.181651,0.308754,0.061301,0.006449},
+	{0.196784,0.307080,0.030792,0.016081},
+	{0.215900,0.329030,0.028037,0.012976},
+	{0.194417,0.327273,0.054083,0.014566},
+	{0.222938,0.309720,0.049824,0.007765},
+	{0.236225,0.315755,0.036277,0.011069},
+	{0.259154,0.323023,0.045475,0.012979},
+	{0.229226,0.318793,0.058722,0.006414},
+	{0.263876,0.304803,0.055229,0.008220},
+	{0.280036,0.308037,0.046953,0.010221},
+	{0.289039,0.323201,0.031727,0.013078},
+	{0.277826,0.320270,0.068751,0.009886},
+	{0.281755,0.301785,0.064415,0.008406},
+	{0.311687,0.313114,0.034665,0.007177},
+	{0.321013,0.324686,0.029636,0.008514},
+	{0.307138,0.327658,0.072817,0.007383},
+	{0.319851,0.313892,0.064538,0.009449},
+	{0.333424,0.313519,0.041662,0.007831},
+	{0.360179,0.317042,0.032555,0.009090},
+	{0.345335,0.325054,0.051853,0.011632},
+	{0.356818,0.307255,0.054092,0.008452},
+	{0.376257,0.314516,0.044839,0.010566},
+	{0.404942,0.322076,0.039531,0.009398},
+	{0.377646,0.330732,0.066428,0.015762},
+	{0.393248,0.303006,0.052180,0.011230},
+	{0.414496,0.303557,0.046583,0.009348},
+	{0.429851,0.323348,0.043622,0.015876},
+	{0.411263,0.319949,0.059797,0.008998},
+	{0.432707,0.308279,0.070597,0.011926},
+	{0.453339,0.305155,0.030681,0.015166},
+	{0.467869,0.322571,0.052192,0.010042},
+	{0.449922,0.317745,0.059766,0.010027},
+	{0.461253,0.304033,0.060778,0.007790},
+	{0.021541,0.332873,0.040513,0.010232},
+	{0.038000,0.356554,0.031870,0.007826},
+	{0.032187,0.360165,0.053724,0.015074},
+	{0.051751,0.340670,0.059341,0.011595},
+	{0.050035,0.338842,0.039691,0.008214},
+	{0.074340,0.355322,0.033149,0.012791},
+	{0.064951,0.354774,0.051051,0.007431},
+	{0.073704,0.344766,0.063534,0.010807},
+	{0.090705,0.345601,0.029750,0.006412},
+	{0.113418,0.360863,0.031428,0.008821},
+	{0.096799,0.362099,0.049082,0.008369},
+	{0.107463,0.341185,0.072071,0.014400},
+	{0.121217,0.345472,0.047617,0.008563},
+	{0.151164,0.358997,0.045262,0.011416},
+	{0.135273,0.360729,0.057086,0.008467},
+	{0.150044,0.351765,0.063675,0.007622},
+	{0.167267,0.337703,0.045162,0.006559},
+	{0.185291,0.357837,0.029177,0.013202},
+	{0.174685,0.353137,0.051201,0.010915},
+	{0.182603,0.341175,0.071944,0.009153},
+	{0.199074,0.341536,0.033569,0.008593},
+	{0.223648,0.364790,0.032933,0.013250},
+	{0.206142,0.359909,0.070232,0.011880},
+	{0.218376,0.338725,0.063741,0.006775},
+	{0.235978,0.341262,0.044598,0.015762},
+	{0.248271,0.357981,0.028623,0.010326},
+	{0.239381,0.361261,0.054185,0.006676},
+	{0.262678,0.342288,0.073448,0.011112},
+	{0.270573,0.339357,0.051890,0.007719},
+	{0.291651,0.365260,0.034029,0.012619},
+	{0.278330,0.357467,0.061963,0.013218},
+	{0.287271,0.340846,0.047013,0.009740},
+	{0.311721,0.350588,0.047719,0.015762},
+	{0.329835,0.361562,0.031124,0.010858},
+	{0.308858,0.362142,0.074170,0.007884},
+	{0.318657,0.331854,0.062466,0.008662},
+	{0.334080,0.339898,0.036091,0.011614},
+	{0.361053,0.363146,0.028462,0.015405},
+	{0.342858,0.361137,0.049372,0.011564},
+	{0.357992,0.345258,0.056926,0.010458},
+	{0.376633,0.335585,0.028650,0.016006},
+	{0.388485,0.356145,0.042465,0.011050},
+	{0.367467,0.367712,0.056170,0.013400},
+	{0.398534,0.339188,0.050584,0.007905},
+	{0.410905,0.345867,0.031138,0.016090},
+	{0.433557,0.364385,0.032172,0.009789},
+	{0.414823,0.362718,0.050261,0.009697},
+	{0.425989,0.342978,0.064208,0.012469},
+	{0.446622,0.347487,0.046030,0.008548},
+	{0.463905,0.355130,0.053326,0.007996},
+	{0.447393,0.368651,0.049700,0.012945},
+	{0.474977,0.341544,0.046688,0.010746},
+	{0.019773,0.386775,0.049869,0.014542},
+	{0.049900,0.390242,0.042917,0.008807},
+	{0.022183,0.402617,0.069178,0.007405},
+	{0.034110,0.379357,0.068905,0.008232},
+	{0.067211,0.383096,0.027225,0.015626},
+	{0.078560,0.396236,0.052905,0.006480},
+	{0.068770,0.402250,0.062282,0.008351},
+	{0.075963,0.374658,0.055577,0.014744},
+	{0.104738,0.376287,0.048997,0.007889},
+	{0.119282,0.396959,0.048600,0.010216},
+	{0.096405,0.402327,0.056212,0.008008},
+	{0.107422,0.388063,0.061078,0.009161},
+	{0.131436,0.376425,0.038024,0.015884},
+	{0.148514,0.406019,0.048436,0.013951},
+	{0.132288,0.405409,0.061120,0.006654},
+	{0.151652,0.388678,0.066685,0.006268},
+	{0.169202,0.379342,0.050424,0.015870},
+	{0.188174,0.396136,0.022829,0.007254},
+	{0.170203,0.400366,0.065913,0.009355},
+	{0.194966,0.372889,0.055640,0.010498},
+	{0.212711,0.382905,0.044145,0.006430},
+	{0.220250,0.394315,0.029698,0.010635},
+	{0.195739,0.397199,0.044541,0.015762},
+	{0.211654,0.377701,0.056428,0.006888},
+	{0.234965,0.382146,0.029519,0.007750},
+	{0.263901,0.397112,0.046806,0.006980},
+	{0.234022,0.391910,0.051822,0.015536},
+	{0.260195,0.374135,0.045281,0.015762},
+	{0.280399,0.376799,0.056025,0.006714},
+	{0.283192,0.402145,0.026391,0.009786},
+	{0.279561,0.389831,0.070096,0.006789},
+	{0.299585,0.373604,0.057431,0.011953},
+	{0.312740,0.372343,0.033714,0.009518},
+	{0.335479,0.387674,0.036866,0.008966},
+	{0.313317,0.390191,0.058539,0.009610},
+	{0.327009,0.381826,0.052052,0.007696},
+	{0.349111,0.381525,0.050691,0.009803},
+	{0.370847,0.389607,0.040148,0.007174},
+	{0.336900,0.404187,0.051731,0.013298},
+	{0.364431,0.386995,0.051672,0.006272},
+	{0.380486,0.372616,0.037016,0.007843},
+	{0.387432,0.394596,0.035861,0.010668},
+	{0.383440,0.392839,0.070329,0.010113},
+	{0.397354,0.378289,0.069987,0.008162},
+	{0.412381,0.379269,0.031555,0.014769},
+	{0.431738,0.399853,0.031097,0.013491},
+	{0.416807,0.388592,0.068089,0.010234},
+	{0.434246,0.385754,0.051562,0.008510},
+	{0.459761,0.377812,0.034232,0.008546},
+	{0.469310,0.399879,0.030659,0.015762},
+	{0.448851,0.389468,0.070969,0.016061},
+	{0.472731,0.373287,0.052274,0.012192},
+	{0.025845,0.411569,0.031706,0.012222},
+	{0.053452,0.432332,0.034575,0.012284},
+	{0.013101,0.425034,0.052342,0.015517},
+	{0.035661,0.409240,0.053396,0.011700},
+	{0.069697,0.410872,0.045637,0.008799},
+	{0.085224,0.435507,0.032725,0.015801},
+	{0.056265,0.422981,0.058037,0.013129},
+	{0.076985,0.417420,0.069616,0.007327},
+	{0.086433,0.412353,0.047787,0.008139},
+	{0.113150,0.426126,0.051781,0.007572},
+	{0.095559,0.431375,0.071602,0.012141},
+	{0.110469,0.407765,0.062669,0.008395},
+	{0.131849,0.404271,0.035325,0.007326},
+	{0.154057,0.433609,0.051576,0.006804},
+	{0.130968,0.431234,0.049111,0.011155},
+	{0.146668,0.411976,0.072037,0.006514},
+	{0.173190,0.416526,0.046090,0.012972},
+	{0.190589,0.427391,0.031914,0.009879},
+	{0.165638,0.431320,0.062630,0.009368},
+	{0.181578,0.418447,0.070458,0.012485},
+	{0.201938,0.420097,0.050532,0.007909},
+	{0.210786,0.430524,0.043687,0.007384},
+	{0.199643,0.440108,0.058556,0.013086},
+	{0.219101,0.413160,0.043518,0.011656},
+	{0.235474,0.419530,0.052019,0.007861},
+	{0.254554,0.428819,0.029869,0.009518},
+	{0.251638,0.431825,0.063212,0.015327},
+	{0.253052,0.411818,0.042596,0.011772},
+	{0.268275,0.411836,0.031385,0.007133},
+	{0.299229,0.425848,0.044101,0.011809},
+	{0.277241,0.422348,0.053397,0.012319},
+	{0.285524,0.396817,0.050771,0.014608},
+	{0.311540,0.402649,0.035156,0.015936},
+	{0.331451,0.434548,0.035449,0.006888},
+	{0.310673,0.434227,0.066608,0.012917},
+	{0.322590,0.420054,0.049005,0.008242},
+	{0.340380,0.414409,0.031798,0.009373},
+	{0.362861,0.429363,0.031830,0.012967},
+	{0.340153,0.437578,0.060896,0.007843},
+	{0.370512,0.415453,0.055970,0.010546},
+	{0,0,0,0}
+};
+
 /* Create permanent link between partcles that have transient link now, return number of created permalinks.
  *
  * Needs valid Omega instance. Stiffness parameters are copied from the transientInteraction. Order of forceId1 and forceId2 is irrelevant.
@@ -497,3 +1124,4 @@
 
 	return numNewLinks;
 }
+

Modified: trunk/extra/clump/Shop.hpp
===================================================================
--- trunk/extra/clump/Shop.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/extra/clump/Shop.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -61,6 +61,11 @@
 		static shared_ptr&lt;Body&gt; tetra(Vector3r v[4]);
 
 		static vector&lt;pair&lt;Vector3r,Real&gt; &gt; loadSpheresFromFile(string fname,Vector3r&amp; minXYZ, Vector3r&amp; maxXYZ);
+		
+		struct sphereGeomStruct{ double C0, C1, C2, r; };
+		static sphereGeomStruct smallSdecXyzData[];
+		static vector&lt;pair&lt;Vector3r,Real&gt; &gt; loadSpheresSmallSdecXyz(Vector3r&amp; minXYZ, Vector3r&amp; maxXYZ);
+		
 		static void saveSpheresToFile(string fileName);
 
 		// (true || boost::lambda::_1) means that true is the default

Modified: trunk/extra/usct/UniaxialStrainControlledTest.cpp
===================================================================
--- trunk/extra/usct/UniaxialStrainControlledTest.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/extra/usct/UniaxialStrainControlledTest.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -124,7 +124,13 @@
 	typedef vector&lt;pair&lt;Vector3r,Real&gt; &gt; vecVecReal;
 	Shop::setDefault(&quot;phys_young&quot;,30e7);
 
-	vecVecReal spheres=Shop::loadSpheresFromFile(spheresFile,minXYZ,maxXYZ);
+	vecVecReal spheres;
+	if(spheresFile.empty()){ 
+		LOG_INFO(&quot;spheresFile empty, loading hardwired Shop::smallSdecXyzData (examples/small.sdec.xyz).&quot;);
+		spheres=Shop::loadSpheresSmallSdecXyz(minXYZ,maxXYZ);
+	}
+	else spheres=Shop::loadSpheresFromFile(spheresFile,minXYZ,maxXYZ);
+
 	TRVAR2(minXYZ,maxXYZ);
 	// get spheres that are &quot;close enough&quot; to the strained ends
 	for(vecVecReal::iterator I=spheres.begin(); I!=spheres.end(); I++){

Modified: trunk/gui/SConscript
===================================================================
--- trunk/gui/SConscript	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/SConscript	2008-03-13 19:14:29 UTC (rev 1274)
@@ -4,28 +4,14 @@
 	env.Install('$PREFIX/lib/yade$SUFFIX/gui',[
 		env.SharedLibrary('QtGUI',
 			['qt3/FileDialog.cpp',
-				'qt3/GLEngineEditor.cpp',
-				'qt3/GLSimulationPlayerViewer.cpp',
 				'qt3/GLViewer.cpp',
 				'qt3/MessageDialog.cpp',
-				'qt3/QtCodeGenerator.cpp',
-				'qt3/QtEngineEditor.cpp',
 				'qt3/QtFileGenerator.cpp',
 				'qt3/QtFileGeneratorController.ui',
 				'qt3/QtGUI.cpp',
 				'qt3/QtGUIPreferences.cpp',
-				'qt3/QtGeneratedCodeGenerator.ui',
-				'qt3/QtGeneratedEngineEditor.ui',
 				'qt3/QtGeneratedMessageDialog.ui',
-				'qt3/QtGeneratedMetaDispatchingEngineProperties.ui',
-				'qt3/QtGeneratedPreferencesEditor.ui',
 				'qt3/QtGeneratedSimulationController.ui',
-				'qt3/QtGeneratedSimulationPlayer.ui',
-				'qt3/QtGeneratedSphericalDEMSimulator.ui',
-				'qt3/QtMetaDispatchingEngineProperties.cpp',
-				'qt3/QtPreferencesEditor.cpp',
-				'qt3/QtSimulationPlayer.cpp',
-				'qt3/QtSphericalDEM.cpp',
 				'qt3/SimulationController.cpp',
 				'qt3/SimulationControllerUpdater.cpp',
 				'qt3/YadeQtGeneratedMainWindow.ui',
@@ -45,7 +31,12 @@
 if 'EMBED_PYTHON' in env['CPPDEFINES']:
 	env.Install('$PREFIX/lib/yade$SUFFIX/gui',[
 		env.SharedLibrary('cmdGui',['cmd/cmdGui.cpp']),
-		env.SharedLibrary('yadeControl',['cmd/yadeControl.cpp'],SHLIBPREFIX='',CPPDEFINES=env['CPPDEFINES']+['NO_PYGLVIEWER'],LIBS=env['LIBS']+['yade-base','libboost_python','XMLFormatManager','yade-factory','yade-serialization']), # link with 'QtGUI' in you enable pyGLViewer
+		env.SharedLibrary('yadeControl',['cmd/yadeControl.cpp','cmd/GLViewer4.cpp'],SHLIBPREFIX='',
+			LIBS=env['LIBS']+['yade-base','libboost_python','XMLFormatManager','yade-factory','yade-serialization',],
+			# '$QGLVIEWER_LIB'
+			#CPPPATH=env['CPPPATH']+['/usr/include/qt4','/usr/include/qt4/Qt','/usr/include/qt4/QtXml','/usr/include/qt4/QtOpenGL','/usr/include/qt4/QtCore','/usr/include/qt4/QtGui'],
+			CPPDEFINES=env['CPPDEFINES']+['NO_PYGLVIEWER'],
+			),
 		env.File('cmdGuiInit.py','cmd')
 ])
 

Added: trunk/gui/cmd/GLViewer4.cpp
===================================================================
--- trunk/gui/cmd/GLViewer4.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/cmd/GLViewer4.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,268 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2005 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+* qt4 port V&#225;clav &#352;milauer 2008
+*/                                                                        
+#ifdef USE_QGLVIEWER //skip the whole file
+
+
+#include&quot;GLViewer4.hpp&quot;
+#include&lt;GL/glut.h&gt;
+#include&lt;yade/lib-opengl/FpsTracker.hpp&gt;
+#include&lt;yade/core/Body.hpp&gt;
+#include&lt;yade/core/Interaction.hpp&gt;
+#include&lt;QKeyEvent&gt;
+#include&lt;QMouseEvent&gt;
+
+
+GLViewer4::GLViewer4(int id, shared_ptr&lt;RenderingEngine&gt; rendererInit, const QGLFormat&amp; format, QWidget * parent, QGLWidget * shareWidget) : QGLViewer(format,parent,shareWidget)//, qglThread(this,rendererInit)
+{
+	isMoving=false;
+	renderer=rendererInit;
+	drawGrid = false;
+	viewId = id;
+	resize(320, 240);
+
+	// if (id==0) setCaption(&quot;Primary View (not closable)&quot;);	else setCaption(&quot;Secondary View number &quot;+lexical_cast&lt;string&gt;(id));
+	
+	show();
+	
+	notMoving();
+
+	if(manipulatedFrame() == 0 )
+		setManipulatedFrame(new qglviewer::ManipulatedFrame());
+}
+
+void GLViewer4::notMoving()
+{
+	camera()-&gt;frame()-&gt;setWheelSensitivity(-1.0f);
+	setMouseBinding(Qt::LeftButton + Qt::RightButton, CAMERA, ZOOM);
+	setMouseBinding(Qt::LeftButton, CAMERA, ROTATE);
+	setMouseBinding(Qt::MidButton, CAMERA, TRANSLATE);
+	setMouseBinding(Qt::RightButton, CAMERA, TRANSLATE);
+	setWheelBinding(Qt::NoModifier, CAMERA, ZOOM);
+	setMouseBinding(Qt::SHIFT + Qt::LeftButton, SELECT);
+	//setMouseBinding(Qt::RightButton, NO_CLICK_ACTION);
+
+	setMouseBinding(Qt::SHIFT + Qt::LeftButton + Qt::RightButton, FRAME, ZOOM);
+	setMouseBinding(Qt::SHIFT + Qt::MidButton, FRAME, TRANSLATE);
+	setMouseBinding(Qt::SHIFT + Qt::RightButton, FRAME, ROTATE);
+	setWheelBinding(Qt::ShiftModifier, FRAME, ZOOM);
+};
+
+
+void GLViewer4::keyPressEvent(QKeyEvent *e)
+{
+	if ( e-&gt;key()==Qt::Key_M )
+		if( !(isMoving = !isMoving ) )
+		{
+			displayMessage(&quot;moving finished&quot;);
+			notMoving();
+		}
+		else
+		{
+			displayMessage(&quot;moving selected object&quot;);
+			setMouseBinding(Qt::LeftButton + Qt::RightButton, FRAME, ZOOM);
+			setMouseBinding(Qt::LeftButton, FRAME, TRANSLATE);
+			setMouseBinding(Qt::MidButton, FRAME, TRANSLATE);
+			setMouseBinding(Qt::RightButton, FRAME, ROTATE);
+			setWheelBinding(Qt::NoModifier , FRAME, ZOOM);
+		}
+	else if( e-&gt;key()==Qt::Key_C &amp;&amp; selectedName() != -1 &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selectedName()))
+		setSceneCenter(manipulatedFrame()-&gt;position()), updateGL();
+	else if( e-&gt;key()==Qt::Key_D )
+		wasDynamic = true;
+	else if( e-&gt;key()==Qt::Key_G )
+		drawGrid = !drawGrid, updateGL();
+
+// FIXME BEGIN - arguments for GLDraw*ers should be from dialog box, not through Omega !!!
+	else if( e-&gt;key()==Qt::Key_Delete )
+		Omega::instance().isoValue-=0.05, updateGL();
+	else if( e-&gt;key()==Qt::Key_Insert )
+		Omega::instance().isoValue+=0.05, updateGL();
+
+	else if( e-&gt;key()==Qt::Key_PageDown)
+		Omega::instance().isoThick-=0.05, updateGL();
+	else if( e-&gt;key()==Qt::Key_PageUp)
+		Omega::instance().isoThick+=0.05, updateGL();
+
+	else if( e-&gt;key()==Qt::Key_End )
+		Omega::instance().isoSec=std::max(1, Omega::instance().isoSec-1), updateGL();
+	else if( e-&gt;key()==Qt::Key_Home )
+		Omega::instance().isoSec+=1, updateGL();
+// FIXME END
+
+	else if (e-&gt;key() == Qt::Key_T)
+	{ // 'T' changes the projection type : perspective or orthogonal
+		if (camera()-&gt;type() == qglviewer::Camera::ORTHOGRAPHIC)
+			camera()-&gt;setType(qglviewer::Camera::PERSPECTIVE);
+		else
+			camera()-&gt;setType(qglviewer::Camera::ORTHOGRAPHIC);
+		updateGL();
+	}
+	else if( e-&gt;key()==Qt::Key_O )
+		camera()-&gt;setFieldOfView(camera()-&gt;fieldOfView()*0.9), updateGL();
+	else if( e-&gt;key()==Qt::Key_P )
+		camera()-&gt;setFieldOfView(camera()-&gt;fieldOfView()*1.1), updateGL();
+
+	else if( e-&gt;key()!=Qt::Key_Escape &amp;&amp; e-&gt;key()!=Qt::Key_Space )
+		QGLViewer::keyPressEvent(e);
+}
+
+void GLViewer4::centerScene()
+{
+	if (!Omega::instance().getRootBody())
+		return;
+
+	if(Omega::instance().getRootBody()-&gt;bodies-&gt;size() &lt; 500)
+		displayMessage(&quot;Less than 500 bodies, moving possible. Select with shift, press 'm' to move.&quot;, 6000);
+	else
+		displayMessage(&quot;More than 500 bodies. Moving not possible&quot;, 6000);
+
+	Vector3r min = Omega::instance().getRootBody()-&gt;boundingVolume-&gt;min;
+	Vector3r max = Omega::instance().getRootBody()-&gt;boundingVolume-&gt;max;
+	Vector3r center = (max+min)*0.5;
+	Vector3r halfSize = (max-min)*0.5;
+	float radius = std::max(halfSize[0] , std::max(halfSize[1] , halfSize[2]) );
+	setSceneCenter(qglviewer::Vec(center[0],center[1],center[2]));
+	setSceneRadius(radius*1.5);
+	showEntireScene();
+}
+
+void GLViewer4::draw() // FIXME maybe rename to RendererFlowControl, or something like that?
+{
+	if(Omega::instance().getRootBody())
+	{
+		int selection = selectedName();
+		if(selection != -1 &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selection) )
+		{
+			Quaternionr&amp; q = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;physicalParameters-&gt;se3.orientation;
+			Vector3r&amp;    v = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;physicalParameters-&gt;se3.position;
+			float v0,v1,v2;
+			manipulatedFrame()-&gt;getPosition(v0,v1,v2);
+			v[0]=v0;v[1]=v1;v[2]=v2;
+			double q0,q1,q2,q3;
+			manipulatedFrame()-&gt;getOrientation(q0,q1,q2,q3);
+			q[0]=q0;q[1]=q1;q[2]=q2;q[3]=q3;
+
+			(*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;userForcedDisplacementRedrawHook();	
+		}
+		
+	// FIXME - here we want to actually call all responsible GLDraw Actors
+		renderer-&gt;render(Omega::instance().getRootBody(), selectedName());
+	}
+}
+
+void GLViewer4::drawWithNames() // FIXME maybe rename to RendererFlowControl, or something like that?
+{
+	if (Omega::instance().getRootBody() &amp;&amp; Omega::instance().getRootBody()-&gt;bodies-&gt;size() &lt; 500 )
+	// FIXME - here we want to actually call all responsible GLDraw Actors
+		renderer-&gt;renderWithNames(Omega::instance().getRootBody());
+}
+
+
+// new object selected.
+// set frame coordinates, and isDynamic=false;
+void GLViewer4::postSelection(const QPoint&amp; point) 
+{
+	int selection = selectedName();
+	if(selection == -1)
+	{
+		if(isMoving)
+		{
+			displayMessage(&quot;moving finished&quot;);
+			notMoving();
+			isMoving=false;
+		}
+		return;
+	}
+	if( (*(Omega::instance().getRootBody()-&gt;bodies)).exists(selection) )
+	{
+		if(Body::byId(body_id_t(selection))-&gt;isClumpMember()){ // select clump (invisible) instead of its member
+			cerr&lt;&lt;&quot;Clump member #&quot;&lt;&lt;selection&lt;&lt;&quot; selected, selecting clump instead.&quot;&lt;&lt;endl;
+			selection=Body::byId(body_id_t(selection))-&gt;clumpId;
+			setSelectedName(selection);
+		}
+
+		std::cerr &lt;&lt; &quot;new selection &quot; &lt;&lt; selection &lt;&lt; &quot;\n&quot;;
+		wasDynamic = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;isDynamic;
+		(*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;isDynamic = false;
+
+		Quaternionr&amp; q = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;physicalParameters-&gt;se3.orientation;
+		Vector3r&amp;    v = (*(Omega::instance().getRootBody()-&gt;bodies))[selection]-&gt;physicalParameters-&gt;se3.position;
+		manipulatedFrame()-&gt;setPositionAndOrientation(qglviewer::Vec(v[0],v[1],v[2]),qglviewer::Quaternion(q[0],q[1],q[2],q[3]));
+	}
+
+}
+
+// maybe new object will be selected.
+// if so, then set isDynamic of previous selection, to old value
+void GLViewer4::endSelection(const QPoint &amp;point)
+{
+	int old = selectedName();
+
+	QGLViewer::endSelection(point);
+
+	if(old != -1 &amp;&amp; old!=selectedName() &amp;&amp; (*(Omega::instance().getRootBody()-&gt;bodies)).exists(old) )
+		(*(Omega::instance().getRootBody()-&gt;bodies))[old]-&gt;isDynamic = wasDynamic;
+}
+
+void GLViewer4::postDraw()
+{
+	if( drawGrid ) // FIXME drawGrid is yet another RendererFlowControl's Actor.
+	{
+//		glMatrixMode(GL_MODELVIEW);
+		glPushMatrix();
+		glPushAttrib(GL_ALL_ATTRIB_BITS);
+		qglColor(foregroundColor());
+		glDisable(GL_LIGHTING);
+		glLineWidth(0.1);
+		glBegin(GL_LINES);
+
+		float sizef = QGLViewer::camera()-&gt;sceneRadius()*3.0f; 
+		int size = static_cast&lt;int&gt;(sizef);
+		qglviewer::Vec v = QGLViewer::camera()-&gt;sceneCenter();
+		int x = static_cast&lt;int&gt;(v[0]); int y = static_cast&lt;int&gt;(v[1]);
+		float xf = (static_cast&lt;int&gt;(v[0]*100.0))/100.0;
+		float yf = (static_cast&lt;int&gt;(v[1]*100.0))/100.0;
+//		float nbSubdivisions = size;
+//		for (int i=0; i&lt;=nbSubdivisions; ++i)
+		for (int i= -size ; i&lt;=size; ++i )
+		{
+//			const float pos = size*(2.0*i/nbSubdivisions-1.0);
+			glVertex2i( i   +x, -size+y);
+			glVertex2i( i   +x, +size+y);
+			glVertex2i(-size+x, i    +y);
+			glVertex2i( size+x, i    +y);
+		}
+		if(sizef &lt;= 2.0)
+		{
+			glColor3f(0.9,0.9,0.9);
+			for (float i= -(static_cast&lt;int&gt;(sizef*100.0))/100.0 ; i&lt;=sizef; i+=0.01 )
+			{
+				glVertex2f( i    +xf, -sizef+yf);
+				glVertex2f( i    +xf, +sizef+yf);
+				glVertex2f(-sizef+xf, i     +yf);
+				glVertex2f( sizef+xf, i     +yf);
+			}
+		}
+		
+		glEnd();
+		glPopAttrib();
+		glPopMatrix();
+	}
+	QGLViewer::postDraw();
+}
+
+/*
+void GLViewer4::closeEvent(QCloseEvent *e)
+{
+	cerr&lt;&lt;&quot;CLOSE&#160;EVENT!?&quot;&lt;&lt;endl;
+	//emit closeSignal(viewId);
+}
+*/
+
+#endif

Added: trunk/gui/cmd/GLViewer4.hpp
===================================================================
--- trunk/gui/cmd/GLViewer4.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/cmd/GLViewer4.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,44 @@
+//  Copyright (C) 2004 by Olivier Galizzi, Janek Kozicki
+//  qt4 port 2008 V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt;
+
+#pragma once
+
+#include&lt;yade/core/Omega.hpp&gt;
+#include&lt;yade/core/RenderingEngine.hpp&gt;
+#include&lt;QGLViewer/qglviewer.h&gt;
+
+class GLViewer4 : public QGLViewer
+{
+	//Q_OBJECT;
+	//friend class QGLThread;
+		
+	private:
+		int			viewId;
+		bool			drawGrid; // FIXME - draw grid is in fact just another GLDrawActor
+		bool			isMoving;
+		bool			wasDynamic;
+		shared_ptr&lt;RenderingEngine&gt; renderer;
+
+	public :
+		GLViewer4 (int id, shared_ptr&lt;RenderingEngine&gt; renderer, const QGLFormat&amp; format, QWidget * parent=0, QGLWidget * shareWidget=0);
+		virtual ~GLViewer4() {};
+		virtual void draw();
+		//virtual void init(){};
+		//virtual QString helpString() const {return QString(&quot;@@@&quot;);}
+		virtual void drawWithNames();
+		void centerScene();
+		void notMoving();
+	protected :
+		virtual void keyPressEvent(QKeyEvent *e);
+		virtual void postDraw();
+		//virtual void closeEvent(QCloseEvent *e);
+		virtual void postSelection(const QPoint&amp; point);
+		virtual void endSelection(const QPoint &amp;point);
+	//slot:
+	//		void callUpdateGL(){cerr&lt;&lt;&quot;@&quot;; updateGL();}
+
+	signals :
+//		virtual void closeSignal(int i);
+};
+
+

Modified: trunk/gui/cmd/yadeControl.cpp
===================================================================
--- trunk/gui/cmd/yadeControl.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/cmd/yadeControl.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -28,11 +28,10 @@
 #include&lt;yade/core/EngineUnit1D.hpp&gt;
 #include&lt;yade/core/EngineUnit2D.hpp&gt;
 
-#ifndef NO_PYGLVIEWER
-	#include&lt;yade/gui-qt3/GLViewer.hpp&gt;
-	#include&lt;qapplication.h&gt;
-	// qt3 sucks
-	#undef DEBUG
+#ifdef USE_PYGLVIEWER
+	#include&quot;GLViewer4.hpp&quot;
+	#include&lt;Qt/qapplication.h&gt;
+	#include&lt;Qt/qthread.h&gt;
 #endif
 
 using namespace boost;
@@ -222,7 +221,7 @@
 
 BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(omega_overloads,run,0,1);
 
-#ifndef NO_PYGLVIEWER
+#ifdef USE_PYGLVIEWER 
 /*! GL viewer wrapper, with full attribute access.
  *
  * Creates the 3D view on instantiation. Currently displays nothing (why???), although it redraws just fine.
@@ -231,7 +230,8 @@
 class pyGLViewer{
 	//DECLARE_LOGGER;
 	shared_ptr&lt;RenderingEngine&gt; renderer;
-	shared_ptr&lt;GLViewer&gt; viewer;
+	shared_ptr&lt;GLViewer4&gt; viewer;
+#if 0
 	shared_ptr&lt;boost::thread&gt; redrawThread,appThread;
 	QApplication* app;
 	void redrawAlarm(void){
@@ -242,8 +242,27 @@
 			usleep(10000000);
 		}
 	}
+#endif 
+	class DrawThread: public QThread{
+		//Q_OBJECT;
+		const shared_ptr&lt;GLViewer4&gt; vw;
+		shared_ptr&lt;QTimer&gt; timer;
+		public:
+			DrawThread(shared_ptr&lt;GLViewer4&gt; _viewer): vw(_viewer){}
+			virtual void run(){
+				LOG_WARN(&quot;drawThread::run() with viewer &quot;&lt;&lt;vw);
+				timer=shared_ptr&lt;QTimer&gt;(new QTimer());
+				connect(timer.get(),SIGNAL(timeout()),vw.get(),SLOT(callUpdateGL()));
+				timer-&gt;start(100);
+				//while(true){ cerr&lt;&lt;&quot;@&quot;; vw-&gt;updateGL(); usleep(50000);}
+				exec();
+			};
+		//public slots:
+		//	void updateGL(){cerr&lt;&lt;&quot;@&quot;;}
+	};
 	shared_ptr&lt;AttrAccess&gt; accessor;
 	void ensureAcc(){if(!accessor)accessor=shared_ptr&lt;AttrAccess&gt;(new AttrAccess(renderer));}
+	shared_ptr&lt;DrawThread&gt; drawThread;
 public:
 	DECLARE_LOGGER;
 	ATTR_ACCESS_CXX(accessor,ensureAcc);	
@@ -269,18 +288,24 @@
 		if(!renderer) throw runtime_error(&quot;Unable to create renderer!&quot;);
 
 		int viewId=0;
-		if(viewId==0){	int _argc=0; char _argvv[]=&quot;foo&quot;; app=new QApplication(_argc,(char**) &amp;_argvv);}
+		//if(viewId==0){	int _argc=0; char _argvv[]=&quot;foo&quot;; app=new QApplication(_argc,(char**) &amp;_argvv);}
+		//app-&gt;setMainWidget(viewer.get());
+		int _argc=0; char _argvv[]=&quot;foo&quot;; //QApplication* app=new 
+		QApplication* app=new QApplication(_argc,(char**) &amp;_argvv);
 
-		QGLFormat format;	QGLFormat::setDefaultFormat(format); // format.setStencil(TRUE); format.setAlpha(TRUE);
-		viewer=shared_ptr&lt;GLViewer&gt;(new GLViewer(viewId,renderer,format,0,0));
+		QGLFormat format;	QGLFormat::setDefaultFormat(format); format.setStencil(TRUE); format.setAlpha(TRUE);
+		viewer=shared_ptr&lt;GLViewer4&gt;(new GLViewer4(viewId,renderer,format,/*parent*/0,0/* non-primary views will have to share widgets, though */)); //
+		viewer-&gt;setWindowTitle(&quot;GL Viewer&quot;);
 		viewer-&gt;centerScene();
-		viewer-&gt;notMoving();
+		viewer-&gt;show();
+		drawThread=shared_ptr&lt;DrawThread&gt;(new DrawThread(viewer));
+		drawThread-&gt;start(); // is the same as DrawThread-&gt;run() except for check that it isn't running already?!
 
-		if(viewId==0){
+		/*if(viewId==0){
 			app-&gt;setMainWidget(viewer.get());
 			redrawThread=shared_ptr&lt;boost::thread&gt;(new boost::thread(boost::bind(&amp;pyGLViewer::redrawAlarm,this)));
 		}
-		appThread=shared_ptr&lt;boost::thread&gt;(new boost::thread(boost::bind(&amp;QApplication::exec,app)));
+		appThread=shared_ptr&lt;boost::thread&gt;(new boost::thread(boost::bind(&amp;QApplication::exec,app))); */
 	}
 	~pyGLViewer(){// redrawThread and appThread deleted by the descructor
 		//viewer-&gt;close();
@@ -288,7 +313,7 @@
 	}
 };
 CREATE_LOGGER(pyGLViewer);
-#endif
+#endif /* USE_PYGLVIEWER&#160;*/
 
 
 BOOST_PYTHON_MODULE(yadeControl)
@@ -327,7 +352,7 @@
 			.def(&quot;newView&quot;, &amp;newView)
 			.def(&quot;centerScene&quot;, &amp;centerScene)
 		#endif
-#ifndef NO_PYGLVIEWER
+#ifdef USE_PYGLVIEWER
 	boost::python::class_&lt;pyGLViewer&gt;(&quot;View&quot;)
 		.ATTR_ACCESS_PY(pyGLViewer);
 #endif

Deleted: trunk/gui/qt3/GLEngineEditor.cpp
===================================================================
--- trunk/gui/qt3/GLEngineEditor.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLEngineEditor.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,522 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;GLEngineEditor.hpp&quot;
-#include &lt;Wm3Vector2.h&gt;
-#include&lt;yade/lib-base/yadeWm3.hpp&gt;
-#include&lt;yade/lib-computational-geometry/Intersections2D.hpp&gt;
-#include&lt;yade/lib-computational-geometry/Distances2D.hpp&gt;
-
-
-GLEngineEditor::GLEngineEditor(QWidget * parent, const char * name) : QGLViewer(parent,name)
-{	
-	resize(800,600);
-
-	setBackgroundColor(QColor(255,255,255));
-	setMouseTracking(true);
-	
-	startRelation = false;
-	relationSelected = false;
-
-	relation.first = -1;
-	relation.second = -1;
-	selectedEngine = -1;
-	firstEngine = -1;
-
-	updateGL();
-}
-
-
-GLEngineEditor::~GLEngineEditor()
-{
-
-}
-
-
-void GLEngineEditor::draw()
-{			
-
-	setBackgroundColor(QColor(255,255,255));
-
-	drawGrid();
-
-	startScreenCoordinatesSystem();
-	glDisable(GL_DEPTH_TEST);	
-	shared_ptr&lt;GLWindow&gt; glw1,glw2;
-	int x1,y1,x2,y2;
-
-	set&lt;pair&lt;int,int&gt; &gt;::iterator li = loop.begin();
-	set&lt;pair&lt;int,int&gt; &gt;::iterator liEnd = loop.end();
-	for(;li!=liEnd;++li)
-	{
-		glw1 = wm.getWindow((*li).first);
-		glw2 = wm.getWindow((*li).second);
-
-		x1 = glw1-&gt;getMinX()+glw1-&gt;getSizeX()/2;
-		y1 = glw1-&gt;getMinY()+glw1-&gt;getSizeY()/2;
-		x2 = glw2-&gt;getMinX()+glw2-&gt;getSizeX()/2;
-		y2 = glw2-&gt;getMinY()+glw2-&gt;getSizeY()/2;
-		cutSegmentWithRectangles(x1,y1,x2,y2,(*li).first,(*li).second);
-		if (relationSelected &amp;&amp; selectedRelation.first==(*li).first &amp;&amp; selectedRelation.second==(*li).second)
-			glColor3f(1.0,0.0,0.0);
-		else
-			glColor3f(0.0,0.0,1.0);
-		drawArrow(x1,y1,x2,y2);
-		
-	}
-
-	stopScreenCoordinatesSystem();
-
-	glEnable(GL_DEPTH_TEST);
-
-	wm.glDraw();
-
-	startScreenCoordinatesSystem();
-	glDisable(GL_DEPTH_TEST);
-	if (startRelation)
-	{
-		glBegin(GL_LINES);
-			glColor3f(1.0,0.0,0.0);
-			glVertex2i(startX,startY);
-			glVertex2i(endX,endY);
-		glEnd();
-	}
-
-	if (selectedEngine!=-1)
-	{
-		glw1 = wm.getWindow(selectedEngine);
-		glBegin(GL_LINE_LOOP);
-			glColor3f(1.0,0.0,0.0);
-			glVertex2i(glw1-&gt;getMinX()-4,glw1-&gt;getMinY()-3);
-			glVertex2i(glw1-&gt;getMinX()+glw1-&gt;getSizeX()+3,glw1-&gt;getMinY()-3);
-			glVertex2i(glw1-&gt;getMinX()+glw1-&gt;getSizeX()+3,glw1-&gt;getMinY()+glw1-&gt;getSizeY()+4);
-			glVertex2i(glw1-&gt;getMinX()-4,glw1-&gt;getMinY()+glw1-&gt;getSizeY()+4);
-		glEnd();
-	}		
-
-	glEnable(GL_DEPTH_TEST);
-	stopScreenCoordinatesSystem();
-
-}
-
-
-void GLEngineEditor::drawArrow(int x1,int y1, int x2, int y2)
-{
-	glBegin(GL_LINES);
-		glVertex2i(x1,y1);
-		glVertex2i(x2,y2);
-	glEnd();
-
-	Vector2r v = Vector2r(x1-x2,y1-y2);
-	v.Normalize();
-	v = v*10;
-	Vector2r n = Vector2r(-v[1],v[0]);
-	
-	glBegin(GL_TRIANGLES);
-		glVertex2i(x2,y2);
-		glVertex2i(x2+2*(int)v[0]+(int)n[0],y2+2*(int)v[1]+(int)n[1]);
-		glVertex2i(x2+2*(int)v[0]-(int)n[0],y2+2*(int)v[1]-(int)n[1]);
-	glEnd();
-
-}
-
-
-void GLEngineEditor::drawGrid()
-{
-	startScreenCoordinatesSystem();
-	glLineWidth(2.0); 
-	glBegin(GL_LINES);
-		int i;
-		glColor3f(0.7,0.7,0.7);
-		for(i=0;i&lt;=width();i+=20)	
-		{
-			glVertex2i(i,0);
-			glVertex2i(i,(int)height());
-		}
-		for(i=0;i&lt;=height();i+=20)	
-		{
-			glVertex2i(0,i);
-			glVertex2i((int)width(),i);
-		}
-	glEnd();
-	stopScreenCoordinatesSystem();
-}
-
-
-void GLEngineEditor::mouseMoveEvent(QMouseEvent * e)
-{
-	if (startRelation)
-	{
-		endX = e-&gt;x();
-		endY = e-&gt;y();
-		int pw = wm.getPointedWindow(endX, endY);
-		if (pw!=-1)
-			relation.second = pw;
-	}
-	
-	if (wm.mouseMoveEvent(e-&gt;x(),e-&gt;y())==-1)
-		QGLViewer::mouseMoveEvent(e);
-
-	updateGL();
-	emit verifyValidity();
-}
-
-
-
-void GLEngineEditor::mousePressEvent(QMouseEvent *e)
-{
-	if ((e-&gt;state() &amp; Qt::KeyButtonMask)==Qt::ControlButton)
-	{
-		int id = wm.getPointedWindow(e-&gt;x(),e-&gt;y());
-		if (id!=-1)
-		{
-			relation.first = id;
-			relation.second = -1;
-			startRelation = true;
-			shared_ptr&lt;GLWindow&gt; glw = wm.getWindow(id);
-			startX = glw-&gt;getMinX()+glw-&gt;getSizeX()/2;
-			startY = glw-&gt;getMinY()+glw-&gt;getSizeY()/2;
-			endX = e-&gt;x();
-			endY = e-&gt;y();
-		}
-		else
-		{
-			relation.first = -1;
-			relation.second = -1;
-			startRelation = false;
-		}
-	}
-	else if ((e-&gt;state() &amp; Qt::KeyButtonMask)==Qt::ShiftButton)
-	{
-		selectedEngine = selectEngine(e-&gt;x(), e-&gt;y());
-		emit engineSelected(selectedEngine);
-		if (selectedEngine==-1)
-			relationSelected = selectRelation(e-&gt;x(), e-&gt;y(), 3.0, selectedRelation.first, selectedRelation.second);
-	}
-	else if (wm.mousePressEvent(e-&gt;x(),e-&gt;y())==-1)
-		QGLViewer::mousePressEvent(e);
-
-	updateGL();
-	emit verifyValidity();
-}
-
-
-void GLEngineEditor::mouseReleaseEvent(QMouseEvent *e)
-{
-	if (startRelation)
-	{
-		startRelation = false;
-		int id = wm.getPointedWindow(e-&gt;x(),e-&gt;y());
-		if (id!=-1 &amp;&amp; relation.first!=id)
-		{
-			relation.second = id;
-			loop.insert(pair&lt;int,int&gt;(relation.first,relation.second));
-		}
-	}
-	else if (wm.mouseReleaseEvent(e-&gt;x(),e-&gt;y())==-1)	
-		QGLViewer::mouseReleaseEvent(e);
-	updateGL();
-	emit verifyValidity();
-}
-
-
-void GLEngineEditor::mouseDoubleClickEvent(QMouseEvent *e)
-{
-	//if (wm.mouseDoubleClickEvent(e-&gt;x(),e-&gt;y())==-1)
-	//	QGLViewer::mouseDoubleClickEvent(e);
-
-	
-	int tmp = wm.getPointedWindow(e-&gt;x(),e-&gt;y());
-	if (firstEngine!=-1)
-		wm.getWindow(firstEngine)-&gt;setBackgroundColor(savedColor[0],savedColor[1],savedColor[2]);
-	
-	firstEngine = tmp;
-	if (firstEngine!=-1)
-	{		
-		wm.getWindow(firstEngine)-&gt;getBackgroundColor(savedColor[0],savedColor[1],savedColor[2]);
-		wm.getWindow(firstEngine)-&gt;setBackgroundColor(1,1,0.5);
-	}
-	
-	updateGL();
-	emit verifyValidity();
-}
-
-
-void GLEngineEditor::keyPressEvent(QKeyEvent *e)
-{	
-	if (e-&gt;key()==Qt::Key_Backspace || e-&gt;key()==Qt::Key_Delete)
-	{
-		if (relationSelected)
-		{
-			loop.erase(selectedRelation);
-			relationSelected=false;
-		}
-		else if (selectedEngine!=-1)
-		{
-			//if (relationSelected &amp;&amp; (selectedRelation.first==selectedEngine || selectedRelation.second==selectedEngine))
-			//	relationSelected=false;
-		
-			set&lt;pair&lt;int,int&gt;, lessThanPair &gt;::iterator li = loop.begin();
-			set&lt;pair&lt;int,int&gt;, lessThanPair &gt;::iterator liEnd = loop.end();
-			for( ; li!=liEnd ; ++li)
-				if ((*li).first==selectedEngine || (*li).second==selectedEngine)
-					loop.erase(*li);
-
-			wm.deleteWindow(selectedEngine);
-
-			emit deleteEngine(selectedEngine);
-
-			if (firstEngine==selectedEngine)
-				firstEngine=-1;
-			selectedEngine = -1;
-		}
-	}
-
-	updateGL();
-	emit verifyValidity();
-}
-
-
-void GLEngineEditor::resizeEvent(QResizeEvent * e)
-{
-	wm.resizeEvent(e-&gt;size().width(),e-&gt;size().height());
-	QGLViewer::resizeEvent(e);
-}
-
-
-void GLEngineEditor::updateLabel(int i)
-{
-	shared_ptr&lt;GLTextLabel&gt; tl = YADE_PTR_CAST&lt;GLTextLabel&gt;(wm.getWindow(i));
-	//tl-&gt;setText(data-&gt;fracProperties[i]-&gt;name);
-	//tl-&gt;setBorderColor(data-&gt;fractures[i]-&gt;color[0],data-&gt;fractures[i]-&gt;color[1],data-&gt;fractures[i]-&gt;color[2]);
-	tl-&gt;fitTextSize();
-	updateGL();
-}
-
-
-void GLEngineEditor::cutSegmentWithRectangles(int&amp; x1,int&amp; y1,int&amp; x2,int&amp; y2, int label1, int label2)
-{
-	Vector2r box[4];
-	shared_ptr&lt;GLWindow&gt; glw;
-
-	bool same;
-	Vector2r iPoint;
-	Vector2r p1 = Vector2r(x1,y1);
-	Vector2r p2 = Vector2r(x2,y2);
-
-
-	glw = wm.getWindow(label1);
-	int x = glw-&gt;getMinX();
-	int y = glw-&gt;getMinY();
-	int sx = glw-&gt;getSizeX();
-	int sy = glw-&gt;getSizeY();
-
-	box[0] = Vector2r(x,y);
-	box[1] = Vector2r(x+sx,y);
-	box[2] = Vector2r(x+sx,y+sy);
-	box[3] = Vector2r(x,y+sy);
-
-	if (!segments2DIntersection(p1,p2,box[0],box[1],same,iPoint))
-		if (!segments2DIntersection(p1,p2,box[1],box[2],same,iPoint))
-			if (!segments2DIntersection(p1,p2,box[2],box[3],same,iPoint))
-				segments2DIntersection(p1,p2,box[3],box[0],same,iPoint);
-
-	x1 = (int)iPoint[0];
-	y1 = (int)iPoint[1];
-
-	glw = wm.getWindow(label2);
-	x = glw-&gt;getMinX();
-	y = glw-&gt;getMinY();
-	sx = glw-&gt;getSizeX();
-	sy = glw-&gt;getSizeY();
-
-	box[0] = Vector2r(x,y);
-	box[1] = Vector2r(x+sx,y);
-	box[2] = Vector2r(x+sx,y+sy);
-	box[3] = Vector2r(x,y+sy);
-
-	if (!segments2DIntersection(p1,p2,box[0],box[1],same,iPoint))
-		if (!segments2DIntersection(p1,p2,box[1],box[2],same,iPoint))
-			if (!segments2DIntersection(p1,p2,box[2],box[3],same,iPoint))
-				segments2DIntersection(p1,p2,box[3],box[0],same,iPoint);
-
-	x2 = (int)iPoint[0];
-	y2 = (int)iPoint[1];
-
-}
-
-
-bool GLEngineEditor::selectRelation(int x, int y, float threshold, int &amp;a, int &amp;b)
-{
-
-	shared_ptr&lt;GLWindow&gt; glw1,glw2;
-	int x1,y1,x2,y2;
-	float minD = threshold;
-	bool selected = false;
-	
-	set&lt;pair&lt;int,int&gt; &gt;::iterator li = loop.begin();
-	set&lt;pair&lt;int,int&gt; &gt;::iterator liEnd = loop.end();
-	for(;li!=liEnd;++li)
-	{
-		glw1 = wm.getWindow((*li).first);
-		glw2 = wm.getWindow((*li).second);
-
-		x1 = glw1-&gt;getMinX()+glw1-&gt;getSizeX()/2;
-		y1 = glw1-&gt;getMinY()+glw1-&gt;getSizeY()/2;
-		x2 = glw2-&gt;getMinX()+glw2-&gt;getSizeX()/2;
-		y2 = glw2-&gt;getMinY()+glw2-&gt;getSizeY()/2;
-		cutSegmentWithRectangles(x1,y1,x2,y2,(*li).first,(*li).second);
-		float d = fabs(distancePointSegment2D(Vector2r(x,y),Vector2r(x1,y1),Vector2r(x2,y2)));
-		if (d&lt;=minD)
-		{
-			minD = d;
-			selected = true;
-			a = (*li).first;
-			b = (*li).second;
-		}
-	}
-
-	if (selected)
-		selectedEngine = -1;
-
-	return selected;
-}
-
-
-int GLEngineEditor::createNewTextLabel(const string&amp; name, float r, float g, float b )
-{
-	shared_ptr&lt;GLTextLabel&gt; tl(new GLTextLabel());
-	tl-&gt;setText(const_cast&lt;char*&gt;(name.c_str()));
-	tl-&gt;setTextColor(0,0,0);
-	tl-&gt;setBorderColor(1,0,1);
-	tl-&gt;setBackgroundColor(r,g,b);
-	tl-&gt;fitTextSize();
-	tl-&gt;setResizable(false);
-	tl-&gt;setWinTranslucenty(0.7);
-	tl-&gt;setBorderWidth(2);
-
-	tl-&gt;setMinX(10);
-	tl-&gt;setMinY(10);	
-
-	shared_ptr&lt;GLWindowsManager::EventSubscription&gt; es(new GLWindowsManager::EventSubscription());
-	es-&gt;mouseDoubleClick = false;
-	return wm.addWindow(tl,es);
-}
-
-
-int GLEngineEditor::addEngine(const string&amp; engineName )
-{
-	int id = createNewTextLabel(engineName,0,0.67,1);
-
-	updateGL();
-	emit verifyValidity();
-
-	return id;
-}
-
-
-int GLEngineEditor::addDeusExMachina	(const string&amp; engineName )
-{
-	int id = createNewTextLabel(engineName,0.67,0.33,1);
-
-	updateGL();
-	emit verifyValidity();
-
-	return id;
-}
-
-
-int GLEngineEditor::addMetaDispatchingEngine2D(const string&amp; engineName, const string&amp; engineUnitName, const string&amp; baseClass1Name,  const string&amp; baseClass2Name)
-{
-	int id = createNewTextLabel(engineName,0,1,0.5);
-
-	updateGL();
-	emit verifyValidity();
-
-	return id;
-}
-
-
-int GLEngineEditor::addMetaDispatchingEngine1D(const string&amp; engineName, const string&amp; engineUnitName, const string&amp; baseClass1Name)
-{
-	int id = createNewTextLabel(engineName,0,1,0.5);
-
-	updateGL();
-	emit verifyValidity();
-
-	return id;
-}
-
-
-int GLEngineEditor::selectEngine(int x, int y)
-{
-	int selected = wm.getPointedWindow(x,y);
-
-	if (selected!=-1)
-		relationSelected = false;
-
-	return selected;
-}
-
-
-bool GLEngineEditor::verify(string&amp; errorMessage)
-{
-	errorMessage = &quot;OK : You can save now&quot;;
-
-	// for each n engine should have only n arrows
-	if (wm.nbWindows()==1)
-		return true;
-	
-	if (wm.nbWindows()==0)
-	{
-		errorMessage = &quot;ERROR : No engine added&quot;;
-		return false;
-	}
-	
-	if (firstEngine==-1)
-	{
-		errorMessage = &quot;ERROR : No initial engine&quot;;
-		return false;
-	}
-	
-	if (loop.size()!=wm.nbWindows())
-	{
-		errorMessage = &quot;ERROR : No loop defined&quot;;
-		return false;
-	}
-
-	int last = firstEngine;
-	// for each engine we should have only 1 incoming and 1 outcoming arrow
-	for(unsigned int i=0;i&lt;wm.nbWindows();i++) 
-	{
-		last = findRelationStartingWith(last);
-		if (last==-1)
-		{
-			errorMessage = &quot;ERROR : No loop defined&quot;;
-			return false;
-		}
-	}
-
-	return true;
-}
-
-
-int GLEngineEditor::findRelationStartingWith(int first)
-{
-	set&lt;pair&lt;int,int&gt;, lessThanPair &gt;::iterator li    =  loop.begin();
-	set&lt;pair&lt;int,int&gt;, lessThanPair &gt;::iterator liEnd =  loop.end();
-
-	for( ; li!=liEnd ; ++li)
-	{
-		if ((*li).first == first)
-			return (*li).second;
-	}
-
-	return -1;
-}
-

Deleted: trunk/gui/qt3/GLEngineEditor.cw
===================================================================
--- trunk/gui/qt3/GLEngineEditor.cw	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLEngineEditor.cw	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,38 +0,0 @@
-&lt;!DOCTYPE CW&gt;&lt;CW&gt;
-&lt;customwidgets&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLViewer&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLViewer.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;
-            &lt;data format=&quot;PNG&quot; length=&quot;1002&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b000003b149444154388dad945f4c5b551cc73fe7dc4b7b4bcba0762d45c43114323599ee6192609c51d883892ce083f1718b3ebb185f8dc91e972cf39d2d2a2f1af664b6f1e0fe3863a0718969700eb0c52142da0242a1bd6d696f7bcff101585203ceb8fd9ece39f99dcff9fe7edf939f88c562ec465f5f9fe609442c161362173c3e3eae7b7a7ac8e7f36432196cdbfe4f907c3e4f2291201e8fe338cec3737357e9e8e828aded1e229d650e1f2d51754b082110124c13a4dc5ea341eb9dc284c0558a853f3ce8cb0677ef500fde7d39d2596679e326597b8e9abb85d7a770ab16ab6983ec5a05b487a70e36f0f4e10afe408d6a558310980108478dba4a1e8233990c5d474b64ed39aa3a8fe5f3317fbf81dbd70bccfeb205947632fd74f6589c1c6ea2f70d03a58ba0c1f2c9bdc1b66de3b8256a6e11cbe7e3ee1d181b590124fe2693aeee08d223c82c3a2c24b7b874bec8f26288774f7bd054504aef0dde6e99c0eb83f9fb266323cb80a27fb0958141836044605a2ee5523393371cc646fee2da37195aa35d0c0c5b4859ac03d7e91712dcaac5adab3650a3ff9d08ef7dd8404bb48869e5d958b5b87dadc4c9a1464e9f0d032!
 6df7ebd86bd2e310cb1bf62d384d59441f2d70a070e1c60e09489929b988681bdd9cc97170bcc4c65595f71f8e0e3301337fc24a7732467831875a47f289652b0be5e4151e6d07316c1b0c0340d8ab92023e76d66a6b2840e36d2fb7a13fee632475e6edc367ea98a90fb98b7dd6310ca0328a44761582e1bab41befabcc0ec940d28bc5e93b68e064cab84e1d9beaeb48934eac1f53b01c1b000fca496aa54b61a99fcde61662a4b4b4b23d1680be9d426173e4df3602a48ea411989a4fd590f52a8fd156b05ed9d350e3defe3cfdf4b4c7ce770ea7d3fb9f520afbe1620daeee5c26735d20b9b9cfb6811a754a439e4e5c5639a4caa1e5caf586bfc0197b78702005cb9b4cae4cd3267ce8638fe964bd72b393e39d74928d242617303a756a37f284447770dcdbffc6384a05a85de1306e9a52057c7527c7131c3c42d3f475eb2303c82d4fc3276d6811db37efeb148723082d9b08f79f97c1e5729109a9a28307cc622d2d6cdf52b2b24efe548dedb00142009862cfa879ee1a71f6cec928353511472fbf4389148b0b0e0c108081412458dfe21c9f11351e67e7358595468246d1d1e5e38a6e9e851bc39d84ab502a669331dafec0d8ec7e3e8cb06e1a881d727d1ae40180a434a8c9db129a54126ad48a7358c2b4c5352c8c374bcccdab2bb37d8719cba79fab8211f9df21!
 8e0582c261e95f8bfc04f1a1e8bc5c4dfe0a190172af6a9690000000049454!
 e44ae426
082&lt;/data&gt;
-        &lt;/pixmap&gt;
-        &lt;signal&gt; closeSignal(int) &lt;/signal&gt;
-    &lt;/customwidget&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLEngineEditor&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLEngineEditor.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;
-            &lt;data format=&quot;PNG&quot; length=&quot;1002&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b000003b149444154388dad945f4c5b551cc73fe7dc4b7b4bcba0762d45c43114323599ee6192609c51d883892ce083f1718b3ebb185f8dc91e972cf39d2d2a2f1af664b6f1e0fe3863a0718969700eb0c52142da0242a1bd6d696f7bcff101585203ceb8fd9ece39f99dcff9fe7edf939f88c562ec465f5f9fe609442c161362173c3e3eae7b7a7ac8e7f36432196cdbfe4f907c3e4f2291201e8fe338cec3737357e9e8e828aded1e229d650e1f2d51754b082110124c13a4dc5ea341eb9dc284c0558a853f3ce8cb0677ef500fde7d39d2596679e326597b8e9abb85d7a770ab16ab6983ec5a05b487a70e36f0f4e10afe408d6a558310980108478dba4a1e8233990c5d474b64ed39aa3a8fe5f3317fbf81dbd70bccfeb205947632fd74f6589c1c6ea2f70d03a58ba0c1f2c9bdc1b66de3b8256a6e11cbe7e3ee1d181b590124fe2693aeee08d223c82c3a2c24b7b874bec8f26288774f7bd054504aef0dde6e99c0eb83f9fb266323cb80a27fb0958141836044605a2ee5523393371cc646fee2da37195aa35d0c0c5b4859ac03d7e91712dcaac5adab3650a3ff9d08ef7dd8404bb48869e5d958b5b87dadc4c9a1464e9f0d032!
 6df7ebd86bd2e310cb1bf62d384d59441f2d70a070e1c60e09489929b988681bdd9cc97170bcc4c65595f71f8e0e3301337fc24a7732467831875a47f289652b0be5e4151e6d07316c1b0c0340d8ab92023e76d66a6b2840e36d2fb7a13fee632475e6edc367ea98a90fb98b7dd6310ca0328a44761582e1bab41befabcc0ec940d28bc5e93b68e064cab84e1d9beaeb48934eac1f53b01c1b000fca496aa54b61a99fcde61662a4b4b4b23d1680be9d426173e4df3602a48ea411989a4fd590f52a8fd156b05ed9d350e3defe3cfdf4b4c7ce770ea7d3fb9f520afbe1620daeee5c26735d20b9b9cfb6811a754a439e4e5c5639a4caa1e5caf586bfc0197b78702005cb9b4cae4cd3267ce8638fe964bd72b393e39d74928d242617303a756a37f284447770dcdbffc6384a05a85de1306e9a52057c7527c7131c3c42d3f475eb2303c82d4fc3276d6811db37efeb148723082d9b08f79f97c1e5729109a9a28307cc622d2d6cdf52b2b24efe548dedb00142009862cfa879ee1a71f6cec928353511472fbf4389148b0b0e0c108081412458dfe21c9f11351e67e7358595468246d1d1e5e38a6e9e851bc39d84ab502a669331dafec0d8ec7e3e8cb06e1a881d727d1ae40180a434a8c9db129a54126ad48a7358c2b4c5352c8c374bcccdab2bb37d8719cba79fab8211f9df21!
 8e0582c261e95f8bfc04f1a1e8bc5c4dfe0a190172af6a9690000000049454!
 e44ae426
082&lt;/data&gt;
-        &lt;/pixmap&gt;
-        &lt;slot access=&quot;public&quot;&gt;pbAddEngineClicked()&lt;/slot&gt;
-    &lt;/customwidget&gt;
-&lt;/customwidgets&gt;
-&lt;/CW&gt;

Deleted: trunk/gui/qt3/GLEngineEditor.hpp
===================================================================
--- trunk/gui/qt3/GLEngineEditor.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLEngineEditor.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,95 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef GL_ENGINE_EDITOR_HPP
-#define GL_ENGINE_EDITOR_HPP
-
-#include &lt;QGLViewer/qglviewer.h&gt;
-
-#include &lt;set&gt;
-
-#include&lt;yade/lib-opengl/GLWindowsManager.hpp&gt;
-#include&lt;yade/lib-opengl/GLTextLabel.hpp&gt;
-
-using namespace std;
-
-class GLEngineEditor : public QGLViewer
-{
-	Q_OBJECT
-
-	private :
-		struct lessThanPair
-		{
-			bool operator()(const pair&lt;int,int&gt;&amp; p1, const pair&lt;int,int&gt;&amp; p2)
-			{
-				return (p1.first&lt;p2.first || p1.first==p2.first &amp;&amp; p1.second&lt;p2.second);
-			}
-		};
-				
-		set&lt;pair&lt;int,int&gt;, lessThanPair &gt; loop;
-
-		GLWindowsManager wm;
-
-		bool startRelation;
-		bool relationSelected;
-		pair&lt;int,int&gt; selectedRelation;
-		pair&lt;int,int&gt; relation;
-		int startX;
-		int startY;
-		int endX;
-		int endY;
-		int selectedEngine;
-		Vector3r savedColor;
-		int firstEngine;
-
-		void drawGrid();
-		void drawArrow(int x1,int y1, int x2, int y2);
-		void cutSegmentWithRectangles(int&amp; x1,int&amp; y1,int&amp; x2,int&amp; y2, int label1, int label2);
-		bool selectRelation(int x, int y, float threshold, int &amp;a, int &amp;b);
-		int selectEngine(int x, int y);
-
-		int createNewTextLabel(const string&amp; name, float r, float g, float b );
-
-	public :
-		GLEngineEditor(QWidget * parent=0, const char * name=0);
-		~GLEngineEditor();
-		
-		void draw();
-
-		void updateLabel(int i);
-		int getFirstEngine() { return firstEngine;};
-		
-		int getWindowMinX(int i) { return wm.getWindow(i)-&gt;getMinX(); };
-		int getWindowMinY(int i) { return wm.getWindow(i)-&gt;getMinY(); };
-
-		int addEngine(const string&amp; engineName );
-		int addDeusExMachina	(const string&amp; engineName );
-		int addMetaDispatchingEngine2D(const string&amp; engineName, const string&amp; engineUnitName, const string&amp; baseClass1Name,  const string&amp; baseClass2Name);
-		int addMetaDispatchingEngine1D(const string&amp; engineName, const string&amp; engineUnitName, const string&amp; baseClass1Name);
-
-		bool verify(string&amp; errorMessage);
-		int findRelationStartingWith(int first);
-	
-	protected :
-		void mouseMoveEvent(QMouseEvent * e);
-		void mousePressEvent(QMouseEvent *e);
-		void mouseReleaseEvent(QMouseEvent *e);
-		void mouseDoubleClickEvent(QMouseEvent *e);
-
-		void keyPressEvent(QKeyEvent *e);
-		void resizeEvent ( QResizeEvent * e);
-
-	signals :
-		void verifyValidity();
-		void engineSelected(int);
-		void deleteEngine(int);
-
-};
-
-#endif //  GL_ENGINE_EDITOR_HPP
-

Deleted: trunk/gui/qt3/GLSimulationPlayerViewer.cpp
===================================================================
--- trunk/gui/qt3/GLSimulationPlayerViewer.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLSimulationPlayerViewer.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,177 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;GLSimulationPlayerViewer.hpp&quot;
-#include &lt;stdlib.h&gt;
-#include &lt;fstream&gt;
-#include &lt;string&gt;
-#include &lt;boost/lexical_cast.hpp&gt;
-#include &lt;boost/filesystem/operations.hpp&gt;
-#include &lt;boost/filesystem/convenience.hpp&gt;
-
-
-using namespace std;
-using namespace boost;
-
-
-GLSimulationPlayerViewer::GLSimulationPlayerViewer(QWidget * parent,char* name) : QGLViewer(parent,name)
-{
-	shared_ptr&lt;Factorable&gt; tmpRenderer = ClassFactory::instance().createShared(&quot;OpenGLRenderingEngine&quot;);
-	renderer = static_pointer_cast&lt;RenderingEngine&gt;(tmpRenderer);
-
-	setSceneRadius(2);
-	showEntireScene();
-	resize(720, 576);
-	setAnimationPeriod(1);
-	saveSnapShots = false;
-	
-}
-
-
-GLSimulationPlayerViewer::~GLSimulationPlayerViewer()
-{
-
-}
-
-
-void GLSimulationPlayerViewer::initializeGL()
-{
-	QGLViewer::initializeGL();
-	renderer-&gt;init();
-}
-
-
-void GLSimulationPlayerViewer::draw()
-{
-	if (rootBody)
-	{
-		//renderer-&gt;drawBoundingVolume = false;
-		//renderer-&gt;drawGeometricalModel = true;
-		renderer-&gt;render(rootBody);
-	}
-}
-
-
-void GLSimulationPlayerViewer::fastDraw()
-{
-	if (rootBody)
-	{
-		//renderer-&gt;drawBoundingVolume = true;
-		//renderer-&gt;drawGeometricalModel = false;
-		renderer-&gt;render(rootBody);
-	}
-}
-
-
-void GLSimulationPlayerViewer::animate()
-{
-	if (!loadPositionOrientationFile())
-	{
-		frameNumber=0;
-		stopAnimation();
-	}
-	else
-	{
-		shared_ptr&lt;BodyContainer&gt;&amp; bodies = rootBody-&gt;bodies;
-	
-		int i=0;
-	
-		BodyContainer::iterator bci = bodies-&gt;begin();
-		BodyContainer::iterator bciEnd = bodies-&gt;end();
-	
-		for( ; bci!=bciEnd ; ++bci , ++i )
-			(*bci)-&gt;physicalParameters-&gt;se3 = Se3r(Vector3r(se3s[i][0],se3s[i][1],se3s[i][2]),Quaternionr(se3s[i][3], se3s[i][4], se3s[i][5], se3s[i][6]));
-	
-		if (saveSnapShots)
-		{
-#ifdef QGLVIEWER20
-			setSnapshotFilename(outputBaseDirectory+&quot;/&quot;+outputBaseName);
-#else
-			setSnapshotFileName(outputBaseDirectory+&quot;/&quot;+outputBaseName);
-#endif
-			setSnapshotFormat(&quot;BMP&quot;);
-			saveSnapshot(true);
-		}
-
-		frameNumber++;
-	}
-}
-
-
-void GLSimulationPlayerViewer::load(const string&amp; fileName)
-{
-	IOFormatManager::loadFromFile(&quot;XMLFormatManager&quot;,fileName,&quot;rootBody&quot;,rootBody);
-	updateGL();
-	frameNumber=0;
-	setSnapshotCounter(0);
-}
-
-
-void GLSimulationPlayerViewer::doOneStep()
-{
-	if (!loadPositionOrientationFile())
-	{
-		frameNumber=0;
-		stopAnimation();
-	}
-	else
-		frameNumber++;
-	updateGL();
-}
-
-
-void GLSimulationPlayerViewer::reset()
-{
-	frameNumber = 0;
-	setSnapshotCounter(0);
-	loadPositionOrientationFile();
-	frameNumber++;
-	updateGL();
-}
-
-
-bool GLSimulationPlayerViewer::loadPositionOrientationFile()
-{
-
-	fileName = inputBaseDirectory+&quot;/&quot;+inputBaseName;
-
-	string num = lexical_cast&lt;string&gt;(frameNumber);
-	while (num.size()&lt;(size_t)inputPaddle)
-		num.insert(num.begin(),'0');
-
-	fileName += num;
-
-	//system((&quot;cp &quot;+fileName+lexical_cast&lt;string&gt;(frameNumber)+&quot;.bz2 tmp.bz2&quot;).c_str());
-	//system(&quot;bzip2 -d tmp.bz2&quot;);
-	if (filesystem::exists( fileName ))
-	{	
-		ifstream f(fileName.c_str());
-	
-		int nbElements;
-	
-		f &gt;&gt; nbElements;
-	
-		int oldSize = se3s.size();
-		if (oldSize!=nbElements)
-		{
-			se3s.resize(nbElements);
-			for(int i=oldSize;i&lt;nbElements;i++)
-				se3s[i].resize(7);
-		}
-	
-		for(int i=0;i&lt;nbElements;i++)
-			f &gt;&gt; se3s[i][0] &gt;&gt;se3s[i][1] &gt;&gt;se3s[i][2] &gt;&gt;se3s[i][3] &gt;&gt;se3s[i][4] &gt;&gt;se3s[i][5] &gt;&gt;se3s[i][6];
-	
-		f.close();
-		//system(&quot;rm tmp&quot;);
-		return true;
-	}
-		return false;
-}
-
-

Deleted: trunk/gui/qt3/GLSimulationPlayerViewer.cw
===================================================================
--- trunk/gui/qt3/GLSimulationPlayerViewer.cw	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLSimulationPlayerViewer.cw	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,54 +0,0 @@
-&lt;!DOCTYPE CW&gt;&lt;CW&gt;
-&lt;customwidgets&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLEngineEditor&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLEngineEditor.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;
-            &lt;data format=&quot;PNG&quot; length=&quot;1002&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b000003b149444154388dad945f4c5b551cc73fe7dc4b7b4bcba0762d45c43114323599ee6192609c51d883892ce083f1718b3ebb185f8dc91e972cf39d2d2a2f1af664b6f1e0fe3863a0718969700eb0c52142da0242a1bd6d696f7bcff101585203ceb8fd9ece39f99dcff9fe7edf939f88c562ec465f5f9fe609442c161362173c3e3eae7b7a7ac8e7f36432196cdbfe4f907c3e4f2291201e8fe338cec3737357e9e8e828aded1e229d650e1f2d51754b082110124c13a4dc5ea341eb9dc284c0558a853f3ce8cb0677ef500fde7d39d2596679e326597b8e9abb85d7a770ab16ab6983ec5a05b487a70e36f0f4e10afe408d6a558310980108478dba4a1e8233990c5d474b64ed39aa3a8fe5f3317fbf81dbd70bccfeb205947632fd74f6589c1c6ea2f70d03a58ba0c1f2c9bdc1b66de3b8256a6e11cbe7e3ee1d181b590124fe2693aeee08d223c82c3a2c24b7b874bec8f26288774f7bd054504aef0dde6e99c0eb83f9fb266323cb80a27fb0958141836044605a2ee5523393371cc646fee2da37195aa35d0c0c5b4859ac03d7e91712dcaac5adab3650a3ff9d08ef7dd8404bb48869e5d958b5b87dadc4c9a1464e9f0d032!
 6df7ebd86bd2e310cb1bf62d384d59441f2d70a070e1c60e09489929b988681bdd9cc97170bcc4c65595f71f8e0e3301337fc24a7732467831875a47f289652b0be5e4151e6d07316c1b0c0340d8ab92023e76d66a6b2840e36d2fb7a13fee632475e6edc367ea98a90fb98b7dd6310ca0328a44761582e1bab41befabcc0ec940d28bc5e93b68e064cab84e1d9beaeb48934eac1f53b01c1b000fca496aa54b61a99fcde61662a4b4b4b23d1680be9d426173e4df3602a48ea411989a4fd590f52a8fd156b05ed9d350e3defe3cfdf4b4c7ce770ea7d3fb9f520afbe1620daeee5c26735d20b9b9cfb6811a754a439e4e5c5639a4caa1e5caf586bfc0197b78702005cb9b4cae4cd3267ce8638fe964bd72b393e39d74928d242617303a756a37f284447770dcdbffc6384a05a85de1306e9a52057c7527c7131c3c42d3f475eb2303c82d4fc3276d6811db37efeb148723082d9b08f79f97c1e5729109a9a28307cc622d2d6cdf52b2b24efe548dedb00142009862cfa879ee1a71f6cec928353511472fbf4389148b0b0e0c108081412458dfe21c9f11351e67e7358595468246d1d1e5e38a6e9e851bc39d84ab502a669331dafec0d8ec7e3e8cb06e1a881d727d1ae40180a434a8c9db129a54126ad48a7358c2b4c5352c8c374bcccdab2bb37d8719cba79fab8211f9df21!
 8e0582c261e95f8bfc04f1a1e8bc5c4dfe0a190172af6a9690000000049454!
 e44ae426
082&lt;/data&gt;
-        &lt;/pixmap&gt;
-        &lt;slot access=&quot;public&quot;&gt;pbAddEngineClicked()&lt;/slot&gt;
-    &lt;/customwidget&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLViewer&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLViewer.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;
-            &lt;data format=&quot;PNG&quot; length=&quot;1125&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b0000042c49444154388db5954f6c14551cc73fefcd7476b65bdaae4bb78bb5502a14d404e4801c88182d1c4c2c693da847400f9c24c68b878684238660e2b1e01f12c19493012ef2478c814412d354a46017a8a564bb6da5bbedccee767776e63d0ffb073751d483bfe49799974c3eeffb7ebf37df9fd05a530b2184040cc0042420aaf9a4d0d554800f045a6b256ae0e1e1e1d6bebebe838ee31c48a7d39b5cd7fd075e251cc7617272f2ded8d8d819cff33e0316819259537aead4a9839d5dd6d1784f91f55b0a94830242088404d304292bef68a89f520802a598fecddaa04f1a876f5c250c7c0a64cdeac686e33807e23d45e6b297c8b877f1831542614550b6599835c83c2a81b6786a75134faf2f1169f12997350881d9021d0903e06de0745d3160a6d3e94dbd5b0a64dcbb94b5831d0e3375ab892b1772dcf9790528543f8dd0d367b36768153b5e31503a0f1aecb004580b44ffac58baae8b1714f0833c7638cc8dab303a320f4822ab4c7a37c69196203de3319d5ce1c4d13c733331dedc67a129a154fd128401ab0616d55a130ac3d42d93d1913940d13fd0c9ee0183685c60da01c5421bd72f7a8c8efccef9afd374267!
 ad93d642365be0636a0d28ec7600941d9e6f23917f0e97f23ce5bef35d19ec863da0ed9059b2be70bec196c66dfa10ec0e49b338f7017258651bf95021035c595429bb0903248fe52a2b5b595dd7b4d945cc2340cdca536be389ee3f67886c5798f773fe8e0dac508c989659277a2180da4ca4ff07821058b8b251445d63d6b13ed1098a6417e39cac85197dbe31962ab9bd9f1f22a226d45366f6d0620fdb08c900d281af6110284b20085b414861d905d88f2e52739ee8cbb8022143259d3dd84691730aa2d52da441a8de0c6958068870022a41e9629ad3473fd3b8fdbe319dadb9b4924da994d2d716c7896fbe35152f78b48245d6b2da4507faf582be8eaf159b721cc837b05ae7debb1f79d08cb8b515edad942a22bc4b1c33eb3d34b1c797f06af90a72d16e2f96d9a74aa11dca8586b222d01af0fb60070f6c402d72f15d97f28c6f6d7027a5f5ce6c3233dc4e2ede496b278be4fff608cee8d3e1add806aeca51094cbb06397c1ecc328e746537c7e3ccdb5cb1136bf60635882d4d41c6ec6836ab37efa214f72208ed9f4d7cdd38ee310280542e38b1c43fb6de26b3672e1ec3cc99bcb246f66a938a3241ab3e91f7c861fbf77710b1e5e49915bae974203ba0e9e9c9cbc373d6d6d305a040a89c2a77f50b27d5782bbbf7acccf28349235dd16cf6dd374f7295e1de!
 8a45c02d37499182b01cc0201a085d61a2144d8b2ac8fb6ed340e77240c426!
 1890e04c
250185262546d534a032154b59e0ad394e41c98182bf268ce6721ed9f064e0253356f6da2e24c1f030f783c15fe6da680af8021602bd051532ca9b8521488559f61aa86c29343578fbf0264a94c906c7d3409214c20043457a116ff6de6795578012889ff6b98fe016ea0ce1c6a2573410000000049454e44ae426082&lt;/data&gt;
-        &lt;/pixmap&gt;
-        &lt;signal&gt; closeSignal(int) &lt;/signal&gt;
-    &lt;/customwidget&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLSimulationPlayerViewer&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLSimulationPlayerViewer.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;
-            &lt;data format=&quot;PNG&quot; length=&quot;1125&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b0000042c49444154388db5954f6c14551cc73fefcd7476b65bdaae4bb78bb5502a14d404e4801c88182d1c4c2c693da847400f9c24c68b878684238660e2b1e01f12c19493012ef2478c814412d354a46017a8a564bb6da5bbedccee767776e63d0ffb073751d483bfe49799974c3eeffb7ebf37df9fd05a530b2184040cc0042420aaf9a4d0d554800f045a6b256ae0e1e1e1d6bebebe838ee31c48a7d39b5cd7fd075e251cc7617272f2ded8d8d819cff33e0316819259537aead4a9839d5dd6d1784f91f55b0a94830242088404d304292bef68a89f520802a598fecddaa04f1a876f5c250c7c0a64cdeac686e33807e23d45e6b297c8b877f1831542614550b6599835c83c2a81b6786a75134faf2f1169f12997350881d9021d0903e06de0745d3160a6d3e94dbd5b0a64dcbb94b5831d0e3375ab892b1772dcf9790528543f8dd0d367b36768153b5e31503a0f1aecb004580b44ffac58baae8b1714f0833c7638cc8dab303a320f4822ab4c7a37c69196203de3319d5ce1c4d13c733331dedc67a129a154fd128401ab0616d55a130ac3d42d93d1913940d13fd0c9ee0183685c60da01c5421bd72f7a8c8efccef9afd374267!
 ad93d642365be0636a0d28ec7600941d9e6f23917f0e97f23ce5bef35d19ec863da0ed9059b2be70bec196c66dfa10ec0e49b338f7017258651bf95021035c595429bb0903248fe52a2b5b595dd7b4d945cc2340cdca536be389ee3f67886c5798f773fe8e0dac508c989659277a2180da4ca4ff07821058b8b251445d63d6b13ed1098a6417e39cac85197dbe31962ab9bd9f1f22a226d45366f6d0620fdb08c900d281af6110284b20085b414861d905d88f2e52739ee8cbb8022143259d3dd84691730aa2d52da441a8de0c6958068870022a41e9629ad3473fd3b8fdbe319dadb9b4924da994d2d716c7896fbe35152f78b48245d6b2da4507faf582be8eaf159b721cc837b05ae7debb1f79d08cb8b515edad942a22bc4b1c33eb3d34b1c797f06af90a72d16e2f96d9a74aa11dca8586b222d01af0fb60070f6c402d72f15d97f28c6f6d7027a5f5ce6c3233dc4e2ede496b278be4fff608cee8d3e1add806aeca51094cbb06397c1ecc328e746537c7e3ccdb5cb1136bf60635882d4d41c6ec6836ab37efa214f72208ed9f4d7cdd38ee310280542e38b1c43fb6de26b3672e1ec3cc99bcb246f66a938a3241ab3e91f7c861fbf77710b1e5e49915bae974203ba0e9e9c9cbc373d6d6d305a040a89c2a77f50b27d5782bbbf7acccf28349235dd16cf6dd374f7295e1de!
 8a45c02d37499182b01cc0201a085d61a2144d8b2ac8fb6ed340e77240c426!
 1890e04c
250185262546d534a032154b59e0ad394e41c98182bf268ce6721ed9f064e0253356f6da2e24c1f030f783c15fe6da680af8021602bd051532ca9b8521488559f61aa86c29343578fbf0264a94c906c7d3409214c20043457a116ff6de6795578012889ff6b98fe016ea0ce1c6a2573410000000049454e44ae426082&lt;/data&gt;
-        &lt;/pixmap&gt;
-    &lt;/customwidget&gt;
-&lt;/customwidgets&gt;
-&lt;/CW&gt;

Deleted: trunk/gui/qt3/GLSimulationPlayerViewer.hpp
===================================================================
--- trunk/gui/qt3/GLSimulationPlayerViewer.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLSimulationPlayerViewer.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,65 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef SIMULATIONPLAYERVIEWER_HPP
-#define SIMULATIONPLAYERVIEWER_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/core/RenderingEngine.hpp&gt;
-#include&lt;yade/core/MetaBody.hpp&gt;
-#include &lt;QGLViewer/qglviewer.h&gt;
-
-class GLSimulationPlayerViewer : public QGLViewer
-{
-/// Attributes
-	private :
-		shared_ptr&lt;RenderingEngine&gt;	 renderer;
-		shared_ptr&lt;MetaBody&gt;		 rootBody;
-		vector&lt;vector&lt;float&gt; &gt;		 se3s;
-		
-		string				 fileName
-						,inputBaseName
-						,inputBaseDirectory
-						,outputBaseName
-						,outputBaseDirectory;
-
-		int				 inputPaddle;
-
-		bool				 saveSnapShots;
-
-		int				 frameNumber;
-		
-		bool loadPositionOrientationFile();
-	
-	public :
-		GLSimulationPlayerViewer(QWidget * parent=0,char*name=0);
-		virtual ~GLSimulationPlayerViewer();
-
-		void setRootBody(shared_ptr&lt;MetaBody&gt; rb) { rootBody = rb;};
-		void load(const string&amp; fileName);
-
-		void setInputPaddle(int p) { inputPaddle = p;};
-		void setInputBaseName(const string&amp; baseName) { inputBaseName = baseName;};
-		void setInputDirectory(const string&amp; baseDirectory) { inputBaseDirectory = baseDirectory;};
-		
-		void setOutputBaseName(const string&amp; baseName) { outputBaseName = baseName;};
-		void setOutputDirectory(const string&amp; baseDirectory) { outputBaseDirectory = baseDirectory;};
-		void setSaveSnapShots(bool b) { saveSnapShots = b;};
-		
-		void doOneStep();
-		void reset();
-
-	protected :
-		virtual void draw();
-		virtual void fastDraw();
-		virtual void animate();
-		virtual void initializeGL();
-};
-
-#endif // SIMULATIONVIEWER_HPP
-

Modified: trunk/gui/qt3/GLViewer.hpp
===================================================================
--- trunk/gui/qt3/GLViewer.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/GLViewer.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -11,7 +11,7 @@
 #include&lt;yade/core/Omega.hpp&gt;
 //#include&lt;yade/lib-opengl/GLWindowsManager.hpp&gt; // remove that...
 #include&lt;yade/core/RenderingEngine.hpp&gt;
-#include &lt;QGLViewer/qglviewer.h&gt;
+#include&lt;yade/lib-QGLViewer/qglviewer.h&gt;
 
 class GLViewer : public QGLViewer
 {	

Deleted: trunk/gui/qt3/QtCodeGenerator.cpp
===================================================================
--- trunk/gui/qt3/QtCodeGenerator.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtCodeGenerator.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,692 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtCodeGenerator.hpp&quot;
-#include &quot;FileDialog.hpp&quot;
-#include &lt;qcombobox.h&gt;
-#include &lt;qlineedit.h&gt;
-#include &lt;qcheckbox.h&gt;
-#include &lt;qgroupbox.h&gt;
-#include &lt;qlabel.h&gt;
-#include &lt;qlistbox.h&gt;
-#include &lt;boost/filesystem/operations.hpp&gt;
-#include &lt;boost/filesystem/convenience.hpp&gt;
-#include &lt;algorithm&gt;
-#include &lt;cctype&gt;
-#include &lt;iostream&gt;
-#include &lt;vector&gt;
-#include &lt;iterator&gt;
-
-
-QtCodeGenerator::QtCodeGenerator ( QWidget * parent , const char * name) : QtGeneratedCodeGenerator(parent,name)
-{
-	bgDataTypeClicked(0); // to init the default data class to be geometricalModel
-	bgEngineTypeClicked(0); // to init the default data class to be geometricalModel
-}
-
-
-QtCodeGenerator::~QtCodeGenerator ()
-{
-
-}
-
-//
-// Data class generation
-//
-
-void QtCodeGenerator::bgDataTypeClicked(int v)
-{
-	switch (v)
-	{
-		case 0 : baseDataClass = &quot;GeometricalModel&quot;; break;
-		case 1 : baseDataClass = &quot;InteractingGeometry&quot;; break;
-		case 2 : baseDataClass = &quot;BoundingVolume&quot;; break;
-		case 3 : baseDataClass = &quot;PhysicalParameters&quot;; break;
-		case 4 : baseDataClass = &quot;State&quot;; break;
-		case 5 : baseDataClass = &quot;InteractionGeometry&quot;; break;
-		case 6 : baseDataClass = &quot;InteractionPhysics&quot;; break;
-		case 7 : baseDataClass = &quot;PhysicalAction&quot;; break;
-	}
-
-	cbDataInheritsFrom-&gt;clear();
-	cbDataInheritsFrom-&gt;insertItem(baseDataClass);
-	map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-	map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-	for(;di!=diEnd;++di)
-	{
-		if (Omega::instance().isInheritingFrom((*di).first,baseDataClass))
-			cbDataInheritsFrom-&gt;insertItem((*di).first);
-	}
-
-}
-
-
-void QtCodeGenerator::pbDataPathClicked()
-{
-	leDataPath-&gt;setText(FileDialog::getExistingDirectory ( &quot;./&quot;,&quot;Choose Path For your Data Class Plugin&quot;,this-&gt;parentWidget()-&gt;parentWidget()).c_str());
-}
-
-
-void QtCodeGenerator::pbGenerateDataClassClicked()
-{
- 	bool generateDestructor = cbDataGenerateDestructor-&gt;isChecked();
-	bool generateRegisterAttributes = cbDataGenerateRegisterAttributes-&gt;isChecked();
- 	bool generatePostProcessAttributes = cbDataGeneratePostProcessAttributes-&gt;isChecked();
-	bool generatePreProcessAttributes = cbDataGeneratePreProcessAttributes-&gt;isChecked();
-
-	string name = leDataYourName-&gt;text();
-	string email = leDataYourEmail-&gt;text();
-	string directory = leDataPath-&gt;text().data();
-
-	if (directory[directory.size()-1]!='/') directory.push_back('/');
-
-	string className = leDataClassName-&gt;text().data();
-	string inheritsFrom = cbDataInheritsFrom-&gt;currentText().data();
-	string hppFile = directory+className+string(&quot;/&quot;)+className+string(&quot;.hpp&quot;);
-	string cppFile = directory+className+string(&quot;/&quot;)+className+string(&quot;.cpp&quot;);
-
-	if (testDirectory(directory,className))
-	{
-		ofstream hpp(hppFile.c_str());
-		ofstream cpp(cppFile.c_str());
-
-///
-/// Generating hpp file
-///
-		writeHeader(hpp,name,email);
-		
-		writeSperarationLines(hpp);
-		
-		writeIfDef(hpp,className,true);
-		
-		writeSperarationLines(hpp);
-		
-		hpp &lt;&lt; &quot;#include &lt;&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;.hpp&gt;&quot; &lt;&lt; endl;
-		
-		writeSperarationLines(hpp);
-	
-		hpp &lt;&lt; &quot;class &quot; &lt;&lt; className &lt;&lt; &quot; : public &quot; &lt;&lt; inheritsFrom &lt;&lt; endl;
-		hpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-
-		writeAttributesArea(hpp);
-		writeMethodsArea(hpp);
-		
-		if (generateDestructor)
-			writeConstructorDestructorArea(hpp);
-		
-		hpp &lt;&lt; &quot;\t public    : &quot; &lt;&lt; className &lt;&lt; &quot;();&quot; &lt;&lt; endl;
-		
-		if (generateDestructor)
-			hpp &lt;&lt; &quot;\t public    : virtual ~&quot; &lt;&lt; className &lt;&lt; &quot;();&quot; &lt;&lt; endl;
-
-		writeSerializationArea(hpp);
-		if (generateRegisterAttributes)
-			hpp &lt;&lt; &quot;\t public    : virtual void registerAttributes();&quot; &lt;&lt; endl;
-	 	if (generatePostProcessAttributes)
-			hpp &lt;&lt; &quot;\t protected : virtual void postProcessAttributes(bool deserializing);&quot; &lt;&lt; endl;
-		if (generatePreProcessAttributes)
-			hpp &lt;&lt; &quot;\t protected : virtual void preProcessAttributes(bool deserializing);&quot; &lt;&lt; endl;
-		
-		if (generateRegisterAttributes||generatePostProcessAttributes||generatePreProcessAttributes)
- 			hpp &lt;&lt; endl;
-
-		hpp &lt;&lt; &quot;\t REGISTER_CLASS_NAME(&quot; &lt;&lt; className &lt;&lt; &quot;);&quot; &lt;&lt; endl;
-
-		hpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		
-		writeSperarationLines(hpp);
-	
-		hpp &lt;&lt; &quot;REGISTER_SERIALIZABLE(&quot; &lt;&lt; className &lt;&lt; &quot;,false);&quot; &lt;&lt; endl;
-
-		writeSperarationLines(hpp);
-
-		writeIfDef(hpp,className,false);
-
-		writeSperarationLines(hpp);
-
-///
-/// Generating cpp file
-///
-		writeHeader(cpp,name,email);
-		
-		writeSperarationLines(cpp);
-
-		cpp &lt;&lt; &quot;#include \&quot;&quot; &lt;&lt; className &lt;&lt; &quot;.hpp\&quot;&quot; &lt;&lt; endl;
-
-		writeSperarationLines(cpp);
-
-		cpp &lt;&lt; className &lt;&lt; &quot;::&quot; &lt;&lt; className &lt;&lt; &quot;() : &quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;()&quot; &lt;&lt; endl;
-		cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-		cpp &lt;&lt; &quot;\t createIndex();&quot; &lt;&lt; endl;
-		writePutYourCodeHereArea(cpp,1);
-		cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		
-		writeSperarationLines(cpp);
-	
-		if (generateDestructor)
-		{
-			cpp &lt;&lt; className &lt;&lt; &quot;::~&quot; &lt;&lt; className &lt;&lt; &quot;()&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-			writePutYourCodeHereArea(cpp);
-			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		}
-
-		writeSperarationLines(cpp);
-	
-		if (generateRegisterAttributes)
-		{
-			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::registerAttributes()&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::registerAttributes();&quot; &lt;&lt; endl;
-			writePutYourCodeHereArea(cpp,1);
-			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		}		
-
-		writeSperarationLines(cpp);
-
-	 	if (generatePostProcessAttributes)
-		{
-			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::postProcessAttributes(bool deserializing)&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::postProcessAttributes(deserializing);&quot; &lt;&lt; endl;
-			writePutYourCodeHereArea(cpp,1);
-			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		}
-
-		writeSperarationLines(cpp);
-
-		if (generatePreProcessAttributes)
-		{
-			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::preProcessAttributes(bool deserializing)&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::preProcessAttributes();&quot; &lt;&lt; endl;
-			writePutYourCodeHereArea(cpp,1);
-			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		}
-
-		writeSperarationLines(cpp);
-
-		hpp.close();
-		cpp.close();
-	}
-	else
-	{
-	}
-	
-
-}
-
-
-void QtCodeGenerator::pbLoadDataClassClicked()
-{
-
-}
-
-
-void QtCodeGenerator::pbSaveDataClassClicked()
-{
-
-}
-
-//
-// Engine generation
-//
-
-void QtCodeGenerator::bgEngineTypeClicked(int v )
-{
-	switch (v)
-	{
-		case 0 : baseEngineClass = &quot;Engine&quot;; break;
-		case 1 : baseEngineClass = &quot;EngineUnit&quot;; break;
-		case 2 : baseEngineClass = &quot;MetaDispatchingEngine1D&quot;; break;
-		case 3 : baseEngineClass = &quot;MetaDispatchingEngine2D&quot;; break;
-	}
-
-	if (baseEngineClass==&quot;Engine&quot;)
-	{
-		gbMetaDispatchingEngineProperties-&gt;setEnabled(false);
-		gbEngineUnitProperties-&gt;setEnabled(false);
-	}
-	else if (baseEngineClass==&quot;EngineUnit&quot;)
-	{
-		gbMetaDispatchingEngineProperties-&gt;setEnabled(false);
-		gbEngineUnitProperties-&gt;setEnabled(true);
-	}
-	else if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot;)
-	{
-		gbMetaDispatchingEngineProperties-&gt;setEnabled(true);
-		gbEngineUnitProperties-&gt;setEnabled(false);
-		tlMetaEngineBaseClass2-&gt;setEnabled(false);
-		cbMetaEngineBaseClass2-&gt;setEnabled(false);
-	}
-	else if (baseEngineClass==&quot;MetaDispatchingEngine2D&quot;)
-	{
-		gbMetaDispatchingEngineProperties-&gt;setEnabled(true);
-		gbEngineUnitProperties-&gt;setEnabled(false);
-		tlMetaEngineBaseClass2-&gt;setEnabled(true);
-		cbMetaEngineBaseClass2-&gt;setEnabled(true);
-	}
-	
-	if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot; || baseEngineClass==&quot;MetaDispatchingEngine1D&quot;)
-	{
-		cbMetaEngineBaseClass1-&gt;clear();
-		map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-		map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-		for(;di!=diEnd;++di)
-		{
-			if ((*di).second.isIndexable)
-				cbMetaEngineBaseClass1-&gt;insertItem((*di).first);
-		}
-
-	}
-
-	if (baseEngineClass==&quot;MetaDispatchingEngine2D&quot;)
-	{
-		cbMetaEngineBaseClass2-&gt;clear();
-		map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-		map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-		for(;di!=diEnd;++di)
-		{
-			if ((*di).second.isIndexable)
-				cbMetaEngineBaseClass2-&gt;insertItem((*di).first);
-		}
-	}
-}
-
-
-void QtCodeGenerator::pbEnginePathClicked()
-{
-	leEnginePath-&gt;setText(FileDialog::getExistingDirectory ( &quot;./&quot;,&quot;Choose Path For your Engine Plugin&quot;,this-&gt;parentWidget()-&gt;parentWidget()).c_str());
-}
-
-
-void QtCodeGenerator::pbAddEngineUnitParamClicked()
-{
-	lbEngineUnitParam-&gt;insertItem(leEngineUnitParam-&gt;text());
-}
-
-
-void QtCodeGenerator::pbAddMetaEngineParamClicked()
-{
-	lbMetaEngineParam-&gt;insertItem(leMetaEngineParam-&gt;text());
-}
-
-void QtCodeGenerator::pbGenerateEngineClassClicked()
-{
-	bool generateConstructor = cbEngineGenerateConstructor-&gt;isChecked();
-	bool generateDestructor = cbEngineGenerateDestructor-&gt;isChecked();
-	bool generateRegisterAttributes = cbEngineGenerateRegisterAttributes-&gt;isChecked();
- 	bool generatePostProcessAttributes = cbEngineGeneratePostProcessAttributes-&gt;isChecked();
-	bool generatePreProcessAttributes = cbEngineGeneratePreProcessAttributes-&gt;isChecked();
-
-	string name = leEngineYourName-&gt;text();
-	string email = leEngineYourEmail-&gt;text();
-	string directory = leEnginePath-&gt;text().data();
-
-	if (directory[directory.size()-1]!='/') directory.push_back('/');
-
-	string className = leEngineClassName-&gt;text().data();
-
-	string metaEngineBaseClass1,metaEngineBaseClass2;
-	string engineUnitBaseClass1,engineUnitBaseClass2;
-	string metaEngineEngineUnitName,engineUnitBaseClass;
-	string metaEngineEngineUnitReturnType, engineUnitReturnType;
-
-	if (baseEngineClass==&quot;EngineUnit&quot;)
-	{
-		//engineUnitBaseClass1
-		//engineUnitBaseClass1
-		engineUnitBaseClass	= leEngineUnitBaseClass-&gt;text().data();
-		engineUnitReturnType	= leEngineUnitReturnType-&gt;text().data();
-	}
-	else if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot; || baseEngineClass==&quot;MetaDispatchingEngine2D&quot;)
-	{
-		metaEngineBaseClass1		= cbMetaEngineBaseClass1-&gt;currentText().data();
-		metaEngineEngineUnitName	= leMetaEngineEngineUnitName-&gt;text().data();
-		metaEngineEngineUnitReturnType	= leMetaEngineEngineUnitReturnType-&gt;text().data();
- 		if (baseEngineClass==&quot;MetaDispatchingEngine2D&quot;)
-			metaEngineBaseClass2	= cbMetaEngineBaseClass2-&gt;currentText().data();
-	}
-
-	string hppFile = directory+className+string(&quot;/&quot;)+className+string(&quot;.hpp&quot;);
-	string cppFile = directory+className+string(&quot;/&quot;)+className+string(&quot;.cpp&quot;);
-
-	if (testDirectory(directory,className))
-	{
-		ofstream hpp(hppFile.c_str());
-		ofstream cpp(cppFile.c_str());
-
-///
-/// Generating hpp file
-///
-		writeHeader(hpp,name,email);
-		
-		writeSperarationLines(hpp);
-		
-		writeIfDef(hpp,className,true);
-		
-		writeSperarationLines(hpp);
-		
-		if (baseEngineClass==&quot;Engine&quot;)
-			hpp &lt;&lt; &quot;#include &lt;Engine.hpp&gt;&quot; &lt;&lt; endl;
-		else if (baseEngineClass==&quot;EngineUnit&quot;)	
-			hpp &lt;&lt; &quot;#include &lt;&quot; &lt;&lt; engineUnitBaseClass &lt;&lt; &quot;.hpp&gt;&quot; &lt;&lt; endl;
-		else if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot; || baseEngineClass==&quot;MetaDispatchingEngine2D&quot;)
-		{
-			hpp &lt;&lt; &quot;#include &lt;Engine.hpp&gt;&quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;#include &lt;yade/lib-multimethods/DynLibDispatcher.hpp&gt;&quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;#include \&quot;&quot; &lt;&lt; metaEngineEngineUnitName &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;
-		}
-
-		writeSperarationLines(hpp);
-	
-		if (baseEngineClass==&quot;Engine&quot;)
-			hpp &lt;&lt; &quot;class &quot; &lt;&lt; className &lt;&lt; &quot; : public Engine&quot; &lt;&lt; endl;
-		else if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot; || baseEngineClass==&quot;MetaDispatchingEngine2D&quot; )
-		{
-			hpp &lt;&lt; &quot;class &quot; &lt;&lt; className &lt;&lt; &quot; : &quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;		public Engine, &quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;		public DynLibDispatcher&quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;		&lt;&quot;&lt;&lt;endl;
-			if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot;)
-				hpp &lt;&lt; &quot;			TYPELIST_1(&quot; &lt;&lt; metaEngineBaseClass1 &lt;&lt; &quot;),&quot; &lt;&lt; endl;
-			else
-				hpp &lt;&lt; &quot;			TYPELIST_2(&quot; &lt;&lt; metaEngineBaseClass1 &lt;&lt; &quot;, &quot; &lt;&lt; metaEngineBaseClass1 &lt;&lt; &quot;),&quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;			&quot; &lt;&lt; metaEngineEngineUnitName &lt;&lt; &quot;,&quot; &lt;&lt; endl;
-			hpp &lt;&lt; &quot;			&quot; &lt;&lt; metaEngineEngineUnitReturnType &lt;&lt; &quot;,&quot; &lt;&lt; endl;
-		
-			/*if (lbMetaEngineParam-&gt;count()==0)
-			{
-				if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot;)
-					hpp &lt;&lt; &quot;			TYPELIST_1(const shared_ptr&lt;&quot;&lt;&lt;metaEngineBaseClass1&lt;&lt;&quot;&gt;&amp;)&quot; &lt;&lt; endl;
-				else
-					hpp &lt;&lt; &quot;			TYPELIST_2(const shared_ptr&lt;&quot;&lt;&lt;metaEngineBaseClass1&lt;&lt; &quot;&gt;&amp;), &quot; &lt;&lt; metaEngineBaseClass2 &lt;&lt; &quot;&gt;&amp;)&quot; &lt;&lt; endl;
-			}
-			else
-			{*/
-				int nb = lbMetaEngineParam-&gt;count();
-				string tab;
-				if (nb&gt;0 || baseEngineClass==&quot;MetaDispatchingEngine2D&quot;) tab=&quot;\t&quot;;
-				if (baseEngineClass==&quot;MetaDispatchingEngine1D&quot;)
-					hpp &lt;&lt; &quot;			TYPELIST_&quot;&lt;&lt;nb+1&lt;&lt;&quot;(&quot;&lt;&lt;tab&lt;&lt;&quot;const shared_ptr&lt;&quot;&lt;&lt;metaEngineBaseClass1&lt;&lt;&quot;&gt;&amp; &quot; ;					
-				else
-				{
-					hpp &lt;&lt; &quot;			TYPELIST_&quot;&lt;&lt;nb+2&lt;&lt;&quot;(&quot;&lt;&lt;tab&lt;&lt;&quot;const shared_ptr&lt;&quot;&lt;&lt;metaEngineBaseClass1&lt;&lt;&quot;&gt;&amp;, &quot; &lt;&lt; endl;
-					hpp &lt;&lt; &quot;					const shared_ptr&lt;&quot;&lt;&lt;metaEngineBaseClass2&lt;&lt;&quot;&gt;&amp; &quot;;
-				}
-
-				if (nb==0)
-					hpp &lt;&lt; &quot;)&quot; &lt;&lt; endl;
-				else
-					hpp &lt;&lt; &quot;,&quot; &lt;&lt; endl;
-
-				for(int i=0;i&lt;nb;i++)
-				{
-					string currentParam = lbMetaEngineParam-&gt;text(i).data();
-					if (i!=nb-1)
-						hpp &lt;&lt; &quot;					&quot; &lt;&lt; currentParam &lt;&lt; &quot; ,&quot; &lt;&lt; endl;
-					else
-					{
-						hpp &lt;&lt; &quot;					&quot; &lt;&lt; currentParam &lt;&lt; endl;
-						hpp &lt;&lt; &quot;			)&quot; &lt;&lt; endl;				
-					}
-				}			
-			//}
-			hpp &lt;&lt; &quot;		&gt;&quot; &lt;&lt; endl;
-		}
-		else if(baseEngineClass==&quot;EngineUnit&quot;)
-		{
-
-		}
-
-		hpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-
-		writeAttributesArea(hpp);
-		writeMethodsArea(hpp);
-		
-		if (generateConstructor || generateDestructor)
-			writeConstructorDestructorArea(hpp);
-		
-		if (generateConstructor)
-			hpp &lt;&lt; &quot;\t public    : &quot; &lt;&lt; className &lt;&lt; &quot;();&quot; &lt;&lt; endl;
-		
-		if (generateDestructor)
-			hpp &lt;&lt; &quot;\t public    : virtual ~&quot; &lt;&lt; className &lt;&lt; &quot;();&quot; &lt;&lt; endl;
-
-		writeSerializationArea(hpp);
-		if (generateRegisterAttributes)
-			hpp &lt;&lt; &quot;\t public    : virtual void registerAttributes();&quot; &lt;&lt; endl;
-	 	if (generatePostProcessAttributes)
-			hpp &lt;&lt; &quot;\t protected : virtual void postProcessAttributes(bool deserializing);&quot; &lt;&lt; endl;
-		if (generatePreProcessAttributes)
-			hpp &lt;&lt; &quot;\t protected : virtual void preProcessAttributes(bool deserializing);&quot; &lt;&lt; endl;
-		
-		if (generateRegisterAttributes||generatePostProcessAttributes||generatePreProcessAttributes)
- 			hpp &lt;&lt; endl;
-
-		hpp &lt;&lt; &quot;\t REGISTER_CLASS_NAME(&quot; &lt;&lt; className &lt;&lt; &quot;);&quot; &lt;&lt; endl;
-
-		hpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-		
-		writeSperarationLines(hpp);
-	
-		hpp &lt;&lt; &quot;REGISTER_SERIALIZABLE(&quot; &lt;&lt; className &lt;&lt; &quot;,false);&quot; &lt;&lt; endl;
-
-		writeSperarationLines(hpp);
-
-		writeIfDef(hpp,className,false);
-
-		writeSperarationLines(hpp);
-
-///
-/// Generating cpp file
-///
-// 		writeHeader(cpp,name,email);
-// 		
-// 		writeSperarationLines(cpp);
-// 
-// 		cpp &lt;&lt; &quot;#include \&quot;&quot; &lt;&lt; className &lt;&lt; &quot;.hpp\&quot;&quot; &lt;&lt; endl;
-// 
-// 		writeSperarationLines(cpp);
-// 
-// 		cpp &lt;&lt; className &lt;&lt; &quot;::&quot; &lt;&lt; className &lt;&lt; &quot;() : &quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;()&quot; &lt;&lt; endl;
-// 		cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-// 		cpp &lt;&lt; &quot;\t createIndex();&quot; &lt;&lt; endl;
-// 		writePutYourCodeHereArea(cpp,1);
-// 		cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-// 		
-// 		writeSperarationLines(cpp);
-// 	
-// 		if (generateDestructor)
-// 		{
-// 			cpp &lt;&lt; className &lt;&lt; &quot;::~&quot; &lt;&lt; className &lt;&lt; &quot;()&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-// 			writePutYourCodeHereArea(cpp);
-// 			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-// 		}
-// 
-// 		writeSperarationLines(cpp);
-// 	
-// 		if (generateRegisterAttributes)
-// 		{
-// 			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::registerAttributes()&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::registerAttributes();&quot; &lt;&lt; endl;
-// 			writePutYourCodeHereArea(cpp,1);
-// 			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-// 		}		
-// 
-// 		writeSperarationLines(cpp);
-// 
-// 	 	if (generatePostProcessAttributes)
-// 		{
-// 			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::postProcessAttributes(bool deserializing)&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::postProcessAttributes(deserializing);&quot; &lt;&lt; endl;
-// 			writePutYourCodeHereArea(cpp,1);
-// 			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-// 		}
-// 
-// 		writeSperarationLines(cpp);
-// 
-// 		if (generatePreProcessAttributes)
-// 		{
-// 			cpp &lt;&lt; &quot;void &quot; &lt;&lt; className &lt;&lt;&quot;::preProcessAttributes(bool deserializing)&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;{&quot; &lt;&lt; endl;
-// 			cpp &lt;&lt; &quot;\t&quot; &lt;&lt; inheritsFrom &lt;&lt; &quot;::preProcessAttributes();&quot; &lt;&lt; endl;
-// 			writePutYourCodeHereArea(cpp,1);
-// 			cpp &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-// 		}
-// 
-// 		writeSperarationLines(cpp);
-
-		hpp.close();
-		cpp.close();
-	}
-	else
-	{
-	}
-	
-
-}
-
-
-void QtCodeGenerator::pbSaveEngineClassClicked()
-{
-
-}
-
-
-void QtCodeGenerator::pbLoadEngineClassClicked()
-{
-
-}
-
-//
-// Common function
-//
-
-void QtCodeGenerator::writeHeader(ofstream&amp; s, const string&amp; name, const string&amp; email)
-{
-	string space1,space2;
-	for(unsigned int i=0;i&lt;=48-name.size();i++)
-		space1.push_back(' ');
-	for(unsigned int i=0;i&lt;=70-email.size();i++)
-		space2.push_back(' ');
-
-	s &lt;&lt; &quot;/***************************************************************************&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   Copyright (C) 2004 by &quot; &lt;&lt; name &lt;&lt; space1 &lt;&lt;                          &quot;*&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   &quot; &lt;&lt; email &lt;&lt; space2 &lt;&lt;                                               &quot;*&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*                                                                          *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   This program is free software; you can redistribute it and/or modify   *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   it under the terms of the GNU General Public License as published by   *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   the Free Software Foundation; either version 2 of the License, or      *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   (at your option) any later version.                                    *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*                                                                          *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   This program is distributed in the hope that it will be useful,        *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   GNU General Public License for more details.                           *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*                                                                          *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   You should have received a copy of the GNU General Public License      *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   along with this program; if not, write to the                          *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   Free Software Foundation, Inc.,                                        *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.              *&quot; &lt;&lt; endl;
-	s &lt;&lt; &quot;***************************************************************************/&quot; &lt;&lt; endl;
-}
-
-	
-void QtCodeGenerator::writeSperarationLines(ofstream&amp; s)
-{
-	s &lt;&lt; endl;
-	s &lt;&lt; endl;
-}
-
-
-void QtCodeGenerator::writeAttributesArea(ofstream&amp; s)
-{
-	s &lt;&lt; endl;
-	s &lt;&lt; &quot;/// ATTRIBUTES                                                                                   //&quot; &lt;&lt; endl;
-	writePutYourCodeHereArea(s);
-}
-
-
-void QtCodeGenerator::writeMethodsArea(ofstream&amp; s)
-{
-	s &lt;&lt; endl;
-	s &lt;&lt; &quot;/// METHODS                                                                                      //&quot; &lt;&lt; endl;
-	writePutYourCodeHereArea(s);
-
-}
-
-
-void QtCodeGenerator::writeConstructorDestructorArea(ofstream&amp; s)
-{
-	s &lt;&lt; endl;
-	s &lt;&lt; &quot;/// CONSTRUCTOR/DESTRUCTOR                                                                       //&quot; &lt;&lt; endl;
-	s &lt;&lt; endl;
-}
-
-
-void QtCodeGenerator::writeSerializationArea(ofstream&amp; s)
-{
-	s &lt;&lt; endl;
-	s &lt;&lt; &quot;/// SERIALIZATION                                                                                //&quot; &lt;&lt; endl;
-	s &lt;&lt; endl;
-}
-
-
-void QtCodeGenerator::writePutYourCodeHereArea(ofstream&amp; s, int nbTabs)
-{
-	s &lt;&lt; endl;
-	
-	for(int i=0;i&lt;nbTabs;i++)
-		s &lt;&lt; &quot;\t&quot;;
-	s &lt;&lt; &quot;///&quot; &lt;&lt; endl;
-	for(int i=0;i&lt;nbTabs;i++)
-		s &lt;&lt; &quot;\t&quot;;
-	s &lt;&lt; &quot;/// PUT YOUR CODE HERE&quot; &lt;&lt; endl;
-	for(int i=0;i&lt;nbTabs;i++)
-		s &lt;&lt; &quot;\t&quot;;
-	s &lt;&lt; &quot;///&quot; &lt;&lt; endl;
-	s &lt;&lt; endl;
-}
-
-
-void QtCodeGenerator::writeIfDef(ofstream&amp; s, const string&amp; name, bool start)
-{
-	string upperCaseName;
-	upperCaseName.resize(name.size());
-	transform (name.begin(),name.end(), upperCaseName.begin(), (int(*)(int))toupper);
-		
-	if (start)
-	{
-		s &lt;&lt; &quot;#ifndef __&quot;+upperCaseName+&quot;_HPP__&quot; &lt;&lt; endl;
-		s &lt;&lt; &quot;#define __&quot;+upperCaseName+&quot;_HPP__&quot; &lt;&lt; endl;
-	}
-	else
-	{
-		s &lt;&lt; &quot;#endif // __&quot;+upperCaseName+&quot;_HPP__&quot; &lt;&lt; endl;
-	}
-}
-
-
-bool QtCodeGenerator::testDirectory(const string&amp; dirName,const string&amp; className)
-{
-	
-	filesystem::path path = filesystem::path(dirName, filesystem::native);
-
-	if ( filesystem::exists( path ) )
-	{
-		filesystem::create_directories(dirName+className);
-		return true;
-	}
-	else
-		return false;
-}
-

Deleted: trunk/gui/qt3/QtCodeGenerator.hpp
===================================================================
--- trunk/gui/qt3/QtCodeGenerator.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtCodeGenerator.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,63 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTCODEGENERATOR_HPP
-#define QTCODEGENERATOR_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/lib-factory/Factorable.hpp&gt;
-#include &lt;string&gt;
-#include &lt;fstream&gt;
-#include &lt;QtGeneratedCodeGenerator.h&gt;
-
-using namespace std;
-
-class QtCodeGenerator : public QtGeneratedCodeGenerator, public Factorable
-{
-	private :
-		string baseDataClass;
-		string baseEngineClass;
-
-		void writeHeader(ofstream&amp; s, const string&amp; name, const string&amp; email);
-		void writeSperarationLines(ofstream&amp; s);
-		void writeIfDef(ofstream&amp; s,bool start);
-		void writeIfDef(ofstream&amp; s, const string&amp; name, bool start);
-		bool testDirectory(const string&amp; dirName,const string&amp; className);
-		void writeAttributesArea(ofstream&amp; s);
-		void writeMethodsArea(ofstream&amp; s);
-		void writeConstructorDestructorArea(ofstream&amp; s);
-		void writeSerializationArea(ofstream&amp; s);
-		void writePutYourCodeHereArea(ofstream&amp; s, int nbTabs=0);
-
-	public :
-		QtCodeGenerator (QWidget * parent = 0, const char * name = 0 );
-		virtual ~QtCodeGenerator ();
-
- 	public slots :
-		virtual void bgDataTypeClicked(int);
- 		virtual void pbDataPathClicked();
-		virtual void pbGenerateDataClassClicked();
-		virtual void pbLoadDataClassClicked();
-		virtual void pbSaveDataClassClicked();
-
-		virtual void bgEngineTypeClicked(int);
-		virtual void pbEnginePathClicked();
-		virtual void pbGenerateEngineClassClicked();
-		virtual void pbAddEngineUnitParamClicked();
-		virtual void pbAddMetaEngineParamClicked();
-		virtual void pbSaveEngineClassClicked();
-		virtual void pbLoadEngineClassClicked();
-
-	REGISTER_CLASS_NAME(QtCodeGenerator);
-	REGISTER_BASE_CLASS_NAME(Factorable);
-};
-
-REGISTER_FACTORABLE(QtCodeGenerator);
-
-#endif // QTCODEGENERATOR_HPP
-

Deleted: trunk/gui/qt3/QtEngineEditor.cpp
===================================================================
--- trunk/gui/qt3/QtEngineEditor.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtEngineEditor.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,229 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtEngineEditor.hpp&quot;
-#include &quot;GLEngineEditor.hpp&quot;
-#include &quot;FileDialog.hpp&quot;
-#include&lt;yade/core/FileGenerator.hpp&gt;
-#include&lt;yade/core/MetaDispatchingEngine.hpp&gt;
-#include &lt;qcombobox.h&gt;
-#include &lt;qgroupbox.h&gt;
-#include &lt;qcolor.h&gt;
-#include &lt;qlabel.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qlineedit.h&gt;
-
-
-QtEngineEditor::QtEngineEditor() : QtGeneratedEngineEditor()
-{
-	map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-	map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-	for(;di!=diEnd;++di)
-	{
-		if (Omega::instance().isInheritingFrom((*di).first,&quot;MetaEngine&quot;))
-			cbMetaEnginesList-&gt;insertItem((*di).first);
-		else if (Omega::instance().isInheritingFrom((*di).first,&quot;DeusExMachina&quot;))
-			cbDeusExMachinaList-&gt;insertItem((*di).first);
-		else if (Omega::instance().isInheritingFrom((*di).first,&quot;StandAloneEngine&quot;))
-			cbEnginesList-&gt;insertItem((*di).first);
-
-	}
-
-	connect( glEngineEditor, SIGNAL( verifyValidity() ), this, SLOT( verifyValidity() ) );
-	connect( glEngineEditor, SIGNAL( engineSelected(int) ), this, SLOT( engineSelected(int) ) );
-	connect( glEngineEditor, SIGNAL( deleteEngine(int) ), this, SLOT( deleteEngine(int) ) );
-
-	engineFrame = 0;	
-	//metaDispatchingEngineFrame = new QtMetaDispatchingEngineProperties();
-
-	verifyValidity();
-}
-
-
-QtEngineEditor::~QtEngineEditor()
-{
-}
-
-
-void QtEngineEditor::pbAddEngineClicked()
-{
-	string engineName = cbEnginesList-&gt;currentText();
-	int id = glEngineEditor-&gt;addEngine(engineName);
-
-	EngineDescriptor ed;
-	ed.engine = dynamic_pointer_cast&lt;Engine&gt;(ClassFactory::instance().createShared(engineName));
-	ed.type = STANDALONEENGINE;
-	engines[id] = ed;
-}
-
-
-void QtEngineEditor::pbAddMetaEngineClicked()
-{
-	int id=0;
-	EngineDescriptor ed;
-
-	string engineName = cbMetaEnginesList-&gt;currentText();
-	shared_ptr&lt;MetaDispatchingEngine&gt; mde = dynamic_pointer_cast&lt;MetaDispatchingEngine&gt;(ClassFactory::instance().createShared(engineName));
-
-	if (mde)
-	{
-		if (mde-&gt;getDimension()==1)
-		{
-			id = glEngineEditor-&gt;addMetaDispatchingEngine1D(engineName, mde-&gt;getEngineUnitType(), mde-&gt;getBaseClassType(0));
-			ed.type = METADISPATCHINGENGINE1D;
-		}
-		else if (mde-&gt;getDimension()==2)
-		{
-			id = glEngineEditor-&gt;addMetaDispatchingEngine2D(engineName, mde-&gt;getEngineUnitType(), mde-&gt;getBaseClassType(0), mde-&gt;getBaseClassType(0));
-			ed.type = METADISPATCHINGENGINE2D;
-		}
-	}
-	else // it is a meta engine
-	{
-		id = glEngineEditor-&gt;addEngine(engineName);
-		ed.type = METAENGINE;
-	}
-
-	ed.engine = mde;
-
-	engines[id] = ed;
-}
-
-
-void QtEngineEditor::pbAddDeusExMachinaClicked()
-{
-	string engineName = cbDeusExMachinaList-&gt;currentText();
-	int id = glEngineEditor-&gt;addDeusExMachina(engineName);
-
-	EngineDescriptor ed;
-	ed.engine = dynamic_pointer_cast&lt;Engine&gt;(ClassFactory::instance().createShared(engineName));
-	ed.type = DEUSEXMACHINA;
-	engines[id] = ed;
-}
-
-
-void QtEngineEditor::pbSaveClicked()
-{
-	enginesVec.clear();
-	int next = glEngineEditor-&gt;getFirstEngine();
-	
-	enginesVec.push_back(engines[next].engine);
-	
-	for(size_t i=0;i&lt;engines.size()-1;i++)
-	{
-		next = glEngineEditor-&gt;findRelationStartingWith(next);
-		enginesVec.push_back(engines[next].engine);
-	}
-
-	//FIXME : add combobox in GUI to select IOFormatManager
-	
-	IOFormatManager::saveToFile(&quot;XMLFormatManager&quot;,leFileName-&gt;text(),&quot;engines&quot;,enginesVec);
-
-}
-
-
-void QtEngineEditor::pbLoadClicked()
-{
-
-}
-
-
-void QtEngineEditor::pbPathClicked()
-{
-	string selectedFilter;
-	std::vector&lt;string&gt; filters;
-	filters.push_back(&quot;XML Yade File (*.xml)&quot;);
-	string fileName = FileDialog::getSaveFileName(&quot;.&quot;, filters, &quot;Choose a file to save&quot;, this-&gt;parentWidget()-&gt;parentWidget(),selectedFilter );
-
-	if (fileName.size()!=0 &amp;&amp; selectedFilter == &quot;XML Yade File (*.xml)&quot;)
-		leFileName-&gt;setText(fileName);
-
-}
-
-
-void QtEngineEditor::verifyValidity()
-{
-	string message;
-	bool enabled;
-	if (enabled=glEngineEditor-&gt;verify(message))
-		tlStatus-&gt;setBackgroundColor(QColor(0,255,0));
-	else
-		tlStatus-&gt;setBackgroundColor(QColor(255,0,0));
-
-	tlStatus-&gt;setText(message.c_str());
-
-	leFileName-&gt;setEnabled(enabled);
-	pbPath-&gt;setEnabled(enabled);
-	pbSave-&gt;setEnabled(enabled);
-	pbLoad-&gt;setEnabled(enabled);
-}
-
-
-void QtEngineEditor::engineSelected(int i)
-{
-	if (i&gt;=0)
-	{
-		if (currentEngine!=engines[i].engine || (currentEngine==engines[i].engine &amp;&amp; engineFrame-&gt;isHidden())) // otherwise the GUI is already created
-		{
-			if (engineFrame)
-			{
-				delete engineFrame;
-				engineFrame = 0;
-			}
-
-			currentEngine = engines[i].engine;
-
-			guiGen.setResizeHeight(true);
-			guiGen.setResizeWidth(true);
-			guiGen.setShift(10,20);
-			guiGen.setShowButtons(true);
-
-			QWidget * parent   = this-&gt;parentWidget()-&gt;parentWidget();
-
-			if (engines[i].type==DEUSEXMACHINA || engines[i].type==STANDALONEENGINE)
-			{
-				engineFrame = new QFrame(parent);
-				engineFrame-&gt;setCaption(currentEngine-&gt;getClassName());
-				guiGen.buildGUI(currentEngine,engineFrame);
-			}
-			else if (engines[i].type==METADISPATCHINGENGINE2D || engines[i].type==METADISPATCHINGENGINE1D)
-			{	
-				shared_ptr&lt;MetaDispatchingEngine&gt; mde = dynamic_pointer_cast&lt;MetaDispatchingEngine&gt;(currentEngine);
-				engineFrame = new QtMetaDispatchingEngineProperties(mde,parent);
-				engineFrame-&gt;setCaption(currentEngine-&gt;getClassName());
-			}
-		}
-		if (engineFrame)
-			engineFrame-&gt;show();
-	}
-	else
-	{
-		currentEngine = shared_ptr&lt;Engine&gt;();
-		if (engineFrame)
-		{
-			delete engineFrame;
-			engineFrame = 0;
-		}
-	}
-}
-
-
-void QtEngineEditor::deleteEngine(int i)
-{
-
-	engines.erase(i);
-	
-}
-
-
-void QtEngineEditor::closeEvent(QCloseEvent *e)
-{
-	QtGeneratedEngineEditor::closeEvent(e);
-	
-}
-

Deleted: trunk/gui/qt3/QtEngineEditor.hpp
===================================================================
--- trunk/gui/qt3/QtEngineEditor.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtEngineEditor.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,66 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTENGINEEDITOR_HPP
-#define QTENGINEEDITOR_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/lib-factory/Factorable.hpp&gt;
-#include&lt;yade/lib-serialization-qt/QtGUIGenerator.hpp&gt;
-#include&lt;yade/core/Engine.hpp&gt;
-#include &lt;QtGeneratedEngineEditor.h&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qframe.h&gt;
-#include &lt;qscrollview.h&gt;
-#include &quot;QtMetaDispatchingEngineProperties.hpp&quot;
-
-class QtEngineEditor : public QtGeneratedEngineEditor, public Factorable
-{
-	private :
-		QtGUIGenerator guiGen;	
-		QFrame * engineFrame;
-
-		enum EngineType { STANDALONEENGINE, DEUSEXMACHINA, METADISPATCHINGENGINE1D, METADISPATCHINGENGINE2D, METAENGINE };
-		struct EngineDescriptor
-		{
-			shared_ptr&lt;Engine&gt; engine;
-			EngineType type;
-		};
-
-		vector&lt;shared_ptr&lt;Engine&gt; &gt; enginesVec;
-	
-		map&lt;int,EngineDescriptor&gt; engines;
-		shared_ptr&lt;Engine&gt; currentEngine;
-
-	public :
-		QtEngineEditor();
-		~QtEngineEditor();
-
-	public slots :
-		void pbAddEngineClicked();
-		void pbAddMetaEngineClicked();
-		void pbAddDeusExMachinaClicked();
-
-		void pbSaveClicked();
-		void pbLoadClicked();
-		void pbPathClicked();
-
-		void verifyValidity();
-		void engineSelected(int i);
-		void deleteEngine(int i);
-	
- 	protected :
-		void closeEvent(QCloseEvent *);
-	REGISTER_CLASS_NAME(QtEngineEditor);
-	REGISTER_BASE_CLASS_NAME(Factorable);
-};
-
-REGISTER_FACTORABLE(QtEngineEditor);
-
-#endif // QTENGINEEDITOR_HPP
-

Deleted: trunk/gui/qt3/QtGeneratedCodeGenerator.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedCodeGenerator.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedCodeGenerator.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,985 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedCodeGenerator&lt;/class&gt;
-&lt;widget class=&quot;QDialog&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedCodeGenerator&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;509&lt;/width&gt;
-            &lt;height&gt;485&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Code Generator&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;grid&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;widget class=&quot;QToolBox&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;toolBox&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;currentIndex&quot;&gt;
-                &lt;number&gt;1&lt;/number&gt;
-            &lt;/property&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;newDataClass&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;property name=&quot;backgroundMode&quot;&gt;
-                    &lt;enum&gt;PaletteBackground&lt;/enum&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;label&quot;&gt;
-                    &lt;string&gt;New Data Class ...&lt;/string&gt;
-                &lt;/attribute&gt;
-                &lt;grid&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbYouData&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Personnal Information&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leDataYourName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leDataYourEmail&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlDataYourName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Name :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlDataYourEmail&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Email : &lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QButtonGroup&quot; row=&quot;1&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;bgDataType&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;sizePolicy&quot;&gt;
-                            &lt;sizepolicy&gt;
-                                &lt;hsizetype&gt;5&lt;/hsizetype&gt;
-                                &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                &lt;verstretch&gt;0&lt;/verstretch&gt;
-                            &lt;/sizepolicy&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Data Type&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbBoundingVolume&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Bounding Volume&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;2&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbPhysicalParameters&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Physical Parameters&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;3&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbInteractingGeometry&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Interacting Geometry&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;1&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbGeometricalModel&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Geometrical Model&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;checked&quot;&gt;
-                                    &lt;bool&gt;true&lt;/bool&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;0&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;3&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbPhysicalAction&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Physical Action&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;7&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbInteractionGeometry&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Interaction Geometry&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;5&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;2&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbInteractionPhysics&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Interaction Physics&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;6&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;0&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbState&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;State&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;4&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbDataClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;sizePolicy&quot;&gt;
-                            &lt;sizepolicy&gt;
-                                &lt;hsizetype&gt;5&lt;/hsizetype&gt;
-                                &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                &lt;verstretch&gt;0&lt;/verstretch&gt;
-                            &lt;/sizepolicy&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Class Parameters&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlDataClassName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Class Name :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlDataPath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Path :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;2&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leDataPath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlInheritsFrom&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Inherits From :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QComboBox&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbDataInheritsFrom&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leDataClassName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QPushButton&quot; row=&quot;2&quot; column=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;pbDataPath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;pixmap&quot;&gt;
-                                    &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;3&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbDataMethod&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;sizePolicy&quot;&gt;
-                            &lt;sizepolicy&gt;
-                                &lt;hsizetype&gt;5&lt;/hsizetype&gt;
-                                &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                &lt;verstretch&gt;0&lt;/verstretch&gt;
-                            &lt;/sizepolicy&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Method&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;vbox&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QCheckBox&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbDataGenerateDestructor&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Generate destructor&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QCheckBox&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbDataGenerateRegisterAttributes&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Generate registerAttribute method&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QCheckBox&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbDataGeneratePostProcessAttributes&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Generate postProcessAttributes method&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QCheckBox&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbDataGeneratePreProcessAttributes&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Generate preProcessAttributes method&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/vbox&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;4&quot; column=&quot;0&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbSaveDataClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Save&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;4&quot; column=&quot;1&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbLoadDataClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Load&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;4&quot; column=&quot;2&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbGenerateDataClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Generate&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                &lt;/grid&gt;
-            &lt;/widget&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;newEngine&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;property name=&quot;backgroundMode&quot;&gt;
-                    &lt;enum&gt;PaletteBackground&lt;/enum&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;label&quot;&gt;
-                    &lt;string&gt;New Engine ...&lt;/string&gt;
-                &lt;/attribute&gt;
-                &lt;grid&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbMetaDispatchingEngineProperties&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;enabled&quot;&gt;
-                            &lt;bool&gt;false&lt;/bool&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Meta Dispatching Engine Properties&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QListBox&quot; row=&quot;5&quot; column=&quot;0&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;lbMetaEngineParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;columnMode&quot;&gt;
-                                    &lt;enum&gt;FixedNumber&lt;/enum&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;rowMode&quot;&gt;
-                                    &lt;enum&gt;Variable&lt;/enum&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QPushButton&quot; row=&quot;5&quot; column=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;pbAddMetaEngineParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Add&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;5&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leMetaEngineParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;4&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineUnitParameters_2&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Extra Parameters :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlMetaEngineBaseClass1&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Base Class 1 :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlMetaEngineBaseClass2&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Base Class 2 :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlMetaEngineEngineUnitName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Name : &lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlMetaEngineEngineUnitReturnType&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Return Type : &lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;3&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leMetaEngineEngineUnitReturnType&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;void&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;2&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leMetaEngineEngineUnitName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QComboBox&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbMetaEngineBaseClass2&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QComboBox&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbMetaEngineBaseClass1&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QCheckBox&quot; row=&quot;6&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbMetaEngineAutoSymmetry&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Auto Symmetry&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;3&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbEngineUnitProperties&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;enabled&quot;&gt;
-                            &lt;bool&gt;false&lt;/bool&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Engine Unit Properties&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineUnitBaseClass&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Base Class:&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QListBox&quot; row=&quot;3&quot; column=&quot;0&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;lbEngineUnitParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;columnMode&quot;&gt;
-                                    &lt;enum&gt;FixedNumber&lt;/enum&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;rowMode&quot;&gt;
-                                    &lt;enum&gt;Variable&lt;/enum&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QPushButton&quot; row=&quot;3&quot; column=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;pbAddEngineUnitParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Add&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineUnitParameters&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Extra Parameters :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;3&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineUnitParam&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineUnitReturnType&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit Return Type : &lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QCheckBox&quot; row=&quot;4&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;cbMetaEngineAutoSymmetry_2&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Auto Symmetry&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineUnitReturnType&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;void&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineUnitBaseClass&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;4&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbEngineSerialization&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Serialization Properties&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QCheckBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEngineGenerateConstructor&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;geometry&quot;&gt;
-                                &lt;rect&gt;
-                                    &lt;x&gt;11&lt;/x&gt;
-                                    &lt;y&gt;31&lt;/y&gt;
-                                    &lt;width&gt;437&lt;/width&gt;
-                                    &lt;height&gt;30&lt;/height&gt;
-                                &lt;/rect&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Generate constructor&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QCheckBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEngineGenerateDestructor&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;geometry&quot;&gt;
-                                &lt;rect&gt;
-                                    &lt;x&gt;11&lt;/x&gt;
-                                    &lt;y&gt;67&lt;/y&gt;
-                                    &lt;width&gt;437&lt;/width&gt;
-                                    &lt;height&gt;30&lt;/height&gt;
-                                &lt;/rect&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Generate destructor&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QCheckBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEngineGenerateRegisterAttributes&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;geometry&quot;&gt;
-                                &lt;rect&gt;
-                                    &lt;x&gt;11&lt;/x&gt;
-                                    &lt;y&gt;103&lt;/y&gt;
-                                    &lt;width&gt;437&lt;/width&gt;
-                                    &lt;height&gt;30&lt;/height&gt;
-                                &lt;/rect&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Generate registerAttribute method&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QCheckBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEngineGeneratePostProcessAttributes&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;geometry&quot;&gt;
-                                &lt;rect&gt;
-                                    &lt;x&gt;11&lt;/x&gt;
-                                    &lt;y&gt;139&lt;/y&gt;
-                                    &lt;width&gt;437&lt;/width&gt;
-                                    &lt;height&gt;30&lt;/height&gt;
-                                &lt;/rect&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Generate postProcessAttributes method&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QCheckBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEngineGeneratePreProcessAttributes&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;geometry&quot;&gt;
-                                &lt;rect&gt;
-                                    &lt;x&gt;11&lt;/x&gt;
-                                    &lt;y&gt;175&lt;/y&gt;
-                                    &lt;width&gt;437&lt;/width&gt;
-                                    &lt;height&gt;30&lt;/height&gt;
-                                &lt;/rect&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Generate preProcessAttributes method&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;5&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbEngineClassParameters&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Engine Class Parameters&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineClassName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Class Name :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEnginePath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Path :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEnginePath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineClassName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;pbEnginePath&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;pixmap&quot;&gt;
-                                    &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;6&quot; column=&quot;2&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbGenerateEngineClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Generate&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;6&quot; column=&quot;0&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbSaveEngineClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Save&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;6&quot; column=&quot;1&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbLoadEngineClass&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Load&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QGroupBox&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;gbYouEngine&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Personnal Information&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineYourName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;leEngineYourEmail&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineYourName&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Name :&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlEngineYourEmail&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Email : &lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QButtonGroup&quot; row=&quot;1&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;bgEngineType&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;32767&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;title&quot;&gt;
-                            &lt;string&gt;Engine Type&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;grid&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbStantAloneEngine&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Stand Alone Engine&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;checked&quot;&gt;
-                                    &lt;bool&gt;true&lt;/bool&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;0&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbMetaDispatchingEngine1D&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Meta Engine With 1D Dispatching&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;2&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbEngineUnit&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Engine Unit&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;buttonGroupId&quot;&gt;
-                                    &lt;number&gt;1&lt;/number&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QRadioButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;rbMetaDispatchingEngine2D&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;Meta Engine With 2D Dispatching&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/grid&gt;
-                    &lt;/widget&gt;
-                &lt;/grid&gt;
-            &lt;/widget&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;newConfigurationGenerator&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;property name=&quot;backgroundMode&quot;&gt;
-                    &lt;enum&gt;PaletteBackground&lt;/enum&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;label&quot;&gt;
-                    &lt;string&gt;New Configuration Generator ...&lt;/string&gt;
-                &lt;/attribute&gt;
-            &lt;/widget&gt;
-        &lt;/widget&gt;
-    &lt;/grid&gt;
-&lt;/widget&gt;
-&lt;images&gt;
-    &lt;image name=&quot;image0&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;892&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000343494441544889ed95cf6f146518c73f5d5a8b96a5ab6de84230b6b02858b134023d28743de8414d6a8c7f01ff801aaf24c24d2f0ac6709693f1a0f5e4c5c42e8907f560a736c4d616322dd275b7753bdb617766f6fdf17898e9b26db798102f263ec924cfccfbe4f3fd3ecffb2403ffc743c408f00e3099493fbafefc338704986a53370e7c909c6dd6f46e2fea68c92780cfcf9d3e92397f26c7f8991ce363c748a552bcffe1249f5e2f5c023ce0cdde7d7bf3e74e1fe5a5178ef0daf967393cd0cbb52f7ee0e2d56f2f0197771398aafc319b4ffbdfd3914a01202288152a5e8deb5fff8888f0e2e810c3b92cc65a8cb1186dd0da50a9d6197dfb6307186d15e86c7df1aa1efb3ac03434d65aac8d018fa4e0c25b679b40dfafa38dc1688bd686a8a1d0da72b03f7daab8e64f259dbe0b2cb50a384b6595ef4f871863304630d6a055ecb01d501bc37a790d43378ff53dc5b5cfae706ae444fe9bafbee4bd8b571de072ab80e7380ec363d0084394d2281d0b6c07d6ea0d0e0c8d923994e3f8cbc364d25d1094e347cde3955c0077fb880a9ee761f61cc6f7570942454369362a1eb55a83fd0347c9648f317af669b2d9be045882!
 fa34d40191982250f8690ea0b0e30e5cd7258a0ee0fb012b772b3c79f2154e8e3d4736fb440c0bca102d4269710b50442059082b961b3fcf7bc0d27601d7755d3a7bdee0aefb1df90b1f9131b720b809c5c4e12633015a2b8858ac3548b214337377009c765bb404201d5d74f6f493e98e60b5747f5d45106b6390c430b1a6b96db1806171b9d81ccf8e1101186bd9d3bd1fa915b15a379dd90420d292b7f9eefcb6bc85b745c07166101106064fa0c27be830481c9b16973be156ee9f19ad77efa05aad22081beb1542df60a260db185af264f69bc2c618b4d6fcba50dcbd03e2dd1ddcdb9326dc28b5779d8063a0a1d1d0440d451429eefc59e5e6ad32c08ddd054406b343c78956969b176713874a1b948a6161a49873d798febd84b350667671955aa80ac0950775c0bd0d9f747f1f4150472b4d4369c22886ce2dad313d5f6266a1cceced55af1628279977a1d5f503051e3f98a3abd3e216ffe297f9620c5c2c737ba5ead502b5092b0033ed80ff149f4c4cbc2eafe6c704580726897f3e230f03db2dc6ff6de07f3bfe067d9f88db21915f870000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-&lt;/images&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;bgDataType&lt;/sender&gt;
-        &lt;signal&gt;clicked(int)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;bgDataTypeClicked(int)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;bgEngineType&lt;/sender&gt;
-        &lt;signal&gt;clicked(int)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;bgEngineTypeClicked(int)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddEngineUnitParam&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbAddEngineUnitParamClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddMetaEngineParam&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbAddMetaEngineParamClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbDataPath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbDataPathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbEnginePath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbEnginePathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbGenerateDataClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbGenerateDataClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbGenerateEngineClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbGenerateEngineClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbLoadEngineClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbLoadEngineClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbSaveEngineClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbSaveEngineClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbLoadDataClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbLoadDataClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbSaveDataClass&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedCodeGenerator&lt;/receiver&gt;
-        &lt;slot&gt;pbSaveDataClassClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;bgDataTypeClicked(int)&lt;/slot&gt;
-    &lt;slot&gt;pbDataPathClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbGenerateDataClassClicked()&lt;/slot&gt;
-    &lt;slot&gt;bgEngineTypeClicked(int)&lt;/slot&gt;
-    &lt;slot&gt;pbEnginePathClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbGenerateEngineClassClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbAddEngineUnitParamClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbAddMetaEngineParamClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbLoadEngineClassClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbSaveEngineClassClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbLoadDataClassClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbSaveDataClassClicked()&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtGeneratedEngineEditor.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedEngineEditor.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedEngineEditor.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,713 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedEngineEditor&lt;/class&gt;
-&lt;widget class=&quot;QDialog&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedEngineEditor&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;892&lt;/width&gt;
-            &lt;height&gt;670&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Engines Editor&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;hbox&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;widget class=&quot;GLEngineEditor&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;glEngineEditor&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;5&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QFrame&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;controller&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;5&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;minimumSize&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;330&lt;/width&gt;
-                    &lt;height&gt;0&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;maximumSize&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;300&lt;/width&gt;
-                    &lt;height&gt;32767&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;frameShape&quot;&gt;
-                &lt;enum&gt;StyledPanel&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;frameShadow&quot;&gt;
-                &lt;enum&gt;Raised&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;vbox&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbEngines&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;minimumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;0&lt;/width&gt;
-                            &lt;height&gt;0&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;maximumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;32767&lt;/width&gt;
-                            &lt;height&gt;32767&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Stand Alone Engines&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;hbox&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QComboBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbEnginesList&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QPushButton&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbAddEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/hbox&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbEngines_2&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;minimumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;0&lt;/width&gt;
-                            &lt;height&gt;0&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;maximumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;32767&lt;/width&gt;
-                            &lt;height&gt;32767&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Deus Ex Machina&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;hbox&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QComboBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbDeusExMachinaList&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QPushButton&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbAddDeusExMachina&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/hbox&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbMetaEngines&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;minimumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;0&lt;/width&gt;
-                            &lt;height&gt;0&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;maximumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;32767&lt;/width&gt;
-                            &lt;height&gt;32767&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Meta Engines&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;hbox&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QComboBox&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;cbMetaEnginesList&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;enabled&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QPushButton&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbAddMetaEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/hbox&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbColors&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;minimumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;0&lt;/width&gt;
-                            &lt;height&gt;0&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;maximumSize&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;32767&lt;/width&gt;
-                            &lt;height&gt;32767&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Colors&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;grid&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QFrame&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;fStandAloneEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;0&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;0&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;minimumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;maximumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;paletteBackgroundColor&quot;&gt;
-                                &lt;color&gt;
-                                    &lt;red&gt;0&lt;/red&gt;
-                                    &lt;green&gt;170&lt;/green&gt;
-                                    &lt;blue&gt;255&lt;/blue&gt;
-                                &lt;/color&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShape&quot;&gt;
-                                &lt;enum&gt;NoFrame&lt;/enum&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShadow&quot;&gt;
-                                &lt;enum&gt;Plain&lt;/enum&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;fMetaEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;0&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;0&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;minimumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;maximumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;paletteBackgroundColor&quot;&gt;
-                                &lt;color&gt;
-                                    &lt;red&gt;0&lt;/red&gt;
-                                    &lt;green&gt;255&lt;/green&gt;
-                                    &lt;blue&gt;127&lt;/blue&gt;
-                                &lt;/color&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShape&quot;&gt;
-                                &lt;enum&gt;NoFrame&lt;/enum&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShadow&quot;&gt;
-                                &lt;enum&gt;Plain&lt;/enum&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;1&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlMEtaEngineColor&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Meta Engines&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlEngineColor&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Stand Alone Engines&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;fDeusExMachina&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;0&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;0&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;minimumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;maximumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;paletteBackgroundColor&quot;&gt;
-                                &lt;color&gt;
-                                    &lt;red&gt;170&lt;/red&gt;
-                                    &lt;green&gt;85&lt;/green&gt;
-                                    &lt;blue&gt;255&lt;/blue&gt;
-                                &lt;/color&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShape&quot;&gt;
-                                &lt;enum&gt;NoFrame&lt;/enum&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShadow&quot;&gt;
-                                &lt;enum&gt;Plain&lt;/enum&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;3&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlDeusExMachina&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Deus Ex Machina&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;3&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlFirstEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;First Engine&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QFrame&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;fFirstEngine&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;0&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;0&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;minimumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;maximumSize&quot;&gt;
-                                &lt;size&gt;
-                                    &lt;width&gt;20&lt;/width&gt;
-                                    &lt;height&gt;20&lt;/height&gt;
-                                &lt;/size&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;paletteBackgroundColor&quot;&gt;
-                                &lt;color&gt;
-                                    &lt;red&gt;255&lt;/red&gt;
-                                    &lt;green&gt;255&lt;/green&gt;
-                                    &lt;blue&gt;127&lt;/blue&gt;
-                                &lt;/color&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShape&quot;&gt;
-                                &lt;enum&gt;NoFrame&lt;/enum&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;frameShadow&quot;&gt;
-                                &lt;enum&gt;Plain&lt;/enum&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/grid&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbStatus&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;mouseTracking&quot;&gt;
-                        &lt;bool&gt;false&lt;/bool&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;frameShape&quot;&gt;
-                        &lt;enum&gt;GroupBoxPanel&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;frameShadow&quot;&gt;
-                        &lt;enum&gt;Sunken&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;lineWidth&quot;&gt;
-                        &lt;number&gt;1&lt;/number&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Status&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;vbox&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QLabel&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlStatus&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/vbox&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QGroupBox&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;gbSaveLoad&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Save/Load&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;grid&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QPushButton&quot; row=&quot;0&quot; column=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbPath&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image1&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;textLabel1&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;leFileName&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbSave&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Save...&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;pbLoad&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;sizePolicy&quot;&gt;
-                                &lt;sizepolicy&gt;
-                                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                                &lt;/sizepolicy&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Load ...&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/grid&gt;
-                &lt;/widget&gt;
-            &lt;/vbox&gt;
-        &lt;/widget&gt;
-    &lt;/hbox&gt;
-&lt;/widget&gt;
-&lt;customwidgets&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLEngineEditor&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLEngineEditor.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-            &lt;horstretch&gt;0&lt;/horstretch&gt;
-            &lt;verstretch&gt;0&lt;/verstretch&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;image2&lt;/pixmap&gt;
-        &lt;slot access=&quot;public&quot; specifier=&quot;&quot;&gt;pbAddEngineClicked()&lt;/slot&gt;
-    &lt;/customwidget&gt;
-&lt;/customwidgets&gt;
-&lt;images&gt;
-    &lt;image name=&quot;image0&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;825&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000300494441544889ed935f4895671cc73fa7f735c5b24e27cc7a3b3684c49c08460ce64d59e04229ad8853636c132446db4092410d83d85575215e042144c96ec610a2344433292fe2c02e02a36c4c64736347cd0b2dd09df3fc79df6717e74fe7f8e7685711f48387e7f93d2fcff7f3fb7ddfe7810ff1aec35abcd1d7d747757535e1701821c4aa02050505e4e6e622a57c7bbae3382b7e2b2929a1b3b393a1a121eaeaead626b8a7f2137ebe374ad7dd6700b4b4b4a4c3e61cc7318b4647434343564d3b3d319e410a81e77900d4d7d7d3d3d3c3c4c404c51f7fe43f75e90bb4ab51aee69fd1bfb977e576556f6f2f00076a1b3976fa3bce357fb632c0331e4abe01949696d2dddd4d6d6d2dc67848ad120085721500957b3fe5ab6fda989bd7fcf1e7d4920ed66576e0a19444a9f80f6b6a6aa2bcbc9cf6f6763c63905a22b424a62452c7013f5cbacedcbce6e5cc2cd1d8d24b9169913128a530c6c3719c3be3e3e3feb2b232007694ed442889743552ab24a0eac76f8f3c4a9318067eca0ad05a618c21585e7cecc4c5d3294ba4d60825115a21b564c3aecdd45c3eea174ad608258929c18b2be19a5501aeab31c6a42c51691527!
 87d032014bcc4a1053cbbf832500cf753126beceb424ee7ba670bcf258625e15002675833ce365589251794230394713eb3500e2e1f3f978393675f797b337fdc9bd4d25819a3d4dfb5296bcfe6b96a9eeb157c048dad1e1ac001f3e6c3b07cbb2999c9c3cdedfdf8f94926030c8e7df7f69a222f6c612290046b615571c3cf9752b5b0b8b586fe7d07cbc7265c03acb227fc346ec9c1c000281007979794c4f4fe37a1eff8968ca92a4e723bf3de0f7a761f61f0ed1183a93dd22cbb2d9b4790b966d27728bfcfc7c060606f08ccb828c129322d1451cf0f02a1c3abfc0839e2e9e84ef67078cbd7842f389aa543e333343515111914804f1efc2abe96ba3fe45e787f336c2e36bb03d008d1726995d8258213a3a3a8844220c0e0ee2f72fd6057f013cbf0dcf7f85a737a0a278adca403018a4b5b5955028b4ac78322a77c3ad36d855f816e2ef5dfc0f3593d6f501bd45830000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image1&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;892&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000343494441544889ed95cf6f146518c73f5d5a8b96a5ab6de84230b6b02858b134023d28743de8414d6a8c7f01ff801aaf24c24d2f0ac6709693f1a0f5e4c5c42e8907f560a736c4d616322dd275b7753bdb617766f6fdf17898e9b26db798102f263ec924cfccfbe4f3fd3ecffb2403ffc743c408f00e3099493fbafefc338704986a53370e7c909c6dd6f46e2fea68c92780cfcf9d3e92397f26c7f8991ce363c748a552bcffe1249f5e2f5c023ce0cdde7d7bf3e74e1fe5a5178ef0daf967393cd0cbb52f7ee0e2d56f2f0197771398aafc319b4ffbdfd3914a01202288152a5e8deb5fff8888f0e2e810c3b92cc65a8cb1186dd0da50a9d6197dfb6307186d15e86c7df1aa1efb3ac03434d65aac8d018fa4e0c25b679b40dfafa38dc1688bd686a8a1d0da72b03f7daab8e64f259dbe0b2cb50a384b6595ef4f871863304630d6a055ecb01d501bc37a790d43378ff53dc5b5cfae706ae444fe9bafbee4bd8b571de072ab80e7380ec363d0084394d2281d0b6c07d6ea0d0e0c8d923994e3f8cbc364d25d1094e347cde3955c0077fb880a9ee761f61cc6f7570942454369362a1eb55a83fd0347c9648f317af669b2d9be045882!
 fa34d40191982250f8690ea0b0e30e5cd7258a0ee0fb012b772b3c79f2154e8e3d4736fb440c0bca102d4269710b50442059082b961b3fcf7bc0d27601d7755d3a7bdee0aefb1df90b1f9131b720b809c5c4e12633015a2b8858ac3548b214337377009c765bb404201d5d74f6f493e98e60b5747f5d45106b6390c430b1a6b96db1806171b9d81ccf8e1101186bd9d3bd1fa915b15a379dd90420d292b7f9eefcb6bc85b745c07166101106064fa0c27be830481c9b16973be156ee9f19ad77efa05aad22081beb1542df60a260db185af264f69bc2c618b4d6fcba50dcbd03e2dd1ddcdb9326dc28b5779d8063a0a1d1d0440d451429eefc59e5e6ad32c08ddd054406b343c78956969b176713874a1b948a6161a49873d798febd84b350667671955aa80ac0950775c0bd0d9f747f1f4150472b4d4369c22886ce2dad313d5f6266a1cceced55af1628279977a1d5f503051e3f98a3abd3e216ffe297f9620c5c2c737ba5ead502b5092b0033ed80ff149f4c4cbc2eafe6c704580726897f3e230f03db2dc6ff6de07f3bfe067d9f88db21915f870000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image2&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;1002&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b000003b149444154388dad945f4c5b551cc73fe7dc4b7b4bcba0762d45c43114323599ee6192609c51d883892ce083f1718b3ebb185f8dc91e972cf39d2d2a2f1af664b6f1e0fe3863a0718969700eb0c52142da0242a1bd6d696f7bcff101585203ceb8fd9ece39f99dcff9fe7edf939f88c562ec465f5f9fe609442c161362173c3e3eae7b7a7ac8e7f36432196cdbfe4f907c3e4f2291201e8fe338cec3737357e9e8e828aded1e229d650e1f2d51754b082110124c13a4dc5ea341eb9dc284c0558a853f3ce8cb0677ef500fde7d39d2596679e326597b8e9abb85d7a770ab16ab6983ec5a05b487a70e36f0f4e10afe408d6a558310980108478dba4a1e8233990c5d474b64ed39aa3a8fe5f3317fbf81dbd70bccfeb205947632fd74f6589c1c6ea2f70d03a58ba0c1f2c9bdc1b66de3b8256a6e11cbe7e3ee1d181b590124fe2693aeee08d223c82c3a2c24b7b874bec8f26288774f7bd054504aef0dde6e99c0eb83f9fb266323cb80a27fb0958141836044605a2ee5523393371cc646fee2da37195aa35d0c0c5b4859ac03d7e91712dcaac5adab3650a3ff9d08ef7dd8404bb48869e5d958b5b87dadc4c9a1464e9f0d0326df7!
 ebd86bd2e310cb1bf62d384d59441f2d70a070e1c60e09489929b988681bdd9cc97170bcc4c65595f71f8e0e3301337fc24a7732467831875a47f289652b0be5e4151e6d07316c1b0c0340d8ab92023e76d66a6b2840e36d2fb7a13fee632475e6edc367ea98a90fb98b7dd6310ca0328a44761582e1bab41befabcc0ec940d28bc5e93b68e064cab84e1d9beaeb48934eac1f53b01c1b000fca496aa54b61a99fcde61662a4b4b4b23d1680be9d426173e4df3602a48ea411989a4fd590f52a8fd156b05ed9d350e3defe3cfdf4b4c7ce770ea7d3fb9f520afbe1620daeee5c26735d20b9b9cfb6811a754a439e4e5c5639a4caa1e5caf586bfc0197b78702005cb9b4cae4cd3267ce8638fe964bd72b393e39d74928d242617303a756a37f284447770dcdbffc6384a05a85de1306e9a52057c7527c7131c3c42d3f475eb2303c82d4fc3276d6811db37efeb148723082d9b08f79f97c1e5729109a9a28307cc622d2d6cdf52b2b24efe548dedb00142009862cfa879ee1a71f6cec928353511472fbf4389148b0b0e0c108081412458dfe21c9f11351e67e7358595468246d1d1e5e38a6e9e851bc39d84ab502a669331dafec0d8ec7e3e8cb06e1a881d727d1ae40180a434a8c9db129a54126ad48a7358c2b4c5352c8c374bcccdab2bb37d8719cba79fab8211f9df218e05!
 82c261e95f8bfc04f1a1e8bc5c4dfe0a190172af6a9690000000049454e44a!
 e426082&lt;
/data&gt;
-    &lt;/image&gt;
-&lt;/images&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddEngine&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbAddEngineClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbSave&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbSaveClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbLoad&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbPath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbPathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddDeusExMachina&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbAddDeusExMachinaClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddMetaEngine&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedEngineEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbAddMetaEngineClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;pbAddEngineClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbSaveClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbPathClicked()&lt;/slot&gt;
-    &lt;slot&gt;verifyValidity()&lt;/slot&gt;
-    &lt;slot&gt;engineSelected(int)&lt;/slot&gt;
-    &lt;slot&gt;pbAddMetaEngineClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbAddDeusExMachinaClicked()&lt;/slot&gt;
-    &lt;slot&gt;deleteEngine(int)&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtGeneratedMetaDispatchingEngineProperties.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedMetaDispatchingEngineProperties.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedMetaDispatchingEngineProperties.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,148 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedMetaDispatchingEngineProperties&lt;/class&gt;
-&lt;widget class=&quot;QFrame&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedMetaDispatchingEngineProperties&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;415&lt;/width&gt;
-            &lt;height&gt;116&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;sizePolicy&quot;&gt;
-        &lt;sizepolicy&gt;
-            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-            &lt;vsizetype&gt;7&lt;/vsizetype&gt;
-            &lt;horstretch&gt;0&lt;/horstretch&gt;
-            &lt;verstretch&gt;0&lt;/verstretch&gt;
-        &lt;/sizepolicy&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Form1&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;frameShape&quot;&gt;
-        &lt;enum&gt;NoFrame&lt;/enum&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;frameShadow&quot;&gt;
-        &lt;enum&gt;Plain&lt;/enum&gt;
-    &lt;/property&gt;
-    &lt;grid&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;pbAdd&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;minimumSize&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;0&lt;/width&gt;
-                    &lt;height&gt;30&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;text&quot;&gt;
-                &lt;string&gt;ADD&lt;/string&gt;
-            &lt;/property&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;pbOk&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;minimumSize&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;0&lt;/width&gt;
-                    &lt;height&gt;30&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;text&quot;&gt;
-                &lt;string&gt;OK&lt;/string&gt;
-            &lt;/property&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbEngineUnits&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Engine Units&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;centralFrame&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;frameShape&quot;&gt;
-                        &lt;enum&gt;StyledPanel&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;frameShadow&quot;&gt;
-                        &lt;enum&gt;Raised&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;grid&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                    &lt;/grid&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-    &lt;/grid&gt;
-&lt;/widget&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbOk&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedMetaDispatchingEngineProperties&lt;/receiver&gt;
-        &lt;slot&gt;pbOkClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAdd&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedMetaDispatchingEngineProperties&lt;/receiver&gt;
-        &lt;slot&gt;pbAddClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;pbAddClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbOkClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbRemoveClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbSerializationClicked()&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtGeneratedPreferencesEditor.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedPreferencesEditor.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedPreferencesEditor.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,508 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedPreferencesEditor&lt;/class&gt;
-&lt;widget class=&quot;QDialog&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedPreferencesEditor&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;626&lt;/width&gt;
-            &lt;height&gt;341&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Preferences&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;hbox&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;widget class=&quot;QListBox&quot;&gt;
-            &lt;item&gt;
-                &lt;property name=&quot;text&quot;&gt;
-                    &lt;string&gt;Plugins Folders&lt;/string&gt;
-                &lt;/property&gt;
-            &lt;/item&gt;
-            &lt;item&gt;
-                &lt;property name=&quot;text&quot;&gt;
-                    &lt;string&gt;Include Folders&lt;/string&gt;
-                &lt;/property&gt;
-            &lt;/item&gt;
-            &lt;item&gt;
-                &lt;property name=&quot;text&quot;&gt;
-                    &lt;string&gt;Plugins&lt;/string&gt;
-                &lt;/property&gt;
-            &lt;/item&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;lbPreferencesList&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;maximumSize&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;150&lt;/width&gt;
-                    &lt;height&gt;32767&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QWidgetStack&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;wsPreferences&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;7&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;5&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;WStackPage&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;id&quot;&gt;
-                    &lt;number&gt;0&lt;/number&gt;
-                &lt;/attribute&gt;
-                &lt;grid&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbPluginPath&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;pixmap&quot;&gt;
-                            &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbDeletePluginFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Delete&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QListView&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;column&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Folder&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;clickable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;resizable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                        &lt;/column&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;lvPluginFolders&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;resizeMode&quot;&gt;
-                            &lt;enum&gt;AllColumns&lt;/enum&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbAddPluginFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Add&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;lePluginFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;fPluginFoldersTitle&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;minimumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;0&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShape&quot;&gt;
-                            &lt;enum&gt;StyledPanel&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShadow&quot;&gt;
-                            &lt;enum&gt;Raised&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;hbox&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlPluginFoldersTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;h2&gt;&lt;b&gt;Plugin Folders&lt;/b&gt;&lt;/h2&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;plPluginFoldersTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;pixmap&quot;&gt;
-                                    &lt;pixmap&gt;image1&lt;/pixmap&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;scaledContents&quot;&gt;
-                                    &lt;bool&gt;false&lt;/bool&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;alignment&quot;&gt;
-                                    &lt;set&gt;WordBreak|AlignVCenter|AlignRight&lt;/set&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/hbox&gt;
-                    &lt;/widget&gt;
-                &lt;/grid&gt;
-            &lt;/widget&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;includeFoldersPage&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;id&quot;&gt;
-                    &lt;number&gt;1&lt;/number&gt;
-                &lt;/attribute&gt;
-                &lt;grid&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;fIncludeFoldersTitle&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;minimumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;0&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShape&quot;&gt;
-                            &lt;enum&gt;StyledPanel&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShadow&quot;&gt;
-                            &lt;enum&gt;Raised&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;hbox&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlIncludeFoldersTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;h2&gt;&lt;b&gt;Include Folders&lt;/b&gt;&lt;/h2&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;plIncludeFoldersTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;pixmap&quot;&gt;
-                                    &lt;pixmap&gt;image1&lt;/pixmap&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;scaledContents&quot;&gt;
-                                    &lt;bool&gt;false&lt;/bool&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;alignment&quot;&gt;
-                                    &lt;set&gt;WordBreak|AlignVCenter|AlignRight&lt;/set&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/hbox&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbAddIncludeFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Add&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbDeleteIncludeFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Delete&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;3&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbIncludePath&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;&lt;/string&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;pixmap&quot;&gt;
-                            &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;leIncludeFolder&lt;/cstring&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QListView&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;column&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Folder&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;clickable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;resizable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                        &lt;/column&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;lvIncludeFolders&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;resizeMode&quot;&gt;
-                            &lt;enum&gt;AllColumns&lt;/enum&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                &lt;/grid&gt;
-            &lt;/widget&gt;
-            &lt;widget class=&quot;QWidget&quot;&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;WStackPage&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;attribute name=&quot;id&quot;&gt;
-                    &lt;number&gt;2&lt;/number&gt;
-                &lt;/attribute&gt;
-                &lt;grid&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;widget class=&quot;QPushButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;pbRescanPlugins&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;text&quot;&gt;
-                            &lt;string&gt;Rescan&lt;/string&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QListView&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;column&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Plugins List&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;pixmap&quot;&gt;
-                                &lt;pixmap&gt;image2&lt;/pixmap&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;clickable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;resizable&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                        &lt;/column&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;lvPluginsList&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;showSortIndicator&quot;&gt;
-                            &lt;bool&gt;true&lt;/bool&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;rootIsDecorated&quot;&gt;
-                            &lt;bool&gt;true&lt;/bool&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;resizeMode&quot;&gt;
-                            &lt;enum&gt;AllColumns&lt;/enum&gt;
-                        &lt;/property&gt;
-                    &lt;/widget&gt;
-                    &lt;widget class=&quot;QFrame&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;fPlugins&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;minimumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;0&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;maximumSize&quot;&gt;
-                            &lt;size&gt;
-                                &lt;width&gt;32767&lt;/width&gt;
-                                &lt;height&gt;75&lt;/height&gt;
-                            &lt;/size&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShape&quot;&gt;
-                            &lt;enum&gt;StyledPanel&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;property name=&quot;frameShadow&quot;&gt;
-                            &lt;enum&gt;Raised&lt;/enum&gt;
-                        &lt;/property&gt;
-                        &lt;hbox&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;tlPluginsTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;h2&gt;&lt;b&gt;Plugins&lt;/b&gt;&lt;/h2&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                            &lt;widget class=&quot;QLabel&quot;&gt;
-                                &lt;property name=&quot;name&quot;&gt;
-                                    &lt;cstring&gt;plPluginsTitle&lt;/cstring&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;text&quot;&gt;
-                                    &lt;string&gt;&lt;/string&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;pixmap&quot;&gt;
-                                    &lt;pixmap&gt;image3&lt;/pixmap&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;scaledContents&quot;&gt;
-                                    &lt;bool&gt;false&lt;/bool&gt;
-                                &lt;/property&gt;
-                                &lt;property name=&quot;alignment&quot;&gt;
-                                    &lt;set&gt;WordBreak|AlignVCenter|AlignRight&lt;/set&gt;
-                                &lt;/property&gt;
-                            &lt;/widget&gt;
-                        &lt;/hbox&gt;
-                    &lt;/widget&gt;
-                &lt;/grid&gt;
-            &lt;/widget&gt;
-        &lt;/widget&gt;
-    &lt;/hbox&gt;
-&lt;/widget&gt;
-&lt;images&gt;
-    &lt;image name=&quot;image0&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;892&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000343494441544889ed95cf6f146518c73f5d5a8b96a5ab6de84230b6b02858b134023d28743de8414d6a8c7f01ff801aaf24c24d2f0ac6709693f1a0f5e4c5c42e8907f560a736c4d616322dd275b7753bdb617766f6fdf17898e9b26db798102f263ec924cfccfbe4f3fd3ecffb2403ffc743c408f00e3099493fbafefc338704986a53370e7c909c6dd6f46e2fea68c92780cfcf9d3e92397f26c7f8991ce363c748a552bcffe1249f5e2f5c023ce0cdde7d7bf3e74e1fe5a5178ef0daf967393cd0cbb52f7ee0e2d56f2f0197771398aafc319b4ffbdfd3914a01202288152a5e8deb5fff8888f0e2e810c3b92cc65a8cb1186dd0da50a9d6197dfb6307186d15e86c7df1aa1efb3ac03434d65aac8d018fa4e0c25b679b40dfafa38dc1688bd686a8a1d0da72b03f7daab8e64f259dbe0b2cb50a384b6595ef4f871863304630d6a055ecb01d501bc37a790d43378ff53dc5b5cfae706ae444fe9bafbee4bd8b571de072ab80e7380ec363d0084394d2281d0b6c07d6ea0d0e0c8d923994e3f8cbc364d25d1094e347cde3955c0077fb880a9ee761f61cc6f7570942454369362a1eb55a83fd0347c9648f317af669b2d9be045882!
 fa34d40191982250f8690ea0b0e30e5cd7258a0ee0fb012b772b3c79f2154e8e3d4736fb440c0bca102d4269710b50442059082b961b3fcf7bc0d27601d7755d3a7bdee0aefb1df90b1f9131b720b809c5c4e12633015a2b8858ac3548b214337377009c765bb404201d5d74f6f493e98e60b5747f5d45106b6390c430b1a6b96db1806171b9d81ccf8e1101186bd9d3bd1fa915b15a379dd90420d292b7f9eefcb6bc85b745c07166101106064fa0c27be830481c9b16973be156ee9f19ad77efa05aad22081beb1542df60a260db185af264f69bc2c618b4d6fcba50dcbd03e2dd1ddcdb9326dc28b5779d8063a0a1d1d0440d451429eefc59e5e6ad32c08ddd054406b343c78956969b176713874a1b948a6161a49873d798febd84b350667671955aa80ac0950775c0bd0d9f747f1f4150472b4d4369c22886ce2dad313d5f6266a1cceced55af1628279977a1d5f503051e3f98a3abd3e216ffe297f9620c5c2c737ba5ead502b5092b0033ed80ff149f4c4cbc2eafe6c704580726897f3e230f03db2dc6ff6de07f3bfe067d9f88db21915f870000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image1&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;1783&quot;&gt;89504e470d0a1a0a0000000d49484452000000300000003008060000005702f987000006be494441546881ed995b6c5b771dc73f4e1a1ab74d9a02dd72991ac79da09774e9d2340fa169ccc4033058b7212126241a1ef6828436215e902690f6c40368439a40801037212434a91b0809210d1c09691d05cd5e8248db5c6ce5d6388e7dec34f1ed7fe1e17f7c8b8f2f494a79c05fe9e8f89ce373fcf9fefebfdfff720c4d35d554534d3d440d012f0137ba3adcf1f111afeeef3da181d7f6f1ace3c035fbdef7010dfcdc3edfb05c75ae0f0117011ff0ecf888b7ebeae5c779e6a94186cef4d1d2d282cbe5e20b5fff19bf7f677a12f8659de75db39fe53bd573e2e2f88897a77de7b932ece5f8b1767ef3877ff0b557dff4039f3ca881d780c93cf0c4e5d35cbdfc7801d865ef7199db43cb9b5c7af6bb96954c798044c973264a807de3235eae5c3acd95612fa77abad05a976ca0b5c6f795379899bbe701c2fb35f0d2f5ebd75fffe9abcfc3fd054760a0fcc795e65737dee3c5577e1b02de022e360a9cdfb0f73ffedd4dbefdc69f5e067ed08881430ee7ba2627276975c5a1adad1c58a902f06e88173e7789b18b1e4f6835f6f2a9ee1315c042484760ad354ad99bd68c9cefc36eb57d1b306aeb44ed2c57052e40a8e27!
 1df239df49eecd813b0560aa5144268a452787abaf2061a92938190dfefe7cab94f23720e1025c08da4443d60a5145248b239859012a5354f9ee9ed7a7f76f51ae0b1cd58c0eb40b021039665e13ad28b14e2a1002ba91052614537d9bc17e1984e313131fe96cf378e6f621ccb4af0dcf35ff201038d18980a0402d0721891130f1c586a8d2e01b6a231accd18eece47f9d8e8a778e23397f9eaf7474166616705521b904e72bcc3ed496ca51a4a2142a110ad474e96e5f18300deb292243637b136e3b4b93fcca9f3a38c5e1dc533384a7b7b3ba423908ac0f29f21631578ace40e89ad54c889d5d140381cf6033ec5219448a13536b0422b8d9472cfc0b4b8393d3cc1f0d8970df0d10ed85e36118ebf5b068ca6ecb3ffe62c98eeb93103a61516e9683f492eb588540a293439210d6415e0d4f60e563446623386506df47d7c98f34f7d9efec151ba1e79cc4437bd0e895b706fa312b6ec58170dbc370be0df8b81402814f69d3b26c9e60452483259493a93232b64a1e84a81d36941ff854f70e6ea676de03ec8c4617b05d27760fe6ff5811dae6934febfefdd8085d6b475f6935bbb43262bd84e65c96405f18d4dd6975648a705ddde27f05cba46ffe028dd03670d703a02a90558bc092ad7387021e0f679add1989a0bce2e85289fa2d43510f24f4d71e18531b259c14!
 e2a432a9d632dbc4cabbb9767bef10add03e76ce07548adc3e2bf0e045ce82!
 828edaa1
553b7ee0004aa70563700e06a355d692e278945a2b4b87bf8e2b77e04d17f42f86d10db07072e402bc76e3af0eff0be0c605916873b7b904a2184647d6995e7bef91d036fddde177011ac0496dddd74b991e0ec1254c9ff5a06ac402008f628a9b5864347e8f69e85f9376d3827606def4a073e5536869482b30bd6c9646835067646ecc540308fa3942297c9e2eef808a4e366842cf0eb22b8a6f0a38ec05ad9df77027636a2b566faee2ad4581b549f8d02eeae5e94d26c25b7f00c8ea1333150da06768a5a651a547eb7b6c9dde793f7d355a35fd740eb87dce484e9ef0f1fed4467b75052ec82ae8c5eb137712ecc0a9315e965ae25b6d250237d6a1a08048280992ea477d2740f9c456e6fa044ae4adeaab2a2ac55988e462a8a59337d67a5167b6d038944c20ff8ec243066b22933c5762acc32802aade2741e67935a9b391735bad09a068c4c37938c5ba605426164590b542fcc5ac5897d5f2d934a69c26b31308b99fd1a28ca7dac8378726d5f8559760d6793668aae90d24c1285502c2cc71e4c0be425a53870611636a5cc2c572aa4b0a1a51934a5bdffcbadc5831a3072b5b481d6083b7d6ae77965616a7b2da1643ec279d022b490665db11abdcfdc729c776756985fb17e419df743b50d68d302277a0610296b57fed7ce73955fa949652f808aa9618e0df45af4!
 3ec1bb113e988b30bd102512df0960a60e7ee0ed7ac1addf02f6482b521642882ac00aa5b4bdf0b1a32a653135ecbd948ad58d2d827311a6e736f2c079d83cb8e3b479df06b2d92ced473ad15a95b4800d6ca74031c27903c5d4985b8e9b08cf6f30331f653b9dcb03fb81a9bdc0eec380662b91e451ef185a2932994c45ceee8ef6dda5381fccfdf780f7680072c245fbd10ee2abb7b1923b15f99ccfdff9158b99c5a8b59d2a03ae7811f5a055cb4020140afb469e7e91c7ce3cc9eda95f93486e13bc1b2138b7c1f4fc06330b51ab04f6a100ef4513434317f45fdff9a3fec90fbfa707bd1fd5c0227003f327c7d0ff16cfa8de1f1cf9f7fb214c841b7a67df54534d35f5ffa3ff0049d7c49058c074ed0000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image2&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;920&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df80000035f494441544889ed956f48dc751cc75ff7bbfbdd9fdffdeeee7737efff4f3c4fd172a7e7e660b53f6db8d55c441614b2d1e67a62240511b1076b5041890c59411b940f2244c5d61eb4592db6d5ca685b9b14e8cacc33d79c4926bab9d9bc3bcf6f0ffa435c3717e19360af675fbebc5f6ff87cf8f285dbfc5f8800bb15553b6492cd4d80045402ca92d8ef88adbab4f7c019d1f6c99cb877478b3099958f2bd6d56542d1ca61a062b1ac7191bbd23fc217376eacdeb37cf5834acf9703f8f51222f9fec2ba866683e42a735f9b1edb796562e434703197c470137964cdfacda7e355eb83efb4bfd15fd7b8bf3c5858c55cc68c2ccba4933798cf2ca0d8558458a0a365c76ca2ff5400b89e2d32e5909b827af4d0aeddedc1c9ab491ef56f29f778035c999d43d7f330cb3226a384241910c0f0c0794613bd49c09fab20d788745fc18a26833b6e4c670c04433aaac3811e0aa0a91634bb11a75dc2619350ad12df0e7c8723b4d2363d3ef8d8dcec542b3077ab82abd31323970d265bedaab55bf1b8dd2c73d9d0ec70fe543b473bf7515c1a2712f6a058400fe451148d1008f86c673f7bff03e0d262237202cf04c285b5cbab369118!
 1aa266d33a3415dedcf774f248d7c17ac019df50df5a565280a6ca386d4ec27e27a383f69c2397b2ced53b9f6a7ea9e3c3a19581fc324a8af2d15498f8b18f235d079b806e6f28da58102d8585140e2b18c52c9f9f78978fde6b4b03a3d905d98d326a11dd9f0e527667293ecd886a85bed101808096a77ff1f0ae172b53b3bfa07bc3586478aba395179e7ff609e0303075ab8219e9c6657cdeb5d8ad46140b2866a8de5cc303f52f3fe90d4671bb1d6ca8cac766fd3daab9dd98cd96bb52a9646bb61cfeb9e491fede93cef974eaeed1b171349793a8eec1e3b45253bd9ad28897fbeea9c0b7ccf557205e514eefb9b3c53f0c275e0752d905d93b58c86432af24be39939c37288cff348ec908460954c542495118abc54c3a9da6abe36dd2c96b74b4b572e2f8b1e7c8f1066e86ea0d157fd5b0b753f4f427c5e098103de712e2c2f73f8bc91921266784a87de89169a021168b8dd86cb6e67f2bfe3b9e60b8b0b7b3fb6b71f4649f8896c4c4e38d7bc4e44c464ccd2445cdd6fb2ffc1769368a2c9b5ff5f943c781edb1f215d7f7bf76406cdbb6fd5797cbd5b21405d954006b58aa3fe0367ff21b3fdf112bedf0530d0000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image3&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;2436&quot;&gt;89504e470d0a1a0a0000000d49484452000000300000003008060000005702f9870000094b494441546881ed997b7054d51dc73ff77d776fb29bdd249b775c92104220bc41509e826f2b333a14b1e8d862ad1607a7be0a631d7c752aea54a73e469da1adc5b15614d45131d24a1165ac20d50a910412431258920dbbd9bcf691dd7bfbc75d4970c62151183bd37c677e73e6de397bcff77bcef93dce5918c52846318a51fc3f43380bdff4007ea004c8054ce01da0fd2c8c7546910bfc12d80e1c52542de62b2cb774a7ab1fd80c68e97e0b80f540f50f43f3dbf1aeaf68ac75f1f25f5bbf7bfe036bc71796f5c28ea475e3fab7acdce26a0bd80a5ca7ea19b17cff644bd58d08f008e0fa3e834a6782791a6bd7dc75bfaf6ade4d78f2cae9895ab47746e808f583e6231ca82b4f44bb974c9d7f4dc6c2abefc1eb2bd53a5aebce8dc77ab3803d40ff771954fe8e6425c000ba87beacf4e7515ae9e4ed5df51c690d904c2671b95c544f994b3c5caf98dd4d5937def90ca1ee1882924152ce953f79e7b1d5ddc1c30bb1aca540e3488988df817c2e701fb009b868c87b2d3e0020100e75e2f178282c2cc4ed76e3743a291b3b995b7e753ff9d94e9c0e8d9e9e1ecaaaa673d1b50f5050366302f034503e523223dd424ee0897!
 3fce56b162cbe625ce068cb75f178cc0bdce12b1a3b63fa821f93e929a6b125883bcb8baeeb274dcdc823cbe727362052577f98acac2cbc5e2fd9be126a662fa5f3687d455767eb62cb4cbd08c4cf860009585d52eabf63ed7d4f8a4b97af664c59057b3fde716ef984f3cbae5df31c7a7615dd7d713a3ac378bd39689a86a669a8aa8a695a7404bb38d27a0c4dd328282840511464594655356445a3e1b3bffb9203f18d4078b8a446e2032b0dc3b86ff5daa7e4736a2e271433b1b2cf67decae798585d45f1982afafaa31cfaaa150419c3309024094992104591cccc4c0441401006538f655998a649a8a395f75e7e80587ff71ea079049c862dc005ac9b73c1325746c9025a3b1304839d341c6e654c4535e1de049d9f7d6e7774b9282d2dc5e170d8024411491410450151e01401a665d11309f1decb0f11091d479494723335b00ef803df0810df57c0c5dedc9271def2253436b7619a26814080a2a2220cc34055552ccb4251143233339165095512912501590249c4262fa6a3860096059625d0547f04d153c3921b2e247cec8077ff077f7cb0afbb632eb09461f8c2707d209e48c456843b8f198e9cf184c25df8fd7e0cc340d775344dc3300c0ca7135d95d115115d13d0144e3155b64d91065b595108b48731cd0174230b5973126e6fac4825e36f036d674a40d83!
 2533b7b4eb4ce0c1d6fcaaf9a7a01054525e8ba8ec3e1b05b5dc5a14a18ba8!
 043054d4
a12ee68e2d0171f12387200b7db8dc79d899e16a2a4cde3729288473174859a09552c5ab498a6837b683fd65c077c7c3a622371e2bdc09681e889291ded6d948ea9c4e572d991469171a8026a7aa649c5d9f2c2a3ec7e7f0bcd4d7598a924cb6f7e846bae5f4341767a480b4ccbde4a0bcf9b02824cca8478224666a60b8659620c4740017675590d2caf9cb490b1e3a7b377ef5ea64f9b46556505ba020ecd9ed9ae600bcf6c58c3473bdef80cdb19ff066c0a854e5cd5dc1ec5edd4c9762b584344688a4d3e65822a2b28caf0e7f5743d67038f02fe9cdcfce2ca9a394c5fbc82be4402d334d154055d057dc81e7ff58547f9d787dbda806b817a200ff0b9dc1e44929c88c428f028b62363af8069412a650b480d244825879dc74e2be0bacaea19731f7cf849aa27cda635044d813807eabe24c370e22fc9c39116a02bf055c33eb6fef5a920b00af832fd8d2b7567e6cc69e75d81682548254d24d14496c5410126a4448844baa9fb7c0fed815680e09910902b18a51c0a1af813269da17e1a1a9a89c5624cac1e872b433f1959541976d66e06d8c7a0f3558b92b476c6fcab3587d34972a01f4574a06b22429abc051c6c38c04b2f6ea4a1be8ee6a606da03478340ed99104056763e9184838daf7d8a242b548e1d8b2bc349866348989441914c8eb61c027bdb788115c0da!
 c9737ee49f77e90d447bc308a42899e845916cf200fdd1281b1e5acbf6dab7f6619fdc6ad39330acf2fab4020cc3c0e7f3d1d7db4b7149094ea70345160643a134181205bbb6bd1298a3eac6a4f1d39668f32f5b852ccbc4a33df8bc4e8af33211c541015f35d6d378b81ee0deb48011e17402e27d5d6d14e464d0d96e272b45124f9257a5a1894964e5cfeea42598f2bb3d3e7f65cd5cdc591e444120dadb45a1cfc5c259154892adf2eb8aa2a3a383befe28c0cf81fd40cb48049c2e918d3393f125353553480a4e0c9717a72ea3298391471b92594b8a0b90330ae91dd0516409cb4c2092a424dfcd258ba6929bed3aa51602282c2c626c6515efffa3b63c1e8b956387dd61e374b7121af0acaa6acb2efec943c6ac0557212423242d0997e160e6e4720c878826a785c8200a26cd2d011a9a5a91259149e3fd1415e4208adf7676b2008b6d6f6de5d65b56118944c6010d674a00d80eb9de70fbd6e4175780968351781ee3c79571fdb28b28ce77a3ca832b714af1968ef5df0e0b011301939b565dcf96d75ed9679ae63c46703e1ece913204aceb8b74b445c29d944f5d4a9ecf47341aa5a5f528a200926013feda04819389ea9be80a87e80a87104821902435d0cf5ffefc3caf6e7eb9cd34cddb47421e865f0bcdc9f41414cfbee466b27273114513992485f9390869c2!
 5f134f733f0502b698139d41d6ddbd86ee9e088f3ff114c545857cb47b178f!
 3db201e0
f70ca378fb26865b8d665966ea2a4f76be515533133319e7c285b3f197e6a3cae96d23a557403c194e4fc19b5b37b362d9e5c94ff77eb2bda9f170fd9bafbf56968847c57b7f734fdff1e38167b12fbb52674bc07133950c75b41d9c238882317de6f94c9e588d2cd9fb5e12a0e1e07fd8f6ee36120349a2d128d9d9de213fb778e3f557d8fedeb6ddc04a606b4f4f8f63e7ce7f8eefefef7f16f82d101d2979185939bd31118fb6ed7ef74f9b32d564ee9c1935e84a06962570e244905b7fb18292f2c9ecdafd09d3264fa0f2b6d50c7552111320903680dbd2f6bd30d27ba1da542a7957ed9b9b02cf3c76379dc1a344fb7b79faf10739545fc791c60324e3bd602501f3a4a30ad8cfff4ba806766464b862f3175d6a4992dc01fc14f8b73727dfbafdeef5d6f160b7b5ffcbc3d63bdb6aad871fde60959595a580277f58daa7a218fb36fa25e01aecd59c258ae2feb2b20aebd2cb2eb766ce3ad7f2f97c96288a87b06b9d31679ac4d9f87fa01cb81d8860df75ee4ab7238e30a318c52846318ab38eff02e963499b9253e95c0000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-&lt;/images&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddPluginFolder&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbAddPluginFolderClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbDeletePluginFolder&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbDeletePluginFolderClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbPluginPath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbPluginPathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbAddIncludeFolder&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbAddIncludeFolderClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbDeleteIncludeFolder&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbDeleteIncludeFolderClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;lvIncludeFolders&lt;/sender&gt;
-        &lt;signal&gt;selectionChanged(QListViewItem*)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;lvIncludeFoldersSelectionChanged(QListViewItem*)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;lvPluginFolders&lt;/sender&gt;
-        &lt;signal&gt;selectionChanged(QListViewItem*)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;lvPluginFoldersSelectionChanged(QListViewItem*)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;lePluginFolder&lt;/sender&gt;
-        &lt;signal&gt;returnPressed()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;lePluginFolderReturnPressed()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;leIncludeFolder&lt;/sender&gt;
-        &lt;signal&gt;returnPressed()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;leIncludeFolderReturnPressed()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;lbPreferencesList&lt;/sender&gt;
-        &lt;signal&gt;highlighted(int)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;lbPreferencesListHighlighted(int)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbIncludePath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbIncludePathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbRescanPlugins&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedPreferencesEditor&lt;/receiver&gt;
-        &lt;slot&gt;pbRescanPluginsClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;pbAddIncludeFolderClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbAddPluginFolderClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbDeleteIncludeFolderClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbDeletePluginFolderClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbPluginPathClicked()&lt;/slot&gt;
-    &lt;slot&gt;lvIncludeFoldersSelectionChanged(QListViewItem*)&lt;/slot&gt;
-    &lt;slot&gt;lvPluginFoldersSelectionChanged(QListViewItem*)&lt;/slot&gt;
-    &lt;slot&gt;lePluginFolderReturnPressed()&lt;/slot&gt;
-    &lt;slot&gt;leIncludeFolderReturnPressed()&lt;/slot&gt;
-    &lt;slot&gt;lbPreferencesListHighlighted(int)&lt;/slot&gt;
-    &lt;slot&gt;pbIncludePathClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbRescanPluginsClicked()&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtGeneratedSimulationPlayer.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedSimulationPlayer.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedSimulationPlayer.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,512 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedSimulationPlayer&lt;/class&gt;
-&lt;widget class=&quot;QDialog&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedSimulationPlayer&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;984&lt;/width&gt;
-            &lt;height&gt;652&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;sizePolicy&quot;&gt;
-        &lt;sizepolicy&gt;
-            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-            &lt;horstretch&gt;0&lt;/horstretch&gt;
-            &lt;verstretch&gt;0&lt;/verstretch&gt;
-        &lt;/sizepolicy&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Simulation Player&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;grid&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;spacer row=&quot;0&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;spacer1_2&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;orientation&quot;&gt;
-                &lt;enum&gt;Vertical&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizeType&quot;&gt;
-                &lt;enum&gt;Expanding&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizeHint&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;20&lt;/width&gt;
-                    &lt;height&gt;60&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-        &lt;/spacer&gt;
-        &lt;widget class=&quot;GLSimulationPlayerViewer&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;5&quot; colspan=&quot;1&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;glSimulationPlayerViewer&lt;/cstring&gt;
-            &lt;/property&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbController&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Controller&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;hbox&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbPlay&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbStep&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image1&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbPause&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image2&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbReset&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image3&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/hbox&gt;
-        &lt;/widget&gt;
-        &lt;spacer row=&quot;4&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;spacer1&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;orientation&quot;&gt;
-                &lt;enum&gt;Vertical&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizeType&quot;&gt;
-                &lt;enum&gt;Expanding&lt;/enum&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizeHint&quot;&gt;
-                &lt;size&gt;
-                    &lt;width&gt;20&lt;/width&gt;
-                    &lt;height&gt;60&lt;/height&gt;
-                &lt;/size&gt;
-            &lt;/property&gt;
-        &lt;/spacer&gt;
-        &lt;widget class=&quot;QGroupBox&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbInput&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Input&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QSpinBox&quot; row=&quot;2&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;sbInputPaddle&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;value&quot;&gt;
-                        &lt;number&gt;4&lt;/number&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;spacer row=&quot;4&quot; column=&quot;2&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;spacer4&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;orientation&quot;&gt;
-                        &lt;enum&gt;Horizontal&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizeType&quot;&gt;
-                        &lt;enum&gt;Expanding&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizeHint&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;40&lt;/width&gt;
-                            &lt;height&gt;20&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                &lt;/spacer&gt;
-                &lt;spacer row=&quot;4&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;spacer3&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;orientation&quot;&gt;
-                        &lt;enum&gt;Horizontal&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizeType&quot;&gt;
-                        &lt;enum&gt;Expanding&lt;/enum&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizeHint&quot;&gt;
-                        &lt;size&gt;
-                            &lt;width&gt;40&lt;/width&gt;
-                            &lt;height&gt;20&lt;/height&gt;
-                        &lt;/size&gt;
-                    &lt;/property&gt;
-                &lt;/spacer&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlInputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Directory : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;4&quot; column=&quot;1&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbLoad&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Load&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlInputPaddle&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Paddle : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;3&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leInputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leInputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlInputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Base Name : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlInputConfigFile&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Config File : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;3&quot; column=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbInputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image4&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leInputConfigFile&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;0&quot; column=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbInputConfigFile&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image4&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbSnapShots&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;sizePolicy&quot;&gt;
-                &lt;sizepolicy&gt;
-                    &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                    &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                    &lt;horstretch&gt;0&lt;/horstretch&gt;
-                    &lt;verstretch&gt;0&lt;/verstretch&gt;
-                &lt;/sizepolicy&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Snap Shots Directory&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;3&quot; column=&quot;1&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlOuputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Base Name : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;3&quot; column=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image4&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leOutputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QCheckBox&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;cbSaveSnapShots&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Save Snap Shots&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Directory : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-    &lt;/grid&gt;
-&lt;/widget&gt;
-&lt;customwidgets&gt;
-    &lt;customwidget&gt;
-        &lt;class&gt;GLSimulationPlayerViewer&lt;/class&gt;
-        &lt;header location=&quot;local&quot;&gt;GLSimulationPlayerViewer.hpp&lt;/header&gt;
-        &lt;sizehint&gt;
-            &lt;width&gt;-1&lt;/width&gt;
-            &lt;height&gt;-1&lt;/height&gt;
-        &lt;/sizehint&gt;
-        &lt;container&gt;0&lt;/container&gt;
-        &lt;sizepolicy&gt;
-            &lt;hordata&gt;5&lt;/hordata&gt;
-            &lt;verdata&gt;5&lt;/verdata&gt;
-            &lt;horstretch&gt;0&lt;/horstretch&gt;
-            &lt;verstretch&gt;0&lt;/verstretch&gt;
-        &lt;/sizepolicy&gt;
-        &lt;pixmap&gt;image5&lt;/pixmap&gt;
-    &lt;/customwidget&gt;
-&lt;/customwidgets&gt;
-&lt;images&gt;
-    &lt;image name=&quot;image0&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;160&quot;&gt;89504e470d0a1a0a0000000d4948445200000015000000150806000000a917a5960000006749444154388dadccd10d80300c03d1947118a1fbcb23b00e2c4013dbc9fd9ef4168098eecae6def73b8eba70893a3085aa308d2ab084b2b08c32b08556b08d66700b3dc16d1478d628fa07b6d01368a31968a11528a30c28a12c48a30a48a12a58a20e1811f101d3512a7c38fee1ac0000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image1&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;181&quot;&gt;89504e470d0a1a0a0000000d4948445200000015000000150806000000a917a5960000007c49444154388db5d5c10dc0200805d0da749a8ee0fe6104d7694f4d0851f91f28270de479e2db44e4a8aeeb3bf47e3fba21329aeee9bb57273a681f2d411998425198461138847a7018ddc1297405a7d1195c825ab80cd51b5782da154ea3b34c48a1ab9009a3bbd40aa15e0cd22892ab148a06358c32c9dffef8a35ea81230cf566a45c40000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image2&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;113&quot;&gt;89504e470d0a1a0a0000000d4948445200000015000000150806000000a917a5960000003849444154388d633c76ec1803b50113d54da495a12cd804adacb4fe23f38f1dbbc6488c1c0c0c1def8f1a3a6ae8a8a123d350c6915df203007bf20ccfb0566fcb0000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image3&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;119&quot;&gt;89504e470d0a1a0a0000000d4948445200000015000000150806000000a917a5960000003e49444154388d633c76ec1803b50113d54d1c5286b2a00b585969fd27d59063c7ae3122f3878ef7470d1d3574d4506a028c0205bd7020070c1defd3c45000a13508e31a4d23f00000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image4&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;892&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000343494441544889ed95cf6f146518c73f5d5a8b96a5ab6de84230b6b02858b134023d28743de8414d6a8c7f01ff801aaf24c24d2f0ac6709693f1a0f5e4c5c42e8907f560a736c4d616322dd275b7753bdb617766f6fdf17898e9b26db798102f263ec924cfccfbe4f3fd3ecffb2403ffc743c408f00e3099493fbafefc338704986a53370e7c909c6dd6f46e2fea68c92780cfcf9d3e92397f26c7f8991ce363c748a552bcffe1249f5e2f5c023ce0cdde7d7bf3e74e1fe5a5178ef0daf967393cd0cbb52f7ee0e2d56f2f0197771398aafc319b4ffbdfd3914a01202288152a5e8deb5fff8888f0e2e810c3b92cc65a8cb1186dd0da50a9d6197dfb6307186d15e86c7df1aa1efb3ac03434d65aac8d018fa4e0c25b679b40dfafa38dc1688bd686a8a1d0da72b03f7daab8e64f259dbe0b2cb50a384b6595ef4f871863304630d6a055ecb01d501bc37a790d43378ff53dc5b5cfae706ae444fe9bafbee4bd8b571de072ab80e7380ec363d0084394d2281d0b6c07d6ea0d0e0c8d923994e3f8cbc364d25d1094e347cde3955c0077fb880a9ee761f61cc6f7570942454369362a1eb55a83fd0347c9648f317af669b2d9be045882!
 fa34d40191982250f8690ea0b0e30e5cd7258a0ee0fb012b772b3c79f2154e8e3d4736fb440c0bca102d4269710b50442059082b961b3fcf7bc0d27601d7755d3a7bdee0aefb1df90b1f9131b720b809c5c4e12633015a2b8858ac3548b214337377009c765bb404201d5d74f6f493e98e60b5747f5d45106b6390c430b1a6b96db1806171b9d81ccf8e1101186bd9d3bd1fa915b15a379dd90420d292b7f9eefcb6bc85b745c07166101106064fa0c27be830481c9b16973be156ee9f19ad77efa05aad22081beb1542df60a260db185af264f69bc2c618b4d6fcba50dcbd03e2dd1ddcdb9326dc28b5779d8063a0a1d1d0440d451429eefc59e5e6ad32c08ddd054406b343c78956969b176713874a1b948a6161a49873d798febd84b350667671955aa80ac0950775c0bd0d9f747f1f4150472b4d4369c22886ce2dad313d5f6266a1cceced55af1628279977a1d5f503051e3f98a3abd3e216ffe297f9620c5c2c737ba5ead502b5092b0033ed80ff149f4c4cbc2eafe6c704580726897f3e230f03db2dc6ff6de07f3bfe067d9f88db21915f870000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-    &lt;image name=&quot;image5&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;1125&quot;&gt;89504e470d0a1a0a0000000d4948445200000016000000160806000000c4b46c3b0000042c49444154388db5954f6c14551cc73fefcd7476b65bdaae4bb78bb5502a14d404e4801c88182d1c4c2c693da847400f9c24c68b878684238660e2b1e01f12c19493012ef2478c814412d354a46017a8a564bb6da5bbedccee767776e63d0ffb073751d483bfe49799974c3eeffb7ebf37df9fd05a530b2184040cc0042420aaf9a4d0d554800f045a6b256ae0e1e1e1d6bebebe838ee31c48a7d39b5cd7fd075e251cc7617272f2ded8d8d819cff33e0316819259537aead4a9839d5dd6d1784f91f55b0a94830242088404d304292bef68a89f520802a598fecddaa04f1a876f5c250c7c0a64cdeac686e33807e23d45e6b297c8b877f1831542614550b6599835c83c2a81b6786a75134faf2f1169f12997350881d9021d0903e06de0745d3160a6d3e94dbd5b0a64dcbb94b5831d0e3375ab892b1772dcf9790528543f8dd0d367b36768153b5e31503a0f1aecb004580b44ffac58baae8b1714f0833c7638cc8dab303a320f4822ab4c7a37c69196203de3319d5ce1c4d13c733331dedc67a129a154fd128401ab0616d55a130ac3d42d93d1913940d13fd0c9ee0183685c60da01c5421bd72f7a8c8efccef9afd374267ad93!
 d642365be0636a0d28ec7600941d9e6f23917f0e97f23ce5bef35d19ec863da0ed9059b2be70bec196c66dfa10ec0e49b338f7017258651bf95021035c595429bb0903248fe52a2b5b595dd7b4d945cc2340cdca536be389ee3f67886c5798f773fe8e0dac508c989659277a2180da4ca4ff07821058b8b251445d63d6b13ed1098a6417e39cac85197dbe31962ab9bd9f1f22a226d45366f6d0620fdb08c900d281af6110284b20085b414861d905d88f2e52739ee8cbb8022143259d3dd84691730aa2d52da441a8de0c6958068870022a41e9629ad3473fd3b8fdbe319dadb9b4924da994d2d716c7896fbe35152f78b48245d6b2da4507faf582be8eaf159b721cc837b05ae7debb1f79d08cb8b515edad942a22bc4b1c33eb3d34b1c797f06af90a72d16e2f96d9a74aa11dca8586b222d01af0fb60070f6c402d72f15d97f28c6f6d7027a5f5ce6c3233dc4e2ede496b278be4fff608cee8d3e1add806aeca51094cbb06397c1ecc328e746537c7e3ccdb5cb1136bf60635882d4d41c6ec6836ab37efa214f72208ed9f4d7cdd38ee310280542e38b1c43fb6de26b3672e1ec3cc99bcb246f66a938a3241ab3e91f7c861fbf77710b1e5e49915bae974203ba0e9e9c9cbc373d6d6d305a040a89c2a77f50b27d5782bbbf7acccf28349235dd16cf6dd374f7295e1de8a45!
 c02d37499182b01cc0201a085d61a2144d8b2ac8fb6ed340e77240c4261890!
 e04c2501
85262546d534a032154b59e0ad394e41c98182bf268ce6721ed9f064e0253356f6da2e24c1f030f783c15fe6da680af8021602bd051532ca9b8521488559f61aa86c29343578fbf0264a94c906c7d3409214c20043457a116ff6de6795578012889ff6b98fe016ea0ce1c6a2573410000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-&lt;/images&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbInputDirectory&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbInputDirectoryClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbLoad&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbPause&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbPauseClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbPlay&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbPlayClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbReset&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbResetClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbOutputDirectory&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbOutputDirectoryClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbStep&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbStepClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbInputConfigFile&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;pbInputConfigFileClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;cbSaveSnapShots&lt;/sender&gt;
-        &lt;signal&gt;toggled(bool)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSimulationPlayer&lt;/receiver&gt;
-        &lt;slot&gt;cbSaveSnapShotsToggled(bool)&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbInputDirectoryClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbOutputDirectoryClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbPlayClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbPauseClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbStepClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbResetClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbInputConfigFileClicked()&lt;/slot&gt;
-    &lt;slot&gt;cbSaveSnapShotsToggled(bool)&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtGeneratedSphericalDEMSimulator.ui
===================================================================
--- trunk/gui/qt3/QtGeneratedSphericalDEMSimulator.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtGeneratedSphericalDEMSimulator.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,445 +0,0 @@
-&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.3&quot; stdsetdef=&quot;1&quot;&gt;
-&lt;class&gt;QtGeneratedSphericalDEMSimulator&lt;/class&gt;
-&lt;widget class=&quot;QDialog&quot;&gt;
-    &lt;property name=&quot;name&quot;&gt;
-        &lt;cstring&gt;QtGeneratedSphericalDEMSimulator&lt;/cstring&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;geometry&quot;&gt;
-        &lt;rect&gt;
-            &lt;x&gt;0&lt;/x&gt;
-            &lt;y&gt;0&lt;/y&gt;
-            &lt;width&gt;712&lt;/width&gt;
-            &lt;height&gt;666&lt;/height&gt;
-        &lt;/rect&gt;
-    &lt;/property&gt;
-    &lt;property name=&quot;caption&quot;&gt;
-        &lt;string&gt;Spherical DEM Simulator&lt;/string&gt;
-    &lt;/property&gt;
-    &lt;vbox&gt;
-        &lt;property name=&quot;name&quot;&gt;
-            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-        &lt;/property&gt;
-        &lt;widget class=&quot;QGroupBox&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbParameter&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Parameters&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;0&quot; column=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leConfigurationFile&lt;/cstring&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;0&quot; column=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbPath&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QButtonGroup&quot; row=&quot;2&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;4&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;bgTimeStep&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;title&quot;&gt;
-                        &lt;string&gt;Time Step&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;grid&gt;
-                        &lt;property name=&quot;name&quot;&gt;
-                            &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                        &lt;/property&gt;
-                        &lt;widget class=&quot;QRadioButton&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;rbUseTimeStepper&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;Use TimeStepper&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QRadioButton&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;rbFixedTimeStep&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;UseFixedTimeStep&lt;/string&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;checked&quot;&gt;
-                                &lt;bool&gt;true&lt;/bool&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLineEdit&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;leTimeStep&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;0.01&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                        &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                            &lt;property name=&quot;name&quot;&gt;
-                                &lt;cstring&gt;tlSecondes&lt;/cstring&gt;
-                            &lt;/property&gt;
-                            &lt;property name=&quot;text&quot;&gt;
-                                &lt;string&gt;sec&lt;/string&gt;
-                            &lt;/property&gt;
-                        &lt;/widget&gt;
-                    &lt;/grid&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlConfigurationFile&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Configuration file : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlNbIterations&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Nb Iterations : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QSpinBox&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;sbNbIterations&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;maxValue&quot;&gt;
-                        &lt;number&gt;1000000000&lt;/number&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;value&quot;&gt;
-                        &lt;number&gt;100&lt;/number&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbRecorder&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Recorder&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QPushButton&quot; row=&quot;4&quot; column=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;4&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;pixmap&quot;&gt;
-                        &lt;pixmap&gt;image0&lt;/pixmap&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QSpinBox&quot; row=&quot;3&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;sbPaddle&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;value&quot;&gt;
-                        &lt;number&gt;4&lt;/number&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QCheckBox&quot; row=&quot;0&quot; column=&quot;0&quot; rowspan=&quot;1&quot; colspan=&quot;3&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;cbRecord&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Record Position Orientation&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;2&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlOuputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Base Name : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlInterval&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Interval : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;4&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Directory : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;3&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlPaddle&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Paddle : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;4&quot; column=&quot;1&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leOutputDirectory&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLineEdit&quot; row=&quot;2&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;leOutputBaseName&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QSpinBox&quot; row=&quot;1&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;sbInterval&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;0&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;value&quot;&gt;
-                        &lt;number&gt;1&lt;/number&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbSimulation&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Simulation&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;hbox&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbLoad&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Load&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbStart&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Start&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QPushButton&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;pbStop&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Stop&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/hbox&gt;
-        &lt;/widget&gt;
-        &lt;widget class=&quot;QGroupBox&quot;&gt;
-            &lt;property name=&quot;name&quot;&gt;
-                &lt;cstring&gt;gbResults&lt;/cstring&gt;
-            &lt;/property&gt;
-            &lt;property name=&quot;title&quot;&gt;
-                &lt;string&gt;Results&lt;/string&gt;
-            &lt;/property&gt;
-            &lt;grid&gt;
-                &lt;property name=&quot;name&quot;&gt;
-                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
-                &lt;/property&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlCurrentIteration&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;5&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Current Iteration : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;0&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlDuration&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;Duration : &lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;1&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlDurationValue&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;0&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;alignment&quot;&gt;
-                        &lt;set&gt;AlignVCenter|AlignRight&lt;/set&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;1&quot; column=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlSecondes_2&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;4&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;5&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;sec&lt;/string&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-                &lt;widget class=&quot;QLabel&quot; row=&quot;0&quot; column=&quot;1&quot; rowspan=&quot;1&quot; colspan=&quot;2&quot;&gt;
-                    &lt;property name=&quot;name&quot;&gt;
-                        &lt;cstring&gt;tlIteration&lt;/cstring&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;sizePolicy&quot;&gt;
-                        &lt;sizepolicy&gt;
-                            &lt;hsizetype&gt;1&lt;/hsizetype&gt;
-                            &lt;vsizetype&gt;1&lt;/vsizetype&gt;
-                            &lt;horstretch&gt;0&lt;/horstretch&gt;
-                            &lt;verstretch&gt;0&lt;/verstretch&gt;
-                        &lt;/sizepolicy&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;text&quot;&gt;
-                        &lt;string&gt;0&lt;/string&gt;
-                    &lt;/property&gt;
-                    &lt;property name=&quot;alignment&quot;&gt;
-                        &lt;set&gt;AlignVCenter|AlignRight&lt;/set&gt;
-                    &lt;/property&gt;
-                &lt;/widget&gt;
-            &lt;/grid&gt;
-        &lt;/widget&gt;
-    &lt;/vbox&gt;
-&lt;/widget&gt;
-&lt;images&gt;
-    &lt;image name=&quot;image0&quot;&gt;
-        &lt;data format=&quot;PNG&quot; length=&quot;892&quot;&gt;89504e470d0a1a0a0000000d4948445200000018000000180806000000e0773df800000343494441544889ed95cf6f146518c73f5d5a8b96a5ab6de84230b6b02858b134023d28743de8414d6a8c7f01ff801aaf24c24d2f0ac6709693f1a0f5e4c5c42e8907f560a736c4d616322dd275b7753bdb617766f6fdf17898e9b26db798102f263ec924cfccfbe4f3fd3ecffb2403ffc743c408f00e3099493fbafefc338704986a53370e7c909c6dd6f46e2fea68c92780cfcf9d3e92397f26c7f8991ce363c748a552bcffe1249f5e2f5c023ce0cdde7d7bf3e74e1fe5a5178ef0daf967393cd0cbb52f7ee0e2d56f2f0197771398aafc319b4ffbdfd3914a01202288152a5e8deb5fff8888f0e2e810c3b92cc65a8cb1186dd0da50a9d6197dfb6307186d15e86c7df1aa1efb3ac03434d65aac8d018fa4e0c25b679b40dfafa38dc1688bd686a8a1d0da72b03f7daab8e64f259dbe0b2cb50a384b6595ef4f871863304630d6a055ecb01d501bc37a790d43378ff53dc5b5cfae706ae444fe9bafbee4bd8b571de072ab80e7380ec363d0084394d2281d0b6c07d6ea0d0e0c8d923994e3f8cbc364d25d1094e347cde3955c0077fb880a9ee761f61cc6f7570942454369362a1eb55a83fd0347c9648f317af669b2d9be045882!
 fa34d40191982250f8690ea0b0e30e5cd7258a0ee0fb012b772b3c79f2154e8e3d4736fb440c0bca102d4269710b50442059082b961b3fcf7bc0d27601d7755d3a7bdee0aefb1df90b1f9131b720b809c5c4e12633015a2b8858ac3548b214337377009c765bb404201d5d74f6f493e98e60b5747f5d45106b6390c430b1a6b96db1806171b9d81ccf8e1101186bd9d3bd1fa915b15a379dd90420d292b7f9eefcb6bc85b745c07166101106064fa0c27be830481c9b16973be156ee9f19ad77efa05aad22081beb1542df60a260db185af264f69bc2c618b4d6fcba50dcbd03e2dd1ddcdb9326dc28b5779d8063a0a1d1d0440d451429eefc59e5e6ad32c08ddd054406b343c78956969b176713874a1b948a6161a49873d798febd84b350667671955aa80ac0950775c0bd0d9f747f1f4150472b4d4369c22886ce2dad313d5f6266a1cceced55af1628279977a1d5f503051e3f98a3abd3e216ffe297f9620c5c2c737ba5ead502b5092b0033ed80ff149f4c4cbc2eafe6c704580726897f3e230f03db2dc6ff6de07f3bfe067d9f88db21915f870000000049454e44ae426082&lt;/data&gt;
-    &lt;/image&gt;
-&lt;/images&gt;
-&lt;connections&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;bgTimeStep&lt;/sender&gt;
-        &lt;signal&gt;clicked(int)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;bgTimeStepClicked(int)&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbLoad&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbStart&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;pbStartClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbStop&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;pbStopClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbPath&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;pbPathClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;pbOutputDirectory&lt;/sender&gt;
-        &lt;signal&gt;clicked()&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;pbOutputDirectoryClicked()&lt;/slot&gt;
-    &lt;/connection&gt;
-    &lt;connection&gt;
-        &lt;sender&gt;cbRecord&lt;/sender&gt;
-        &lt;signal&gt;toggled(bool)&lt;/signal&gt;
-        &lt;receiver&gt;QtGeneratedSphericalDEMSimulator&lt;/receiver&gt;
-        &lt;slot&gt;cbRecordToggled(bool)&lt;/slot&gt;
-    &lt;/connection&gt;
-&lt;/connections&gt;
-&lt;slots&gt;
-    &lt;slot&gt;pbLoadClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbStartClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbStopClicked()&lt;/slot&gt;
-    &lt;slot&gt;bgTimeStepClicked(int)&lt;/slot&gt;
-    &lt;slot&gt;pbPathClicked()&lt;/slot&gt;
-    &lt;slot&gt;pbOutputDirectoryClicked()&lt;/slot&gt;
-    &lt;slot&gt;cbRecordToggled(bool)&lt;/slot&gt;
-&lt;/slots&gt;
-&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
-&lt;/UI&gt;

Deleted: trunk/gui/qt3/QtMetaDispatchingEngineProperties.cpp
===================================================================
--- trunk/gui/qt3/QtMetaDispatchingEngineProperties.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtMetaDispatchingEngineProperties.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,400 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtMetaDispatchingEngineProperties.hpp&quot;
-#include&lt;yade/core/EngineUnit.hpp&gt;
-#include&lt;yade/lib-multimethods/Indexable.hpp&gt;
-#include &lt;qgroupbox.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qimage.h&gt;
-#include &lt;qaction.h&gt;
-#include &lt;boost/type_traits.hpp&gt;
-
-
-using namespace boost;
-
-
-static const unsigned char image0_data[] = { 
-    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
-    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18,
-    0x08, 0x06, 0x00, 0x00, 0x00, 0xe0, 0x77, 0x3d, 0xf8, 0x00, 0x00, 0x02,
-    0x3f, 0x49, 0x44, 0x41, 0x54, 0x48, 0x89, 0xed, 0x93, 0x4d, 0x48, 0x14,
-    0x61, 0x18, 0xc7, 0x7f, 0xef, 0xcc, 0x7e, 0xd9, 0x66, 0x8d, 0xb5, 0x5b,
-    0x97, 0xa0, 0x28, 0x28, 0x42, 0x59, 0x08, 0xf1, 0x90, 0x19, 0x28, 0x64,
-    0x50, 0x76, 0xb0, 0xe8, 0x16, 0x15, 0xec, 0x21, 0x24, 0x84, 0x0e, 0x1d,
-    0xea, 0xd6, 0xa9, 0x82, 0x28, 0x90, 0x3e, 0x48, 0x62, 0xd3, 0xa8, 0x90,
-    0x42, 0x48, 0x85, 0xc2, 0xf2, 0x90, 0xeb, 0x16, 0x1d, 0xa2, 0x34, 0xf0,
-    0x60, 0x1f, 0xd8, 0x07, 0x92, 0x59, 0x54, 0x3b, 0x91, 0xae, 0xbb, 0x33,
-    0x3b, 0xf3, 0x76, 0x30, 0x73, 0x3f, 0x72, 0xb6, 0xa5, 0xab, 0x3f, 0x78,
-    0x19, 0x78, 0x3e, 0xfe, 0xff, 0x79, 0x9e, 0x77, 0x06, 0x16, 0x58, 0x60,
-    0x96, 0x83, 0xfb, 0xd7, 0xd1, 0xdf, 0xb7, 0xbd, 0xe8, 0x3e, 0xe5, 0x5f,
-    0x8a, 0x8e, 0x34, 0x6f, 0xe4, 0x5a, 0x64, 0x0b, 0xe8, 0xd6, 0xbc, 0x35,
-    0x1b, 0xca, 0x2b, 0xb9, 0xd2, 0xf9, 0x9c, 0xd6, 0xdb, 0x4f, 0x9d, 0x0d,
-    0xca, 0x43, 0x55, 0x5c, 0xbd, 0x35, 0xc0, 0xb6, 0x1d, 0x7b, 0xff, 0xc4,
-    0x5a, 0xce, 0x55, 0x41, 0xff, 0x4f, 0xe8, 0xd6, 0xe7, 0x35, 0xb0, 0x6d,
-    0x89, 0x69, 0x1a, 0x98, 0x86, 0x91, 0x15, 0x77, 0xe5, 0x16, 0xa6, 0x0c,
-    0x13, 0xe1, 0xf6, 0x13, 0x6e, 0x3e, 0x41, 0x75, 0x6d, 0x03, 0x9d, 0x37,
-    0x2e, 0x21, 0xbc, 0xd7, 0x01, 0x90, 0xad, 0x0d, 0xc8, 0xf6, 0x03, 0x00,
-    0xe8, 0xba, 0x41, 0x34, 0x36, 0x41, 0xcb, 0x85, 0x11, 0x06, 0x62, 0x9f,
-    0x91, 0xd2, 0xc6, 0x34, 0x0d, 0xa4, 0x6d, 0x3b, 0x1b, 0x24, 0x93, 0x06,
-    0xef, 0x3e, 0x8c, 0xe3, 0xf7, 0xfb, 0xd0, 0x82, 0x6b, 0x38, 0x74, 0xf4,
-    0x2c, 0xc3, 0x83, 0x8f, 0xe8, 0xea, 0xb8, 0x88, 0x68, 0xba, 0x07, 0x4d,
-    0x20, 0x8f, 0xd7, 0xa3, 0x01, 0x8d, 0xb8, 0x69, 0x0c, 0x57, 0x21, 0x62,
-    0x77, 0x91, 0x52, 0x92, 0x36, 0xcd, 0xc2, 0x06, 0x96, 0x65, 0x71, 0xf9,
-    0x54, 0x38, 0x0e, 0x68, 0x99, 0x71, 0x55, 0x40, 0x20, 0x10, 0x00, 0x20,
-    0x18, 0x19, 0xca, 0xea, 0x09, 0x04, 0x02, 0xfc, 0xf8, 0xf6, 0x31, 0x6a,
-    0xa5, 0xcd, 0x3a, 0x5b, 0x4a, 0x67, 0x03, 0x84, 0xa0, 0x7a, 0x75, 0x50,
-    0xeb, 0xd9, 0xb7, 0x15, 0x52, 0xe6, 0xcc, 0x49, 0x1a, 0x30, 0x3d, 0x7b,
-    0x52, 0x73, 0xcf, 0x44, 0x0a, 0x12, 0x49, 0x48, 0xa4, 0x08, 0x7e, 0x9a,
-    0xac, 0x4d, 0x5b, 0x16, 0x52, 0x16, 0x98, 0x40, 0x51, 0x04, 0x48, 0x59,
-    0x94, 0x38, 0x53, 0x29, 0x00, 0x6c, 0xcb, 0x42, 0xe6, 0x4c, 0x90, 0xf7,
-    0x15, 0x29, 0x42, 0x01, 0x5b, 0x16, 0x27, 0x3e, 0x95, 0x9c, 0x31, 0xb0,
-    0xf3, 0x27, 0xc8, 0x37, 0x50, 0x14, 0xb0, 0xed, 0xe2, 0xc4, 0x13, 0xc9,
-    0xac, 0x15, 0x3b, 0xae, 0x48, 0x28, 0x82, 0x27, 0xe3, 0x71, 0x3d, 0x18,
-    0x79, 0xa8, 0xe5, 0xe6, 0xfe, 0x8e, 0x0a, 0x5e, 0x3f, 0x40, 0x54, 0x55,
-    0x5d, 0xa8, 0xae, 0x6c, 0xc9, 0xfc, 0x3b, 0x10, 0x0a, 0xc7, 0xce, 0x74,
-    0x95, 0x09, 0x01, 0xcf, 0x1e, 0xf7, 0xf2, 0xa0, 0xa7, 0x8d, 0xf8, 0xd7,
-    0x09, 0x00, 0x16, 0xbb, 0x04, 0x93, 0xe9, 0xb9, 0x1d, 0xaf, 0x5a, 0xe1,
-    0xe3, 0xfd, 0xeb, 0x3d, 0xb8, 0xb4, 0x0e, 0xd6, 0xae, 0x0f, 0xe1, 0x2b,
-    0x59, 0x84, 0xdb, 0xe3, 0x29, 0x3c, 0xc1, 0xd8, 0xe8, 0x30, 0xbd, 0x77,
-    0x22, 0xbc, 0x19, 0x19, 0xcc, 0xca, 0x65, 0x8a, 0x03, 0x74, 0x77, 0xd6,
-    0xa1, 0xbe, 0x98, 0xb9, 0x60, 0x55, 0x55, 0x29, 0x5d, 0xa2, 0xe1, 0xf1,
-    0x7a, 0x9d, 0x0d, 0x46, 0x5f, 0x0e, 0x71, 0xfe, 0xe4, 0xe1, 0xfc, 0x4d,
-    0x64, 0xb0, 0xb4, 0xd4, 0x4d, 0xeb, 0xe9, 0x4a, 0x42, 0xcb, 0xfd, 0xe8,
-    0x37, 0xbf, 0xff, 0x36, 0x70, 0xe1, 0xf1, 0x96, 0x60, 0x98, 0x86, 0x63,
-    0x6f, 0x41, 0x36, 0x57, 0x68, 0x44, 0xdb, 0x6b, 0x48, 0xdc, 0xdf, 0x45,
-    0xdb, 0xee, 0x0a, 0xca, 0x7c, 0xf9, 0xbf, 0x52, 0x26, 0xc2, 0x31, 0x9b,
-    0x43, 0xfd, 0xa6, 0x65, 0xec, 0xac, 0x59, 0xc9, 0xab, 0xb1, 0x04, 0x7d,
-    0xd1, 0x2f, 0xbc, 0xd5, 0xa7, 0xff, 0xeb, 0x65, 0x17, 0x00, 0xe0, 0x17,
-    0x23, 0x64, 0x1a, 0x58, 0x23, 0xf6, 0xd0, 0x84, 0x00, 0x00, 0x00, 0x00,
-    0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
-};
-
-static const unsigned char image1_data[] = { 
-    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
-    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x18,
-    0x08, 0x06, 0x00, 0x00, 0x00, 0xe0, 0x77, 0x3d, 0xf8, 0x00, 0x00, 0x03,
-    0x5f, 0x49, 0x44, 0x41, 0x54, 0x48, 0x89, 0xed, 0x95, 0x6f, 0x48, 0xdc,
-    0x75, 0x1c, 0xc7, 0x5f, 0xf7, 0xbb, 0xfb, 0xdd, 0x9f, 0xdf, 0xfd, 0xee,
-    0xee, 0x77, 0x37, 0xef, 0xff, 0x4f, 0x3c, 0x4f, 0xd1, 0x72, 0xa7, 0xe7,
-    0xe6, 0x60, 0xb5, 0x3f, 0x6d, 0xb8, 0xd5, 0x5c, 0x44, 0x16, 0x14, 0xb2,
-    0xd1, 0xe6, 0x7a, 0x62, 0x24, 0x05, 0x11, 0xb1, 0x07, 0x6b, 0x50, 0x41,
-    0x89, 0x0c, 0x59, 0x41, 0x1b, 0x94, 0x0f, 0x22, 0x44, 0xc5, 0xd6, 0x1e,
-    0xb4, 0x59, 0x2d, 0xb6, 0xd5, 0xca, 0x68, 0x5b, 0x9b, 0x14, 0xe8, 0xca,
-    0xcc, 0x33, 0xd7, 0x9c, 0x49, 0x26, 0xba, 0xb9, 0xd9, 0xbc, 0x3b, 0xcf,
-    0x6f, 0x0f, 0xfa, 0x43, 0x5c, 0x37, 0x17, 0xe1, 0x93, 0x60, 0xaf, 0x67,
-    0x5f, 0xbe, 0xbc, 0x5f, 0x6f, 0xf8, 0x7c, 0xf8, 0xf2, 0x85, 0xdb, 0xfc,
-    0x5f, 0x88, 0x00, 0xbb, 0x15, 0x55, 0x3b, 0x64, 0x92, 0xcd, 0x4d, 0x80,
-    0x04, 0x54, 0x02, 0xca, 0x92, 0xd8, 0xef, 0x88, 0xad, 0xba, 0xb4, 0xf7,
-    0xc0, 0x19, 0xd1, 0xf6, 0xc9, 0x9c, 0xb8, 0x77, 0x47, 0x8b, 0x30, 0x99,
-    0x95, 0x8f, 0x2b, 0xd6, 0xd5, 0x65, 0x42, 0xd1, 0xca, 0x61, 0xa0, 0x62,
-    0xb1, 0xac, 0x71, 0x91, 0xbb, 0xd2, 0x3f, 0xc2, 0x17, 0x37, 0x6e, 0xac,
-    0xde, 0xb3, 0x7c, 0xf5, 0x83, 0x4a, 0xcf, 0x97, 0x03, 0xf8, 0xf5, 0x12,
-    0x22, 0xf9, 0xfe, 0xc2, 0xba, 0x86, 0x66, 0x83, 0xe4, 0x2a, 0x73, 0x5f,
-    0x9b, 0x1e, 0xdb, 0x79, 0x65, 0x62, 0xe4, 0x34, 0x70, 0x31, 0x97, 0xc4,
-    0x70, 0x13, 0x79, 0x64, 0xcd, 0xfa, 0xcd, 0xa7, 0xe3, 0x55, 0xeb, 0x83,
-    0xef, 0xb4, 0xbf, 0xd1, 0x5f, 0xd7, 0xb8, 0xbf, 0x3c, 0x58, 0x58, 0xc5,
-    0x5c, 0xc6, 0x8c, 0x2c, 0xcb, 0xa4, 0x93, 0x37, 0x98, 0xcf, 0x2c, 0xa0,
-    0xd8, 0x55, 0x84, 0x58, 0xa0, 0xa3, 0x65, 0xc7, 0x6c, 0xa2, 0xff, 0x54,
-    0x00, 0xb8, 0x9e, 0x2d, 0x32, 0xe5, 0x90, 0x9b, 0x82, 0x7a, 0xf4, 0xd0,
-    0xae, 0xdd, 0xed, 0xc1, 0xc9, 0xab, 0x49, 0x1e, 0xf5, 0x6f, 0x29, 0xf7,
-    0x78, 0x03, 0x5c, 0x99, 0x9d, 0x43, 0xd7, 0xf3, 0x30, 0xcb, 0x32, 0x26,
-    0xa3, 0x84, 0x24, 0x19, 0x10, 0xc0, 0xf0, 0xc0, 0x79, 0x46, 0x13, 0xbd,
-    0x49, 0xc0, 0x9f, 0xab, 0x20, 0xd7, 0x88, 0x74, 0x5f, 0xc1, 0x8a, 0x26,
-    0x83, 0x3b, 0x6e, 0x4c, 0x67, 0x0c, 0x04, 0x43, 0x3a, 0xaa, 0xc3, 0x81,
-    0x1e, 0x0a, 0xa0, 0xa9, 0x16, 0x34, 0xbb, 0x11, 0xa7, 0x5d, 0xc2, 0x61,
-    0x93, 0x50, 0xad, 0x12, 0xdf, 0x0e, 0x7c, 0x87, 0x23, 0xb4, 0xd2, 0x36,
-    0x3d, 0x3e, 0xf8, 0xd8, 0xdc, 0xec, 0x54, 0x2b, 0x30, 0x77, 0xab, 0x82,
-    0xab, 0xd3, 0x13, 0x23, 0x97, 0x0d, 0x26, 0x5b, 0xed, 0xaa, 0xb5, 0x5b,
-    0xf1, 0xb8, 0xdd, 0x2c, 0x73, 0xd9, 0xd0, 0xec, 0x70, 0xfe, 0x54, 0x3b,
-    0x47, 0x3b, 0xf7, 0x51, 0x5c, 0x1a, 0x27, 0x12, 0xf6, 0xa0, 0x58, 0x40,
-    0x0f, 0xe4, 0x51, 0x14, 0x8d, 0x10, 0x08, 0xf8, 0x6c, 0x67, 0x3f, 0x7b,
-    0xff, 0x03, 0xe0, 0xd2, 0x62, 0x23, 0x72, 0x02, 0xcf, 0x04, 0xc2, 0x85,
-    0xb5, 0xcb, 0xab, 0x36, 0x91, 0x18, 0x1a, 0xa2, 0x66, 0xd3, 0x3a, 0x34,
-    0x15, 0xde, 0xdc, 0xf7, 0x74, 0xf2, 0x48, 0xd7, 0xc1, 0x7a, 0xc0, 0x19,
-    0xdf, 0x50, 0xdf, 0x5a, 0x56, 0x52, 0x80, 0xa6, 0xca, 0x38, 0x6d, 0x4e,
-    0xc2, 0x7e, 0x27, 0xa3, 0x83, 0xf6, 0x9c, 0x23, 0x97, 0xb2, 0xce, 0xd5,
-    0x3b, 0x9f, 0x6a, 0x7e, 0xa9, 0xe3, 0xc3, 0xa1, 0x95, 0x81, 0xfc, 0x32,
-    0x4a, 0x8a, 0xf2, 0xd1, 0x54, 0x98, 0xf8, 0xb1, 0x8f, 0x23, 0x5d, 0x07,
-    0x9b, 0x80, 0x6e, 0x6f, 0x28, 0xda, 0x58, 0x10, 0x2d, 0x85, 0x85, 0x14,
-    0x0e, 0x2b, 0x18, 0xc5, 0x2c, 0x9f, 0x9f, 0x78, 0x97, 0x8f, 0xde, 0x6b,
-    0x4b, 0x03, 0xa3, 0xd9, 0x05, 0xd9, 0x8d, 0x32, 0x6a, 0x11, 0xdd, 0x9f,
-    0x0e, 0x52, 0x76, 0x67, 0x29, 0x3e, 0xcd, 0x88, 0x6a, 0x85, 0xbe, 0xd1,
-    0x01, 0x80, 0x80, 0x96, 0xa7, 0x7f, 0xf1, 0xf0, 0xae, 0x17, 0x2b, 0x53,
-    0xb3, 0xbf, 0xa0, 0x7b, 0xc3, 0x58, 0x64, 0x78, 0xab, 0xa3, 0x95, 0x17,
-    0x9e, 0x7f, 0xf6, 0x09, 0xe0, 0x30, 0x30, 0x75, 0xab, 0x82, 0x19, 0xe9,
-    0xc6, 0x65, 0x7c, 0xde, 0xb5, 0xd8, 0xad, 0x46, 0x14, 0x0b, 0x28, 0x66,
-    0xa8, 0xde, 0x5c, 0xc3, 0x03, 0xf5, 0x2f, 0x3f, 0xe9, 0x0d, 0x46, 0x71,
-    0xbb, 0x1d, 0x6c, 0xa8, 0xca, 0xc7, 0x66, 0xfd, 0x3d, 0xaa, 0xb9, 0xdd,
-    0x98, 0xcd, 0x96, 0xbb, 0x52, 0xa9, 0x64, 0x6b, 0xb6, 0x1c, 0xfe, 0xb9,
-    0xe4, 0x91, 0xfe, 0xde, 0x93, 0xce, 0xf9, 0x74, 0xea, 0xee, 0xd1, 0xb1,
-    0x71, 0x34, 0x97, 0x93, 0xa8, 0xee, 0xc1, 0xe3, 0xb4, 0x52, 0x53, 0xbd,
-    0x9a, 0xd2, 0x88, 0x97, 0xfb, 0xee, 0xa9, 0xc0, 0xb7, 0xcc, 0xf5, 0x57,
-    0x20, 0x5e, 0x51, 0x4e, 0xef, 0xb9, 0xb3, 0xc5, 0x3f, 0x0c, 0x27, 0x5e,
-    0x07, 0x52, 0xd9, 0x05, 0xd9, 0x3b, 0x58, 0xc8, 0x64, 0x32, 0xaf, 0x24,
-    0xbe, 0x39, 0x93, 0x9c, 0x37, 0x28, 0x8c, 0xff, 0x34, 0x8e, 0xc9, 0x08,
-    0x46, 0x09, 0x54, 0xc5, 0x42, 0x49, 0x51, 0x18, 0xab, 0xc5, 0x4c, 0x3a,
-    0x9d, 0xa6, 0xab, 0xe3, 0x6d, 0xd2, 0xc9, 0x6b, 0x74, 0xb4, 0xb5, 0x72,
-    0xe2, 0xf8, 0xb1, 0xe7, 0xc8, 0xf1, 0x06, 0x6e, 0x86, 0xea, 0x0d, 0x15,
-    0x7f, 0xd5, 0xb0, 0xb7, 0x53, 0xf4, 0xf4, 0x27, 0xc5, 0xe0, 0x98, 0x10,
-    0x3d, 0xe7, 0x12, 0xe2, 0xc2, 0xf7, 0x3f, 0x8b, 0xc9, 0x19, 0x21, 0x26,
-    0x67, 0x84, 0xa8, 0x7d, 0xe8, 0x91, 0x69, 0xa0, 0x21, 0x16, 0x8b, 0x8d,
-    0xd8, 0x6c, 0xb6, 0xe6, 0x7f, 0x2b, 0xfe, 0x3b, 0x9e, 0x60, 0xb8, 0xb0,
-    0xb7, 0xb3, 0xfb, 0x6b, 0x71, 0xf4, 0x64, 0x9f, 0x88, 0x96, 0xc4, 0xc4,
-    0xe3, 0x8d, 0x7b, 0xc4, 0xe4, 0x4c, 0x46, 0x4c, 0xcd, 0x24, 0x45, 0xcd,
-    0xd6, 0xfb, 0x2f, 0xfc, 0x17, 0x69, 0x36, 0x8a, 0x2c, 0x9b, 0x5f, 0xf5,
-    0xf9, 0x43, 0xc7, 0x81, 0xed, 0xb1, 0xf2, 0x15, 0xd7, 0xf7, 0xbf, 0x76,
-    0x40, 0x6c, 0xdb, 0xb6, 0xfd, 0x57, 0x97, 0xcb, 0xd5, 0xb2, 0x14, 0x05,
-    0xd9, 0x54, 0x00, 0x6b, 0x58, 0xaa, 0x3f, 0xe0, 0x36, 0x7f, 0xf2, 0x1b,
-    0x3f, 0xdf, 0x11, 0x2b, 0xed, 0xf0, 0x53, 0x0d, 0x00, 0x00, 0x00, 0x00,
-    0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
-};
-
-
-QtMetaDispatchingEngineProperties::QtMetaDispatchingEngineProperties(QWidget* parent,  const char*name ) : QtGeneratedMetaDispatchingEngineProperties( parent, name )
-{
-}
-
-
-
-QtMetaDispatchingEngineProperties::QtMetaDispatchingEngineProperties(shared_ptr&lt;MetaDispatchingEngine&gt;&amp; mde, QWidget* parent,  const char* name ) 
-	: QtGeneratedMetaDispatchingEngineProperties( parent, name )
-{
-	dimension = mde-&gt;getDimension();
-	
-	for(int i=0;i&lt;dimension;i++)
-		baseClasses.push_back(mde-&gt;getBaseClassType(i));
-
-	baseClasses.push_back(mde-&gt;getEngineUnitType());
-	
-	metaEngine = mde;
-
-	QImage img;
-	img.loadFromData( image0_data, sizeof( image0_data ), &quot;PNG&quot; );
-	image0 = img;
-
-	img.loadFromData( image1_data, sizeof( image1_data ), &quot;PNG&quot; );
-	image1 = img;
-
-	buildDynlibList();
-
-	engineUnitFrame = new QFrame();
-
-	engineUnitParameters.clear();
-	cbs.clear();
-
-	vector&lt;vector&lt;string&gt; &gt; functorNames = mde-&gt;getFunctorNames();
-
-	for(size_t i=0;i&lt;functorNames.size() ;i++)
-	{
-		pbAddClicked();
-		for(size_t j=0;j&lt;functorNames[i].size();j++)
-			((QComboBox*)cbs[i][j])-&gt;setCurrentText(functorNames[i][j]);
-		engineUnitParameters.back() = mde-&gt;findFunctorArguments(functorNames[i].back());
-	}
-
-}
-
-
-QtMetaDispatchingEngineProperties::~QtMetaDispatchingEngineProperties()
-{
-}
-
-
-void QtMetaDispatchingEngineProperties::showEvent( QShowEvent * )
-{
-	adjustSize();
-}
-
-
-void QtMetaDispatchingEngineProperties::buildDynlibList()
-{
-
-	inheritedClasses.resize(baseClasses.size());
-
-	map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-	map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-	for(;di!=diEnd;++di)
-	{
-		shared_ptr&lt;Factorable&gt; f = ClassFactory::instance().createShared((*di).first);
-
-		if (dynamic_pointer_cast&lt;EngineUnit&gt;(f))
-		{
-			if (Omega::instance().isInheritingFrom((*di).first,metaEngine-&gt;getEngineUnitType()))
-				inheritedClasses.back().push_back((*di).first);
-		}
-		else if (dynamic_pointer_cast&lt;Indexable&gt;(f))
-		{
-			for(unsigned int i=0;i&lt;baseClasses.size()-1;i++)
-			{
-				if (Omega::instance().isInheritingFrom((*di).first,metaEngine-&gt;getBaseClassType(i)))
-					inheritedClasses[i].push_back((*di).first);
-			}
-		}
-	}
-}
-
-
-void QtMetaDispatchingEngineProperties::pbAddClicked()
-{
-	vector&lt;QWidget*&gt; v;
-
-	for(int i=0;i&lt;=dimension;i++)
-	{	
-		QComboBox * cb = new QComboBox( FALSE, centralFrame);
-    		cb-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)1, (QSizePolicy::SizeType)1, 0, 0, cb-&gt;sizePolicy().hasHeightForWidth() ) );
-		cb-&gt;show();
-
-		for(unsigned int j=0;j&lt;inheritedClasses[i].size();j++)
-			cb-&gt;insertItem(inheritedClasses[i][j]);
-
-		v.push_back(cb);
-	}
-
-	string pbName = &quot;pbRemove&quot;;
-	static int num = 0;
-	num++;
-	pbName += lexical_cast&lt;string&gt;(num);
-
-	QPushButton * pbRemove = new QPushButton( centralFrame,pbName.c_str());
-	pbRemove-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)1, (QSizePolicy::SizeType)1, 0, 0, pbRemove-&gt;sizePolicy().hasHeightForWidth() ) );
-	pbRemove-&gt;setPixmap( image0 );
-	pbRemove-&gt;show();
-	connect( pbRemove, SIGNAL( clicked() ), this, SLOT( pbRemoveClicked() ) );
-
-	v.push_back(pbRemove);
-
-	pbName = &quot;pbSerialization&quot;;
-	pbName += lexical_cast&lt;string&gt;(num);
-	QPushButton * pbSerialization = new QPushButton( centralFrame,pbName.c_str());
-	pbSerialization-&gt;setSizePolicy( QSizePolicy( (QSizePolicy::SizeType)1, (QSizePolicy::SizeType)1, 0, 0, pbSerialization-&gt;sizePolicy().hasHeightForWidth() ) );
-	pbSerialization-&gt;setPixmap( image1 );
-	pbSerialization-&gt;show();
-	connect( pbSerialization, SIGNAL( clicked() ), this, SLOT( pbSerializationClicked() ) );
-
-	v.push_back(pbSerialization);
-
-	cbs.push_back(v);
-
-	engineUnitParameters.push_back(shared_ptr&lt;EngineUnit&gt;());
-
-	// if no attributes are registered then the button to open the serialization frame is not enabled
-	shared_ptr&lt;EngineUnit&gt; eu = dynamic_pointer_cast&lt;EngineUnit&gt;(ClassFactory::instance().createShared(((QComboBox*)v[v.size()-3])-&gt;currentText()));
-	eu-&gt;registerSerializableAttributes(false);
-	v.back()-&gt;setEnabled(eu-&gt;getArchives().size()!=0);
-
-	for(unsigned int j=0;j&lt;v.size();j++)
-		centralFrameLayout-&gt;addWidget( v[j], cbs.size()-1, j );
-
-	adjustSize();
-
-}
-
-
-void QtMetaDispatchingEngineProperties::pbRemoveClicked()
-{
-	QPushButton * pb = (QPushButton*)(this-&gt;sender());
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsi    = cbs.begin();
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsiEnd = cbs.end();adjustSize();
-
-	vector&lt;shared_ptr&lt;EngineUnit&gt; &gt;::iterator eui    = engineUnitParameters.begin();
-
-	for( ; cbsi!=cbsiEnd; ++cbsi,++eui)
-	{
-		QPushButton * tmppb = (QPushButton*)(*cbsi)[dimension+1];
-		if (tmppb-&gt;name()==pb-&gt;name())
-		{
-    			for(unsigned int i=0;i&lt;(*cbsi).size();i++)
-			{
-    				centralFrameLayout-&gt;remove((*cbsi)[i]);
-				(*cbsi)[i]-&gt;hide();
-			}
-			cbs.erase(cbsi);
-			engineUnitParameters.erase(eui);
-			adjustSize();
-			return;
-		}
-	}
-}
-
-
-void QtMetaDispatchingEngineProperties::pbSerializationClicked()
-{
-
-	QPushButton * pb = (QPushButton*)(this-&gt;sender());
-
-	string name;
-	shared_ptr&lt;EngineUnit&gt; eu;
-
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsi    = cbs.begin();
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsiEnd = cbs.end();
-	vector&lt;shared_ptr&lt;EngineUnit&gt; &gt;::iterator eui    = engineUnitParameters.begin();
-	for( ; cbsi!=cbsiEnd; ++cbsi,++eui)
-	{
-		QPushButton * tmppb = (QPushButton*)(*cbsi)[dimension+2];
-		if (tmppb-&gt;name()==pb-&gt;name())
-		{
-			QComboBox *  cb = (QComboBox*)((*cbsi)[dimension]);
-			const char * str = cb-&gt;currentText();
-			name = str;
-
-			if ((*eui)==shared_ptr&lt;EngineUnit&gt;() || (*eui)!=shared_ptr&lt;EngineUnit&gt;() &amp;&amp; (*eui)-&gt;getClassName()!=name)
-				*eui = shared_ptr&lt;EngineUnit&gt;(dynamic_pointer_cast&lt;EngineUnit&gt;(ClassFactory::instance().createShared(name)));
-			eu = *eui;
-		}
-	}
-
-	guiGen.setResizeHeight(true);
-	guiGen.setResizeWidth(true);
-	guiGen.setShift(10,20);
-	guiGen.setShowButtons(true);
-
-	QWidget * parent   = this-&gt;parentWidget()-&gt;parentWidget();
-
-	delete engineUnitFrame;
-	engineUnitFrame = new QFrame(parent);
-	engineUnitFrame-&gt;setCaption(name);
-
-	guiGen.buildGUI(eu,engineUnitFrame);
-	engineUnitFrame-&gt;show();
-}
-
-
-void QtMetaDispatchingEngineProperties::pbOkClicked()
-{
-
-	metaEngine-&gt;clear();
-
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsi    = cbs.begin();
-	vector&lt;vector&lt;QWidget*&gt; &gt;::iterator cbsiEnd = cbs.end();
-	vector&lt;shared_ptr&lt;EngineUnit&gt; &gt;::iterator eui    = engineUnitParameters.begin();
-	for( ; cbsi!=cbsiEnd; ++cbsi,++eui)
-	{
-		string baseClass1 = ((QComboBox*)(*cbsi)[0])-&gt;currentText();
-		if (metaEngine-&gt;getDimension()==1)
-		{			
-			string baseFunctor = ((QComboBox*)(*cbsi)[1])-&gt;currentText();
-			if (*eui!=shared_ptr&lt;EngineUnit&gt;())
-				metaEngine-&gt;add(*eui);
-			else
-				metaEngine-&gt;add(baseFunctor);
-		}
-		else if (metaEngine-&gt;getDimension()==2)
-		{
-			string baseClass2 = ((QComboBox*)(*cbsi)[1])-&gt;currentText();
-			string baseFunctor = ((QComboBox*)(*cbsi)[2])-&gt;currentText();
-			if (*eui!=shared_ptr&lt;EngineUnit&gt;())
-				metaEngine-&gt;add(*eui);
-			else
-				metaEngine-&gt;add(baseFunctor);
-		}
-	}
-
-	close();
-}
-

Deleted: trunk/gui/qt3/QtMetaDispatchingEngineProperties.hpp
===================================================================
--- trunk/gui/qt3/QtMetaDispatchingEngineProperties.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtMetaDispatchingEngineProperties.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,56 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTMETADISPATCHINGENGINEPROPERTIES_HPP
-#define QTMETADISPATCHINGENGINEPROPERTIES_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include &lt;QtGeneratedMetaDispatchingEngineProperties.h&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qcombobox.h&gt;
-#include &lt;qpixmap.h&gt;
-#include&lt;yade/core/MetaDispatchingEngine.hpp&gt;
-#include&lt;yade/core/Engine.hpp&gt;
-#include&lt;yade/lib-serialization-qt/QtGUIGenerator.hpp&gt;
-
-class QtMetaDispatchingEngineProperties : public QtGeneratedMetaDispatchingEngineProperties
-{
-	protected :
-		vector&lt;vector&lt;QWidget*&gt; &gt; cbs;
-		vector&lt;shared_ptr&lt;EngineUnit&gt; &gt; engineUnitParameters;
-
-		vector&lt;string&gt; baseClasses;
-		int dimension;
-		QtGUIGenerator guiGen;
-		QFrame * engineUnitFrame;
-		shared_ptr&lt;MetaDispatchingEngine&gt; metaEngine;
-
-		vector&lt;vector&lt;string&gt; &gt; inheritedClasses;
-
-		void buildDynlibList();
-
-	private :
-		QPixmap image0;
-		QPixmap image1;
-
-	public :
-		QtMetaDispatchingEngineProperties(shared_ptr&lt;MetaDispatchingEngine&gt;&amp; mde, QWidget* parent=0,  const char* name=0 );
-		QtMetaDispatchingEngineProperties(QWidget* parent=0,  const char* name=0);
-		~QtMetaDispatchingEngineProperties();
-
-	public slots :
-		void pbAddClicked();
-		void pbOkClicked();
-		void pbRemoveClicked();
-		void pbSerializationClicked();
-
-	protected  : void showEvent( QShowEvent * );
-};
-
-#endif // QTMETADISPATCHINGENGINEPROPERTIES_HPP
-

Deleted: trunk/gui/qt3/QtPreferencesEditor.cpp
===================================================================
--- trunk/gui/qt3/QtPreferencesEditor.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtPreferencesEditor.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,229 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtPreferencesEditor.hpp&quot;
-#include &quot;FileDialog.hpp&quot;
-#include&lt;yade/core/Preferences.hpp&gt;
-#include &lt;qlineedit.h&gt;
-#include &lt;qlistview.h&gt;
-#include &lt;qlistbox.h&gt;
-#include &lt;qwidgetstack.h&gt;
-#include &lt;boost/filesystem/operations.hpp&gt;
-#include &lt;boost/filesystem/convenience.hpp&gt;
-
-QtPreferencesEditor::QtPreferencesEditor ( QWidget * parent , const char * name) : QtGeneratedPreferencesEditor(parent,name)
-{
-	loadPreferences();
-
-	buildPluginsListView();
-}
-
-
-QtPreferencesEditor::~QtPreferencesEditor ()
-{
-
-}
-
-
-void QtPreferencesEditor::closeEvent(QCloseEvent *evt)
-{
-
-	savePreferences();	
-
-	QtGeneratedPreferencesEditor::closeEvent(evt);
-}
-
-/// List box
-
-void QtPreferencesEditor::lbPreferencesListHighlighted(int i)
-{
-	wsPreferences-&gt;raiseWidget(i);
-}
-
-/// Include Folder Page
-	
-void QtPreferencesEditor::pbAddIncludeFolderClicked()
-{
-	if (!leIncludeFolder-&gt;text().isEmpty())
-	{
-		if (testDirectory(leIncludeFolder-&gt;text().data()))
-			lvIncludeFolders-&gt;insertItem(new QListViewItem(lvIncludeFolders,leIncludeFolder-&gt;text()));
-	}
-}
-
-
-void QtPreferencesEditor::pbDeleteIncludeFolderClicked()
-{
-	lvIncludeFolders-&gt;takeItem(lvIncludeFolders-&gt;currentItem());
-}
-
-
-void QtPreferencesEditor::pbIncludePathClicked()
-{
-	leIncludeFolder-&gt;setText(FileDialog::getExistingDirectory ( &quot;./&quot;,&quot;Choose A New Include Folder&quot;,this-&gt;parentWidget()-&gt;parentWidget()).c_str());
-}
-
-
-void QtPreferencesEditor::lvIncludeFoldersSelectionChanged(QListViewItem* lvi)
-{
-	leIncludeFolder-&gt;setText(lvi-&gt;text(0));
-}
-
-
-void QtPreferencesEditor::leIncludeFolderReturnPressed()
-{
-	if (!leIncludeFolder-&gt;text().isEmpty() &amp;&amp; testDirectory(leIncludeFolder-&gt;text().data()))
-	{
-			
-		if (lvIncludeFolders-&gt;childCount()==0)
-			lvIncludeFolders-&gt;insertItem(new QListViewItem(lvIncludeFolders,leIncludeFolder-&gt;text()));
-		else if (lvIncludeFolders-&gt;selectedItem())
-			lvIncludeFolders-&gt;selectedItem()-&gt;setText(0,leIncludeFolder-&gt;text());
-	}	
-}
-
-/// Plugin Folder Page
-
-void QtPreferencesEditor::pbAddPluginFolderClicked()
-{
-	if (!lePluginFolder-&gt;text().isEmpty())
-	{
-		if (testDirectory(lePluginFolder-&gt;text().data()))
-			lvPluginFolders-&gt;insertItem(new QListViewItem(lvPluginFolders,lePluginFolder-&gt;text()));
-	}
-}
-
-
-void QtPreferencesEditor::pbDeletePluginFolderClicked()
-{
-	lvPluginFolders-&gt;takeItem(lvPluginFolders-&gt;currentItem());
-}
-
-
-
-void QtPreferencesEditor::pbPluginPathClicked()
-{
-	lePluginFolder-&gt;setText(FileDialog::getExistingDirectory ( &quot;./&quot;,&quot;Choose A New Inlude Folder&quot;,this-&gt;parentWidget()-&gt;parentWidget()).c_str());
-}
-
-
-void QtPreferencesEditor::lvPluginFoldersSelectionChanged(QListViewItem* lvi)
-{
-	lePluginFolder-&gt;setText(lvi-&gt;text(0));
-}
-
-
-void QtPreferencesEditor::lePluginFolderReturnPressed()
-{
-	if (!lePluginFolder-&gt;text().isEmpty() &amp;&amp; testDirectory(lePluginFolder-&gt;text().data()))
-	{
-			
-		if (lvPluginFolders-&gt;childCount()==0)
-			lvPluginFolders-&gt;insertItem(new QListViewItem(lvPluginFolders,lePluginFolder-&gt;text()));
-		else if (lvPluginFolders-&gt;selectedItem())
-			lvPluginFolders-&gt;selectedItem()-&gt;setText(0,lePluginFolder-&gt;text());
-	}	
-}
-
-/// Plugins Page
-
-void QtPreferencesEditor::pbRescanPluginsClicked()
-{
-	scanPlugins();
-}
-
-/// Misc
-
-bool QtPreferencesEditor::testDirectory(const string&amp; dirName)
-{
-	filesystem::path path = filesystem::path(dirName, filesystem::native);
-	return filesystem::exists( path );
-}
-
-
-
-void QtPreferencesEditor::loadPreferences()
-{
-	filesystem::path yadeConfigPath = filesystem::path( Omega::instance().yadeConfigPath, filesystem::native);
-	IOFormatManager::loadFromFile(&quot;XMLFormatManager&quot;,yadeConfigPath.string()+&quot;/preferences.xml&quot;,&quot;preferences&quot;,Omega::instance().preferences);
-
-	vector&lt;string&gt;::iterator idi    = Omega::instance().preferences-&gt;includeDirectories.begin();
-	vector&lt;string&gt;::iterator idiEnd = Omega::instance().preferences-&gt;includeDirectories.end();
-	for( ; idi!=idiEnd ; ++idi)
-		lvIncludeFolders-&gt;insertItem(new QListViewItem(lvIncludeFolders,(*idi).c_str()));
-
-	vector&lt;string&gt;::iterator dldi    = Omega::instance().preferences-&gt;dynlibDirectories.begin();
-	vector&lt;string&gt;::iterator dldiEnd = Omega::instance().preferences-&gt;dynlibDirectories.end();
-	for( ; dldi!=dldiEnd ; ++dldi)
-		lvPluginFolders-&gt;insertItem(new QListViewItem(lvPluginFolders,(*dldi).c_str()));
-}
-
-
-void QtPreferencesEditor::savePreferences()
-{
-	filesystem::path yadeConfigPath = filesystem::path( Omega::instance().yadeConfigPath, filesystem::native);
-
-	Omega::instance().preferences-&gt;dynlibDirectories.clear();
-	Omega::instance().preferences-&gt;includeDirectories.clear();
-
-	QListViewItem * currentItem = lvIncludeFolders-&gt;firstChild();
-	while (currentItem)
-	{
-		Omega::instance().preferences-&gt;includeDirectories.push_back(currentItem-&gt;text(0).data());
-		currentItem=currentItem-&gt;nextSibling();	
-	}
-
-	currentItem = lvPluginFolders-&gt;firstChild();
-	while (currentItem)
-	{
-		Omega::instance().preferences-&gt;dynlibDirectories.push_back(currentItem-&gt;text(0).data());
-		currentItem=currentItem-&gt;nextSibling();	
-	}
-
-	IOFormatManager::saveToFile(&quot;XMLFormatManager&quot;,yadeConfigPath.string()+&quot;/preferences.xml&quot;,&quot;preferences&quot;,Omega::instance().preferences);
-}
-
-
-void QtPreferencesEditor::scanPlugins()
-{
-	savePreferences();
-	
-	Omega::instance().scanPlugins();
-	
-	buildPluginsListView();
-}
-
-
-#include &lt;qpixmap.h&gt;
-
-void QtPreferencesEditor::buildPluginsListView()
-{
-	lvPluginsList-&gt;clear();
-
-// 	QCheckListItem * data		= new QCheckListItem(lvPluginsList,&quot;Data&quot;,);
-// 	QCheckListItem * engine		= new QCheckListItem(lvPluginsList,&quot;Engine&quot;);
-// 	QCheckListItem * container	= new QCheckListItem(lvPluginsList,&quot;Container&quot;);
-// 
-// 	QCheckListItem * state			= new QCheckListItem(data,&quot;State&quot;);
-// 	QCheckListItem * physicalParameters	= new QCheckListItem(data,&quot;PhysicalParameters&quot;);
-// 	QCheckListItem * geometricalModel	= new QCheckListItem(data,&quot;GeometricalModel&quot;);
-// 	QCheckListItem * interactingGeometry	= new QCheckListItem(data,&quot;InteractingGeometry&quot;);
-// 	QCheckListItem * boundingVolume		= new QCheckListItem(data,&quot;BoundingVolume&quot;);
-// 	QCheckListItem * interactionGeometry	= new QCheckListItem(data,&quot;InteractionGeometry&quot;);
-// 	QCheckListItem * interactionPhysics	= new QCheckListItem(data,&quot;InteractionPhysics&quot;);
-// 	QCheckListItem * physicalAction 	= new QCheckListItem(data,&quot;PhysicalAction&quot;);
-
-	//QCheckListItem * engine = new QCheckListItem(lvPluginsList,&quot;Engine&quot;)
-	//QCheckListItem * container = new QCheckListItem(lvPluginsList,&quot;Container&quot;)
-
-	map&lt;string,DynlibDescriptor&gt;::const_iterator di    = Omega::instance().getDynlibsDescriptor().begin();
-	map&lt;string,DynlibDescriptor&gt;::const_iterator diEnd = Omega::instance().getDynlibsDescriptor().end();
-	for(;di!=diEnd;++di)
-		lvPluginsList-&gt;insertItem(new QListViewItem(lvPluginsList,(*di).first));
-
-}

Deleted: trunk/gui/qt3/QtPreferencesEditor.hpp
===================================================================
--- trunk/gui/qt3/QtPreferencesEditor.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtPreferencesEditor.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,56 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTPREFERENCESEDITOR_HPP
-#define QTPREFERENCESEDITOR_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include &lt;QtGeneratedPreferencesEditor.h&gt;
-#include&lt;yade/lib-factory/Factorable.hpp&gt;
-
-class QtPreferencesEditor : public QtGeneratedPreferencesEditor, public Factorable
-{
-	private :
-		bool testDirectory(const string&amp; dirName);
-		void savePreferences();
-		void loadPreferences();
-		void scanPlugins();
-		void buildPluginsListView();
-
-	protected :
-		void closeEvent(QCloseEvent *evt);
-
-	public :
-		QtPreferencesEditor (QWidget * parent = 0, const char * name = 0 );
-		virtual ~QtPreferencesEditor ();
-	
-	public slots :
-		virtual void lbPreferencesListHighlighted(int i);
-	
- 		virtual void pbAddIncludeFolderClicked();
-		virtual void pbDeleteIncludeFolderClicked();
-		virtual void pbIncludePathClicked();
-		virtual void lvIncludeFoldersSelectionChanged(QListViewItem* lvi);
-		virtual void leIncludeFolderReturnPressed();
-
- 		virtual void pbAddPluginFolderClicked();
-		virtual void pbDeletePluginFolderClicked();
-		virtual void pbPluginPathClicked();
-		virtual void lvPluginFoldersSelectionChanged(QListViewItem* lvi);
-		virtual void lePluginFolderReturnPressed();
-
-		virtual void pbRescanPluginsClicked();	
-	
-	REGISTER_CLASS_NAME(QtPreferencesEditor);
-	REGISTER_BASE_CLASS_NAME(Factorable);
-};
-
-REGISTER_FACTORABLE(QtPreferencesEditor);
-
-#endif // QTPREFERENCESEDITOR_HPP
-

Deleted: trunk/gui/qt3/QtSimulationPlayer.cpp
===================================================================
--- trunk/gui/qt3/QtSimulationPlayer.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtSimulationPlayer.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,116 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtSimulationPlayer.hpp&quot;
-#include &quot;FileDialog.hpp&quot;
-#include &quot;GLSimulationPlayerViewer.hpp&quot;
-#include&lt;yade/core/FileGenerator.hpp&gt;
-#include &lt;qlineedit.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qspinbox.h&gt;
-
-QtSimulationPlayer::QtSimulationPlayer() : QtGeneratedSimulationPlayer()
-{
-	
-}
-
-
-QtSimulationPlayer::~QtSimulationPlayer()
-{
-}
-
-
-void QtSimulationPlayer::pbInputConfigFileClicked()
-{
-	string selectedFilter;
-	std::vector&lt;string&gt; filters;
-	filters.push_back(&quot;XML Yade File (*.xml)&quot;);
-	string fileName = FileDialog::getOpenFileName(&quot;.&quot;, filters, &quot;Choose a file to load&quot;, this-&gt;parentWidget()-&gt;parentWidget(),selectedFilter );
- 
-	if (!fileName.empty() &amp;&amp; selectedFilter == &quot;XML Yade File (*.xml)&quot;)
-		leInputConfigFile-&gt;setText(fileName);
-}
-
-
-
-void QtSimulationPlayer::pbInputDirectoryClicked()
-{
-	string directory = FileDialog::getExistingDirectory ( &quot;.&quot;,&quot;Choose the directory where the recorded file are&quot;, this-&gt;parentWidget()-&gt;parentWidget());
-	if (!directory.empty())
-		leInputDirectory-&gt;setText(directory);
-}
-
-
-void QtSimulationPlayer::pbLoadClicked()
-{
-	glSimulationPlayerViewer-&gt;load(leInputConfigFile-&gt;text());
-}
-
-
-void QtSimulationPlayer::pbOutputDirectoryClicked()
-{
-	string directory = FileDialog::getExistingDirectory ( &quot;.&quot;,&quot;Choose the directory where to save the sna shots&quot;, this-&gt;parentWidget()-&gt;parentWidget());
-	if (!directory.empty())
-		leOutputDirectory-&gt;setText(directory.c_str());
-
-}
-
-
-void QtSimulationPlayer::pbPlayClicked()
-{	
-	setParameters();
-
-	glSimulationPlayerViewer-&gt;startAnimation();
-
-}
-
-
-void QtSimulationPlayer::pbPauseClicked()
-{	
-	glSimulationPlayerViewer-&gt;stopAnimation();
-}
-
-
-void QtSimulationPlayer::pbStepClicked()
-{
-	glSimulationPlayerViewer-&gt;stopAnimation();
-	glSimulationPlayerViewer-&gt;doOneStep();
-}
-
-
-void QtSimulationPlayer::pbResetClicked()
-{
-	setParameters();
-	glSimulationPlayerViewer-&gt;reset();
-}
-
-
-void QtSimulationPlayer::cbSaveSnapShotsToggled(bool b)
-{
-	glSimulationPlayerViewer-&gt;setSaveSnapShots(b);
-}
-
-
-void QtSimulationPlayer::closeEvent(QCloseEvent *e)
-{
-	QtGeneratedSimulationPlayer::closeEvent(e);
-	
-}
-
-
-void QtSimulationPlayer::setParameters()
-{
-	glSimulationPlayerViewer-&gt;setInputPaddle(sbInputPaddle-&gt;value());
-	glSimulationPlayerViewer-&gt;setInputBaseName(leInputBaseName-&gt;text());
-	glSimulationPlayerViewer-&gt;setInputDirectory(leInputDirectory-&gt;text());
-	
-	glSimulationPlayerViewer-&gt;setOutputBaseName(leOutputBaseName-&gt;text());
-	glSimulationPlayerViewer-&gt;setOutputDirectory(leOutputDirectory-&gt;text());
-}
-
-

Deleted: trunk/gui/qt3/QtSimulationPlayer.hpp
===================================================================
--- trunk/gui/qt3/QtSimulationPlayer.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtSimulationPlayer.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,46 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTSIMULATIONPLAYER_HPP
-#define QTSIMULATIONPLAYER_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/lib-factory/Factorable.hpp&gt;
-#include &lt;QtGeneratedSimulationPlayer.h&gt;
-
-class QtSimulationPlayer : public QtGeneratedSimulationPlayer, public Factorable
-{
-	public : QtSimulationPlayer();
-	public : ~QtSimulationPlayer();
-
-	private : void setParameters();
-
-	public slots : virtual void pbInputDirectoryClicked();
-	public slots : virtual void pbLoadClicked();
-	public slots : virtual void pbInputConfigFileClicked();
-
-	public slots : virtual void pbOutputDirectoryClicked();
-	public slots : virtual void cbSaveSnapShotsToggled(bool b);
-
-	public slots : virtual void pbPlayClicked();
-	public slots : virtual void pbPauseClicked();
-	public slots : virtual void pbStepClicked();
-	public slots : virtual void pbResetClicked();
-	
- 	protected    : void closeEvent(QCloseEvent *);
-
-	REGISTER_CLASS_NAME(QtSimulationPlayer);
-	REGISTER_BASE_CLASS_NAME(Factorable);
-
-};
-
-
-REGISTER_FACTORABLE(QtSimulationPlayer);
-
-#endif // QTSIMULATIONPLAYER_HPP
-

Deleted: trunk/gui/qt3/QtSphericalDEM.cpp
===================================================================
--- trunk/gui/qt3/QtSphericalDEM.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtSphericalDEM.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,110 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;QtSphericalDEM.hpp&quot;
-#include &quot;FileDialog.hpp&quot;
-#include &lt;sstream&gt;
-#include &lt;qlabel.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;qgroupbox.h&gt;
-#include &lt;qcombobox.h&gt;
-#include &lt;qlineedit.h&gt;
-#include &lt;qspinbox.h&gt;
-#include&lt;yade/lib-factory/ClassFactory.hpp&gt;
-#include&lt;yade/core/FileGenerator.hpp&gt;
-#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;
-
-QtSphericalDEM::QtSphericalDEM ( QWidget * parent , const char * name) : QtGeneratedSphericalDEMSimulator(parent,name)
-{
-	shared_ptr&lt;Factorable&gt; f = ClassFactory::instance().createShared(&quot;SphericalDEMSimulator&quot;);
-	simulator = static_pointer_cast&lt;StandAloneSimulator&gt;(f);
-}
-
-
-QtSphericalDEM::~QtSphericalDEM()
-{
-
-}
-
-
-void QtSphericalDEM::pbPathClicked()
-{
-	string selectedFilter;
-	std::vector&lt;string&gt; filters;
-	filters.push_back(&quot;XML Yade File (*.xml)&quot;);
-	string fileName = FileDialog::getOpenFileName(&quot;.&quot;, filters, &quot;Choose a file to open&quot;, parentWidget()-&gt;parentWidget(), selectedFilter );
-		
-	if (fileName.size()!=0 &amp;&amp; selectedFilter == &quot;XML Yade File (*.xml)&quot; )
-		leConfigurationFile-&gt;setText(fileName.c_str());
-
-}
-
-
-void QtSphericalDEM::pbLoadClicked()
-{
-	simulator-&gt;loadConfigurationFile(leConfigurationFile-&gt;text().data());
-}
-
-
-///FIXME : use thread here !
-void QtSphericalDEM::pbStartClicked()
-{
-	maxIteration = sbNbIterations-&gt;value();
-	currentIteration = 0;
-	stop = false;
-	boost::posix_time::ptime start = boost::posix_time::second_clock::local_time();
-/*	while (currentIteration!=maxIteration &amp;&amp; !stop)
-	{
-		currentIteration++;
-		tlIteration-&gt;setText(lexical_cast&lt;string&gt;(currentIteration).c_str());
-		simulator-&gt;doOneIteration();
-		tlDurationValue-&gt;setText(lexical_cast&lt;string&gt;(chron.getTime()).c_str());
-		repaint();
-	}*/
-
-	simulator-&gt;setRecording(record);
-	simulator-&gt;setRecordingProperties(sbInterval-&gt;value(),leOutputDirectory-&gt;text(),leOutputBaseName-&gt;text(),sbPaddle-&gt;value());
-	simulator-&gt;run(maxIteration);
-	tlDurationValue-&gt;setText(boost::posix_time::to_simple_string(boost::posix_time::time_duration(boost::posix_time::second_clock::local_time() - start)));
-	tlIteration-&gt;setText(lexical_cast&lt;string&gt;(maxIteration).c_str());
-}
-
-
-void QtSphericalDEM::pbOutputDirectoryClicked()
-{
-	string directory = FileDialog::getExistingDirectory ( &quot;.&quot;,&quot;Choose the directory where to save the data&quot;, this-&gt;parentWidget()-&gt;parentWidget());
-	if (!directory.empty())
-		leOutputDirectory-&gt;setText(directory.c_str());
-}
-
-
-void QtSphericalDEM::pbStopClicked()
-{
-	stop = true;
-}
-
-
-void QtSphericalDEM::bgTimeStepClicked(int i)
-{
-	if (i==0)
-	{
-		Real dt = lexical_cast&lt;Real&gt;(leTimeStep-&gt;text().data());
-		simulator-&gt;setTimeStep(dt);
-	}
-	else
-		simulator-&gt;setTimeStep(-1);
-}
-
-
-
-void QtSphericalDEM::closeEvent(QCloseEvent *evt)
-{
-	close();
-	QtGeneratedSphericalDEMSimulator::closeEvent(evt);
-}
-

Deleted: trunk/gui/qt3/QtSphericalDEM.hpp
===================================================================
--- trunk/gui/qt3/QtSphericalDEM.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/gui/qt3/QtSphericalDEM.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -1,55 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#ifndef QTSPHERICALDEM_HPP
-#define QTSPHERICALDEM_HPP
-
-#include&lt;yade/core/Omega.hpp&gt;
-#include&lt;yade/lib-factory/Factorable.hpp&gt;
-#include&lt;yade/core/StandAloneSimulator.hpp&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qframe.h&gt;
-#include &lt;qscrollview.h&gt;
-#include &lt;QtGeneratedSphericalDEMSimulator.h&gt;
-
-using namespace boost;
-
-class QtSphericalDEM : public QtGeneratedSphericalDEMSimulator, public Factorable
-{
-	private :
-		shared_ptr&lt;StandAloneSimulator&gt; simulator;
-		int	currentIteration;
-		int	maxIteration;
-		bool	stop;
-		bool	record;
-
-	public :
-		QtSphericalDEM (QWidget * parent = 0, const char * name = 0 );
-		virtual ~QtSphericalDEM ();
-
-	public slots :
-		virtual void pbPathClicked();
-		virtual void pbLoadClicked();
-		virtual void pbStartClicked();
-		virtual void pbStopClicked();
-		virtual void bgTimeStepClicked(int i);
-		virtual void pbOutputDirectoryClicked();
-		virtual void cbRecordToggled(bool b) { record = b;};
-
-	protected :
-		void closeEvent(QCloseEvent *evt);
-
-	REGISTER_CLASS_NAME(QtSphericalDEM);
-	REGISTER_BASE_CLASS_NAME(Factorable);
-};
-
-REGISTER_FACTORABLE(QtSphericalDEM);
-
-#endif // QTSPHERICALDEM_HPP
-

Added: trunk/lib/QGLViewer/ImageInterface.Qt3.cpp
===================================================================
--- trunk/lib/QGLViewer/ImageInterface.Qt3.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/ImageInterface.Qt3.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,223 @@
+/****************************************************************************
+** Form implementation generated from reading ui file 'ImageInterface.Qt3.ui'
+**
+** Created: &#268;t b&#345;e 13 19:58:45 2008
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+
+#include &quot;ImageInterface.Qt3.h&quot;
+
+#include &lt;qvariant.h&gt;
+#include &lt;qpushbutton.h&gt;
+#include &lt;qlabel.h&gt;
+#include &lt;qspinbox.h&gt;
+#include &lt;qcheckbox.h&gt;
+#include &lt;qlayout.h&gt;
+#include &lt;qtooltip.h&gt;
+#include &lt;qwhatsthis.h&gt;
+#include &lt;qimage.h&gt;
+#include &lt;qpixmap.h&gt;
+
+static const unsigned char image0_data[] = { 
+    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
+    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x10,
+    0x08, 0x06, 0x00, 0x00, 0x00, 0xc9, 0x56, 0x25, 0x04, 0x00, 0x00, 0x03,
+    0x4b, 0x49, 0x44, 0x41, 0x54, 0x28, 0x91, 0x75, 0x93, 0x6b, 0x6c, 0x93,
+    0x65, 0x14, 0xc7, 0xcf, 0x79, 0xde, 0xb7, 0x7d, 0x7b, 0xa1, 0xdd, 0xda,
+    0x8e, 0x6e, 0xa1, 0x73, 0xb2, 0xb5, 0x74, 0xab, 0xb3, 0x8e, 0x0e, 0xe5,
+    0x92, 0x39, 0x36, 0x2b, 0x53, 0x42, 0x82, 0x9a, 0xe8, 0xb8, 0x24, 0x26,
+    0x26, 0xc6, 0x68, 0x62, 0x96, 0x20, 0x1a, 0x09, 0x09, 0x24, 0xc6, 0x2f,
+    0xc6, 0x20, 0x8c, 0x20, 0x97, 0x2f, 0x2c, 0x46, 0x82, 0xf3, 0x83, 0xc4,
+    0x49, 0x60, 0x8a, 0x80, 0x53, 0x33, 0xa6, 0x33, 0x20, 0x6c, 0x73, 0x63,
+    0xdd, 0x6a, 0xda, 0xcd, 0xca, 0x6a, 0xa1, 0x17, 0xd6, 0xee, 0x5d, 0xdf,
+    0xbe, 0xb7, 0xe7, 0xf1, 0x0b, 0x8b, 0x8a, 0x7a, 0x92, 0xff, 0xb7, 0xdf,
+    0xc9, 0x3f, 0x39, 0xf9, 0x1d, 0x64, 0x8c, 0xc1, 0xff, 0x4d, 0x3e, 0x9b,
+    0xf5, 0x5c, 0x3e, 0xde, 0xf3, 0x5e, 0x5d, 0x20, 0x70, 0x33, 0xf4, 0xc2,
+    0xd6, 0x83, 0x88, 0x48, 0x19, 0xa5, 0x9c, 0x78, 0xb9, 0xef, 0x65, 0xce,
+    0xb5, 0x3c, 0x0b, 0x8c, 0xb1, 0x7f, 0x44, 0x51, 0x54, 0xe1, 0xb7, 0x58,
+    0x72, 0xbd, 0x54, 0x94, 0xca, 0xce, 0x1c, 0x39, 0xd6, 0xbd, 0xd7, 0xbf,
+    0x56, 0xfe, 0xf4, 0xc5, 0xae, 0x11, 0x65, 0xb1, 0xe8, 0x64, 0x8c, 0x81,
+    0x38, 0x78, 0x61, 0xfb, 0x6c, 0xfb, 0x8a, 0x4c, 0xee, 0xfd, 0xdd, 0x9f,
+    0x10, 0x00, 0x00, 0xc6, 0x18, 0x47, 0x29, 0x33, 0x00, 0x00, 0x44, 0x46,
+    0xe3, 0x4f, 0x9e, 0x3d, 0xf5, 0xc3, 0x9e, 0x3b, 0xc9, 0xd4, 0xa3, 0x4d,
+    0x6d, 0x1b, 0xbf, 0xd9, 0xf0, 0x54, 0xc7, 0x15, 0x52, 0x28, 0x2d, 0xd7,
+    0x65, 0xd5, 0x06, 0x00, 0x40, 0xe7, 0x66, 0x7c, 0x86, 0x74, 0xd2, 0x45,
+    0x66, 0xa7, 0x1a, 0x08, 0x00, 0x83, 0x89, 0x9b, 0xb7, 0x3a, 0xf2, 0x79,
+    0xd1, 0x03, 0x00, 0x5c, 0x74, 0xec, 0xce, 0x0e, 0xb3, 0xd9, 0xa1, 0x5a,
+    0x6d, 0x96, 0xa2, 0xaf, 0x29, 0x78, 0xd1, 0xe5, 0xae, 0x4a, 0x5b, 0xcc,
+    0x56, 0x89, 0x18, 0xf8, 0x12, 0x00, 0x80, 0x50, 0xe9, 0x49, 0x99, 0x8d,
+    0x02, 0x70, 0x72, 0xd1, 0x44, 0xc6, 0xa3, 0x5a, 0xf8, 0xeb, 0x6f, 0xa7,
+    0x3b, 0x79, 0x1e, 0xf3, 0xaa, 0xa2, 0x3d, 0x30, 0x17, 0xd7, 0x42, 0xde,
+    0x80, 0xe7, 0x57, 0xbb, 0xa3, 0x6c, 0x86, 0x69, 0xba, 0x41, 0xc9, 0x14,
+    0xaa, 0x6d, 0x55, 0x95, 0x49, 0xde, 0x24, 0x14, 0x00, 0x00, 0x88, 0xae,
+    0x13, 0x03, 0x22, 0xf0, 0x82, 0x45, 0x21, 0xa9, 0x1c, 0xae, 0x0c, 0xb7,
+    0xfa, 0x86, 0xac, 0x56, 0x73, 0x3e, 0x11, 0x2b, 0x34, 0xe7, 0xd2, 0xcc,
+    0xba, 0x2a, 0x58, 0x31, 0xc6, 0xf3, 0xc6, 0x8c, 0x3c, 0x5f, 0x58, 0xb1,
+    0x98, 0x48, 0x7b, 0x5d, 0xfe, 0xba, 0x71, 0xe4, 0x39, 0x09, 0x00, 0x00,
+    0xb2, 0xa9, 0x4a, 0x9e, 0x52, 0xe0, 0xdc, 0x9e, 0x39, 0xbe, 0x63, 0x1d,
+    0x77, 0xaa, 0x58, 0x74, 0x3f, 0x44, 0x29, 0x9a, 0x2f, 0xf5, 0xfd, 0xbe,
+    0xbd, 0x66, 0x95, 0xf3, 0xba, 0xcb, 0x6d, 0x8a, 0x23, 0xa2, 0x76, 0x77,
+    0x72, 0xb6, 0x45, 0x99, 0x2f, 0x3a, 0x2b, 0x56, 0x07, 0x06, 0xf1, 0xde,
+    0x6d, 0x60, 0x66, 0xaa, 0x91, 0x20, 0x01, 0xe2, 0x6d, 0x9c, 0xe0, 0x19,
+    0x00, 0x1d, 0x1e, 0x8e, 0xb4, 0x45, 0xc7, 0xd4, 0xae, 0xd1, 0x6b, 0x0b,
+    0xad, 0xbb, 0xdf, 0x6d, 0xda, 0x05, 0x08, 0x22, 0xd5, 0x75, 0x63, 0x62,
+    0xe0, 0x6a, 0xa7, 0xb9, 0xaa, 0x22, 0xe9, 0x08, 0xac, 0x1c, 0x06, 0x00,
+    0x00, 0x31, 0xef, 0x86, 0xc8, 0xc8, 0x6a, 0xb4, 0x97, 0x97, 0xb0, 0xb1,
+    0xf9, 0x27, 0x82, 0x88, 0x6c, 0x3a, 0x92, 0xaa, 0xed, 0x39, 0xf1, 0xe3,
+    0xab, 0xa1, 0xc7, 0xcb, 0x07, 0xaa, 0x6b, 0xcd, 0x23, 0x94, 0x31, 0x39,
+    0x3b, 0x39, 0xd3, 0x96, 0x18, 0xfa, 0x25, 0x5c, 0xdd, 0xbe, 0xe6, 0xbc,
+    0x50, 0x6e, 0x9b, 0x03, 0x00, 0x60, 0xd3, 0x63, 0xeb, 0x58, 0x2c, 0x52,
+    0x07, 0xb5, 0x0d, 0x71, 0xf4, 0x3d, 0x7c, 0x9d, 0x07, 0x00, 0x68, 0xdd,
+    0x18, 0xec, 0x07, 0x6d, 0x99, 0xbd, 0xf1, 0x11, 0x3a, 0x29, 0xcb, 0x25,
+    0x8b, 0xba, 0x20, 0x55, 0x8c, 0x9e, 0x3c, 0xb7, 0x1f, 0x4d, 0x82, 0x54,
+    0xb3, 0x79, 0xc3, 0x69, 0x44, 0xa4, 0x4c, 0xd7, 0x8c, 0xfa, 0xa5, 0xbe,
+    0x9d, 0x74, 0x51, 0x34, 0x72, 0xeb, 0x37, 0x0d, 0x80, 0xdd, 0x91, 0xc4,
+    0x25, 0xc3, 0x18, 0xa3, 0x7c, 0xef, 0xd1, 0x8f, 0x0f, 0x98, 0x90, 0xb3,
+    0x48, 0xe3, 0x89, 0xb5, 0xe2, 0x8d, 0x58, 0x53, 0x4b, 0x57, 0xe7, 0x07,
+    0xc1, 0x97, 0xb6, 0xec, 0x43, 0x44, 0x5d, 0x9f, 0xf8, 0xf9, 0x69, 0xf9,
+    0x8d, 0x6d, 0x9f, 0x21, 0x41, 0x26, 0x1c, 0x3b, 0xbb, 0x95, 0xf8, 0x83,
+    0x57, 0xc8, 0x92, 0x8a, 0x88, 0x44, 0xb3, 0xd9, 0x6c, 0xb9, 0xfe, 0xee,
+    0xde, 0xd7, 0x62, 0x43, 0xe3, 0xa1, 0x9a, 0xf0, 0x9a, 0x8b, 0xf5, 0xcf,
+    0xb7, 0x1f, 0x46, 0x44, 0x9d, 0x2e, 0xe4, 0xdd, 0xc5, 0x8f, 0xba, 0xf7,
+    0xaa, 0xe9, 0xdb, 0x76, 0x12, 0x7e, 0xee, 0x2b, 0xac, 0x0b, 0x5c, 0xbd,
+    0xd7, 0xf8, 0x97, 0x9a, 0xd9, 0xdb, 0x19, 0x6f, 0xcf, 0x5b, 0x07, 0xce,
+    0x1f, 0xdd, 0xb1, 0x6b, 0x22, 0x9f, 0xca, 0xd4, 0x33, 0xc6, 0x40, 0x17,
+    0x17, 0x9c, 0xd9, 0x43, 0xfb, 0x4f, 0xfe, 0x11, 0x72, 0xe8, 0x77, 0x9f,
+    0x0d, 0xdd, 0xd2, 0xe2, 0x53, 0x8f, 0x2d, 0xf1, 0x78, 0xff, 0x63, 0xc8,
+    0x92, 0xe4, 0xec, 0xdd, 0xf3, 0x66, 0xaf, 0xf7, 0xc1, 0xea, 0xa8, 0xaf,
+    0xbe, 0x21, 0x5a, 0xfa, 0xae, 0xff, 0x19, 0xfd, 0xfb, 0xfe, 0x4d, 0x16,
+    0x93, 0xa0, 0xb8, 0xf6, 0x1d, 0x7a, 0xdb, 0xb4, 0x65, 0xdb, 0x71, 0x44,
+    0x64, 0xff, 0x6a, 0x5e, 0xca, 0xe8, 0xb9, 0x2f, 0x5e, 0x39, 0xd2, 0xe0,
+    0x91, 0x3f, 0xf7, 0xbb, 0xd8, 0xa0, 0xbf, 0x8c, 0x4d, 0xb6, 0xd4, 0x8a,
+    0xf3, 0xa7, 0x4f, 0xbc, 0x43, 0x55, 0x45, 0xf8, 0x3b, 0xf7, 0x9f, 0xcb,
+    0x6a, 0x49, 0x5a, 0x76, 0xed, 0xc3, 0x83, 0x87, 0xbf, 0x7c, 0xa2, 0x39,
+    0x7d, 0x63, 0xe7, 0xe6, 0x48, 0xee, 0x42, 0xdf, 0xeb, 0x54, 0x55, 0x85,
+    0xfb, 0xb9, 0x3f, 0x01, 0xb2, 0x2d, 0xcb, 0x16, 0xd1, 0x81, 0x19, 0x0d,
+    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
+};
+
+
+/*
+ *  Constructs a ImageInterface as a child of 'parent', with the
+ *  name 'name' and widget flags set to 'f'.
+ *
+ *  The dialog will by default be modeless, unless you set 'modal' to
+ *  TRUE to construct a modal dialog.
+ */
+ImageInterface::ImageInterface( QWidget* parent, const char* name, bool modal, WFlags fl )
+    : QDialog( parent, name, modal, fl )
+{
+    QImage img;
+    img.loadFromData( image0_data, sizeof( image0_data ), &quot;PNG&quot; );
+    image0 = img;
+    if ( !name )
+	setName( &quot;ImageInterface&quot; );
+    setIcon( image0 );
+    ImageInterfaceLayout = new QVBoxLayout( this, 11, 6, &quot;ImageInterfaceLayout&quot;); 
+
+    layout5 = new QHBoxLayout( 0, 0, 6, &quot;layout5&quot;); 
+
+    textLabel1 = new QLabel( this, &quot;textLabel1&quot; );
+    layout5-&gt;addWidget( textLabel1 );
+
+    imgWidth = new QSpinBox( this, &quot;imgWidth&quot; );
+    imgWidth-&gt;setMaxValue( 32000 );
+    imgWidth-&gt;setMinValue( 1 );
+    layout5-&gt;addWidget( imgWidth );
+
+    textLabel2 = new QLabel( this, &quot;textLabel2&quot; );
+    layout5-&gt;addWidget( textLabel2 );
+
+    imgHeight = new QSpinBox( this, &quot;imgHeight&quot; );
+    imgHeight-&gt;setMaxValue( 32000 );
+    imgHeight-&gt;setMinValue( 1 );
+    layout5-&gt;addWidget( imgHeight );
+    ImageInterfaceLayout-&gt;addLayout( layout5 );
+
+    layout2 = new QHBoxLayout( 0, 0, 6, &quot;layout2&quot;); 
+
+    textLabel3 = new QLabel( this, &quot;textLabel3&quot; );
+    layout2-&gt;addWidget( textLabel3 );
+
+    imgQuality = new QSpinBox( this, &quot;imgQuality&quot; );
+    imgQuality-&gt;setMaxValue( 100 );
+    layout2-&gt;addWidget( imgQuality );
+    spacer1 = new QSpacerItem( 271, 31, QSizePolicy::Expanding, QSizePolicy::Minimum );
+    layout2-&gt;addItem( spacer1 );
+    ImageInterfaceLayout-&gt;addLayout( layout2 );
+
+    layout2_2 = new QHBoxLayout( 0, 0, 6, &quot;layout2_2&quot;); 
+
+    textLabel3_2 = new QLabel( this, &quot;textLabel3_2&quot; );
+    layout2_2-&gt;addWidget( textLabel3_2 );
+
+    oversampling = new QSpinBox( this, &quot;oversampling&quot; );
+    oversampling-&gt;setMaxValue( 64 );
+    oversampling-&gt;setMinValue( 1 );
+    layout2_2-&gt;addWidget( oversampling );
+    spacer1_2 = new QSpacerItem( 271, 31, QSizePolicy::Expanding, QSizePolicy::Minimum );
+    layout2_2-&gt;addItem( spacer1_2 );
+    ImageInterfaceLayout-&gt;addLayout( layout2_2 );
+
+    whiteBackground = new QCheckBox( this, &quot;whiteBackground&quot; );
+    ImageInterfaceLayout-&gt;addWidget( whiteBackground );
+
+    expandFrustum = new QCheckBox( this, &quot;expandFrustum&quot; );
+    ImageInterfaceLayout-&gt;addWidget( expandFrustum );
+
+    layout4 = new QHBoxLayout( 0, 0, 6, &quot;layout4&quot;); 
+    spacer3 = new QSpacerItem( 251, 21, QSizePolicy::Expanding, QSizePolicy::Minimum );
+    layout4-&gt;addItem( spacer3 );
+
+    pushButton1 = new QPushButton( this, &quot;pushButton1&quot; );
+    layout4-&gt;addWidget( pushButton1 );
+
+    pushButton2 = new QPushButton( this, &quot;pushButton2&quot; );
+    layout4-&gt;addWidget( pushButton2 );
+    ImageInterfaceLayout-&gt;addLayout( layout4 );
+    languageChange();
+    resize( QSize(288, 213).expandedTo(minimumSizeHint()) );
+    clearWState( WState_Polished );
+
+    // signals and slots connections
+    connect( pushButton1, SIGNAL( clicked() ), this, SLOT( accept() ) );
+    connect( pushButton2, SIGNAL( clicked() ), this, SLOT( reject() ) );
+}
+
+/*
+ *  Destroys the object and frees any allocated resources
+ */
+ImageInterface::~ImageInterface()
+{
+    // no need to delete child widgets, Qt does it all for us
+}
+
+/*
+ *  Sets the strings of the subwidgets using the current
+ *  language.
+ */
+void ImageInterface::languageChange()
+{
+    setCaption( tr( &quot;Image settings&quot; ) );
+    textLabel1-&gt;setText( tr( &quot;Width&quot; ) );
+    imgWidth-&gt;setSuffix( tr( &quot; px&quot; ) );
+    QToolTip::add( imgWidth, tr( &quot;Width of the image (in pixels)&quot; ) );
+    textLabel2-&gt;setText( tr( &quot;Height&quot; ) );
+    imgHeight-&gt;setPrefix( QString::null );
+    imgHeight-&gt;setSuffix( tr( &quot; px&quot; ) );
+    QToolTip::add( imgHeight, tr( &quot;Height of the image (in pixels)&quot; ) );
+    textLabel3-&gt;setText( tr( &quot;Image quality&quot; ) );
+    QToolTip::add( imgQuality, tr( &quot;Between 0 (smallest files) and 100 (highest quality)&quot; ) );
+    textLabel3_2-&gt;setText( tr( &quot;Oversampling&quot; ) );
+    QToolTip::add( textLabel3_2, QString::null );
+    oversampling-&gt;setPrefix( tr( &quot;x &quot; ) );
+    QToolTip::add( oversampling, tr( &quot;Antialiases image (when larger then 1.0)&quot; ) );
+    whiteBackground-&gt;setText( tr( &quot;Use white background&quot; ) );
+    QToolTip::add( whiteBackground, tr( &quot;Use white as background color&quot; ) );
+    expandFrustum-&gt;setText( tr( &quot;Expand frustum if needed&quot; ) );
+    QToolTip::add( expandFrustum, tr( &quot;When image aspect ratio differs from viewer's one, expand frustum as needed. Fits inside current frustum otherwise.&quot; ) );
+    pushButton1-&gt;setText( tr( &quot;OK&quot; ) );
+    pushButton2-&gt;setText( tr( &quot;Cancel&quot; ) );
+}
+

Added: trunk/lib/QGLViewer/ImageInterface.Qt3.ui
===================================================================
--- trunk/lib/QGLViewer/ImageInterface.Qt3.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/ImageInterface.Qt3.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,276 @@
+&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.0&quot; stdsetdef=&quot;1&quot;&gt;
+&lt;class&gt;ImageInterface&lt;/class&gt;
+&lt;widget class=&quot;QDialog&quot;&gt;
+    &lt;property name=&quot;name&quot;&gt;
+        &lt;cstring&gt;ImageInterface&lt;/cstring&gt;
+    &lt;/property&gt;
+    &lt;property name=&quot;geometry&quot;&gt;
+        &lt;rect&gt;
+            &lt;x&gt;0&lt;/x&gt;
+            &lt;y&gt;0&lt;/y&gt;
+            &lt;width&gt;288&lt;/width&gt;
+            &lt;height&gt;213&lt;/height&gt;
+        &lt;/rect&gt;
+    &lt;/property&gt;
+    &lt;property name=&quot;caption&quot;&gt;
+        &lt;string&gt;Image settings&lt;/string&gt;
+    &lt;/property&gt;
+    &lt;property name=&quot;icon&quot;&gt;
+        &lt;pixmap&gt;image0&lt;/pixmap&gt;
+    &lt;/property&gt;
+    &lt;vbox&gt;
+        &lt;property name=&quot;name&quot;&gt;
+            &lt;cstring&gt;unnamed&lt;/cstring&gt;
+        &lt;/property&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;layout5&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;widget class=&quot;QLabel&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;textLabel1&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Width&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QSpinBox&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;imgWidth&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;suffix&quot;&gt;
+                        &lt;string&gt; px&lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;maxValue&quot;&gt;
+                        &lt;number&gt;32000&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;minValue&quot;&gt;
+                        &lt;number&gt;1&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Width of the image (in pixels)&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QLabel&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;textLabel2&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Height&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QSpinBox&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;imgHeight&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;prefix&quot;&gt;
+                        &lt;string&gt;&lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;suffix&quot;&gt;
+                        &lt;string&gt; px&lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;maxValue&quot;&gt;
+                        &lt;number&gt;32000&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;minValue&quot;&gt;
+                        &lt;number&gt;1&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Height of the image (in pixels)&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;layout2&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;widget class=&quot;QLabel&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;textLabel3&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Image quality&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QSpinBox&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;imgQuality&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;maxValue&quot;&gt;
+                        &lt;number&gt;100&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Between 0 (smallest files) and 100 (highest quality)&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;spacer&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;spacer1&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;orientation&quot;&gt;
+                        &lt;enum&gt;Horizontal&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeType&quot;&gt;
+                        &lt;enum&gt;Expanding&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeHint&quot;&gt;
+                        &lt;size&gt;
+                            &lt;width&gt;271&lt;/width&gt;
+                            &lt;height&gt;31&lt;/height&gt;
+                        &lt;/size&gt;
+                    &lt;/property&gt;
+                &lt;/spacer&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;layout2_2&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;widget class=&quot;QLabel&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;textLabel3_2&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Oversampling&lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QSpinBox&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;oversampling&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;prefix&quot;&gt;
+                        &lt;string&gt;x &lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;maxValue&quot;&gt;
+                        &lt;number&gt;64&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;minValue&quot;&gt;
+                        &lt;number&gt;1&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Antialiases image (when larger then 1.0)&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;spacer&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;spacer1_2&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;orientation&quot;&gt;
+                        &lt;enum&gt;Horizontal&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeType&quot;&gt;
+                        &lt;enum&gt;Expanding&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeHint&quot;&gt;
+                        &lt;size&gt;
+                            &lt;width&gt;271&lt;/width&gt;
+                            &lt;height&gt;31&lt;/height&gt;
+                        &lt;/size&gt;
+                    &lt;/property&gt;
+                &lt;/spacer&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;whiteBackground&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Use white background&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Use white as background color&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;expandFrustum&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Expand frustum if needed&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;When image aspect ratio differs from viewer's one, expand frustum as needed. Fits inside current frustum otherwise.&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;layout4&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;spacer&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;spacer3&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;orientation&quot;&gt;
+                        &lt;enum&gt;Horizontal&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeType&quot;&gt;
+                        &lt;enum&gt;Expanding&lt;/enum&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;sizeHint&quot;&gt;
+                        &lt;size&gt;
+                            &lt;width&gt;251&lt;/width&gt;
+                            &lt;height&gt;21&lt;/height&gt;
+                        &lt;/size&gt;
+                    &lt;/property&gt;
+                &lt;/spacer&gt;
+                &lt;widget class=&quot;QPushButton&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;pushButton1&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;OK&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QPushButton&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;pushButton2&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Cancel&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+    &lt;/vbox&gt;
+&lt;/widget&gt;
+&lt;images&gt;
+    &lt;image name=&quot;image0&quot;&gt;
+        &lt;data format=&quot;PNG&quot; length=&quot;900&quot;&gt;89504e470d0a1a0a0000000d494844520000000f000000100806000000c95625040000034b49444154289175936b6c936514c7cf79deb77d7ba1ddda8e6ea173b2b574abb38e0ee59239362b5342829ae8b8242626c6686296201a090924c62fc6208c20972f2c4682f383c449608a805333a633206c7363dd6adacdca6aa117d6ee5ddfbeb7e7f10b8b8a7a92ffb7dfc93f39f91d648cc1ff4d3e9bf55c3edef35e5d207033f4c2d683884819a59c78b9ef65ceb53c0b8cb17f445154e1b75872bd5494cace1c39d6bdd7bf56fef4c5ae1165b1e8648c81387861fb6cfb8a4ceefddd9f100000c61847293300004446e34f9e3df5c39e3bc9d4a34d6d1bbfd9f054c71552282dd765d5060040e7667c8674d24566a71a080083899bb73af279d103005c74ecce0eb3d9a15a6d96a2af2978d1e5ae4a5bcc568918f812008050e949998d027072d144c6a35af8eb6fa73b791ef3aaa23d3017d742de80e757bba36c8669ba41c914aa6d559549de2414000088ae130322f0824521a91cae0cb7fa86ac56733e112b34e7d2ccba2a5831c6f3c68c3c5f58b198487b5dfeba71e439090000b2a94a9e52e0dc9e39be631d77aa58743f44299a2ff5fdbebd6695f3bacb6d8a23a2767772b645992f3a2b560706f1de6d6066aa9120!
 01e26d9ce019001d1e8eb445c7d4aed16b0badbbdf6dda050822d5756362e06aa7b9aa22e908ac1c06000031ef86c8c86ab49797b0b1f92782886c3a92aaed39f1e3aba1c7cb07aa6bcd239431393b39d39618fa255cddbee6bc506e9b030060d363eb582c5207b50d71f43d7c9d070068dd18ec076d99bdf1113a29cb258bba20558c9e3cb71f4d8254b379c36944a44cd78cfaa5be9d74513472eb370d80dd91c425c318a37cefd18f0f9890b348e389b5e28d58534b57e707c197b6ec43445d9ff8f969f98d6d9f2141261c3bbb95f88357c8928a8844b3d96cb9feeeded76243e3a19af09a8bf5cfb71f46449d2ee4ddc58fbaf7aae9db76127eee2bac0b5cbdd7f8979ad9db196fcf5b07ce1fddb16b229fcad433c64017179cd943fb4ffe1172e8779f0dddd2e2538f2df178ff63c892e4ecddf366aff7c1eaa8afbe215afaaeff19fdfbfe4d1693a0b8f61d7adbb465db714464ff6a5ecae8b92f5e39d2e0913ff7bbd8a0bf8c4db6d48af3a74fbc435545f83bf79fcb6a495a76edc38387bf7ca2397d63e7e648ee42dfeb545585fbb93f01b22dcb16d181190d0000000049454e44ae426082&lt;/data&gt;
+    &lt;/image&gt;
+&lt;/images&gt;
+&lt;connections&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;pushButton1&lt;/sender&gt;
+        &lt;signal&gt;clicked()&lt;/signal&gt;
+        &lt;receiver&gt;ImageInterface&lt;/receiver&gt;
+        &lt;slot&gt;accept()&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;pushButton2&lt;/sender&gt;
+        &lt;signal&gt;clicked()&lt;/signal&gt;
+        &lt;receiver&gt;ImageInterface&lt;/receiver&gt;
+        &lt;slot&gt;reject()&lt;/slot&gt;
+    &lt;/connection&gt;
+&lt;/connections&gt;
+&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
+&lt;/UI&gt;

Added: trunk/lib/QGLViewer/ImageInterface.Qt4.ui
===================================================================
--- trunk/lib/QGLViewer/ImageInterface.Qt4.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/ImageInterface.Qt4.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,303 @@
+&lt;ui version=&quot;4.0&quot; &gt;
+ &lt;author&gt;&lt;/author&gt;
+ &lt;comment&gt;&lt;/comment&gt;
+ &lt;exportmacro&gt;&lt;/exportmacro&gt;
+ &lt;class&gt;ImageInterface&lt;/class&gt;
+ &lt;widget class=&quot;QDialog&quot; name=&quot;ImageInterface&quot; &gt;
+  &lt;property name=&quot;geometry&quot; &gt;
+   &lt;rect&gt;
+    &lt;x&gt;0&lt;/x&gt;
+    &lt;y&gt;0&lt;/y&gt;
+    &lt;width&gt;238&lt;/width&gt;
+    &lt;height&gt;195&lt;/height&gt;
+   &lt;/rect&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;windowTitle&quot; &gt;
+   &lt;string&gt;Image settings&lt;/string&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;windowIcon&quot; &gt;
+   &lt;iconset&gt;../../../../../../Documents and Settings/debunne/Bureau/libQGLViewer-2.2.0-1/doc/images/qglviewer.icon.png&lt;/iconset&gt;
+  &lt;/property&gt;
+  &lt;layout class=&quot;QVBoxLayout&quot; &gt;
+   &lt;property name=&quot;margin&quot; &gt;
+    &lt;number&gt;9&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;spacing&quot; &gt;
+    &lt;number&gt;6&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QLabel&quot; name=&quot;label_2&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;&quot;&gt;&lt;span style=&quot; font-size:8pt;&quot;&gt;Width&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QSpinBox&quot; name=&quot;imgWidth&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Width of the image (in pixels)&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;suffix&quot; &gt;
+        &lt;string&gt; px&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;maximum&quot; &gt;
+        &lt;number&gt;32000&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;1&lt;/number&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;spacer&gt;
+       &lt;property name=&quot;orientation&quot; &gt;
+        &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeHint&quot; &gt;
+        &lt;size&gt;
+         &lt;width&gt;20&lt;/width&gt;
+         &lt;height&gt;22&lt;/height&gt;
+        &lt;/size&gt;
+       &lt;/property&gt;
+      &lt;/spacer&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QLabel&quot; name=&quot;label_3&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Height&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QSpinBox&quot; name=&quot;imgHeight&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Height of the image (in pixels)&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;suffix&quot; &gt;
+        &lt;string&gt; px&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;maximum&quot; &gt;
+        &lt;number&gt;32000&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;1&lt;/number&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QLabel&quot; name=&quot;label_4&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Image quality&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QSpinBox&quot; name=&quot;imgQuality&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Between 0 (smallest files) and 100 (highest quality)&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;maximum&quot; &gt;
+        &lt;number&gt;100&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;number&gt;0&lt;/number&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;spacer&gt;
+       &lt;property name=&quot;orientation&quot; &gt;
+        &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeHint&quot; &gt;
+        &lt;size&gt;
+         &lt;width&gt;40&lt;/width&gt;
+         &lt;height&gt;20&lt;/height&gt;
+        &lt;/size&gt;
+       &lt;/property&gt;
+      &lt;/spacer&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QLabel&quot; name=&quot;label&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;qrichtext&quot; content=&quot;1&quot; /&gt;&lt;/head&gt;&lt;body style=&quot; white-space: pre-wrap; font-family:MS Shell Dlg; font-size:8.25pt; font-weight:400; font-style:normal; text-decoration:none;&quot;&gt;&lt;p style=&quot; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;&quot;&gt;Oversampling&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QDoubleSpinBox&quot; name=&quot;oversampling&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Antialiases image (when larger then 1.0)&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;prefix&quot; &gt;
+        &lt;string&gt;x &lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;decimals&quot; &gt;
+        &lt;number&gt;1&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;maximum&quot; &gt;
+        &lt;double&gt;64&lt;/double&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;minimum&quot; &gt;
+        &lt;double&gt;0.1&lt;/double&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;singleStep&quot; &gt;
+        &lt;double&gt;1&lt;/double&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;value&quot; &gt;
+        &lt;double&gt;1&lt;/double&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;spacer&gt;
+       &lt;property name=&quot;orientation&quot; &gt;
+        &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeHint&quot; &gt;
+        &lt;size&gt;
+         &lt;width&gt;40&lt;/width&gt;
+         &lt;height&gt;20&lt;/height&gt;
+        &lt;/size&gt;
+       &lt;/property&gt;
+      &lt;/spacer&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;whiteBackground&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Use white as background color&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Use white background&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;expandFrustum&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;When image aspect ratio differs from viewer's one, expand frustum as needed. Fits inside current frustum otherwise.&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Expand frustum if needed&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;spacer&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Vertical&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeHint&quot; &gt;
+      &lt;size&gt;
+       &lt;width&gt;20&lt;/width&gt;
+       &lt;height&gt;16&lt;/height&gt;
+      &lt;/size&gt;
+     &lt;/property&gt;
+    &lt;/spacer&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;spacer&gt;
+       &lt;property name=&quot;orientation&quot; &gt;
+        &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeHint&quot; &gt;
+        &lt;size&gt;
+         &lt;width&gt;131&lt;/width&gt;
+         &lt;height&gt;31&lt;/height&gt;
+        &lt;/size&gt;
+       &lt;/property&gt;
+      &lt;/spacer&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;okButton&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;OK&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;cancelButton&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Cancel&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+  &lt;/layout&gt;
+ &lt;/widget&gt;
+ &lt;pixmapfunction&gt;&lt;/pixmapfunction&gt;
+ &lt;resources/&gt;
+ &lt;connections&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;okButton&lt;/sender&gt;
+   &lt;signal&gt;clicked()&lt;/signal&gt;
+   &lt;receiver&gt;ImageInterface&lt;/receiver&gt;
+   &lt;slot&gt;accept()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;135&lt;/x&gt;
+     &lt;y&gt;184&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;96&lt;/x&gt;
+     &lt;y&gt;254&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;cancelButton&lt;/sender&gt;
+   &lt;signal&gt;clicked()&lt;/signal&gt;
+   &lt;receiver&gt;ImageInterface&lt;/receiver&gt;
+   &lt;slot&gt;reject()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;226&lt;/x&gt;
+     &lt;y&gt;184&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;179&lt;/x&gt;
+     &lt;y&gt;282&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+ &lt;/connections&gt;
+&lt;/ui&gt;

Added: trunk/lib/QGLViewer/README
===================================================================
--- trunk/lib/QGLViewer/README	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/README	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,13 @@
+Contents of this directory is a copy of upstream from <A HREF="http://artis.imag.fr/Software/QGLViewer/,">http://artis.imag.fr/Software/QGLViewer/,</A> as of
+
+2007-08-28 23:40 libQGLViewer-2.2.6-3.tar.gz
+
+SConscript file is mostly cut&amp;paste from the original .pro file. EXCEPT for these 2 files:
+
+ ImageInterface.Qt3.cpp
+ VRenderInterface.Qt3.cpp
+
+which are generated by uic in the upstream directory (qmake&amp;&amp;make),
+but I have no idea how to get the using scons automatically.
+
+V&#225;clav &#352;milauer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">eudoxos at arcig.cz</A>&gt;

Added: trunk/lib/QGLViewer/VRender/AxisAlignedBox.h
===================================================================
--- trunk/lib/QGLViewer/VRender/AxisAlignedBox.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/AxisAlignedBox.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,104 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_AXISALIGNEDBOX_H
+#define _VRENDER_AXISALIGNEDBOX_H
+
+namespace vrender
+{
+  class Vector2;
+  class Vector3;
+
+	template&lt;class T&gt; class AxisAlignedBox
+	{
+		public:
+			AxisAlignedBox() ;
+			AxisAlignedBox(const T&amp; v) ;
+			AxisAlignedBox(const T&amp; v,const T&amp; w) ;
+
+			const T&amp; mini() const { return _min ; }
+			const T&amp; maxi() const { return _max ; }
+
+			void include(const T&amp; v) ;
+			void include(const AxisAlignedBox&lt;T&gt;&amp; b) ;
+		private:
+			T _min ;
+			T _max ;
+	};
+
+	typedef AxisAlignedBox&lt; Vector2 &gt; AxisAlignedBox_xy ;
+	typedef AxisAlignedBox&lt; Vector3 &gt; AxisAlignedBox_xyz ;
+
+	template&lt;class T&gt; AxisAlignedBox&lt;T&gt;::AxisAlignedBox()
+	: _min(T::inf), _max(-T::inf)
+	{
+	}
+
+	template&lt;class T&gt; AxisAlignedBox&lt;T&gt;::AxisAlignedBox(const T&amp; v)
+		: _min(v), _max(v)
+	{
+	}
+
+	template&lt;class T&gt; AxisAlignedBox&lt;T&gt;::AxisAlignedBox(const T&amp; v,const T&amp; w)
+		: _min(v), _max(v)
+	{
+		include(w) ;
+	}
+
+	template&lt;class T&gt; void AxisAlignedBox&lt;T&gt;::include(const T&amp; v)
+	{
+		_min = T::mini(_min,v) ;
+		_max = T::maxi(_max,v) ;
+	}
+
+	template&lt;class T&gt; void AxisAlignedBox&lt;T&gt;::include(const AxisAlignedBox&lt;T&gt;&amp; b)
+	{
+		include(b._min) ;
+		include(b._max) ;
+	}
+}
+#endif

Added: trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/BSPSortMethod.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,645 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;VRender.h&quot;
+#include &quot;Primitive.h&quot;
+#include &quot;SortMethod.h&quot;
+#include &quot;math.h&quot; // fabs
+
+using namespace vrender ;
+using namespace std;
+
+double EGALITY_EPS 		= 0.0001 ;
+double LINE_EGALITY_EPS = 0.0001 ;
+
+typedef enum { BSP_CROSS_PLANE, BSP_UPPER, BSP_LOWER } BSPPosition ;
+
+class BSPNode ;
+
+class BSPTree
+{
+	public:
+		BSPTree() ;
+		~BSPTree() ;
+
+		void insert(Polygone *) ;
+		void insert(Segment *) ;
+		void insert(Point *) ;
+
+		void recursFillPrimitiveArray(vector&lt;PtrPrimitive&gt;&amp;) const ;
+	private:
+		BSPNode *_root ;
+		vector&lt;Segment *&gt; _segments ;	// these are for storing segments and points when _root is null
+		vector&lt;Point *&gt; _points ;
+};
+
+void BSPSortMethod::sortPrimitives(std::vector&lt;PtrPrimitive&gt;&amp; primitive_tab,VRenderParams&amp; vparams)
+{
+	// 1 - build BSP using polygons only
+
+	BSPTree tree ;
+	Polygone *P ;
+
+	int N = primitive_tab.size()/200 +1 ;
+	int nbinserted = 0 ;
+
+	vector&lt;PtrPrimitive&gt; segments_and_points ;	// Store segments and points for pass 2, because polygons are deleted
+																// by the insertion and can not be dynamic_casted anymore.
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i,++nbinserted)
+	{
+		if((P = dynamic_cast&lt;Polygone *&gt;(primitive_tab[i])) != NULL)
+			tree.insert(P) ;
+		else
+			segments_and_points.push_back(primitive_tab[i]) ;
+
+		if(nbinserted%N==0)
+			vparams.progress(nbinserted/(float)primitive_tab.size(),string(&quot;BSP Construction&quot;)) ;
+	}
+
+	// 2 - insert points and segments into the BSP
+
+	Segment *S ;
+	Point *p ;
+
+	for(unsigned int j=0;j&lt;segments_and_points.size();++j,++nbinserted)
+	{
+		if((S = dynamic_cast&lt;Segment *&gt;(segments_and_points[j])) != NULL)
+			tree.insert(S) ;
+		else if((p = dynamic_cast&lt;Point *&gt;(segments_and_points[j])) != NULL)
+			tree.insert(p) ;
+
+		if(nbinserted%N==0)
+			vparams.progress(nbinserted/(float)primitive_tab.size(),string(&quot;BSP Construction&quot;)) ;
+	}
+
+	// 3 - refill the array with the content of the BSP
+
+	primitive_tab.resize(0) ;
+	tree.recursFillPrimitiveArray(primitive_tab) ;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+class BSPNode
+{
+	public:
+		BSPNode(Polygone *) ;
+		~BSPNode() ;
+
+		void recursFillPrimitiveArray(vector&lt;PtrPrimitive&gt;&amp;) const ;
+
+		void insert(Polygone *) ;
+		void insert(Segment *) ;
+		void insert(Point *) ;
+
+	private:
+		double a,b,c,d ;
+
+		BSPNode *fils_moins ;
+		BSPNode *fils_plus ;
+
+		vector&lt;Segment *&gt; seg_plus ;
+		vector&lt;Segment *&gt; seg_moins ;
+
+		vector&lt;Point *&gt; pts_plus ;
+		vector&lt;Point *&gt; pts_moins ;
+
+		Polygone *polygone ;
+
+		void Classify(Polygone *, Polygone * &amp;, Polygone * &amp;) ;
+		void Classify(Segment *, Segment * &amp;, Segment * &amp;) ;
+		int  Classify(Point *) ;
+
+		void initEquation(const Polygone *P,double &amp; a, double &amp; b, double &amp; c, double &amp; d) ;
+} ;
+
+BSPTree::BSPTree()
+{
+	_root = NULL ;
+}
+
+BSPTree::~BSPTree()
+{
+	delete _root ;
+}
+
+void BSPTree::insert(Point *P) 	{ if(_root == NULL) _points.push_back(P) 	 ; else _root-&gt;insert(P) ; }
+void BSPTree::insert(Segment *S) { if(_root == NULL) _segments.push_back(S) ; else _root-&gt;insert(S) ; }
+void BSPTree::insert(Polygone *P){ if(_root == NULL) _root = new BSPNode(P) ; else _root-&gt;insert(P) ; }
+
+void BSPTree::recursFillPrimitiveArray(vector&lt;PtrPrimitive&gt;&amp; tab) const
+{
+	if(_root != NULL) _root-&gt;recursFillPrimitiveArray(tab) ;
+
+	for(unsigned int i=0;i&lt;_points.size();++i) tab.push_back(_points[i]);
+	for(unsigned int j=0;j&lt;_segments.size();++j) tab.push_back(_segments[j]);
+}
+
+//----------------------------------------------------------------------------//
+
+BSPNode::~BSPNode()
+{
+	delete fils_moins ;
+	delete fils_plus ;
+}
+
+int BSPNode::Classify(Point *P)
+{
+  double Z = P-&gt;sommet3DColor(0).x() * a + P-&gt;sommet3DColor(0).y() * b + P-&gt;sommet3DColor(0).z() * c - d ;
+
+  if(Z &gt; EGALITY_EPS)
+    return 1 ;
+  else
+    return -1 ;
+}
+
+void BSPNode::Classify(Segment *S, Segment * &amp; moins_, Segment * &amp; plus_)
+{
+	double Z1 = S-&gt;sommet3DColor(0).x() * a + S-&gt;sommet3DColor(0).y() * b + S-&gt;sommet3DColor(0).z() * c - d ;
+	double Z2 = S-&gt;sommet3DColor(1).x() * a + S-&gt;sommet3DColor(1).y() * b + S-&gt;sommet3DColor(1).z() * c - d ;
+
+	int s1, s2 ;
+
+	if(Z1 &lt; -LINE_EGALITY_EPS)
+		s1 = -1 ;
+	else if(Z1 &gt; EGALITY_EPS)
+		s1 = 1 ;
+	else
+		s1 = 0 ;
+
+	if(Z2 &lt; -LINE_EGALITY_EPS)
+		s2 = -1 ;
+	else if(Z2 &gt; EGALITY_EPS)
+		s2 = 1 ;
+	else
+		s2 = 0 ;
+
+	if(s1 == -s2)
+	{
+		if(s1 == 0)
+		{
+			moins_ = S ;
+			plus_  = NULL ;
+			return ;
+		}
+		else
+		{
+			double t = fabs(Z1/(Z2 - Z1)) ;
+
+			if((t &lt; 0.0)||(t &gt; 1.0))
+			{
+#ifdef DEBUGEPSRENDER
+				//				printf(&quot;BSPNode::Classify Segment: Error. Incorrect value t=%1.5lf\n&quot;,t) ;
+#endif
+
+				if(t &gt; 1.0) t = 0.999 ;
+				if(t &lt; 0.0) t = 0.001 ;
+			}
+
+			Feedback3DColor newVertex((1-t)*S-&gt;sommet3DColor(0) + t*S-&gt;sommet3DColor(1)) ;
+
+			if(s1 &gt; 0)
+			{
+				plus_  = new Segment(S-&gt;sommet3DColor(0), newVertex) ;
+				moins_ = new Segment(newVertex, S-&gt;sommet3DColor(1)) ;
+			}
+			else
+			{
+				plus_  = new Segment(newVertex, S-&gt;sommet3DColor(1)) ;
+				moins_ = new Segment(S-&gt;sommet3DColor(0), newVertex) ;
+			}
+
+			delete S ;
+			return ;
+		}
+	}
+	else if(s1 == s2)
+	{
+		if(s1 == -1)
+		{
+			moins_ = S ;
+			plus_ = NULL ;
+			return ;
+		}
+		else
+		{
+			moins_ = NULL ;
+			plus_  = S ;
+			return ;
+		}
+	}
+	else if(s1 == 0)
+	{
+		if(s2 &gt; 0)
+		{
+			moins_ = NULL ;
+			plus_  = S ;
+			return ;
+		}
+		else
+		{
+			moins_ = S ;
+			plus_  = NULL ;
+			return ;
+		}
+	}
+	else if(s2 == 0)
+	{
+		if(s1 &gt; 0)
+		{
+			moins_ = NULL ;
+			plus_  = S ;
+			return ;
+		}
+		else
+		{
+			moins_ = S ;
+			plus_  = NULL ;
+			return ;
+		}
+	}
+	else
+		printf(&quot;BSPNode::Classify: unexpected classification case !!\n&quot;) ;
+}
+
+void BSPNode::Classify(Polygone *P, Polygone * &amp; moins_, Polygone * &amp; plus_)
+{
+	static int Signs[100] ;
+	static double Zvals[100] ;
+
+	moins_ = NULL ;
+	plus_ = NULL ;
+
+	if(P == NULL)
+	{
+		printf(&quot;BSPNode::Classify: Error. Null polygon.\n&quot;) ;
+		return ;
+	}
+
+	int n = P-&gt;nbVertices() ;
+
+	int Smin = 1 ;
+	int Smax = -1 ;
+
+	// On classe les sommets en fonction de leur signe
+
+	for(int i=0;i&lt;n;i++)
+	{
+		double Z = P-&gt;vertex(i).x() * a + P-&gt;vertex(i).y() * b + P-&gt;vertex(i).z() * c - d ;
+
+		if(Z &lt; -EGALITY_EPS)
+			Signs[i] = -1 ;
+		else if(Z &gt; EGALITY_EPS)
+			Signs[i] = 1 ;
+		else
+			Signs[i] = 0 ;
+
+		Zvals[i] = Z ;
+
+		if(Smin &gt; Signs[i]) Smin = Signs[i] ;
+		if(Smax &lt; Signs[i]) Smax = Signs[i] ;
+	}
+
+	// Polygone inclus dans le plan
+
+	if((Smin == 0)&amp;&amp;(Smax == 0))
+	{
+		moins_ = P ;
+		plus_  = NULL ;
+		return ;
+	}
+
+	// Polygone tout positif
+
+	if(Smin == 1)
+	{
+		plus_  = P ;
+		moins_ = NULL ;
+		return ;
+	}
+
+	// Polygone tout negatif
+
+	if(Smax == -1)
+	{
+		plus_ = NULL ;
+		moins_ = P ;
+		return ;
+	}
+
+	if((Smin == -1)&amp;&amp;(Smax == 0))
+	{
+		plus_ = NULL ;
+		moins_ = P ;
+		return ;
+	}
+
+	if((Smin == 0)&amp;&amp;(Smax == 1))
+	{
+		plus_ = P ;
+		moins_ = NULL ;
+		return ;
+	}
+
+	// Reste le cas Smin = -1 et Smax = 1. Il faut couper
+
+	vector&lt;Feedback3DColor&gt; Ps ;
+	vector&lt;Feedback3DColor&gt; Ms ;
+
+	// On teste la coherence des signes.
+
+	int nZero = 0 ;
+	int nconsZero = 0 ;
+
+	for(int j=0;j&lt;n;j++)
+	{
+		if(Signs[j] == 0)
+		{
+			nZero++ ;
+
+			if(Signs[(j+1)%n] == 0)
+				nconsZero++ ;
+		}
+	}
+
+	if((nZero &gt; 2)||(nconsZero &gt; 0))
+	{
+		// Ils y a des imprecisions numeriques dues au fait que le poly estpres du plan.
+
+		moins_ = P ;
+		plus_  = NULL ;
+		return ;
+	}
+
+	int dep=0 ;
+
+	while(Signs[dep] == 0) dep++ ;
+
+	int prev_sign = Signs[dep] ;
+
+	for(int k=1;k&lt;=n;k++)
+	{
+		int sign = Signs[(k+dep)%n] ;
+
+		if(sign == prev_sign)
+		{
+			if(sign == 1)
+				Ps.push_back(P-&gt;sommet3DColor(k+dep)) ;
+
+			if(sign == -1)
+				Ms.push_back(P-&gt;sommet3DColor(k+dep)) ;
+		}
+		else if(sign == -prev_sign)
+		{
+			//  Il faut effectuer le calcul en utilisant les memes valeurs que pour le calcul des signes,
+			// sinon on risque des incoherences dues aux imprecisions numeriques.
+
+			double Z1 = Zvals[(k+dep-1)%n] ;
+			double Z2 = Zvals[(k+dep)%n] ;
+
+			double t = fabs(Z1/(Z2 - Z1)) ;
+
+			if((t &lt; 0.0)||(t &gt; 1.0))
+			{
+				if(t &gt; 1.0) t = 0.999 ;
+				if(t &lt; 0.0) t = 0.001 ;
+			}
+
+			Feedback3DColor newVertex((1-t)*P-&gt;sommet3DColor(k+dep-1) + t*P-&gt;sommet3DColor(k+dep)) ;
+
+			Ps.push_back(newVertex) ;
+			Ms.push_back(newVertex) ;
+
+			if(sign == 1)
+				Ps.push_back(P-&gt;sommet3DColor(k+dep)) ;
+
+			if(sign == -1)
+				Ms.push_back(P-&gt;sommet3DColor(k+dep)) ;
+
+			prev_sign = sign ;
+		} // prev_sign != 0 donc necessairement sign = 0. Le sommet tombe dans le plan
+		else
+		{
+			Feedback3DColor newVertex = P-&gt;sommet3DColor(k+dep) ;
+
+			Ps.push_back(newVertex) ;
+			Ms.push_back(newVertex) ;
+
+			prev_sign = -prev_sign ;
+		}
+	}
+
+	if((Ps.size() &gt; 100)||(Ms.size() &gt; 100))
+		printf(&quot;BSPNode::Classify: Error. nPs = %d, nMs = %d.\n&quot;,int(Ps.size()),int(Ms.size())) ;
+
+	if(Ps.size() &lt; 3)
+		printf(&quot;BSPNode::Classify: Error. nPs = %d.\n&quot;,int(Ps.size())) ;
+
+	if(Ms.size() &lt; 3)
+		printf(&quot;BSPNode::Classify: Error. nMs = %d.\n&quot;,int(Ms.size())) ;
+
+	// Les polygones sont convexes, car OpenGL les clip lui-meme.
+
+	//  Si les parents ne sont pas degeneres, plus et moins ne le
+	// sont pas non plus.
+
+	plus_  = new Polygone(Ps) ;
+	moins_ = new Polygone(Ms) ;
+
+	delete  P ;
+}
+
+void BSPNode::insert(Polygone *P)
+{
+	Polygone *side_plus = NULL, *side_moins = NULL ;
+
+	// 1 - Check on which size the polygon is, possibly split.
+
+	Classify(P,side_moins,side_plus) ;
+
+	// 2 - insert polygons
+
+	if(side_plus != NULL)
+		if(fils_plus == NULL)
+			fils_plus = new BSPNode(side_plus) ;
+		else
+			fils_plus-&gt;insert(side_plus) ;
+
+	if(side_moins != NULL)
+		if(fils_moins == NULL)
+			fils_moins = new BSPNode(side_moins) ;
+		else
+			fils_moins-&gt;insert(side_moins) ;
+}
+
+void BSPNode::recursFillPrimitiveArray(vector&lt;PtrPrimitive&gt;&amp; primitive_tab) const
+{
+  if(fils_plus != NULL)
+    fils_plus-&gt;recursFillPrimitiveArray(primitive_tab) ;
+
+  for(unsigned int i=0;i&lt;seg_plus.size();++i)
+    primitive_tab.push_back(seg_plus[i]) ;
+  for(unsigned int j=0;j&lt;pts_plus.size();++j)
+    primitive_tab.push_back(pts_plus[j]) ;
+
+  if(polygone != NULL)
+    primitive_tab.push_back(polygone) ;
+
+  if(fils_moins != NULL)
+    fils_moins-&gt;recursFillPrimitiveArray(primitive_tab) ;
+
+  for(unsigned int i2=0;i2&lt;seg_moins.size();++i2)
+    primitive_tab.push_back(seg_moins[i2]) ;
+  for(unsigned int j2=0;j2&lt;pts_moins.size();++j2)
+    primitive_tab.push_back(pts_moins[j2]) ;
+}
+
+void BSPNode::insert(Point *P)
+{
+	int res = Classify(P) ;
+
+	if(res == -1)
+		if(fils_moins == NULL)
+			pts_moins.push_back(P) ;
+		else
+			fils_moins-&gt;insert(P) ;
+
+	if(res == 1)
+		if(fils_plus == NULL)
+			pts_plus.push_back(P);
+		else
+			fils_plus-&gt;insert(P) ;
+}
+
+void BSPNode::insert(Segment *S)
+{
+	Segment *side_plus = NULL, *side_moins = NULL ;
+
+	Classify(S,side_moins,side_plus) ;
+
+	if(side_plus != NULL)
+		if(fils_plus == NULL)
+			seg_plus.push_back(side_plus) ;
+		else
+			fils_plus-&gt;insert(side_plus) ;
+
+	if(side_moins != NULL)
+		if(fils_moins == NULL)
+			seg_moins.push_back(side_moins) ;
+		else
+			fils_moins-&gt;insert(side_moins) ;
+}
+
+BSPNode::BSPNode(Polygone *P)
+{
+  polygone = P ;
+
+  initEquation(P,a,b,c,d) ;
+
+  fils_moins = NULL ;
+  fils_plus  = NULL ;
+}
+
+void BSPNode::initEquation(const Polygone *P,double &amp; a, double &amp; b, double &amp; c, double &amp; d)
+{
+	Vector3 n(0.,0.,0.) ;
+	int j = 0 ;
+
+	while((j &lt; P-&gt;nbVertices())&amp;&amp; n.infNorm() &lt;= 0.00001)
+	{
+		n = (P-&gt;vertex(j+2) - P-&gt;vertex(j+1))^(P-&gt;vertex(j) - P-&gt;vertex(j+1)) ;
+		j++ ;
+	}
+
+	if(n.infNorm() &lt;= 0.00001)
+	{
+		int ind = P-&gt;nbVertices() ;
+
+		for(int i=0;i&lt;P-&gt;nbVertices();i++)
+			if((P-&gt;vertex(i+1)-P-&gt;vertex(i)).infNorm() &gt; 0.00001)
+			{
+				ind = i ;
+				i = P-&gt;nbVertices() ;
+			}
+
+		if(ind &lt; P-&gt;nbVertices())	// the polygon is a true segment
+		{
+			if((P-&gt;vertex(ind+1).x() != P-&gt;vertex(ind).x())||(P-&gt;vertex(ind+1).y() != P-&gt;vertex(ind).y()))
+			{
+				n[0] = - P-&gt;vertex(ind+1).y() + P-&gt;vertex(ind).y() ;
+				n[1] =   P-&gt;vertex(ind+1).x() - P-&gt;vertex(ind).x() ;
+				n[2] =   0 ;
+			}
+			else
+			{
+				n[0] = - P-&gt;vertex(ind+1).z() + P-&gt;vertex(ind).z() ;
+				n[1] =   0 ;
+				n[2] =   P-&gt;vertex(ind+1).x() - P-&gt;vertex(ind).x() ;
+			}
+		}
+		else				// the polygon is a point
+		{
+			n[0] = 1.0 ;
+			n[1] = 0.0 ;
+			n[2] = 0.0 ;
+		}
+	}
+
+	double D = n.norm() ;
+
+	if(n[2] &lt; 0.0)
+		n /= -D ;
+	else
+		n /= D ;
+
+	d = n*P-&gt;vertex(0) ;
+
+	a = n[0] ;
+	b = n[1] ;
+	c = n[2] ;
+}
+

Added: trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/BackFaceCullingOptimizer.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,88 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;vector&gt;
+#include &quot;VRender.h&quot;
+#include &quot;Optimizer.h&quot;
+#include &quot;Primitive.h&quot;
+
+using namespace std ;
+using namespace vrender ;
+
+// Over-simplified algorithm to check wether a polygon is front-facing or not.
+// Only works for convex polygons.
+
+void BackFaceCullingOptimizer::optimize(std::vector&lt;PtrPrimitive&gt;&amp; primitives_tab,VRenderParams&amp;)
+{
+	Polygone *P ;
+	int nb_culled = 0 ;
+
+	for(unsigned int i=0;i&lt;primitives_tab.size();++i)
+		if((P = dynamic_cast&lt;Polygone *&gt;(primitives_tab[i])) != NULL)
+		{
+			for(int j=0;j&lt;P-&gt;nbVertices();++j)
+				if(( (P-&gt;vertex(j+2) - P-&gt;vertex(j+1))^(P-&gt;vertex(j+1) - P-&gt;vertex(j))).z() &gt; 0.0 )
+				{
+					delete primitives_tab[i] ;
+					primitives_tab[i] = NULL ;
+					++nb_culled ;
+					break ;
+				}
+		}
+
+	// Rule out gaps. This avoids testing for null primitives later.
+
+	int j=0 ;
+	for(unsigned int k=0;k&lt;primitives_tab.size();++k)
+		if(primitives_tab[k] != NULL)
+			primitives_tab[j++] = primitives_tab[k] ;
+
+	primitives_tab.resize(j) ;
+#ifdef DEBUG_BFC
+	cout &lt;&lt; &quot;Backface culling: &quot; &lt;&lt; nb_culled &lt;&lt; &quot; polygons culled.&quot; &lt;&lt; endl ;
+#endif
+}

Added: trunk/lib/QGLViewer/VRender/EPSExporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/EPSExporter.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/EPSExporter.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,352 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &quot;Primitive.h&quot;
+#include &quot;Exporter.h&quot;
+#include &quot;math.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+const double EPSExporter::EPS_GOURAUD_THRESHOLD = 0.05 ;
+const char *EPSExporter::CREATOR = &quot;VRender library - (c) Cyril Soler 2005&quot; ;
+
+float EPSExporter::last_r = -1.0 ;
+float EPSExporter::last_g = -1.0 ;
+float EPSExporter::last_b = -1.0 ;
+
+EPSExporter::EPSExporter()
+{
+	last_r = -1 ;
+	last_g = -1 ;
+	last_b = -1 ;
+}
+
+void EPSExporter::writeHeader(FILE *file) const
+{
+	/* Emit EPS header. */
+
+	fputs(&quot;%!PS-Adobe-2.0 EPSF-2.0\n&quot;, file);
+
+	fprintf(file, &quot;%%%%HiResBoundingBox: %g %g %g %g\n&quot;, _xmin,_ymin,_xmax,_ymax);
+
+	fprintf(file, &quot;%%%%Creator: %s (using OpenGL feedback)\n&quot;, CREATOR);
+	fputs(&quot;%%EndComments\n&quot;, file);
+	fputs(&quot;\n&quot;, file);
+	fputs(&quot;gsave\n&quot;, file);
+	fputs(&quot;\n&quot;, file);
+
+	fputs(&quot;%\n&quot;,file) ;
+	fputs(&quot;% Contributors:\n&quot;,file) ;
+	fputs(&quot;%\n&quot;,file) ;
+	fputs(&quot;%   Frederic Delhoume (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">delhoume at ilog.fr</A>):\n&quot;,file) ;
+	fputs(&quot;%        Gouraud triangle PostScript fragment\n&quot;, file);
+	fputs(&quot;%\n&quot;,file) ;
+	fputs(&quot;%   Cyril Soler       (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">csoler at imag.fr</A>):\n&quot;,file) ;
+	fputs(&quot;%        BSP Sort,\n&quot;,file) ;
+	fputs(&quot;%        Topological and advanced topological Sort,\n&quot;,file) ;
+	fputs(&quot;%        Hidden surface removal,\n&quot;,file) ;
+	fputs(&quot;%        Xfig3.2 (and EPS) format\n&quot;, file);
+	fputs(&quot;%\n\n&quot;,file) ;
+
+	fprintf(file, &quot;/threshold %g def\n&quot;, EPS_GOURAUD_THRESHOLD);
+
+	for(int i = 0; GOURAUD_TRIANGLE_EPS[i] != NULL; i++)
+		fprintf(file, &quot;%s\n&quot;, GOURAUD_TRIANGLE_EPS[i]);
+#ifdef A_VOIR
+	fprintf(file, &quot;\n%g setlinewidth\n\n&quot;, _lineWidth);
+#endif
+	/* Clear the background like OpenGL had it. */
+
+	if(_clearBG)
+	{
+		fprintf(file, &quot;%g %g %g setrgbcolor\n&quot;, _clearR, _clearG, _clearB);
+		fprintf(file, &quot;%g %g %g %g rectfill\n\n&quot;,_xmin,_ymin,_xmax,_ymax);
+	}
+}
+
+void EPSExporter::writeFooter(FILE *file) const
+{
+	fputs(&quot;grestore\n\n&quot;, file);
+
+	fputs(&quot;% uncomment next line to be able to print to a printer.\n&quot;, file);
+	fputs(&quot;% showpage\n&quot;, file) ;
+}
+
+void PSExporter::writeFooter(FILE *file) const
+{
+	fputs(&quot;showpage\n&quot;, file) ;
+}
+
+const char *EPSExporter::GOURAUD_TRIANGLE_EPS[] =
+{
+	&quot;/bd{bind def}bind def /triangle { aload pop   &quot;,
+	&quot;setrgbcolor aload pop 5 3 roll 4 2 roll 3 2 roll exch moveto lineto &quot;,
+	&quot;lineto closepath fill } bd /computediff1 { 2 copy sub abs threshold &quot;,
+	&quot;ge {pop pop pop true} { exch 2 index sub abs threshold ge { pop pop &quot;,
+	&quot;true} { sub abs threshold ge } ifelse } ifelse } bd /computediff3 { 3 &quot;,
+	&quot;copy 0 get 3 1 roll 0 get 3 1 roll 0 get computediff1 {true} { 3 copy &quot;,
+	&quot;1 get 3 1 roll 1 get 3 1 roll 1 get computediff1 {true} { 3 copy 2 &quot;,
+	&quot;get 3 1 roll  2 get 3 1 roll 2 get computediff1 } ifelse } ifelse } &quot;,
+	&quot;bd /middlecolor { aload pop 4 -1 roll aload pop 4 -1 roll add 2 div 5 &quot;,
+	&quot;1 roll 3 -1 roll add 2 div 3 1 roll add 2 div 3 1 roll exch 3 array &quot;,
+	&quot;astore } bd /gdt { computediff3 { 4 -1 roll aload 7 1 roll &quot;,
+	&quot;6 -1 roll pop 3 -1 roll pop add 2 div 3 1 roll add 2 div exch 3 -1 roll &quot;,
+	&quot;aload 7 1 roll exch pop 4 -1 roll pop add 2 div 3 1 roll add 2 div &quot;,
+	&quot;exch 3 -1 roll aload 7 1 roll pop 3 -1 roll pop add 2 div 3 1 roll add &quot;,
+	&quot;2 div exch 7 3 roll 10 -3 roll dup 3 index middlecolor 4 1 roll 2 copy &quot;,
+	&quot;middlecolor 4 1 roll 3 copy pop middlecolor 4 1 roll 13 -1 roll aload &quot;,
+	&quot;pop 17 index 6 index 15 index 19 index 6 index 17 index 6 array astore &quot;,
+	&quot;10 index 10 index 14 index gdt 17 index 5 index 17 index &quot;,
+	&quot;19 index 5 index 19 index 6 array astore 10 index 9 index 13 index &quot;,
+	&quot;gdt 13 index 16 index 5 index 15 index 18 index 5 index 6 &quot;,
+	&quot;array astore 12 index 12 index 9 index gdt 17 index 16 &quot;,
+	&quot;index 15 index 19 index 18 index 17 index 6 array astore 10 index 12 &quot;,
+	&quot;index 14 index gdt 18 {pop} repeat } { aload pop 5 3 roll &quot;,
+	&quot;aload pop 7 3 roll aload pop 9 3 roll 8 index 6 index 4 index add add 3 &quot;,
+	&quot;div 10 1 roll 7 index 5 index 3 index add add 3 div 10 1 roll 6 index 4 &quot;,
+	&quot;index 2 index add add 3 div 10 1 roll 9 {pop} repeat 3 array astore &quot;,
+	&quot;triangle } ifelse } bd&quot;,
+	NULL
+};
+#ifdef A_VIRER
+//	&quot;/bd{bind def}bind def /triangle { aload pop   setrgbcolor  aload pop 5 3&quot;,
+//	&quot;roll 4 2 roll 3 2 roll exch moveto lineto lineto closepath fill } bd&quot;,
+//	&quot;/computediff1 { 2 copy sub abs threshold ge {pop pop pop true} { exch 2&quot;,
+//	&quot;index sub abs threshold ge { pop pop true} { sub abs threshold ge } ifelse&quot;,
+//	&quot;} ifelse } bd /computediff3 { 3 copy 0 get 3 1 roll 0 get 3 1 roll 0 get&quot;,
+//	&quot;computediff1 {true} { 3 copy 1 get 3 1 roll 1 get 3 1 roll 1 get&quot;,
+//	&quot;computediff1 {true} { 3 copy 2 get 3 1 roll  2 get 3 1 roll 2 get&quot;,
+//	&quot;computediff1 } ifelse } ifelse } bd /middlecolor { aload pop 4 -1 roll&quot;,
+//	&quot;aload pop 4 -1 roll add 2 div 5 1 roll 3 -1 roll add 2 div 3 1 roll add 2&quot;,
+//	&quot;div 3 1 roll exch 3 array astore } bd /gdt { computediff3 { 4&quot;,
+//	&quot;-1 roll aload 7 1 roll 6 -1 roll pop 3 -1 roll pop add 2 div 3 1 roll add&quot;,
+//	&quot;2 div exch 3 -1 roll aload 7 1 roll exch pop 4 -1 roll pop add 2 div 3 1&quot;,
+//	&quot;roll add 2 div exch 3 -1 roll aload 7 1 roll pop 3 -1 roll pop add 2 div 3&quot;,
+//	&quot;1 roll add 2 div exch 7 3 roll 10 -3 roll dup 3 index middlecolor 4 1 roll&quot;,
+//	&quot;2 copy middlecolor 4 1 roll 3 copy pop middlecolor 4 1 roll 13 -1 roll&quot;,
+//	&quot;aload pop 17 index 6 index 15 index 19 index 6 index 17 index 6 array&quot;,
+//	&quot;astore 10 index 10 index 14 index gdt 17 index 5 index 17&quot;,
+//	&quot;index 19 index 5 index 19 index 6 array astore 10 index 9 index 13 index&quot;,
+//	&quot;gdt 13 index 16 index 5 index 15 index 18 index 5 index 6&quot;,
+//	&quot;array astore 12 index 12 index 9 index gdt 17 index 16 index&quot;,
+//	&quot;15 index 19 index 18 index 17 index 6 array astore 10 index 12 index 14&quot;,
+//	&quot;index gdt 18 {pop} repeat } { aload pop 5 3 roll aload pop 7 3&quot;,
+//	&quot;roll aload pop 9 3 roll 4 index 6 index 4 index add add 3 div 10 1 roll 7&quot;,
+//	&quot;index 5 index 3 index add add 3 div 10 1 roll 6 index 4 index 2 index add&quot;,
+//	&quot;add 3 div 10 1 roll 9 {pop} repeat 3 array astore triangle } ifelse } bd&quot;,
+//	NULL
+#endif
+
+void EPSExporter::spewPolygone(const Polygone *P,FILE *file)
+{
+	int nvertices;
+	GLfloat red, green, blue;
+	bool smooth;
+
+	nvertices = P-&gt;nbVertices() ;
+
+    const Feedback3DColor&amp; vertex = Feedback3DColor(P-&gt;sommet3DColor(0)) ;
+
+	if(nvertices &gt; 0)
+	{
+		red   = vertex.red();
+		green = vertex.green();
+		blue  = vertex.blue();
+
+		smooth = false;
+
+		for(int i=1;i &lt; nvertices &amp;&amp; !smooth; i++)
+			if(fabs(red - P-&gt;sommet3DColor(i).red()) &gt; 0.01 || fabs(green - P-&gt;sommet3DColor(i).green()) &gt; 0.01 || fabs(blue - P-&gt;sommet3DColor(i).blue()) &gt; 0.01)
+				smooth = true;
+
+		if(smooth &amp;&amp; !_blackAndWhite)
+		{
+			/* Smooth shaded polygon; varying colors at vertices. */
+			/* Break polygon into &quot;nvertices-2&quot; triangle fans. */
+
+			for (int j = 0; j &lt; nvertices - 2; j++)
+			{
+				fprintf(file, &quot;[%g %g %g %g %g %g]&quot;,P-&gt;sommet3DColor(0).x(), P-&gt;sommet3DColor(j + 1).x(), P-&gt;sommet3DColor(j + 2).x(),
+																P-&gt;sommet3DColor(0).y(), P-&gt;sommet3DColor(j + 1).y(), P-&gt;sommet3DColor(j + 2).y());
+
+				fprintf(file, &quot; [%g %g %g] [%g %g %g] [%g %g %g] gdt\n&quot;,
+						P-&gt;sommet3DColor(0    ).red(), P-&gt;sommet3DColor(0    ).green(), P-&gt;sommet3DColor(0    ).blue(),
+						P-&gt;sommet3DColor(j + 1).red(), P-&gt;sommet3DColor(j + 1).green(), P-&gt;sommet3DColor(j + 1).blue(),
+						P-&gt;sommet3DColor(j + 2).red(), P-&gt;sommet3DColor(j + 2).green(), P-&gt;sommet3DColor(j + 2).blue());
+
+				last_r = last_g = last_b = -1.0 ;
+			}
+		}
+		else
+		{
+			/* Flat shaded polygon and white polygons; all vertex colors the same. */
+
+			fprintf(file, &quot;newpath\n&quot;);
+
+			if(_blackAndWhite)
+				setColor(file,1.0,1.0,1.0) ;
+			else
+				setColor(file,red,green,blue) ;
+
+			/* Draw a filled triangle. */
+
+			fprintf(file, &quot;%g %g moveto\n&quot;, P-&gt;sommet3DColor(0).x(), P-&gt;sommet3DColor(0).y());
+
+			for (int i = 1; i &lt; nvertices; i++)
+				fprintf(file, &quot;%g %g lineto\n&quot;, P-&gt;sommet3DColor(i).x(), P-&gt;sommet3DColor(i).y());
+
+			fprintf(file, &quot;closepath fill\n\n&quot;);
+		}
+	}
+}
+
+void EPSExporter::spewSegment(const Segment *S,FILE * file)
+{
+  GLdouble dx, dy;
+  GLfloat dr, dg, db, absR, absG, absB, colormax;
+  int steps;
+  GLdouble xstep=0.0, ystep=0.0;
+  GLfloat rstep=0.0, gstep=0.0, bstep=0.0;
+  GLdouble xnext=0.0, ynext=0.0, distance=0.0;
+  GLfloat rnext=0.0, gnext=0.0, bnext=0.0;
+
+  const Feedback3DColor&amp; P1 = Feedback3DColor(S-&gt;sommet3DColor(0)) ;
+  const Feedback3DColor&amp; P2 = Feedback3DColor(S-&gt;sommet3DColor(1)) ;
+
+  dr = P2.red()   - P1.red();
+  dg = P2.green() - P1.green();
+  db = P2.blue()  - P1.blue();
+
+  if((!_blackAndWhite)&amp;&amp;(dr != 0 || dg != 0 || db != 0))
+  {
+	  /* Smooth shaded line. */
+
+	  dx = P2.x() - P1.x();
+	  dy = P2.y() - P1.y();
+
+	  distance = sqrt(dx*dx + dy*dy);
+
+	  absR = fabs(dr);
+	  absG = fabs(dg);
+	  absB = fabs(db);
+
+	  colormax = max(absR, max(absG, absB));
+	  steps = int(0.5f + max(1.0, colormax * distance * EPS_SMOOTH_LINE_FACTOR));
+
+	  xstep = dx / steps;
+	  ystep = dy / steps;
+
+	  rstep = dr / steps;
+	  gstep = dg / steps;
+	  bstep = db / steps;
+
+	  xnext = P1.x();
+	  ynext = P1.y();
+	  rnext = P1.red();
+	  gnext = P1.green();
+	  bnext = P1.blue();
+
+	  /* Back up half a step; we want the end points to be
+		  exactly the their endpoint colors. */
+
+	  xnext -= xstep / 2.0;
+	  ynext -= ystep / 2.0;
+	  rnext -= rstep / 2.0f;
+	  gnext -= gstep / 2.0f;
+	  bnext -= bstep / 2.0f;
+  }
+  else
+	  steps = 0; /* Single color line. */
+
+  if(_blackAndWhite)
+	  setColor(file,0.0,0.0,0.0) ;
+  else
+	  setColor(file,P1.red(),P1.green(),P1.blue()) ;
+
+  fprintf(file, &quot;%g %g moveto\n&quot;, P1.x(), P1.y());
+
+  for(int i = 0;i &lt; steps;i++)
+  {
+	  xnext += xstep;
+	  ynext += ystep;
+	  rnext += rstep;
+	  gnext += gstep;
+	  bnext += bstep;
+
+	  fprintf(file, &quot;%g %g lineto stroke\n&quot;, xnext, ynext);
+	  fprintf(file, &quot;%g %g %g setrgbcolor\n&quot;, rnext, gnext, bnext);
+	  fprintf(file, &quot;%g %g moveto\n&quot;, xnext, ynext);
+
+	  last_r = last_g = last_b = -1.0 ;
+  }
+  fprintf(file, &quot;%g %g lineto stroke\n&quot;, P2.x(), P2.y());
+}
+
+void EPSExporter::spewPoint(const Point *P,FILE *file)
+{
+	const Feedback3DColor&amp; p = Feedback3DColor(P-&gt;sommet3DColor(0)) ;
+
+	if(_blackAndWhite)
+		setColor(file,0.0,0.0,0.0) ;
+	else
+		setColor(file,p.red(),p.green(),p.blue()) ;
+
+	fprintf(file, &quot;%g %g %g 0 360 arc fill\n\n&quot;, p.x(), p.y(), _pointSize / 2.0);
+}
+
+void EPSExporter::setColor(FILE *file, float red, float green, float blue)
+{
+	if(last_r != red || last_g != green || last_b != blue)
+		fprintf(file, &quot;%g %g %g setrgbcolor\n&quot;, red, green, blue);
+
+	last_r = red ;
+	last_g = green ;
+	last_b = blue ;
+}
+

Added: trunk/lib/QGLViewer/VRender/Exporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Exporter.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Exporter.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,104 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;stdexcept&gt;
+#include &quot;VRender.h&quot;
+#include &quot;Exporter.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+Exporter::Exporter()
+{
+	_xmin=_xmax=_ymin=_ymax=_zmin=_zmax = 0.0 ;
+	_pointSize=1 ;
+}
+
+void Exporter::exportToFile(	const char *filename,
+										const vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+										VRenderParams&amp; vparams)
+{
+	FILE *f = fopen(filename,&quot;w&quot;) ;
+
+	if(f == NULL)
+		throw runtime_error(string(&quot;could not open file &quot;) + filename) ;
+
+	writeHeader(f) ;
+
+	int N = primitive_tab.size()/200 + 1 ;
+
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i)
+	{
+		Point *p = dynamic_cast&lt;Point *&gt;(primitive_tab[i]) ;
+		Segment *s = dynamic_cast&lt;Segment *&gt;(primitive_tab[i]) ;
+		Polygone *P = dynamic_cast&lt;Polygone *&gt;(primitive_tab[i]) ;
+
+		if(p != NULL) spewPoint(p,f) ;
+		if(s != NULL) spewSegment(s,f) ;
+		if(P != NULL) spewPolygone(P,f) ;
+
+		if(i%N == 0)
+			vparams.progress(i/(float)primitive_tab.size(),string(&quot;Exporting to file &quot;)+filename) ;
+	}
+
+	writeFooter(f) ;
+
+	fclose(f) ;
+}
+
+void Exporter::setBoundingBox(float xmin,float ymin,float xmax,float ymax)
+{
+	_xmin = xmin ;
+	_ymin = ymin ;
+	_xmax = xmax ;
+	_ymax = ymax ;
+}
+
+void Exporter::setClearColor(float r, float g, float b) { _clearR=r; _clearG=g; _clearB=b; }
+void Exporter::setClearBackground(bool b) { _clearBG=b; }
+void Exporter::setBlackAndWhite(bool b) { _blackAndWhite = b; }
+

Added: trunk/lib/QGLViewer/VRender/Exporter.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Exporter.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Exporter.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,164 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_EXPORTER_H
+#define _VRENDER_EXPORTER_H
+
+// Set of classes for exporting in various formats, like EPS, XFig3.2, SVG.
+
+#include &quot;Primitive.h&quot;
+
+namespace vrender
+{
+	class VRenderParams ;
+	class Exporter
+	{
+		public:
+			Exporter() ;
+			virtual ~Exporter() {};
+
+			virtual void exportToFile(const char *filename,const std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) ;
+
+			void setBoundingBox(float xmin,float ymin,float xmax,float ymax) ;
+			void setClearColor(float r,float g,float b) ;
+			void setClearBackground(bool b) ;
+			void setBlackAndWhite(bool b) ;
+
+		protected:
+			virtual void spewPoint(const Point *,FILE *) = 0 ;
+			virtual void spewSegment(const Segment *,FILE *) = 0 ;
+			virtual void spewPolygone(const Polygone *,FILE *) = 0 ;
+
+			virtual void writeHeader(FILE *) const = 0 ;
+			virtual void writeFooter(FILE *) const = 0 ;
+
+			float _clearR,_clearG,_clearB ;
+			float _pointSize ;
+			float _lineWidth ;
+
+			GLfloat _xmin,_xmax,_ymin,_ymax,_zmin,_zmax ;
+
+			bool _clearBG,_blackAndWhite ;
+	};
+
+	// Exports to encapsulated postscript.
+
+	class EPSExporter: public Exporter
+	{
+		public:
+			EPSExporter() ;
+			virtual ~EPSExporter() {};
+
+		protected:
+			virtual void spewPoint(const Point *,FILE *) ;
+			virtual void spewSegment(const Segment *,FILE *) ;
+			virtual void spewPolygone(const Polygone *,FILE *) ;
+
+			virtual void writeHeader(FILE *) const ;
+			virtual void writeFooter(FILE *) const ;
+
+		private:
+			void setColor(FILE *,float,float,float) ;
+
+			static const double EPS_GOURAUD_THRESHOLD ;
+			static const char *GOURAUD_TRIANGLE_EPS[] ;
+			static const char *CREATOR ;
+
+			static float last_r ;
+			static float last_g ;
+			static float last_b ;
+	};
+
+	//  Exports to postscript. The only difference is the filename extension and
+	// the showpage at the end.
+
+	class PSExporter: public EPSExporter
+	{
+		public:
+			virtual ~PSExporter() {};
+		protected:
+			virtual void writeFooter(FILE *) const ;
+	};
+
+	class FIGExporter: public Exporter
+	{
+		public:
+			FIGExporter() ;
+			virtual ~FIGExporter() {};
+
+		protected:
+			virtual void spewPoint(const Point *,FILE *) ;
+			virtual void spewSegment(const Segment *,FILE *) ;
+			virtual void spewPolygone(const Polygone *,FILE *) ;
+
+			virtual void writeHeader(FILE *) const ;
+			virtual void writeFooter(FILE *) const ;
+
+		private:
+			mutable int _sizeX ;
+			mutable int _sizeY ;
+			mutable int _depth ;
+
+			int FigCoordX(double) const ;
+			int FigCoordY(double) const ;
+			int FigGrayScaleIndex(float red, float green, float blue) const ;
+	};
+#ifdef A_FAIRE
+	class SVGExporter: public Exporter
+	{
+		protected:
+			virtual void spewPoint(const Point *,FILE *) ;
+			virtual void spewSegment(const Segment *,FILE *) ;
+			virtual void spewPolygone(const Polygone *,FILE *) ;
+
+			virtual void writeHeader(FILE *) const ;
+			virtual void writeFooter(FILE *) const ;
+	};
+#endif
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/FIGExporter.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/FIGExporter.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/FIGExporter.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,227 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;Exporter.h&quot;
+#include &quot;math.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+int FIGExporter::FigCoordX(double x) const
+{
+	float MaxX = 12000 ;
+	float MaxY = MaxX * _sizeY/(float)_sizeX ;
+
+	if(MaxY &gt; 7000)
+	{
+		MaxX *= 7000/(float)MaxY ;
+		MaxY = 7000 ;
+	}
+
+	return int(0.5f + x/_sizeX*MaxX) ;
+}
+
+int FIGExporter::FigCoordY(double y) const
+{
+	float MaxX = 12000 ;
+	float MaxY = MaxX * _sizeY/(float)_sizeX ;
+
+	if(MaxY &gt; 7000)
+	{
+		MaxX *= 7000/(float)MaxY ;
+		MaxY = 7000 ;
+	}
+
+	return int(0.5f + (1.0 - y/_sizeY)*MaxY) ;
+}
+
+int FIGExporter::FigGrayScaleIndex(float red, float green, float blue) const
+{
+	float intensity = 0.3f*red+0.6f*green+0.1f*blue ;
+
+	return int(intensity * 20.0) ;
+}
+
+FIGExporter::FIGExporter()
+{
+}
+
+void FIGExporter::writeHeader(FILE *file) const
+{
+	fputs(&quot;#FIG 3.2\nPortrait\nCenter\nInches\nLetter\n100.00\nSingle\n0\n1200 2\n&quot;,file) ;
+	_depth = 999 ;
+	_sizeX = int(0.5f + _xmax - _xmin) ;
+	_sizeY = int(0.5f + _ymax - _ymin) ;
+}
+
+void FIGExporter::writeFooter(FILE *) const
+{
+}
+
+void FIGExporter::spewPoint(const Point *P,FILE *file)
+{
+	fprintf(file, &quot;2 1 0 5 0 7 %d 0 -1 0.000 0 1 -1 0 0 1\n&quot;,_depth--) ;
+
+	fprintf(file, &quot;\t %d %d\n&quot;,FigCoordX(P-&gt;vertex(0)[0]),FigCoordY(P-&gt;vertex(0)[1])) ;
+	if(_depth &gt; 0) _depth = 0 ;
+}
+
+void FIGExporter::spewSegment(const Segment *S,FILE *file)
+{
+	const Feedback3DColor&amp; P1 = Feedback3DColor(S-&gt;sommet3DColor(0)) ;
+	const Feedback3DColor&amp; P2 = Feedback3DColor(S-&gt;sommet3DColor(1)) ;
+
+	GLdouble dx, dy;
+	GLfloat dr, dg, db, absR, absG, absB, colormax;
+	int steps;
+	GLdouble xstep, ystep;
+	GLfloat rstep, gstep, bstep;
+	GLdouble xnext, ynext, distance;
+	GLfloat rnext, gnext, bnext;
+
+	dr = P2.red()   - P1.red();
+	dg = P2.green() - P1.green();
+	db = P2.blue()  - P1.blue();
+
+	if (dr != 0 || dg != 0 || db != 0)
+	{
+		/* Smooth shaded line. */
+
+		dx = P2.x() - P1.x();
+		dy = P2.y() - P1.y();
+
+		distance = sqrt(dx * dx + dy * dy);
+
+		absR = fabs(dr);
+		absG = fabs(dg);
+		absB = fabs(db);
+
+		colormax = max(absR, max(absG, absB));
+		steps = int(0.5f + max(1.0, colormax * distance * EPS_SMOOTH_LINE_FACTOR));
+
+		xstep = dx / steps;
+		ystep = dy / steps;
+
+		rstep = dr / steps;
+		gstep = dg / steps;
+		bstep = db / steps;
+
+		xnext = P1.x();
+		ynext = P1.y();
+		rnext = P1.red();
+		gnext = P1.green();
+		bnext = P1.blue();
+
+		/* Back up half a step; we want the end points to be
+   			exactly the their endpoint colors. */
+
+		xnext -= xstep / 2.0;
+		ynext -= ystep / 2.0;
+		rnext -= rstep / 2.0f;
+		gnext -= gstep / 2.0f;
+		bnext -= bstep / 2.0f;
+	}
+	else
+	{
+		/* Single color line. */
+		steps = 0;
+	}
+
+	fprintf(file,&quot;2 1 0 1 0 7 %d 0 -1 0.000 0 0 -1 0 0 2\n&quot;,_depth--) ;
+	fprintf(file,&quot;\t %d %d&quot;,FigCoordX(P1.x()),FigCoordY(P1.y())) ;
+
+	fprintf(file, &quot; %d %d\n&quot;, FigCoordX(P2.x()), FigCoordY(P2.y())) ;
+	if(_depth &gt; 0) _depth = 0 ;
+}
+
+void FIGExporter::spewPolygone(const Polygone *P,FILE * file)
+{
+	int nvertices;
+	GLfloat red, green, blue;
+
+	nvertices = P-&gt;nbVertices() ;
+
+	Feedback3DColor vertex(P-&gt;sommet3DColor(0)) ;
+
+	if (nvertices &gt; 0)
+	{
+		red   = 0 ;
+		green = 0 ;
+		blue  = 0 ;
+
+		for(int i = 0; i &lt; nvertices; i++)
+		{
+			red   += P-&gt;sommet3DColor(i).red() ;
+			green += P-&gt;sommet3DColor(i).green() ;
+			blue  += P-&gt;sommet3DColor(i).blue() ;
+		}
+
+		red   /= nvertices ;
+		green /= nvertices ;
+		blue  /= nvertices ;
+
+		/* Flat shaded polygon; all vertex colors the same. */
+
+		if(_blackAndWhite)
+			fprintf(file, &quot;2 3 0 0 0 7 %d 0 20 0.000 0 0 -1 0 0 %d\n&quot;,_depth--,nvertices+1);
+		else
+			fprintf(file, &quot;2 3 0 0 0 7 %d 0 %d 0.000 0 0 -1 0 0 %d\n&quot;,_depth--,FigGrayScaleIndex(red,green,blue),nvertices+1);
+
+		/* Draw a filled triangle. */
+
+		fprintf(file, &quot;\t&quot;) ;
+
+		for (int j = 0; j &lt; nvertices; j++)
+			fprintf(file, &quot; %d %d&quot;, FigCoordX(P-&gt;sommet3DColor(j).x()), FigCoordY(P-&gt;sommet3DColor(j).y()));
+
+		fprintf(file, &quot; %d %d\n&quot;,FigCoordX(P-&gt;sommet3DColor(0).x()), FigCoordY(P-&gt;sommet3DColor(0).y()));
+	}
+
+	if(_depth &gt; 0) _depth = 0 ;
+}
+
+

Added: trunk/lib/QGLViewer/VRender/NVector3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/NVector3.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/NVector3.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,199 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;NVector3.h&quot;
+#include &quot;Vector3.h&quot;
+
+using namespace vrender;
+
+NVector3::NVector3(const Vector3 &amp;u,bool normalization)
+{
+  setXYZ(u[0],u[1],u[2],normalization);
+}
+/*
+Vector3 operator+(const NVector3 &amp;u,const Vector3  &amp;v)
+{
+  return Vector3(u[0]+v[0],u[1]+v[1],u[2]+v[2]);
+}
+
+Vector3 operator+(const Vector3  &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(u[0]+v[0],u[1]+v[1],u[2]+v[2]);
+}
+
+Vector3 operator+(const NVector3 &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(u[0]+v[0],u[1]+v[1],u[2]+v[2]);
+}
+
+Vector3 operator-(const NVector3 &amp;u,const Vector3  &amp;v)
+{
+  return Vector3(u[0]-v[0],u[1]-v[1],u[2]-v[2]);
+}
+
+Vector3 operator-(const Vector3  &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(u[0]-v[0],u[1]-v[1],u[2]-v[2]);
+}
+
+Vector3 operator-(const NVector3 &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(u[0]-v[0],u[1]-v[1],u[2]-v[2]);
+}
+*/
+double vrender::operator*(const NVector3 &amp;u,const Vector3  &amp;v)
+{
+  return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
+}
+
+double vrender::operator*(const Vector3  &amp;u,const NVector3 &amp;v)
+{
+  return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
+}
+/*
+double operator*(const NVector3 &amp;u,const NVector3 &amp;v)
+{
+  return u[0]*v[0] + u[1]*v[1] + u[2]*v[2];
+}
+
+Vector3 operator*(double r,const NVector3 &amp;u)
+{
+  return Vector3(r*u[0],r*u[1],r*u[2]);
+}
+
+Vector3 operator/(const NVector3 &amp;u,double r)
+{
+  return Vector3(u[0]/r,u[1]/r,u[2]/r);
+}
+
+
+Vector3 operator^(const NVector3 &amp;u,const Vector3  &amp;v)
+{
+  return Vector3(	u[1]*v[2]-u[2]*v[1],
+			u[2]*v[0]-u[0]*v[2],
+			u[0]*v[1]-u[1]*v[0]);
+}
+
+Vector3 operator^(const Vector3  &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(	u[1]*v[2]-u[2]*v[1],
+			u[2]*v[0]-u[0]*v[2],
+			u[0]*v[1]-u[1]*v[0]);
+}
+
+Vector3 operator^(const NVector3 &amp;u,const NVector3 &amp;v)
+{
+  return Vector3(	u[1]*v[2]-u[2]*v[1],
+			u[2]*v[0]-u[0]*v[2],
+			u[0]*v[1]-u[1]*v[0]);
+}
+*/
+// -----------------------------------------------------------------------------
+//! Default constructor (the default normalized vector is (1,0,0))
+NVector3::NVector3()
+{
+  _n[0] = 1.0;
+  _n[1] = 0.0;
+  _n[2] = 0.0;
+}
+
+// -----------------------------------------------------------------------------
+//! Copy constructor
+NVector3::NVector3(const NVector3&amp; u)
+{
+  _n[0] = u._n[0] ;
+  _n[1] = u._n[1] ;
+  _n[2] = u._n[2] ;
+}
+// -----------------------------------------------------------------------------
+//! Writing X,Y and Z coordinates
+void NVector3::setXYZ(double x,double y,double z,bool normalization)
+{
+  _n[0] = x;
+  _n[1] = y;
+  _n[2] = z;
+  if ( normalization ) normalize();
+}
+
+// -----------------------------------------------------------------------------
+//! Assignment
+NVector3&amp; NVector3::operator=(const NVector3&amp; u)
+{
+  if ( &amp;u != this )
+    {
+	_n[0] = u[0];
+	_n[1] = u[1];
+	_n[2] = u[2];
+    }
+  return *this;
+}
+// -----------------------------------------------------------------------------
+//! Out stream override: prints the 3 normalized vector components
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out,const NVector3&amp; u)
+{
+  out &lt;&lt; u[0] &lt;&lt; &quot; &quot; &lt;&lt; u[1] &lt;&lt; &quot; &quot; &lt;&lt; u[2];
+  return out;
+}
+
+// -----------------------------------------------------------------------------
+//! Normalization
+//! Private method to do normalization (using Norm() method of the Vector class)
+//! when it is necessary (construction of a normalized vector for exemple).
+void NVector3::normalize()
+{
+  double n = _n[0]*_n[0]+_n[1]*_n[1]+_n[2]*_n[2] ;
+
+  if ( n &gt; 0.0 )
+    {
+	_n[0] /= n;
+	_n[1] /= n;
+	_n[2] /= n;
+    }
+  else
+    throw std::runtime_error(&quot;Attempt to normalize a null 3D vector.&quot;) ;
+}
+

Added: trunk/lib/QGLViewer/VRender/NVector3.h
===================================================================
--- trunk/lib/QGLViewer/VRender/NVector3.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/NVector3.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,123 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_NVECTOR3_H
+#define _VRENDER_NVECTOR3_H
+
+#include &lt;iostream&gt;
+#include &lt;stdexcept&gt;
+
+namespace vrender
+{
+  class Vector3;
+
+  class NVector3
+  {
+  public:
+    NVector3();
+    NVector3(const NVector3&amp; u);
+    inline NVector3(double x,double y,double z,bool normalization=true)
+    {
+      setXYZ(x,y,z,normalization);
+    }
+
+    NVector3(const Vector3 &amp;u,bool normalization=true);
+
+    inline double x() const {return _n[0];}
+    inline double y() const {return _n[1];}
+    inline double z() const {return _n[2];}
+    void setXYZ(double x,double y,double z,bool normalization=true);
+
+    NVector3&amp; operator=(const NVector3&amp; u);
+    /*
+      inline friend bool operator==(const NVector3 &amp;u,const Vector3  &amp;v) {return u.isEqualTo(v);}
+      inline friend bool operator==(const Vector3  &amp;u,const NVector3 &amp;v) {return v.isEqualTo(u);}
+      inline friend bool operator==(const NVector3 &amp;u,const NVector3 &amp;v) {return u.isEqualTo(v);}
+      inline friend bool operator!=(const NVector3 &amp;u,const Vector3  &amp;v) {return !(u == v);}
+      inline friend bool operator!=(const Vector3  &amp;u,const NVector3 &amp;v) {return !(u == v);}
+      inline friend bool operator!=(const NVector3 &amp;u,const NVector3 &amp;v) {return !(u == v);}
+    */
+
+    inline friend NVector3 operator-(const NVector3 &amp;u) { return NVector3(-u[0],-u[1],-u[2],false); }
+    //inline friend Vector3 operator+(const NVector3 &amp;u,const Vector3  &amp;v);
+    //inline friend Vector3 operator+(const Vector3  &amp;u,const NVector3 &amp;v);
+    //inline friend Vector3 operator+(const NVector3 &amp;u,const NVector3 &amp;v);
+    //inline friend Vector3 operator-(const NVector3 &amp;u,const Vector3  &amp;v);
+    //inline friend Vector3 operator-(const Vector3  &amp;u,const NVector3 &amp;v);
+    //inline friend Vector3 operator-(const NVector3 &amp;u,const NVector3 &amp;v);
+    friend double operator*(const NVector3 &amp;u,const Vector3  &amp;v);
+    friend double operator*(const Vector3  &amp;u,const NVector3 &amp;v);
+    //inline friend double operator*(const NVector3 &amp;u,const NVector3 &amp;v);
+    //inline friend Vector3 operator*(double r,const NVector3 &amp;u);
+    //inline friend Vector3 operator/(const NVector3 &amp;u,double r);
+
+    //inline friend Vector3 operator^(const NVector3 &amp;u,const Vector3  &amp;v);
+    //inline friend Vector3 operator^(const Vector3  &amp;u,const NVector3 &amp;v);
+    //inline friend Vector3 operator^(const NVector3 &amp;u,const NVector3 &amp;v);
+
+    inline double norm() const {return 1.0;}
+    inline double squareNorm() const {return 1.0;}
+    friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out,const NVector3 &amp;u);
+
+    double operator[](int i) const
+    {
+      if((i &lt; 0)||(i &gt; 2))
+	throw std::runtime_error(&quot;Out of bounds in NVector3::operator[]&quot;) ;
+
+      return _n[i];
+    }
+
+  private:
+    void normalize();
+
+    double _n[3];  //!&lt; normalized vector
+
+  }; // interface of NVector3
+
+}
+
+#endif // _NVECTOR3_H

Added: trunk/lib/QGLViewer/VRender/Optimizer.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Optimizer.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Optimizer.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,94 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _OPTIMIZER_H
+#define _OPTIMIZER_H
+
+#include &quot;Types.h&quot;
+
+namespace vrender
+{
+	// Implements some global optimizations on the polygon sorting.
+
+	class VRenderParams ;
+	class Optimizer
+	{
+		public:
+			virtual void optimize(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) = 0 ;
+			virtual ~Optimizer() {} ;
+	};
+
+	//  Optimizes visibility by culling primitives which do not appear in the
+	// rendered image. Computations are done analytically rather than using an item
+	// buffer.
+
+	class VisibilityOptimizer: public Optimizer
+	{
+		public:
+			virtual void optimize(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) ;
+			virtual ~VisibilityOptimizer() {} ;
+	};
+
+	//  Optimizes by collapsing together primitives which can be, without
+	// perturbating the back to front painting algorithm.
+
+	class PrimitiveSplitOptimizer: public Optimizer
+	{
+		public:
+			virtual void optimize(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) {}
+			virtual ~PrimitiveSplitOptimizer() {} ;
+	};
+
+	class BackFaceCullingOptimizer: public Optimizer
+	{
+		public:
+			virtual void optimize(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) ;
+			virtual ~BackFaceCullingOptimizer() {} ;
+	};
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/ParserGL.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/ParserGL.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/ParserGL.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,486 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;assert.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;VRender.h&quot;
+#include &quot;ParserGL.h&quot;
+
+using namespace vrender ;
+using namespace std;
+
+class ParserUtils
+{
+	public:
+		static void NormalizeBufferCoordinates(GLint size, GLfloat * buffer, GLfloat MaxSize, GLfloat&amp; zmin, GLfloat&amp; zmax) ;
+
+		static PtrPrimitive checkPoint(Point *&amp; P);
+		static PtrPrimitive checkSegment(Segment *&amp; P);
+		static PtrPrimitive checkPolygon(Polygone *&amp; P);
+
+		static void ComputeBufferBB(GLint size, GLfloat * buffer,
+				GLfloat &amp; xmin, GLfloat &amp; xmax,
+				GLfloat &amp; ymin, GLfloat &amp; ymax,
+				GLfloat &amp; zmin, GLfloat &amp; zmax) ;
+
+	private:
+		static void print3DcolorVertex(GLint size, GLint * count, GLfloat * buffer) ;
+		static void debug_printBuffer(GLint size, GLfloat *buffer) ;
+
+		static void NormalizePrimitiveCoordinates(GLfloat * &amp; loc,GLfloat MaxSize,GLfloat zmin,GLfloat zmax) ;
+		static void ComputePrimitiveBB(	GLfloat * &amp; loc,
+				GLfloat &amp; xmin,GLfloat &amp; xmax,
+				GLfloat &amp; ymin,GLfloat &amp; ymax,
+				GLfloat &amp; zmin,GLfloat &amp; zmax);
+
+		static const char *nameOfToken(int token);
+
+		static const double EGALITY_EPS ;
+};
+
+const double ParserUtils::EGALITY_EPS = 0.00001 ;
+
+void ParserGL::parseFeedbackBuffer(	GLfloat *buffer,int size,
+												std::vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+												VRenderParams&amp; vparams)
+{
+	int token;
+	int nvertices = 0 ;
+	nb_lines = 0 ;
+	nb_polys = 0 ;
+	nb_points = 0 ;
+	nb_degenerated_lines = 0 ;
+	nb_degenerated_polys = 0 ;
+	nb_degenerated_points = 0 ;
+
+	// pre-treatment of coordinates so as to get something more consistent
+
+	_xmin = FLT_MAX ;
+	_ymin = FLT_MAX ;
+	_zmin = FLT_MAX ;
+	_xmax = -FLT_MAX ;
+	_ymax = -FLT_MAX ;
+	_zmax = -FLT_MAX ;
+
+	ParserUtils::ComputeBufferBB(size, buffer, _xmin,_xmax,_ymin,_ymax,_zmin,_zmax) ;
+
+#ifdef DEBUGEPSRENDER
+	printf(&quot;Buffer bounding box: %f %f %f %f %f %f\n&quot;,xmin,xmax,ymin,ymax,zmin,zmax) ;
+#endif
+	float Zdepth = max(_ymax-_ymin,_xmax-_xmin) ;
+	ParserUtils::NormalizeBufferCoordinates(size,buffer,Zdepth,_zmin,_zmax) ;
+
+	// now, read buffer
+	GLfloat *end = buffer + size;
+
+	GLfloat *loc = buffer ;
+	int next_step = 0 ;
+	int N = size/200 + 1 ;
+
+	while (loc &lt; end)
+	{
+		token = int(0.5f + *loc) ;
+		loc++;
+
+		if((end-loc)/N &gt;= next_step)
+			vparams.progress((end-loc)/(float)size,string(&quot;Parsing feedback buffer.&quot;)), ++next_step ;
+
+		switch (token)
+		{
+			case GL_LINE_TOKEN:
+			case GL_LINE_RESET_TOKEN:
+				{
+					Segment *S = new Segment(Feedback3DColor(loc),Feedback3DColor(loc+Feedback3DColor::sizeInBuffer())) ;
+
+					primitive_tab.push_back(ParserUtils::checkSegment(S)) ;
+
+					if(S == NULL)
+						nb_degenerated_lines++ ;
+
+					nb_lines++ ;
+					loc += 2*Feedback3DColor::sizeInBuffer();
+				}
+				break;
+
+			case GL_POLYGON_TOKEN:
+				{
+					nvertices = int(0.5f + *loc) ;
+					loc++;
+
+					std::vector&lt;Feedback3DColor&gt; verts ;
+
+					for(int i=0;i&lt;nvertices;++i)
+						verts.push_back(Feedback3DColor(loc)),loc+=Feedback3DColor::sizeInBuffer() ;
+
+					Polygone *P = new Polygone(verts) ;
+
+					primitive_tab.push_back(ParserUtils::checkPolygon(P)) ;
+
+					if(P == NULL)
+						nb_degenerated_polys++ ;
+
+					nb_polys++ ;
+				}
+				break ;
+
+			case GL_POINT_TOKEN:
+				{
+					Point *Pt = new Point(Feedback3DColor(loc)) ;
+
+					primitive_tab.push_back(Pt);//ParserUtils::checkPoint(Pt)) ;
+
+					if(Pt == NULL)
+						nb_degenerated_points++ ;
+
+					nb_points++ ;
+					loc += Feedback3DColor::sizeInBuffer();
+				}
+				break;
+			default:
+				break;
+		}
+	}
+
+}
+
+// Traitement des cas degeneres. Renvoie false si le polygone est degenere.
+// Traitement des cas degeneres. Renvoie false si le segment est degenere.
+
+PtrPrimitive ParserUtils::checkPoint(Point *&amp; P)
+{
+	return P ;
+}
+
+PtrPrimitive ParserUtils::checkSegment(Segment *&amp; P)
+{
+	if((P-&gt;vertex(0) - P-&gt;vertex(1)).infNorm() &lt; EGALITY_EPS)
+	{
+		Point *pp = new Point(P-&gt;sommet3DColor(0)) ;
+		delete P ;
+		P = NULL ;
+
+		return checkPoint(pp) ;
+	}
+
+	return P ;
+}
+
+PtrPrimitive ParserUtils::checkPolygon(Polygone *&amp; P)
+{
+	if(P-&gt;nbVertices() != 3)
+	{
+		cout &lt;&lt; &quot;unexpected case: Polygon with &quot; &lt;&lt; P-&gt;nbVertices() &lt;&lt; &quot; vertices !&quot; &lt;&lt; endl ;
+		delete P ;
+		return NULL ;
+	}
+
+	if(P-&gt;FlatFactor() &lt; FLAT_POLYGON_EPS)
+	{
+		// On ne traite que le cas du triangle plat, vu qu'on est sur d'avoir un triangle
+
+		int n = P-&gt;nbVertices() ;
+
+		for(int i=0;i&lt;n;++i)
+			if( (P-&gt;vertex(i) - P-&gt;vertex((i+1)%n)).norm() &gt; EGALITY_EPS)
+			{
+				Segment *pp = new Segment(P-&gt;sommet3DColor((i+1)%n),P-&gt;sommet3DColor((i+2)%n)) ;
+				delete P ;
+				P = NULL ;
+
+				return checkSegment(pp) ;
+			}
+
+		Point *pp = new Point(P-&gt;sommet3DColor(0)) ;
+		delete P ;
+		P = NULL ;
+
+		return checkPoint(pp) ;
+	}
+
+	// No problem detected.
+
+	return P ;
+}
+
+
+/* Write contents of one vertex to stdout. */
+
+void ParserUtils::print3DcolorVertex(GLint size, GLint * count, GLfloat * buffer)
+{
+	int i;
+
+	printf(&quot;  &quot;);
+	for (i = 0; i &lt; Feedback3DColor::sizeInBuffer(); i++)
+	{
+		printf(&quot;%4.2f &quot;, buffer[size - (*count)]);
+		*count = *count - 1;
+	}
+	printf(&quot;\n&quot;);
+}
+
+void ParserUtils::debug_printBuffer(GLint size, GLfloat * buffer)
+{
+	GLint count;
+	int token, nvertices;
+
+	count = size;
+	while (count) {
+		token = int(buffer[size - count]);
+		count--;
+		switch (token)
+		{
+			case GL_PASS_THROUGH_TOKEN:
+				printf(&quot;GL_PASS_THROUGH_TOKEN\n&quot;);
+				printf(&quot;  %4.2f\n&quot;, buffer[size - count]);
+				count--;
+				break;
+			case GL_POINT_TOKEN:
+				printf(&quot;GL_POINT_TOKEN\n&quot;);
+				print3DcolorVertex(size, &amp;count, buffer);
+				break;
+			case GL_LINE_TOKEN:
+				printf(&quot;GL_LINE_TOKEN\n&quot;);
+				print3DcolorVertex(size, &amp;count, buffer);
+				print3DcolorVertex(size, &amp;count, buffer);
+				break;
+			case GL_LINE_RESET_TOKEN:
+				printf(&quot;GL_LINE_RESET_TOKEN\n&quot;);
+				print3DcolorVertex(size, &amp;count, buffer);
+				print3DcolorVertex(size, &amp;count, buffer);
+				break;
+			case GL_POLYGON_TOKEN:
+				printf(&quot;GL_POLYGON_TOKEN\n&quot;);
+				nvertices = int(buffer[size - count]) ;
+				count--;
+				for (; nvertices &gt; 0; nvertices--)
+					print3DcolorVertex(size, &amp;count, buffer);
+		}
+	}
+}
+
+void ParserUtils::NormalizePrimitiveCoordinates(GLfloat * &amp; loc,GLfloat MaxSize,GLfloat zmin,GLfloat zmax)
+{
+	int token;
+	int nvertices, i;
+
+	token = int(*loc) ;
+	loc++;
+	int size = Feedback3DColor::sizeInBuffer() ;
+
+	switch (token)
+	{
+		case GL_LINE_RESET_TOKEN:
+		case GL_LINE_TOKEN:
+			{
+				for (i = 0; i &lt; 2; i++)
+					(loc+size*i)[2] = ((loc+size*i)[2] - zmin)/(zmax-zmin)*MaxSize ;
+
+				loc += 2*size;          /* Each vertex element in the feedback buffer is size GLfloats. */
+				break;
+			}
+		case GL_POLYGON_TOKEN:
+			{
+				nvertices = int(*loc) ;
+				loc++;
+
+				for (i = 0; i &lt; nvertices; i++)
+					(loc+size*i)[2] = ((loc+size*i)[2] - zmin)/(zmax-zmin)*MaxSize ;
+
+				loc += nvertices * size;  /* Each vertex element in the feedback buffer is size GLfloats. */
+				break;
+			}
+		case GL_POINT_TOKEN:
+			{
+				loc[2] = (loc[2] - zmin)/(zmax-zmin)*MaxSize ;
+
+				loc += size;           /* Each vertex element in the feedback buffer is size GLfloats. */
+				break;
+			}
+		default:
+			/* XXX Left as an excersie to the reader. */
+#ifdef DEBUGEPSRENDER
+			printf(&quot;%s (%d) not handled yet. Sorry.\n&quot;, ParserUtils::nameOfToken(token), token);
+#endif
+			;
+	}
+}
+
+void ParserUtils::ComputePrimitiveBB(GLfloat * &amp; loc,GLfloat &amp; xmin,GLfloat &amp; xmax,GLfloat &amp; ymin,GLfloat &amp; ymax, GLfloat &amp; zmin,GLfloat &amp; zmax)
+{
+	int token;
+	int nvertices, i;
+
+	token = int(*loc) ;
+	loc++;
+	int size = Feedback3DColor::sizeInBuffer() ;
+
+	switch (token)
+	{
+		case GL_LINE_RESET_TOKEN:
+		case GL_LINE_TOKEN:
+			{
+				for (i = 0; i &lt; 2; i++)
+				{
+					Feedback3DColor f(loc+size*i) ;
+
+					if(f.x() &lt; xmin) xmin = GLfloat(f.x()) ;
+					if(f.y() &lt; ymin) ymin = GLfloat(f.y()) ;
+					if(f.z() &lt; zmin) zmin = GLfloat(f.z()) ;
+					if(f.x() &gt; xmax) xmax = GLfloat(f.x()) ;
+					if(f.y() &gt; ymax) ymax = GLfloat(f.y()) ;
+					if(f.z() &gt; zmax) zmax = GLfloat(f.z()) ;
+				}
+
+				loc += 2*size;          /* Each vertex element in the feedback
+													buffer is size GLfloats. */
+				break;
+			}
+		case GL_POLYGON_TOKEN:
+			{
+				nvertices = int(*loc) ;
+				loc++;
+
+				for (i = 0; i &lt; nvertices; i++)
+				{
+					Feedback3DColor f(loc+size*i) ;
+
+					if(f.x() &lt; xmin) xmin = GLfloat(f.x()) ;
+					if(f.y() &lt; ymin) ymin = GLfloat(f.y()) ;
+					if(f.z() &lt; zmin) zmin = GLfloat(f.z()) ;
+					if(f.x() &gt; xmax) xmax = GLfloat(f.x()) ;
+					if(f.y() &gt; ymax) ymax = GLfloat(f.y()) ;
+					if(f.z() &gt; zmax) zmax = GLfloat(f.z()) ;
+				}
+
+				loc += nvertices * size;  /* Each vertex element in the
+													  feedback buffer is size GLfloats. */
+				break;
+			}
+		case GL_POINT_TOKEN:
+			{
+				Feedback3DColor f(loc) ;
+
+				if(f.x() &lt; xmin) xmin = GLfloat(f.x()) ;
+				if(f.y() &lt; ymin) ymin = GLfloat(f.y()) ;
+				if(f.z() &lt; zmin) zmin = GLfloat(f.z()) ;
+				if(f.x() &gt; xmax) xmax = GLfloat(f.x()) ;
+				if(f.y() &gt; ymax) ymax = GLfloat(f.y()) ;
+				if(f.z() &gt; zmax) zmax = GLfloat(f.z()) ;
+
+				loc += size;           /* Each vertex element in the feedback
+												  buffer is size GLfloats. */
+				break;
+			}
+		default:
+			/* XXX Left as an excersie to the reader. */
+#ifdef DEBUGEPSRENDER
+			printf(&quot;Incomplete implementation.  Unexpected token (%d).\n&quot;, token);
+#endif
+			;
+	}
+}
+
+void ParserUtils::NormalizeBufferCoordinates(GLint size, GLfloat * buffer, GLfloat MaxSize, GLfloat&amp; zmin,GLfloat&amp; zmax)
+{
+	GLfloat *loc, *end;
+
+	if(zmax == zmin)
+	{
+#ifdef DEBUGEPSRENDER
+		printf(&quot;Warning: zmin = zmax in NormalizePrimitiveCoordinates\n&quot;) ;
+#endif
+		return ;
+	}
+
+	loc = buffer;
+	end = buffer + size;
+
+	while (loc &lt; end)
+		NormalizePrimitiveCoordinates(loc,MaxSize,zmin,zmax);
+
+	zmin = 0.0 ;
+	zmax = MaxSize ;
+}
+
+void ParserUtils::ComputeBufferBB(GLint size, GLfloat * buffer,
+		     GLfloat &amp; xmin, GLfloat &amp; xmax,
+		     GLfloat &amp; ymin, GLfloat &amp; ymax,
+		     GLfloat &amp; zmin, GLfloat &amp; zmax)
+{
+	GLfloat *loc, *end;
+
+	loc = buffer;
+	end = buffer + size;
+
+	while (loc &lt; end)
+		ComputePrimitiveBB(loc,xmin,xmax,ymin,ymax,zmin,zmax);
+}
+
+typedef struct _DepthIndex {
+  GLfloat *ptr;
+  GLfloat depth;
+} DepthIndex;
+
+const char *ParserUtils::nameOfToken(int token)
+{
+	switch(token)
+	{
+		case GL_PASS_THROUGH_TOKEN: 	return &quot;GL_PASS_THROUGH_TOKEN&quot; ;
+		case GL_POINT_TOKEN: 			return &quot;GL_POINT_TOKEN&quot; ;
+		case GL_LINE_TOKEN: 				return &quot;GL_LINE_TOKEN&quot; ;
+		case GL_POLYGON_TOKEN: 			return &quot;GL_POLYGON_TOKEN&quot; ;
+		case GL_BITMAP_TOKEN: 			return &quot;GL_BITMAP_TOKEN&quot; ;
+		case GL_DRAW_PIXEL_TOKEN:		return &quot;GL_DRAW_PIXEL_TOKEN&quot; ;
+		case GL_COPY_PIXEL_TOKEN:		return &quot;GL_COPY_PIXEL_TOKEN&quot; ;
+		case GL_LINE_RESET_TOKEN:		return &quot;GL_LINE_RESET_TOKEN&quot; ;
+		default:
+										  		return &quot;(Unidentified token)&quot; ;
+	}
+}
+

Added: trunk/lib/QGLViewer/VRender/ParserGL.h
===================================================================
--- trunk/lib/QGLViewer/VRender/ParserGL.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/ParserGL.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,91 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_PARSERGL_H
+#define _VRENDER_PARSERGL_H
+
+//  This class implements the conversion from OpenGL feedback buffer into more
+// usable data structures such as points, segments, and polygons (See Primitive.h)
+
+#include &lt;vector&gt;
+#include &quot;Primitive.h&quot;
+
+namespace vrender
+{
+	class ParserGL
+	{
+		public:
+			void parseFeedbackBuffer(	GLfloat *,
+												int size,
+												std::vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+												VRenderParams&amp; vparams) ;
+			void printStats() const ;
+
+			inline GLfloat xmin() const { return _xmin ; }
+			inline GLfloat ymin() const { return _ymin ; }
+			inline GLfloat zmin() const { return _zmin ; }
+			inline GLfloat xmax() const { return _xmax ; }
+			inline GLfloat ymax() const { return _ymax ; }
+			inline GLfloat zmax() const { return _zmax ; }
+		private:
+			int nb_lines ;
+			int nb_polys ;
+			int nb_points ;
+			int nb_degenerated_lines ;
+			int nb_degenerated_polys ;
+			int nb_degenerated_points ;
+
+			GLfloat _xmin ;
+			GLfloat _ymin ;
+			GLfloat _zmin ;
+			GLfloat _xmax ;
+			GLfloat _ymax ;
+			GLfloat _zmax ;
+	};
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/Primitive.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Primitive.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Primitive.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,173 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;math.h&gt;
+#include &lt;assert.h&gt;
+#include &quot;Primitive.h&quot;
+#include &quot;Types.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+Point::Point(const Feedback3DColor&amp; f)
+	: _position_and_color(f)
+{
+}
+
+const Vector3&amp; Point::vertex(int) const
+{
+	return _position_and_color.pos() ;
+}
+
+const Feedback3DColor&amp; Point::sommet3DColor(int) const
+{
+	return _position_and_color ;
+}
+
+const Feedback3DColor&amp; Segment::sommet3DColor(int i) const
+{
+	return ( (i&amp;1)==0 )?P1:P2 ;
+}
+
+AxisAlignedBox_xyz Point::bbox() const
+{
+	return AxisAlignedBox_xyz(_position_and_color.pos(),_position_and_color.pos()) ;
+}
+
+const Vector3&amp; Segment::vertex(int i) const
+{
+	return ( (i&amp;1)==0 )?P1.pos():P2.pos() ;
+}
+
+AxisAlignedBox_xyz Segment::bbox() const
+{
+	AxisAlignedBox_xyz B(P1.pos());
+	B.include(P2.pos()) ;
+
+	return B ;
+}
+
+const Feedback3DColor&amp; Polygone::sommet3DColor(int i) const
+{
+	return _vertices[i % nbVertices()] ;
+}
+
+const Vector3&amp; Polygone::vertex(int i) const
+{
+	return _vertices[i % nbVertices()].pos() ;
+}
+
+
+Polygone::Polygone(const vector&lt;Feedback3DColor&gt;&amp; fc)
+	: _vertices(fc)
+{
+	initNormal() ;
+
+	for(unsigned int i=0;i&lt;fc.size();i++)
+		_bbox.include(fc[i].pos()) ;
+}
+
+AxisAlignedBox_xyz Polygone::bbox() const
+{
+	return _bbox ;
+}
+
+double Polygone::equation(const Vector3&amp; v) const
+{
+	return v * _normal - _c ;
+}
+
+void Polygone::initNormal()
+{
+	FLOAT anglemax = 0.0 ;
+	Vector3 normalmax = Vector3(0.0,0.0,0.0) ;
+	FLOAT v12norm = (vertex(1)-vertex(0)).norm() ;
+
+	for(int i=0;i&lt;nbVertices();i++)
+	{
+		Vector3 v1(vertex(i)) ;
+		Vector3 v2(vertex(i+1));
+		Vector3 v3(vertex(i+2)) ;
+
+		Vector3 normal_tmp((v3-v2)^(v1-v2)) ;
+
+		FLOAT v32norm = (v3-v2).norm() ;
+
+		if(normal_tmp.z() &gt; 0)
+			normal_tmp *= -1.0 ;
+
+		if((v32norm &gt; 0.0)&amp;&amp;(v12norm &gt; 0.0))
+		{
+			double anglemaxtmp = normal_tmp.norm()/v32norm/v12norm ;
+
+			if(anglemaxtmp &gt; anglemax)
+			{
+				anglemax = anglemaxtmp ;
+				normalmax = normal_tmp ;
+			}
+		}
+
+		v12norm = v32norm ;
+
+		if(anglemax &gt; FLAT_POLYGON_EPS)	// slight optimization
+			break ;
+	}
+
+	if(normalmax.infNorm() != 0.0)
+		_normal = NVector3(normalmax) ;
+
+	anglefactor = anglemax ;
+	_c = _normal*vertex(0) ;
+}
+
+std::ostream&amp; vrender::operator&lt;&lt;(std::ostream&amp; o,const Feedback3DColor&amp; f)
+{
+	o &lt;&lt; &quot;(&quot; &lt;&lt; f.pos() &lt;&lt; &quot;) + (&quot; &lt;&lt; f.red() &lt;&lt; &quot;,&quot; &lt;&lt; f.green() &lt;&lt; &quot;,&quot; &lt;&lt; f.blue() &lt;&lt; &quot;,&quot; &lt;&lt; f.alpha() &lt;&lt; &quot;)&quot; &lt;&lt; endl ;
+	return o ;
+}
+
+

Added: trunk/lib/QGLViewer/VRender/Primitive.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Primitive.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Primitive.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,223 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _PRIMITIVE_H_
+#define _PRIMITIVE_H_
+
+#include &lt;vector&gt;
+#include &quot;AxisAlignedBox.h&quot;
+#include &quot;Vector3.h&quot;
+#include &quot;NVector3.h&quot;
+#include &quot;Types.h&quot;
+
+#ifdef WIN32
+# include &lt;windows.h&gt;
+#endif
+
+#ifdef __APPLE__
+# include &lt;OpenGL/gl.h&gt;
+#else
+# include &lt;GL/gl.h&gt;
+#endif
+
+namespace vrender
+{
+	class Feedback3DColor ;
+	class Primitive ;
+
+
+#define EPS_SMOOTH_LINE_FACTOR 0.06  /* Lower for better smooth lines. */
+
+	//  A Feedback3DColor is a structure containing informations about a vertex projected into
+	// the frame buffer.
+
+	class Feedback3DColor
+	{
+		public:
+			Feedback3DColor(GLfloat *loc)
+				: 	_pos(loc[0],loc[1],loc[2]),
+			_red(loc[3]),_green(loc[4]),_blue(loc[5]),_alpha(loc[6]) {}
+
+			inline FLOAT x() const { return _pos[0] ; }
+			inline FLOAT y() const { return _pos[1] ; }
+			inline FLOAT z() const { return _pos[2] ; }
+			inline GLfloat red() const { return _red ; }
+			inline GLfloat green() const { return _green ; }
+			inline GLfloat blue() const { return _blue ; }
+			inline GLfloat alpha() const { return _alpha ; }
+			inline const Vector3&amp; pos() const { return _pos ; }
+
+			inline Feedback3DColor operator+(const Feedback3DColor &amp; v) const
+			{
+				return Feedback3DColor(x()+v.x(),y()+v.y(),z()+v.z(),red()+v.red(),green()+v.green(),blue()+v.blue(),alpha()+v.alpha()) ;
+			}
+			inline Feedback3DColor operator*(const GLFLOAT &amp; f) const
+			{
+				return Feedback3DColor(x()*f,y()*f,z()*f,red()*GLfloat(f),green()*GLfloat(f),blue()*GLfloat(f),alpha()*GLfloat(f)) ;
+			}
+			friend inline Feedback3DColor operator*(const GLFLOAT &amp; f,const Feedback3DColor&amp; F)
+			{
+				return F*f ;
+			}
+
+			static int sizeInBuffer() { return 7 ; }
+
+			friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp;,const Feedback3DColor&amp;) ;
+
+		protected:
+			Feedback3DColor(FLOAT x, FLOAT y, FLOAT z, GLfloat r, GLfloat g, GLfloat b, GLfloat a)
+				:_pos(x,y,z), _red(r), _green(g), _blue(b), _alpha(a) {}
+
+			Vector3	_pos ;
+			GLfloat	_red;
+			GLfloat	_green;
+			GLfloat	_blue;
+			GLfloat	_alpha;
+	} ;
+
+	// A primitive is an entity
+	//
+	class Primitive
+	{
+		public:
+			virtual ~Primitive() {}
+
+
+			virtual const Feedback3DColor&amp; sommet3DColor(int) const =0 ;
+
+			// Renvoie le ieme vertex modulo le nombre de vertex.
+			virtual const Vector3&amp; vertex(int) const = 0 ;
+#ifdef A_FAIRE
+			virtual FLOAT Get_I_EPS(Primitive *) const ;
+			Vect3 VerticalProjectPointOnSupportPlane(const Vector3 &amp;) const ;
+			void IntersectPrimitiveWithSupportPlane(Primitive *,int[],FLOAT[],Vect3 *&amp;,Vect3 *&amp;) ;
+			inline FLOAT Equation(const Vect3&amp; p) { return p*_normal-_C ; }
+			virtual void Split(Vect3,FLOAT,Primitive * &amp;,Primitive * &amp;) = 0 ;
+			void GetSigns(Primitive *,int * &amp;,FLOAT * &amp;,int &amp;,int &amp;,FLOAT) ;
+			FLOAT Const() const { return _C ; }
+
+			int depth() const { return _depth ; }
+			void setDepth(int d) const { _depth = d ; }
+#endif
+			virtual AxisAlignedBox_xyz bbox() const = 0 ;
+			virtual int nbVertices() const = 0 ;
+
+		protected:
+
+			int _vibility ;
+	} ;
+
+	class Point: public Primitive
+	{
+		public:
+			Point(const Feedback3DColor&amp; f);
+			virtual ~Point() {}
+
+			virtual const Vector3&amp; vertex(int) const ;
+			virtual int nbVertices() const { return 1 ; }
+			virtual const Feedback3DColor&amp; sommet3DColor(int) const ;
+			virtual AxisAlignedBox_xyz bbox() const ;
+
+		private:
+			Feedback3DColor _position_and_color ;
+	};
+
+	class Segment: public Primitive
+	{
+		public:
+			Segment(const Feedback3DColor &amp; p1, const Feedback3DColor &amp; p2): P1(p1), P2(p2) {}
+			virtual ~Segment() {}
+			virtual int nbVertices() const { return 2 ; }
+			virtual const Vector3&amp; vertex(int) const ;
+			virtual const Feedback3DColor&amp; sommet3DColor(int i) const ;
+			virtual AxisAlignedBox_xyz bbox() const ;
+#ifdef A_FAIRE
+			virtual void Split(const Vector3&amp;,FLOAT,Primitive * &amp;,Primitive * &amp;) ;
+#endif
+
+		protected:
+			Feedback3DColor P1 ;
+			Feedback3DColor P2 ;
+	} ;
+
+
+	class Polygone: public Primitive
+	{
+		public:
+			Polygone(const std::vector&lt;Feedback3DColor&gt;&amp;) ;
+			virtual ~Polygone() {}
+#ifdef A_FAIRE
+			virtual int IsAPolygon() { return 1 ; }
+			virtual void Split(const Vector3&amp;,FLOAT,Primitive * &amp;,Primitive * &amp;) ;
+			void InitEquation(double &amp;,double &amp;,double &amp;,double &amp;) ;
+#endif
+			virtual const Feedback3DColor&amp; sommet3DColor(int) const ;
+			virtual const Vector3&amp; vertex(int) const ;
+			virtual int nbVertices() const { return _vertices.size() ; }
+			virtual AxisAlignedBox_xyz bbox() const ;
+			double equation(const Vector3&amp; p) const ;
+			const NVector3&amp; normal() const { return _normal ; }
+			double c() const { return _c ; }
+
+			FLOAT FlatFactor() const { return anglefactor ; }
+
+		protected:
+			virtual void initNormal() ;
+			void CheckInfoForPositionOperators() ;
+
+			AxisAlignedBox_xyz _bbox ;
+			std::vector&lt;Feedback3DColor&gt; _vertices ;
+			// std::vector&lt;FLOAT&gt; _sommetsProjetes ;
+			// Vector3 N,M,L ;
+			double anglefactor ;		//  Determine a quel point un polygone est plat.
+			// Comparer a FLAT_POLYGON_EPS
+			double _c ;
+			NVector3 _normal ;
+	} ;
+}
+#endif
+

Added: trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/PrimitivePositioning.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,714 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#include &quot;Primitive.h&quot;
+#include &quot;AxisAlignedBox.h&quot;
+#include &quot;PrimitivePositioning.h&quot;
+#include &quot;math.h&quot;
+#include &quot;Vector2.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+#define DEBUG_TS
+
+double PrimitivePositioning::_EPS = 0.00001 ;
+
+// Computes relative position of the second primitive toward the first.
+// As a general rule, the smaller the Z of a primitive, the Upper the primitive.
+
+int PrimitivePositioning::computeRelativePosition(const Primitive *p1,const Primitive *p2)
+{
+	AxisAlignedBox_xyz bb1(p1-&gt;bbox()) ;
+	AxisAlignedBox_xyz bb2(p2-&gt;bbox()) ;
+
+	// 1 - check if bounding boxes are disjoint. In such a case, a rapid answer is possible.
+
+	if( bb1.maxi().x() &lt; bb2.mini().x() || bb1.mini().x() &gt; bb2.maxi().x()) return Independent ;
+	if( bb1.maxi().y() &lt; bb2.mini().y() || bb1.mini().y() &gt; bb2.maxi().y()) return Independent ;
+
+	// 2 - call specific tests for each case.
+
+	if(p1-&gt;nbVertices() &gt;= 3)
+		if(p2-&gt;nbVertices() &gt;= 3)
+			return computeRelativePosition( dynamic_cast&lt;const Polygone *&gt;(p1),dynamic_cast&lt;const Polygone *&gt;(p2)) ;
+		else if(p2-&gt;nbVertices() == 2) // Case of a segment versus a polygon
+			return computeRelativePosition( dynamic_cast&lt;const Polygone *&gt;(p1),dynamic_cast&lt;const Segment *&gt;(p2)) ;
+		else
+			return computeRelativePosition( dynamic_cast&lt;const Polygone *&gt;(p1),dynamic_cast&lt;const Point *&gt;(p2)) ;
+	else if(p1-&gt;nbVertices() == 2)
+		if(p2-&gt;nbVertices() &gt;= 3)
+			return inverseRP(computeRelativePosition( dynamic_cast&lt;const Polygone *&gt;(p2),dynamic_cast&lt;const Segment *&gt;(p1))) ;
+		else if(p2-&gt;nbVertices() == 2)
+			return computeRelativePosition( dynamic_cast&lt;const Segment *&gt;(p1),dynamic_cast&lt;const Segment *&gt;(p2)) ;
+		else
+			return Independent ;	// segment vs point =&gt; independent
+	else
+		if(p2-&gt;nbVertices() &gt;= 3)
+			return inverseRP(computeRelativePosition( dynamic_cast&lt;const Polygone *&gt;(p2),dynamic_cast&lt;const Point *&gt;(p1))) ;
+		else if(p2-&gt;nbVertices() == 2)
+			return Independent ;	// point vs segment =&gt; independent
+		else
+			return Independent ;	// point vs point =&gt; independent
+}
+
+// Computes the relative position of the point toward a *convex* polygon.
+
+int PrimitivePositioning::computeRelativePosition(const Polygone *Q,const Point *P)
+{
+	if(pointOutOfPolygon_XY(P-&gt;vertex(0),Q,(double)_EPS)) // On met un eps &gt; 0, pour que les
+		return Independent ;							 // points du bords soient inclus dans le polygone.
+
+	// now compute the relative position of the point toward the polygon
+
+	if(Q-&gt;equation(P-&gt;vertex(0)) &gt;= 0)
+		return Upper ;
+	else
+		return Lower ;
+}
+
+// Computes the relative position of the segment toward a *convex* polygon.
+
+int PrimitivePositioning::computeRelativePosition(const Polygone *P,const Segment *S)
+{
+	//  Computes the intersection of the segment and the polygon in 2D, then
+	// project the extremities of the intersection onto the segment, and compare
+	// the points to the polygon.
+
+	// 1 - 2D-intersection of segment and polygon
+
+	vector&lt;double&gt; intersections ;
+
+	if(!pointOutOfPolygon_XY(S-&gt;vertex(0),P,_EPS)) intersections.push_back(0.0);
+	if(!pointOutOfPolygon_XY(S-&gt;vertex(1),P,_EPS)) intersections.push_back(1.0);
+
+	double t1,t2 ;
+
+	for(int i=0;i&lt;P-&gt;nbVertices();++i)
+		if(intersectSegments_XY(Vector2(S-&gt;vertex(0)),Vector2(S-&gt;vertex(1)),Vector2(P-&gt;vertex(i)),Vector2(P-&gt;vertex(i+1)),_EPS,t1,t2))
+			intersections.push_back(t1) ;
+
+	// 2 - Checks wether the intersection segment is reduced to a point. In this case,
+	// 	both primitives are independent.
+
+	double tmin = FLT_MAX ;
+	double tmax = -FLT_MAX ;
+
+	for(unsigned int j=0;j&lt;intersections.size();++j)
+	{
+		tmin = min(tmin,intersections[j]) ;
+		tmax = max(tmax,intersections[j]) ;
+	}
+
+	if(tmax - tmin &lt; 2*_EPS)
+		return Independent ;
+
+	// 3 - The intersection segment is not reduced to a point. Compares 3D
+	//   projections of the intersections with the plane of the polygon.
+
+	int res = Independent ;
+
+	for(unsigned int k=0;k&lt;intersections.size();++k)
+	{
+		Vector3 v( (1-intersections[k])*S-&gt;vertex(0) + intersections[k]*S-&gt;vertex(1) ) ;
+
+		if(P-&gt;equation(v) &lt; -_EPS) res |= Lower ;
+		if(P-&gt;equation(v) &gt;  _EPS) res |= Upper ;
+	}
+
+	if(intersections.size() &gt; 1 &amp;&amp; res == Independent)	// case of segments tangent to the polygon
+		res = Upper ;
+
+	return res ;
+}
+
+// Computes the relative position of a polygon toward a convex polygon.
+
+int PrimitivePositioning::computeRelativePosition(const Polygone *P1,const Polygone *P2)
+{
+	// 1 - use gpc to conservatively check for intersection. This works fine because
+	//    gpc produces a null intersection for polygons sharing an edge, which
+	//    is exactly what we need.
+
+	gpc_polygon gpc_int ;
+
+	try
+	{
+		gpc_polygon gpc_p1 = createGPCPolygon_XY(P1) ;
+		gpc_polygon gpc_p2 = createGPCPolygon_XY(P2) ;
+
+		gpc_polygon_clip(GPC_INT,&amp;gpc_p1,&amp;gpc_p2,&amp;gpc_int) ;
+
+		gpc_free_polygon(&amp;gpc_p1) ;
+		gpc_free_polygon(&amp;gpc_p2) ;
+	}
+	catch(exception&amp;)
+	{
+		return Independent ;				// no free, because we don't really now what happenned.
+	}
+
+	int res = Independent ;
+
+	if (gpc_int.num_contours != 1) // There is some numerical error in gpc. Let's skip.
+	  {
+	    gpc_free_polygon(&amp;gpc_int) ;
+	    return res ;
+	    // throw runtime_error(&quot;Intersection with more than 1 contour ! Non convex polygons ?&quot;) ;
+	  }
+
+	// 2 - polygons are not independent. Compute their relative position.
+	//    For this, we project the vertices of the 2D intersection onto the
+	//   support plane of each polygon. The epsilon-signs of each point toward
+	//   both planes give the relative position of the polygons.
+
+	for(int i=0;i&lt;gpc_int.contour[0].num_vertices &amp;&amp; (res &lt; (Upper | Lower));++i)
+	{
+		if(P1-&gt;normal().z() == 0.0) throw runtime_error(&quot;could not project point. Unexpected case !&quot;) ;
+		if(P2-&gt;normal().z() == 0.0) throw runtime_error(&quot;could not project point. Unexpected case !&quot;) ;
+
+		// project point onto support planes
+
+		double f1 = P1-&gt;normal().x() * gpc_int.contour[0].vertex[i].x + P1-&gt;normal().y() * gpc_int.contour[0].vertex[i].y - P1-&gt;c() ;
+		double f2 = P2-&gt;normal().x() * gpc_int.contour[0].vertex[i].x + P2-&gt;normal().y() * gpc_int.contour[0].vertex[i].y - P2-&gt;c() ;
+
+		Vector3 v1(gpc_int.contour[0].vertex[i].x,gpc_int.contour[0].vertex[i].y, -f1/P1-&gt;normal().z()) ;
+		Vector3 v2(gpc_int.contour[0].vertex[i].x,gpc_int.contour[0].vertex[i].y, -f2/P2-&gt;normal().z()) ;
+
+		if(P1-&gt;equation(v2) &lt; -_EPS) res |= Lower ;
+		if(P1-&gt;equation(v2) &gt;  _EPS) res |= Upper ;
+		if(P2-&gt;equation(v1) &lt; -_EPS) res |= Upper ;
+		if(P2-&gt;equation(v1) &gt;  _EPS) res |= Lower ;
+	}
+	gpc_free_polygon(&amp;gpc_int) ;
+	return res ;
+}
+
+// Computes the relative position of a segment toward another segment.
+
+int PrimitivePositioning::computeRelativePosition(const Segment *S1,const Segment *S2)
+{
+	double t1,t2 ;
+
+	if(!intersectSegments_XY(	Vector2(S1-&gt;vertex(0)),Vector2(S1-&gt;vertex(1)),
+										Vector2(S2-&gt;vertex(0)),Vector2(S2-&gt;vertex(1)),
+										-(double)_EPS,t1,t2 ))
+		return Independent ;
+	else
+	{
+		double z1 = (1.0 - t1)*S1-&gt;vertex(0).z() + t1*S1-&gt;vertex(1).z() ;
+		double z2 = (1.0 - t2)*S2-&gt;vertex(0).z() + t2*S2-&gt;vertex(1).z() ;
+
+		if(z1 &lt;= z2)
+			return Lower ;
+		else
+			return Upper ;
+	}
+}
+
+
+// Teste si le point est exterieur au polygone (convexe). Plus I_EPS est grand
+// plus il faut etre loin pour que ca soit vrai. EPS=0 correspond au polygone
+// lui-meme bords inclus. Pour EPS&lt;0, des points interieurs pres de la frontiere sont
+// declares exterieurs.  Plus I_EPS est grand, plus l'ensemble des points
+// consideres comme interieur est dilate.
+
+bool PrimitivePositioning::pointOutOfPolygon_XY(const Vector3&amp; P,const Polygone *Q,double I_EPS)
+{
+	int nq = Q-&gt;nbVertices() ;
+	Vector2 p = Vector2(P) ;
+
+	FLOAT MaxZ = -FLT_MAX ;
+	FLOAT MinZ =  FLT_MAX ;
+
+	for(int j=0;j&lt;nq;j++)  				//  Regarde si P.(x,y) est a l'interieur
+	{                               	// ou a l'exterieur du polygone.
+		Vector2 q1 = Vector2(Q-&gt;vertex(j)) ;
+		Vector2 q2 = Vector2(Q-&gt;vertex(j+1)) ;
+
+		double Z = (q1-p)^(q2-p) ;
+
+		MinZ = min(Z,MinZ) ;
+		MaxZ = max(Z,MaxZ) ;
+	}
+
+	if((MaxZ &lt;= -I_EPS*I_EPS)||(MinZ &gt;= I_EPS*I_EPS))	// the point is inside the polygon
+		return false ;
+	else
+		return true ;
+}
+
+int PrimitivePositioning::inverseRP(int pos)
+{
+	// Basically switch bits of Lower and Upper
+
+	switch(pos)
+	{
+		case Independent: return Independent ;
+		case Lower: return Upper ;
+		case Upper: return Lower ;
+		case Upper | Lower: return Upper | Lower ;
+		default:
+								  throw runtime_error(&quot;Unexpected value.&quot;) ;
+								  return pos ;
+	}
+}
+
+// Calcule l'intersection des segments [P1,Q1] et [P2,Q2]
+// En retour, (1-t1,t1) et (1-t2,t2) sont les coordonnees
+// barycentriques de l'intersection dans chaque segment.
+
+bool PrimitivePositioning::intersectSegments_XY(const Vector2&amp; P1,const Vector2&amp; Q1,
+																const Vector2&amp; P2,const Vector2&amp; Q2,
+																double I_EPS,
+																double &amp; t1,double &amp; t2)
+{
+	double P1x(P1.x()) ;
+	double P1y(P1.y()) ;
+	double P2x(P2.x()) ;
+	double P2y(P2.y()) ;
+	double Q1x(Q1.x()) ;
+	double Q1y(Q1.y()) ;
+	double Q2x(Q2.x()) ;
+	double Q2y(Q2.y()) ;
+
+	double a2 = -(Q2y - P2y) ;
+	double b2 =  (Q2x - P2x) ;
+	double c2 =  P2x*a2+P2y*b2 ;
+
+	double a1 = -(Q1y - P1y) ;
+	double b1 =  (Q1x - P1x) ;
+	double c1 =  P1x*a1+P1y*b1 ;
+
+	double d2 = a2*(Q1x-P1x)+b2*(Q1y-P1y) ;
+	double d1 = a1*(Q2x-P2x)+b1*(Q2y-P2y) ;
+
+	if((fabs(d2) &lt;= fabs(I_EPS))||(fabs(d1) &lt;= fabs(I_EPS)))	// les segments sont paralleles
+	{
+		if(fabs(a2*P1x + b2*P1y - c2) &gt;= I_EPS)
+			return false ;
+
+		double tP1,tQ1 ;
+
+		if(P1x != Q1x)
+		{
+			tP1 = (P2x-P1x)/(Q1x-P1x) ;
+			tQ1 = (Q2x-P1x)/(Q1x-P1x) ;
+		}
+		else if(P1y != Q1y)
+		{
+			tP1 = (P2y-P1y)/(Q1y-P1y) ;
+			tQ1 = (Q2y-P1y)/(Q1y-P1y) ;
+		}
+		else
+		{
+#ifdef DEBUG_TS
+			printf(&quot;IntersectSegments2D:: Error ! One segment has length 0\n&quot;) ;
+			printf(&quot;This special case is not treated yet.\n&quot;) ;
+#endif
+			return false ;
+		}
+
+		double tPQM = max(tP1,tQ1) ;
+		double tPQm = min(tP1,tQ1) ;
+
+		if(( tPQM &lt; -I_EPS) || (tPQm &gt; 1.0+I_EPS))
+			return false ;
+
+		if(tPQm &gt; 0.0)
+		{
+			t1 = tPQm ;
+			t2 = 0.0 ;
+		}
+		else
+		{
+			t1 = 0.0 ;
+			if(P2x != Q2x)
+				t2 = (P1x-P2x)/(Q2x-P2x) ;
+			else if(P2y != Q2y)
+				t2 = (P1y-P2y)/(Q2y-P2y) ;
+			else
+			{
+#ifdef DEBUG_TS
+				printf(&quot;IntersectSegments2D:: Error ! One segment has length 0\n&quot;) ;
+				printf(&quot;This special case is not treated yet.\n&quot;) ;
+#endif
+				return false ;
+			}
+		}
+
+		return true ;
+	}
+	else
+	{
+		t2 = (c1 - a1*P2x - b1*P2y)/d1 ;
+		t1 = (c2 - a2*P1x - b2*P1y)/d2 ;
+
+		if((t2 &gt; 1+I_EPS)||(t2 &lt; -I_EPS)||(t1 &gt; 1+I_EPS)||(t1 &lt; -I_EPS))
+			return false ;
+
+		return true ;
+	}
+}
+
+gpc_polygon PrimitivePositioning::createGPCPolygon_XY(const Polygone *P)
+{
+	gpc_polygon p ;
+
+	p.num_contours = 0 ;
+	p.hole = NULL ;
+	p.contour = NULL ;
+
+	gpc_vertex_list *gpc_p_verts = new gpc_vertex_list ;
+
+	gpc_p_verts-&gt;num_vertices = P-&gt;nbVertices() ;
+	gpc_p_verts-&gt;vertex = new gpc_vertex[P-&gt;nbVertices()] ;
+
+	for(int i=0;i&lt;P-&gt;nbVertices();++i)
+	{
+		gpc_p_verts-&gt;vertex[i].x = P-&gt;vertex(i).x() ;
+		gpc_p_verts-&gt;vertex[i].y = P-&gt;vertex(i).y() ;
+	}
+
+	gpc_add_contour(&amp;p,gpc_p_verts,false) ;
+
+	return p ;
+}
+
+void PrimitivePositioning::getsigns(const Primitive *P,const NVector3&amp; v,double C,
+												vector&lt;int&gt;&amp; signs,vector&lt;double&gt;&amp; zvals,int&amp; Smin,int&amp; Smax,double I_EPS)
+{
+	if(P == NULL)
+		throw runtime_error(&quot;Null primitive in getsigns !&quot;) ;
+
+	int n = P-&gt;nbVertices() ;
+
+	Smin =  1 ;
+	Smax = -1 ;
+
+	// On classe les sommets en fonction de leur signe
+
+	double zmax = -FLT_MAX ;
+	double zmin =  FLT_MAX ;
+	zvals.resize(n) ;
+
+	for(int i=0;i&lt;n;i++)
+	{
+		double Z = P-&gt;vertex(i) * v - C ;
+
+		if(Z &gt; zmax) zmax = Z ;
+		if(Z &lt; zmin) zmin = Z ;
+
+		zvals[i] = Z ;
+	}
+
+	signs.resize(n) ;
+
+	for(int j=0;j&lt;n;j++)
+	{
+		if(zvals[j] &lt; -I_EPS)
+			signs[j] = -1 ;
+		else if(zvals[j] &gt; I_EPS)
+			signs[j] = 1 ;
+		else
+			signs[j] = 0 ;
+
+		if(Smin &gt; signs[j]) Smin = signs[j] ;
+		if(Smax &lt; signs[j]) Smax = signs[j] ;
+	}
+}
+
+void PrimitivePositioning::split(Polygone *P,const NVector3&amp; v,double C,Primitive *&amp; P_plus,Primitive *&amp; P_moins)
+{
+	vector&lt;int&gt; Signs ;
+	vector&lt;double&gt; Zvals ;
+
+	P_plus = NULL ;
+	P_moins = NULL ;
+
+	int Smin = 1 ;
+	int Smax = -1 ;
+
+	getsigns(P,v,C,Signs,Zvals,Smin,Smax,_EPS) ;
+
+	int n = P-&gt;nbVertices() ;
+
+	if((Smin == 0)&amp;&amp;(Smax == 0)){ P_moins = P ; P_plus = NULL ; return ; }	// Polygone inclus dans le plan
+	if(Smin == 1) 					{ P_plus = P ; P_moins = NULL ; return ; }	// Polygone tout positif
+	if(Smax == -1) 					{ P_plus = NULL ; P_moins = P ; return ; }	// Polygone tout negatif
+
+	if((Smin == -1)&amp;&amp;(Smax == 0)) { P_plus = NULL ; P_moins = P ; return ; }	// Polygone tout negatif ou null
+	if((Smin == 0)&amp;&amp;(Smax == 1))  { P_plus = P ; P_moins = NULL ; return ; }	// Polygone tout positif ou null
+
+	// Reste le cas Smin = -1 et Smax = 1. Il faut couper
+
+	vector&lt;Feedback3DColor&gt; Ps ;
+	vector&lt;Feedback3DColor&gt; Ms ;
+
+	// On teste la coherence des signes.
+
+	int nZero = 0 ;
+	int nconsZero = 0 ;
+
+	for(int i=0;i&lt;n;i++)
+	{
+		if(Signs[i] == 0)
+		{
+			nZero++ ;
+
+			if(Signs[(i+1)%n] == 0)
+				nconsZero++ ;
+		}
+	}
+
+	// Ils y a des imprecisions numeriques dues au fait que le poly estpres du plan.
+	if((nZero &gt; 2)||(nconsZero &gt; 0)) { P_moins = P ; P_plus  = NULL ; return ; }
+
+	int dep=0 ; while(Signs[dep] == 0) dep++ ;
+	int prev_sign = Signs[dep] ;
+
+	for(int j=1;j&lt;=n;j++)
+	{
+		int sign = Signs[(j+dep)%n] ;
+
+		if(sign == prev_sign)
+		{
+			if(sign ==  1) Ps.push_back(P-&gt;sommet3DColor(j+dep)) ;
+			if(sign == -1) Ms.push_back(P-&gt;sommet3DColor(j+dep)) ;
+		}
+		else if(sign == -prev_sign)
+		{
+			//  Il faut effectuer le calcul en utilisant les memes valeurs que pour le calcul des signes,
+			// sinon on risque des incoherences dues aux imprecisions numeriques.
+
+			double Z1 = Zvals[(j+dep-1)%n] ;
+			double Z2 = Zvals[(j+dep)%n] ;
+
+			double t = fabs(Z1/(Z2 - Z1)) ;
+
+			if((t &lt; 0.0)||(t &gt; 1.0))
+			{
+				if(t &gt; 1.0) t = 1.0 ;
+				if(t &lt; 0.0) t = 0.0 ;
+			}
+			Feedback3DColor newVertex((1-t)*P-&gt;sommet3DColor(j+dep-1) + t*P-&gt;sommet3DColor(j+dep)) ;
+
+			Ps.push_back(newVertex) ;
+			Ms.push_back(newVertex) ;
+
+			if(sign == 1)
+				Ps.push_back(P-&gt;sommet3DColor(j+dep)) ;
+
+			if(sign == -1)
+				Ms.push_back(P-&gt;sommet3DColor(j+dep)) ;
+
+			prev_sign = sign ;
+		} // prev_sign != 0 donc necessairement sign = 0. Le sommet tombe dans le plan
+		else
+		{
+			Feedback3DColor newVertex = P-&gt;sommet3DColor(j+dep) ;
+
+			Ps.push_back(newVertex) ;
+			Ms.push_back(newVertex) ;
+
+			prev_sign = -prev_sign ;
+		}
+	}
+
+	if(Ps.size() &gt; 100 || Ms.size() &gt; 100 )
+		printf(&quot;Primitive::split: Error. nPs = %d, nMs = %d.\n&quot;,int(Ps.size()),int(Ms.size())) ;
+
+	// on suppose pour l'instant que les polygones sont convexes
+
+	if(Ps.size() == 1)
+		P_plus = new Point(Ps[0]) ;
+	else if(Ps.size() == 2)
+		P_plus = new Segment(Ps[0],Ps[1]) ;
+	else
+		P_plus  = new Polygone(Ps) ;
+
+	if(Ms.size() == 1)
+		P_moins = new Point(Ms[0]) ;
+	else if(Ms.size() == 2)
+		P_moins = new Segment(Ms[0],Ms[1]) ;
+	else
+		P_moins = new Polygone(Ms) ;
+}
+
+void PrimitivePositioning::split(Point *P,const NVector3&amp; v,double C,Primitive * &amp; P_plus,Primitive * &amp; P_moins)
+{
+	if(v*P-&gt;vertex(0)-C &gt; -_EPS)
+	{
+		P_plus = P ;
+		P_moins = NULL ;
+	}
+	else
+	{
+		P_moins = P ;
+		P_plus = NULL ;
+	}
+}
+
+void PrimitivePositioning::split(Segment *S,const NVector3&amp; v,double C,Primitive * &amp; P_plus,Primitive * &amp; P_moins)
+{
+	vector&lt;int&gt; Signs ;
+	vector&lt;double&gt; Zvals ;
+
+	P_plus = NULL ;
+	P_moins = NULL ;
+
+	int Smin = 1 ;
+	int Smax = -1 ;
+
+	getsigns(S,v,C,Signs,Zvals,Smin,Smax,_EPS) ;
+
+	int n = S-&gt;nbVertices() ;
+
+	if((Smin == 0)&amp;&amp;(Smax == 0)) 	{ P_moins = S ; P_plus = NULL ; return ; }	// Polygone inclus dans le plan
+	if(Smin == 1) 						{ P_plus = S ; P_moins = NULL ; return ; }	// Polygone tout positif
+	if(Smax == -1) 					{ P_plus = NULL ; P_moins = S ; return ; }	// Polygone tout negatif
+
+	if((Smin == -1)&amp;&amp;(Smax == 0)) { P_plus = NULL ; P_moins = S ; return ; }	// Polygone tout negatif ou null
+	if((Smin == 0)&amp;&amp;(Smax == 1))  { P_plus = S ; P_moins = NULL ; return ; }	// Polygone tout positif ou null
+
+	// Reste le cas Smin = -1 et Smax = 1. Il faut couper
+	// On teste la coherence des signes.
+
+	int nZero = 0 ;
+	int nconsZero = 0 ;
+
+	for(int i=0;i&lt;n;i++)
+	{
+		if(Signs[i] == 0)
+		{
+			nZero++ ;
+
+			if(Signs[(i+1)%n] == 0)
+				nconsZero++ ;
+		}
+	}
+
+	// Ils y a des imprecisions numeriques dues au fait que le poly estpres du plan.
+	if((nZero &gt; 2)||(nconsZero &gt; 0)) { P_moins = S ; P_plus  = NULL ; return ; }
+
+	double Z1 = Zvals[0] ;
+	double Z2 = Zvals[1] ;
+
+	double t = fabs(Z1/(Z2 - Z1)) ;
+
+	if((t &lt; 0.0)||(t &gt; 1.0))
+	{
+		if(t &gt; 1.0) t = 1.0 ;
+		if(t &lt; 0.0) t = 0.0 ;
+	}
+
+	Feedback3DColor newVertex = S-&gt;sommet3DColor(0) * (1-t) + S-&gt;sommet3DColor(1) * t ;
+
+	if(Signs[0] &lt; 0)
+	{
+		P_plus = new Segment(newVertex,S-&gt;sommet3DColor(1)) ;
+		P_moins = new Segment(S-&gt;sommet3DColor(0),newVertex) ;
+	}
+	else
+	{
+		P_plus = new Segment(S-&gt;sommet3DColor(0),newVertex) ;
+		P_moins = new Segment(newVertex,S-&gt;sommet3DColor(1)) ;
+	}
+}
+
+// splits primitive P by plane of equation v.X=c. The upper part is setup in a new primitive called prim_up and
+// the lower part is in prim_lo.
+
+void PrimitivePositioning::splitPrimitive(Primitive *P,const NVector3&amp; v,double c, Primitive *&amp; prim_up,Primitive *&amp; prim_lo)
+{
+	Polygone *p1 = dynamic_cast&lt;Polygone *&gt;(P) ; if(p1 != NULL) PrimitivePositioning::split(p1,v,c,prim_up,prim_lo) ;
+	Segment  *p2 = dynamic_cast&lt;Segment  *&gt;(P) ; if(p2 != NULL) PrimitivePositioning::split(p2,v,c,prim_up,prim_lo) ;
+	Point    *p3 = dynamic_cast&lt;Point    *&gt;(P) ; if(p3 != NULL) PrimitivePositioning::split(p3,v,c,prim_up,prim_lo) ;
+}
+

Added: trunk/lib/QGLViewer/VRender/PrimitivePositioning.h
===================================================================
--- trunk/lib/QGLViewer/VRender/PrimitivePositioning.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/PrimitivePositioning.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,105 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _PRIMITIVEPOSITIONING_H
+#define _PRIMITIVEPOSITIONING_H
+
+#include &lt;vector&gt;
+#include &quot;gpc.h&quot;
+
+namespace vrender
+{
+	class Primitive ;
+
+	// This class implements a static method for positioning two primitives relative to each other.
+
+	class PrimitivePositioning
+	{
+		public:
+			typedef enum { Independent = 0x0,
+								Upper 		= 0x1,
+								Lower 		= 0x2 } RelativePosition ;
+
+			static int computeRelativePosition(const Primitive *p1,const Primitive *p2) ;
+
+			static void splitPrimitive(Primitive *P,const NVector3&amp; v,double c,Primitive *&amp; prim_up,Primitive *&amp; prim_lo) ;
+
+			static void split(Segment *S,	const NVector3&amp; v,double C,Primitive * &amp; P_plus,Primitive * &amp; P_moins) ;
+			static void split(Point *P,	const NVector3&amp; v,double C,Primitive * &amp; P_plus,Primitive * &amp; P_moins) ;
+			static void split(Polygone *P,const NVector3&amp; v,double C,Primitive * &amp; P_plus,Primitive * &amp; P_moins) ;
+
+		private:
+			static void getsigns(const Primitive *P,const NVector3&amp; v,
+										double C,std::vector&lt;int&gt;&amp; signs,std::vector&lt;double&gt;&amp; zvals,
+										int&amp; Smin,int&amp; Smax,double I_EPS) ;
+
+			static int computeRelativePosition(const Polygone  *p1,const Polygone  *p2) ;
+			static int computeRelativePosition(const Polygone  *p1,const Segment   *p2) ;
+			static int computeRelativePosition(const Polygone  *p1,const Point     *p2) ;
+			static int computeRelativePosition(const Segment   *p1,const Segment   *p2) ;
+
+			//  2D intersection/positioning methods. Parameter I_EPS may be positive of negative
+			// depending on the wanted degree of conservativeness of the result.
+
+			static bool pointOutOfPolygon_XY(const Vector3&amp;  P,const Polygone *Q,double I_EPS) ;
+			static bool intersectSegments_XY(const Vector2&amp; P1,const Vector2&amp; Q1,
+														const Vector2&amp; P2,const Vector2&amp; Q2,
+														double I_EPS,double &amp; t1,double &amp; t2) ;
+			static gpc_polygon createGPCPolygon_XY(const Polygone *P) ;
+
+
+			static int inverseRP(int) ;
+
+			//  This value is *non negative*. It may be used with a negative sign
+			// in 2D methods such as pointOutOfPolygon() so as to rule the behaviour of
+			// the positionning.
+
+			static double _EPS ;
+	};
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/SortMethod.h
===================================================================
--- trunk/lib/QGLViewer/VRender/SortMethod.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/SortMethod.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,105 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _SORTMETHOD_H
+#define _SORTMETHOD_H
+
+#include &lt;vector&gt;
+#include &quot;Types.h&quot;
+
+namespace vrender
+{
+	// Class which implements the sorting of the primitives. An object of
+	class VRenderParams ;
+	class SortMethod
+	{
+		public:
+			SortMethod() {}
+			virtual ~SortMethod() {}
+
+			virtual void sortPrimitives(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) = 0 ;
+
+			void SetZDepth(FLOAT s) { zSize = s ; }
+			FLOAT ZDepth() const { return zSize ; }
+
+		protected:
+			FLOAT zSize ;
+	};
+
+	class DontSortMethod: public SortMethod
+	{
+		public:
+			DontSortMethod() {}
+			virtual ~DontSortMethod() {}
+
+			virtual void sortPrimitives(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) {}
+	};
+
+	class BSPSortMethod: public SortMethod
+	{
+		public:
+			BSPSortMethod() {} ;
+			virtual ~BSPSortMethod() {}
+
+			virtual void sortPrimitives(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) ;
+	};
+
+	class TopologicalSortMethod: public SortMethod
+	{
+		public:
+			TopologicalSortMethod() ;
+			virtual ~TopologicalSortMethod() {}
+
+			virtual void sortPrimitives(std::vector&lt;PtrPrimitive&gt;&amp;,VRenderParams&amp;) ;
+
+			void setBreakCycles(bool b) { _break_cycles = b ; }
+		private:
+			bool _break_cycles ;
+	};
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/TopologicalSortMethod.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,693 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;assert.h&gt;
+#include &quot;VRender.h&quot;
+#include &quot;Primitive.h&quot;
+#include &quot;PrimitivePositioning.h&quot;
+#include &quot;AxisAlignedBox.h&quot;
+#include &quot;SortMethod.h&quot;
+#include &quot;Vector2.h&quot;
+
+using namespace std ;
+using namespace vrender ;
+
+// #define DEBUG_TS
+
+namespace vrender
+{
+class TopologicalSortUtils
+{
+	public:
+		static void buildPrecedenceGraph(vector&lt;PtrPrimitive&gt;&amp; primitive_tab, vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph) ;
+
+		static void recursFindNeighbors(	const vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+													const vector&lt;int&gt;&amp; pindices,
+													vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+													const AxisAlignedBox_xy&amp;,int) ;
+
+		static void checkAndAddEdgeToGraph(int a,int b,vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph) ;
+		static void suppressPrecedence(int a,int b,vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph) ;
+
+		static void recursTopologicalSort(vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+													 vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+													 vector&lt;bool&gt;&amp; alread_rendered,
+													 vector&lt;bool&gt;&amp; alread_visited,
+													 vector&lt;PtrPrimitive&gt;&amp;,int,int&amp;,
+													 VRenderParams&amp; vparams,
+													 int info_cnt,int&amp; nbrendered) ;
+
+		static void recursTopologicalSort(vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+													 vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+													 vector&lt;bool&gt;&amp; alread_rendered,
+													 vector&lt;bool&gt;&amp; alread_visited,
+													 vector&lt;PtrPrimitive&gt;&amp;,int,
+													 vector&lt;int&gt;&amp; ancestors,
+													 int&amp;, int&amp;,
+													 VRenderParams&amp; vparams,
+													 int info_cnt,int&amp; nbrendered) ;
+
+		static void topologicalSort(	vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+												vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+												VRenderParams&amp;) ;
+
+		static void topologicalSortBreakCycles(vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+															vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+															VRenderParams&amp;) ;
+
+#ifdef DEBUG_TS
+		static void printPrecedenceGraph(const vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+													const vector&lt;PtrPrimitive&gt;&amp; primitive_tab) ;
+#endif
+};
+
+TopologicalSortMethod::TopologicalSortMethod()
+{
+	_break_cycles = false ;
+}
+
+void TopologicalSortMethod::sortPrimitives(vector&lt;PtrPrimitive&gt;&amp; primitive_tab,VRenderParams&amp; vparams)
+{
+	// 1 - build a precedence graph
+
+#ifdef DEBUG_TS
+	cout &lt;&lt; &quot;Computing precedence graph.&quot; &lt;&lt; endl ;
+	cout &lt;&lt; &quot;Old order: &quot; ;
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i) cout &lt;&lt; (void *)(primitive_tab[i]) &lt;&lt; &quot; &quot; ;
+	cout &lt;&lt; endl ;
+#endif
+	vector&lt; vector&lt;int&gt; &gt; precedence_graph(primitive_tab.size());
+	TopologicalSortUtils::buildPrecedenceGraph(primitive_tab,precedence_graph) ;
+
+#ifdef DEBUG_TS
+	TopologicalSortUtils::printPrecedenceGraph(precedence_graph,primitive_tab) ;
+#endif
+	// 2 - perform a topological sorting of the graph
+
+#ifdef DEBUG_TS
+	cout &lt;&lt; &quot;Sorting.&quot; &lt;&lt; endl ;
+#endif
+
+	if(_break_cycles)
+		TopologicalSortUtils::topologicalSortBreakCycles(precedence_graph, primitive_tab,vparams) ;
+	else
+		TopologicalSortUtils::topologicalSort(precedence_graph, primitive_tab,vparams) ;
+
+#ifdef DEBUG_TS
+	cout &lt;&lt; &quot;New order: &quot; ;
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i) cout &lt;&lt; (void *)(primitive_tab[i]) &lt;&lt; &quot; &quot; ;
+	cout &lt;&lt; endl ;
+#endif
+}
+
+#ifdef DEBUG_TS
+void TopologicalSortUtils::printPrecedenceGraph(const vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+																const vector&lt;PtrPrimitive&gt;&amp; primitive_tab)
+{
+	for(unsigned int i=0;i&lt;precedence_graph.size();++i)
+	{
+		cout &lt;&lt; i &lt;&lt; &quot; (&quot; &lt;&lt; primitive_tab[i]-&gt;nbVertices() &lt;&lt; &quot;) : &quot; ;
+		for(unsigned int j=0;j&lt;precedence_graph[i].size();++j)
+			cout &lt;&lt; precedence_graph[i][j] &lt;&lt; &quot; &quot; ;
+
+		cout &lt;&lt; endl ;
+	}
+}
+#endif
+
+void TopologicalSortUtils::buildPrecedenceGraph(vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+																vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph)
+{
+	// The precedence graph is constructed by first conservatively determining which
+	// primitives can possibly intersect using a quadtree. Candidate pairs of
+	// primitives are then carefully checked to compute their exact relative positionning.
+	//
+	// Because of the conservativeness of the quadtree, some pairs of primitives may be checked
+	// multiple times for intersection. Using a buffer of already computed results may proove
+	// very efficient.
+
+	// 0 - compute bounding box of the set of primitives.
+
+	AxisAlignedBox_xy BBox ;
+
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i)
+	{
+		BBox.include(Vector2(primitive_tab[i]-&gt;bbox().mini().x(),primitive_tab[i]-&gt;bbox().mini().y())) ;
+		BBox.include(Vector2(primitive_tab[i]-&gt;bbox().maxi().x(),primitive_tab[i]-&gt;bbox().maxi().y())) ;
+	}
+
+	// 1 - recursively find pairs.
+
+	vector&lt;int&gt; pindices(primitive_tab.size()) ;
+	for(unsigned int j=0;j&lt;pindices.size();++j)
+		pindices[j] = j ;
+
+	recursFindNeighbors(primitive_tab, pindices, precedence_graph, BBox,0) ;
+}
+
+void TopologicalSortUtils::recursFindNeighbors(const vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+																const vector&lt;int&gt;&amp; pindices,
+																vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+																const AxisAlignedBox_xy&amp; bbox,
+																int depth)
+{
+	static const unsigned int MAX_PRIMITIVES_IN_CELL = 5 ;
+
+	// Refinment: first decide which sub-cell each primitive meets, then call
+	// algorithm recursively.
+
+	if(primitive_tab.size() &gt; MAX_PRIMITIVES_IN_CELL)
+	{
+		vector&lt;int&gt; p_indices_min_min ;
+		vector&lt;int&gt; p_indices_min_max ;
+		vector&lt;int&gt; p_indices_max_min ;
+		vector&lt;int&gt; p_indices_max_max ;
+
+		double xmin = bbox.mini().x() ;
+		double ymin = bbox.mini().y() ;
+		double xmax = bbox.maxi().x() ;
+		double ymax = bbox.maxi().y() ;
+
+		double xMean = 0.5*(xmin+xmax) ;
+		double yMean = 0.5*(ymin+ymax) ;
+
+		for(unsigned int i=0;i&lt;pindices.size();++i)
+		{
+			bool left  = primitive_tab[pindices[i]]-&gt;bbox().mini().x() &lt;= xMean ;
+			bool right = primitive_tab[pindices[i]]-&gt;bbox().maxi().x() &gt;= xMean ;
+			bool down  = primitive_tab[pindices[i]]-&gt;bbox().mini().y() &lt;= yMean ;
+			bool up    = primitive_tab[pindices[i]]-&gt;bbox().maxi().y() &gt;= yMean ;
+
+			if(left  &amp;&amp; down) p_indices_min_min.push_back(pindices[i]) ;
+			if(right &amp;&amp; down) p_indices_max_min.push_back(pindices[i]) ;
+			if(left  &amp;&amp; up  ) p_indices_min_max.push_back(pindices[i]) ;
+			if(right &amp;&amp; up  ) p_indices_max_max.push_back(pindices[i]) ;
+		}
+
+		// checks if refining is not too much stupid
+
+		if(p_indices_min_min.size() &lt; pindices.size() &amp;&amp; p_indices_max_min.size() &lt; pindices.size()
+				&amp;&amp; p_indices_min_max.size() &lt; pindices.size() &amp;&amp; p_indices_max_max.size() &lt; pindices.size())
+		{
+			recursFindNeighbors(primitive_tab,p_indices_min_min,precedence_graph,AxisAlignedBox_xy(Vector2(xmin,xMean),Vector2(ymin,yMean)),depth+1) ;
+			recursFindNeighbors(primitive_tab,p_indices_min_max,precedence_graph,AxisAlignedBox_xy(Vector2(xmin,xMean),Vector2(yMean,ymax)),depth+1) ;
+			recursFindNeighbors(primitive_tab,p_indices_max_min,precedence_graph,AxisAlignedBox_xy(Vector2(xMean,xmax),Vector2(ymin,yMean)),depth+1) ;
+			recursFindNeighbors(primitive_tab,p_indices_max_max,precedence_graph,AxisAlignedBox_xy(Vector2(xMean,xmax),Vector2(yMean,ymax)),depth+1) ;
+			return ;
+		}
+	}
+
+	// No refinment either because it could not be possible, or because the number of primitives is below
+	// the predefined limit.
+
+	for(unsigned int i=0;i&lt;pindices.size();++i)
+		for(unsigned int j=i+1;j&lt;pindices.size();++j)
+		{
+			// Compute the position of j as regard to i
+
+			int prp = PrimitivePositioning::computeRelativePosition(	primitive_tab[pindices[i]], primitive_tab[pindices[j]]) ;
+
+			if(prp &amp; PrimitivePositioning::Upper) checkAndAddEdgeToGraph(pindices[j],pindices[i],precedence_graph) ;
+			if(prp &amp; PrimitivePositioning::Lower) checkAndAddEdgeToGraph(pindices[i],pindices[j],precedence_graph) ;
+		}
+}
+
+void TopologicalSortUtils::checkAndAddEdgeToGraph(int a,int b,vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph)
+{
+#ifdef DEBUG_TS
+	cout &lt;&lt; &quot;Trying to add &quot; &lt;&lt; a &lt;&lt; &quot; -&gt; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; ;
+#endif
+	bool found = false ;
+
+	for(unsigned int k=0;k&lt;precedence_graph[a].size() &amp;&amp; !found;++k)
+		if(precedence_graph[a][k] == b)
+			found = true ;
+
+#ifdef DEBUG_TS
+	if(found)
+		cout &lt;&lt; &quot;already&quot; &lt;&lt; endl ;
+	else
+		cout &lt;&lt; &quot;ok&quot; &lt;&lt; endl ;
+#endif
+	if(!found)
+		precedence_graph[a].push_back(b) ;
+}
+
+void TopologicalSortUtils::suppressPrecedence(int a,int b,vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph)
+{
+	vector&lt;int&gt; prec_tab = vector&lt;int&gt;(precedence_graph[a]) ;
+	bool trouve = false ;
+
+	for(unsigned int k=0;k&lt;prec_tab.size();++k)
+		if(prec_tab[k] == b)
+		{
+			prec_tab[k] = prec_tab[prec_tab.size()-1] ;
+			prec_tab.pop_back() ;
+		}
+
+	if(!trouve)
+		throw runtime_error(&quot;Unexpected error in suppressPrecedence&quot;) ;
+}
+
+void TopologicalSortUtils::topologicalSort(vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+														 vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+														 VRenderParams&amp; vparams)
+{
+	vector&lt;PtrPrimitive&gt; new_pr_tab ;
+	vector&lt;bool&gt; already_visited(primitive_tab.size(),false) ;
+	vector&lt;bool&gt; already_rendered(primitive_tab.size(),false) ;
+	int nb_skews = 0 ;
+
+	int info_cnt = primitive_tab.size()/200 + 1 ;
+	int nbrendered = 0 ;
+
+	// 1 - sorts primitives by rendering order
+
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i)
+		if(!already_rendered[i])
+			recursTopologicalSort(precedence_graph,primitive_tab,already_rendered,already_visited,new_pr_tab,i,nb_skews,vparams,info_cnt,nbrendered);
+
+#ifdef DEBUG_TS
+	if(nb_skews &gt; 0)
+		cout &lt;&lt; nb_skews &lt;&lt; &quot; cycles found.&quot; &lt;&lt; endl ;
+	else
+		cout &lt;&lt; &quot;No cycles found.&quot; &lt;&lt; endl ;
+#endif
+	primitive_tab = new_pr_tab ;
+}
+
+void TopologicalSortUtils::topologicalSortBreakCycles(vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+																		vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+																		VRenderParams&amp; vparams)
+{
+	vector&lt;PtrPrimitive&gt; new_pr_tab ;
+	vector&lt;bool&gt; already_visited(primitive_tab.size(),false) ;
+	vector&lt;bool&gt; already_rendered(primitive_tab.size(),false) ;
+	vector&lt;int&gt; ancestors ;
+	int nb_skews = 0 ;
+	int ancestors_backward_index ;
+
+	int info_cnt = primitive_tab.size()/200 + 1 ;
+	int nbrendered = 0 ;
+
+	// 1 - sorts primitives by rendering order
+
+	for(unsigned int i=0;i&lt;primitive_tab.size();++i)
+		if(!already_rendered[i])
+			recursTopologicalSort(precedence_graph,primitive_tab,already_rendered,already_visited,
+										new_pr_tab,i,ancestors,ancestors_backward_index,nb_skews,vparams,info_cnt,nbrendered) ;
+
+#ifdef DEBUG_TS
+	if(nb_skews &gt; 0)
+		cout &lt;&lt; nb_skews &lt;&lt; &quot; cycles found.&quot; &lt;&lt; endl ;
+	else
+		cout &lt;&lt; &quot;No cycles found.&quot; &lt;&lt; endl ;
+#endif
+	primitive_tab = new_pr_tab ;
+}
+
+void TopologicalSortUtils::recursTopologicalSort(	vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+																	vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+																	vector&lt;bool&gt;&amp; already_rendered,
+																	vector&lt;bool&gt;&amp; already_visited,
+																	vector&lt;PtrPrimitive&gt;&amp; new_pr_tab,
+																	int indx,
+																	int&amp; nb_cycles,
+																	VRenderParams&amp; vparams,
+																	int info_cnt,int&amp; nbrendered)
+{
+	// One must first render the primitives indicated by the precedence graph,
+	// then render the current primitive. Skews are detected, but and treated.
+
+	already_visited[indx] = true ;
+
+	for(unsigned int j=0;j&lt;precedence_graph[indx].size();++j)
+	{
+		// Both tests are important. If we ommit the second one, the recursion is
+		// always performed down to the next cycle, although this is useless if
+		// the current primitive was rendered already.
+
+		if(!already_visited[precedence_graph[indx][j]])
+		{
+			if(!already_rendered[precedence_graph[indx][j]])
+				recursTopologicalSort(	precedence_graph,primitive_tab,already_rendered,already_visited,
+												new_pr_tab,precedence_graph[indx][j],nb_cycles,vparams,info_cnt,nbrendered) ;
+		}
+		else //  A cycle is detected, but in this version, it is not broken.
+			++nb_cycles ;
+	}
+
+	if(!already_rendered[indx])
+	{
+		new_pr_tab.push_back(primitive_tab[indx]) ;
+
+		if((++nbrendered)%info_cnt==0)
+			vparams.progress(nbrendered/(float)primitive_tab.size(),string(&quot;Topological sort&quot;)) ;
+	}
+
+	already_rendered[indx] = true ;
+	already_visited[indx] = false ;
+}
+
+void TopologicalSortUtils::recursTopologicalSort(	vector&lt; vector&lt;int&gt; &gt;&amp; precedence_graph,
+																	vector&lt;PtrPrimitive&gt;&amp; primitive_tab,
+																	vector&lt;bool&gt;&amp; already_rendered,
+																	vector&lt;bool&gt;&amp; already_visited,
+																	vector&lt;PtrPrimitive&gt;&amp; new_pr_tab,
+																	int indx,
+																	vector&lt;int&gt;&amp; ancestors,
+																	int&amp; ancestors_backward_index,
+																	int&amp; nb_cycles,
+																	VRenderParams&amp; vparams,
+																	int info_cnt,int&amp; nbrendered)
+{
+	// One must first render the primitives indicated by the precedence graph,
+	// then render the current primitive. Skews are detected, but and treated.
+
+	already_visited[indx] = true ;
+	ancestors.push_back(indx) ;
+
+	for(unsigned int j=0;j&lt;precedence_graph[indx].size();++j)
+	{
+		// Both tests are important. If we ommit the second one, the recursion is
+		// always performed down to the next cycle, although this is useless if
+		// the current primitive was rendered already.
+
+		if(!already_visited[precedence_graph[indx][j]])
+		{
+			if(!already_rendered[precedence_graph[indx][j]])
+			{
+				recursTopologicalSort(	precedence_graph,primitive_tab,already_rendered,already_visited,
+												new_pr_tab,precedence_graph[indx][j],ancestors,ancestors_backward_index,nb_cycles,vparams,info_cnt,nbrendered) ;
+
+				if(ancestors_backward_index != INT_MAX &amp;&amp; ancestors.size() &gt; (unsigned int)(ancestors_backward_index+1))
+				{
+#ifdef DEBUG_TS
+					cout &lt;&lt; &quot;Returning early&quot; &lt;&lt; endl ;
+#endif
+					already_visited[indx] = false ;
+					ancestors.pop_back() ;
+					return;
+				}
+				if(ancestors_backward_index != INT_MAX) // we are returning from emergency. j must be re-tried
+					--j ;
+			}
+		}
+		else
+		{
+			//  A cycle is detected. It must be broken. The algorithm is the following: primitives of the cycle
+			// are successively split by a chosen splitting plane and the precendence graph is updated
+			// at the same time by re-computing primitive precedence. As soon as the cycle is broken,
+			// the algorithm stops and calls recursively calls on the new precedence graph. This necessarily
+			// happens because of the BSP-node nature of the current set of primitives.
+
+			// 0 - stats
+			++nb_cycles ;
+
+			// 0.5 - determine cycle beginning
+
+			int cycle_beginning_index = -1 ;
+			for(int i=ancestors.size()-1; i &gt;= 0 &amp;&amp; cycle_beginning_index &lt; 0;--i)
+				if(ancestors[i] == precedence_graph[indx][j])
+					cycle_beginning_index = i ;
+#ifdef DEBUG_TS
+			cout &lt;&lt; &quot;Unbreaking cycle : &quot; ;
+			for(unsigned int i=0;i&lt;ancestors.size();++i)
+				cout &lt;&lt; ancestors[i] &lt;&lt; &quot; &quot; ;
+			cout &lt;&lt; precedence_graph[indx][j] &lt;&lt; endl ;
+#endif
+#ifdef DEBUG_TS
+			assert(cycle_beginning_index &gt;= 0) ;
+#endif
+			// 1 - determine splitting plane
+
+			int split_prim_ancestor_indx = -1 ;
+			int split_prim_indx = -1 ;
+
+			// Go down ancestors tab, starting from the skewing primitive, and stopping at it.
+
+			for(unsigned int i2=cycle_beginning_index;i2&lt;ancestors.size() &amp;&amp; split_prim_ancestor_indx &lt; 0;++i2)
+				if(primitive_tab[ancestors[i2]]-&gt;nbVertices() &gt; 2)
+				{
+					split_prim_ancestor_indx = i2 ;
+					split_prim_indx = ancestors[i2] ;
+				}
+
+#ifdef DEBUG_TS
+			cout &lt;&lt; &quot;Split primitive index = &quot; &lt;&lt; split_prim_ancestor_indx &lt;&lt; &quot;(primitive = &quot; &lt;&lt; split_prim_indx &lt;&lt; &quot;)&quot; &lt;&lt; endl ;
+#endif
+			if(split_prim_indx &lt; 0)	// no need to unskew cycles between segments and points
+				continue ;
+
+			// 2 - split all necessary primitives
+
+			const Polygone *P = dynamic_cast&lt;const Polygone *&gt;(primitive_tab[split_prim_indx]) ;
+			const NVector3&amp; normal = NVector3(P-&gt;normal()) ;
+			double c(P-&gt;c()) ;
+			ancestors.push_back(precedence_graph[indx][j]) ;				// sentinel
+			ancestors.push_back(ancestors[cycle_beginning_index+1]) ;	// sentinel
+			bool cycle_broken = false ;
+
+			for(unsigned int i3=cycle_beginning_index+1;i3&lt;ancestors.size()-1 &amp;&amp; !cycle_broken;++i3)
+				if(ancestors[i3] != split_prim_indx)
+				{
+					bool prim_lower_ante_contains_im1 = false ;
+					bool prim_upper_ante_contains_im1 = false ;
+					bool prim_lower_prec_contains_ip1 = false ;
+					bool prim_upper_prec_contains_ip1 = false ;
+
+					Primitive *prim_upper = NULL ;
+					Primitive *prim_lower = NULL ;
+
+					PrimitivePositioning::splitPrimitive(primitive_tab[ancestors[i3]],normal,c,prim_upper,prim_lower) ;
+
+					if(prim_upper == NULL || prim_lower == NULL)
+						continue ;
+#ifdef DEBUG_TS
+					cout &lt;&lt; &quot;Splitted primitive &quot; &lt;&lt; ancestors[i3] &lt;&lt; endl ;
+#endif
+
+					vector&lt;int&gt; prim_upper_prec ;
+					vector&lt;int&gt; prim_lower_prec ;
+
+					vector&lt;int&gt; old_prec = vector&lt;int&gt;(precedence_graph[ancestors[i3]]) ;
+
+					int upper_indx = precedence_graph.size() ;
+					int lower_indx = ancestors[i3] ;
+
+					//  Updates the precedence graph downwards.
+
+					for(unsigned int k=0;k&lt;old_prec.size();++k)
+					{
+						int prp1 = PrimitivePositioning::computeRelativePosition(prim_upper,primitive_tab[old_prec[k]]) ;
+#ifdef DEBUG_TS
+						cout &lt;&lt; &quot;Compariing &quot; &lt;&lt; upper_indx &lt;&lt; &quot; and &quot; &lt;&lt; old_prec[k] &lt;&lt; &quot;: &quot; ;
+#endif
+						// It can not be Upper, because it was lower from the original primitive, but it is not
+						// necessary lower any longer because of the split.
+
+						if(prp1 &amp; PrimitivePositioning::Lower)
+						{
+#ifdef DEBUG_TS
+							cout &lt;&lt; &quot; &gt; &quot; &lt;&lt; endl ;
+#endif
+							prim_upper_prec.push_back(old_prec[k]) ;
+
+							if(old_prec[k] == ancestors[i3+1])
+								prim_upper_prec_contains_ip1 = true ;
+						}
+#ifdef DEBUG_TS
+						else
+							cout &lt;&lt; &quot; I &quot; &lt;&lt; endl ;
+#endif
+
+						int prp2 = PrimitivePositioning::computeRelativePosition(prim_lower,primitive_tab[old_prec[k]]) ;
+#ifdef DEBUG_TS
+						cout &lt;&lt; &quot;Compariing &quot; &lt;&lt; lower_indx &lt;&lt; &quot; and &quot; &lt;&lt; old_prec[k] &lt;&lt; &quot;: &quot; ;
+#endif
+						if(prp2 &amp; PrimitivePositioning::Lower)
+						{
+#ifdef DEBUG_TS
+							cout &lt;&lt; &quot; &gt; &quot; &lt;&lt; endl ;
+#endif
+							prim_lower_prec.push_back(old_prec[k]) ;
+
+							if(old_prec[k] == ancestors[i3+1])
+								prim_lower_prec_contains_ip1 = true ;
+						}
+#ifdef DEBUG_TS
+						else
+							cout &lt;&lt; &quot; I &quot; &lt;&lt; endl ;
+#endif
+					}
+
+					// We also have to update the primitives which are upper to the
+					// current one, because some of them may not be upper anymore.
+					// This would requires either a O(n^2) algorithm, or to store an
+					// dual precedence graph. For now it's O(n^2). This test can not
+					// be skipped because upper can still be lower to ancestors[i-1].
+
+					for(unsigned int l=0;l&lt;precedence_graph.size();++l)
+						if(l != (unsigned int)lower_indx)
+							for(int k=0;k&lt;(int)precedence_graph[l].size();++k)
+								if(precedence_graph[l][k] == ancestors[i3])
+								{
+									int prp1 = PrimitivePositioning::computeRelativePosition(prim_upper,primitive_tab[l]) ;
+
+									// It can not be Lower, because it was upper from the original primitive, but it is not
+									// necessary upper any longer because of the split.
+
+									if(prp1 &amp; PrimitivePositioning::Upper)
+									{
+										// Still upper. Add the new index at end of the array
+
+										precedence_graph[l].push_back(upper_indx) ;
+
+										if(l == (unsigned int)ancestors[i3-1])
+											prim_upper_ante_contains_im1 = true ;
+									}
+									// If the primitive is not upper anymore there is
+									// nothing to change since the index has changed.
+
+									int prp2 = PrimitivePositioning::computeRelativePosition(prim_lower,primitive_tab[l]) ;
+#ifdef DEBUG_TS
+									cout &lt;&lt; &quot;Compariing &quot; &lt;&lt; l &lt;&lt; &quot; and &quot; &lt;&lt; lower_indx  &lt;&lt; &quot;: &quot; ;
+#endif
+									if(prp2 &amp; PrimitivePositioning::Upper)
+									{
+#ifdef DEBUG_TS
+										cout &lt;&lt; &quot; &gt; &quot; &lt;&lt; endl ;
+#endif
+										if(l == (unsigned int)ancestors[i3-1])						 // The index is the same =&gt; nothing to change.
+											prim_lower_ante_contains_im1 = true ;
+									}
+									else
+									{
+#ifdef DEBUG_TS
+										cout &lt;&lt; &quot; I &quot; &lt;&lt; endl ;
+#endif
+										// Not upper anymore. We have to suppress this entry from the tab.
+
+										precedence_graph[l][k] = precedence_graph[l][precedence_graph[l].size()-1] ;
+										precedence_graph[l].pop_back() ;
+										--k ;
+									}
+
+									break ;	// each entry is present only once.
+								}
+
+					// setup recorded new info
+
+					primitive_tab.push_back(prim_upper) ;
+					delete primitive_tab[lower_indx] ;
+					primitive_tab[lower_indx] = prim_lower ;
+
+					// Adds the info to the precedence graph
+
+					precedence_graph.push_back(prim_upper_prec) ;
+					precedence_graph[lower_indx] = prim_lower_prec ;
+
+					// Adds new entries to the 'already_rendered' and 'already_visited' vectors
+					already_visited.push_back(false) ;
+					already_rendered.push_back(false) ;
+#ifdef DEBUG_TS
+					cout &lt;&lt; &quot;New precedence graph: &quot; &lt;&lt; endl ;
+					printPrecedenceGraph(precedence_graph,primitive_tab) ;
+#endif
+					// Checks if the cycle is broken. Because the graph is only
+					// updated downwards, we check wether lower (which still is
+					// lower to ancestors[i-1]) is upper to ancestors[i+1], or
+					// if upper is still .
+
+					if(( !(prim_lower_ante_contains_im1 &amp;&amp; prim_lower_prec_contains_ip1))
+					  &amp;&amp;(!(prim_upper_ante_contains_im1 &amp;&amp; prim_upper_prec_contains_ip1)))
+						cycle_broken = true ;
+				}
+
+			ancestors.pop_back() ;
+			ancestors.pop_back() ;
+
+			// 3 - recurs call
+
+			if(cycle_broken)
+			{
+				ancestors_backward_index = cycle_beginning_index ;
+#ifdef DEBUG_TS
+				cout &lt;&lt; &quot;Cycle broken. Jumping back to rank &quot; &lt;&lt; ancestors_backward_index &lt;&lt; endl ;
+#endif
+				already_visited[indx] = false ;
+				ancestors.pop_back() ;
+				return;
+			}
+#ifdef DEBUG_TS
+			else
+				cout &lt;&lt; &quot;Cycle could not be broken !!&quot; &lt;&lt; endl ;
+#endif
+		}
+	}
+
+	if(!already_rendered[indx])
+	{
+#ifdef DEBUG_TS
+		cout &lt;&lt; &quot;Returning ok. Rendered primitive &quot; &lt;&lt; indx &lt;&lt; endl ;
+#endif
+		new_pr_tab.push_back(primitive_tab[indx]) ;
+
+		if((++nbrendered)%info_cnt==0)
+			vparams.progress(nbrendered/(float)primitive_tab.size(),string(&quot;Advanced topological sort&quot;)) ;
+	}
+
+	already_rendered[indx] = true ;
+	ancestors_backward_index = INT_MAX ;
+	already_visited[indx] = false ;
+	ancestors.pop_back() ;
+}
+} // namespace
+
+
+
+

Added: trunk/lib/QGLViewer/VRender/Types.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Types.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Types.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,77 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_TYPES_H
+#define _VRENDER_TYPES_H
+
+#ifdef WIN32
+# include &lt;windows.h&gt;
+#endif
+
+#ifdef __APPLE__
+# include &lt;OpenGL/gl.h&gt;
+#else
+# include &lt;GL/gl.h&gt;
+#endif
+
+namespace vrender
+{
+	typedef double FLOAT ;
+	typedef GLdouble GLFLOAT ;
+
+#ifdef A_VOIR
+	typedef T_Vect3&lt;double&gt; DVector3 ;
+	typedef T_Vect2&lt;double&gt; Vector2 ;
+#endif
+
+	class Primitive ;
+	typedef Primitive *PtrPrimitive ;
+
+	const float FLAT_POLYGON_EPS = 1e-5f ;
+}
+
+#endif

Added: trunk/lib/QGLViewer/VRender/VRender.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/VRender.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/VRender.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,287 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifdef WIN32
+# include &lt;windows.h&gt;
+#endif
+
+#ifdef __APPLE__
+# include &lt;OpenGL/gl.h&gt;
+#else
+# include &lt;GL/gl.h&gt;
+#endif
+
+#include &lt;stdio.h&gt;
+#include &lt;vector&gt;
+#include &quot;VRender.h&quot;
+#include &quot;ParserGL.h&quot;
+#include &quot;Exporter.h&quot;
+#include &quot;SortMethod.h&quot;
+#include &quot;Optimizer.h&quot;
+
+using namespace vrender ;
+using namespace std ;
+
+void vrender::VectorialRender(RenderCB render_callback, void *callback_params, VRenderParams&amp; vparams)
+{
+	GLfloat *feedbackBuffer = NULL ;
+	SortMethod *sort_method = NULL ;
+	Exporter *exporter = NULL ;
+
+	try
+	{
+		GLint returned = -1 ;
+
+		vparams.error() = 0 ;
+
+		int nb_renders = 0 ;
+
+		vparams.progress(0.0,string(&quot;Rendering&quot;)) ;
+
+		while(returned &lt; 0)
+		{
+			if(feedbackBuffer != NULL)
+				delete[] feedbackBuffer ;
+
+			feedbackBuffer = new GLfloat[vparams.size()] ;
+
+			if(feedbackBuffer == NULL)
+				throw std::runtime_error(&quot;Out of memory during feedback buffer allocation.&quot;) ;
+
+			glFeedbackBuffer(vparams.size(), GL_3D_COLOR, feedbackBuffer);
+			glRenderMode(GL_FEEDBACK);
+			render_callback(callback_params);
+			returned = glRenderMode(GL_RENDER);
+
+			nb_renders++ ;
+
+			if(returned &lt; 0)
+				vparams.size() *= 2 ;
+		}
+
+#ifdef A_VOIR
+		if(SortMethod != EPS_DONT_SORT)
+		{
+			GLint depth_bits ;
+			glGetIntegerv(GL_DEPTH_BITS, &amp;depth_bits) ;
+
+			EGALITY_EPS 		= 2.0/(1 &lt;&lt; depth_bits) ;
+			LINE_EGALITY_EPS 	= 2.0/(1 &lt;&lt; depth_bits) ;
+		}
+#endif
+		if (returned &gt; vparams.size())
+		    vparams.size() = returned;
+#ifdef _VRENDER_DEBUG
+		cout &lt;&lt; &quot;Size = &quot; &lt;&lt; vparams.size() &lt;&lt; &quot;, returned=&quot; &lt;&lt; returned &lt;&lt; endl ;
+#endif
+
+		//  On a un beau feedback buffer tout plein de saloperies. Faut aller
+		// defricher tout ca. Ouaiiiis !
+
+		vector&lt;PtrPrimitive&gt; primitive_tab ;
+
+		ParserGL parserGL ;
+		parserGL.parseFeedbackBuffer(feedbackBuffer,returned,primitive_tab,vparams) ;
+
+		if(feedbackBuffer != NULL)
+		{
+			delete[] feedbackBuffer ;
+			feedbackBuffer = NULL ;
+		}
+
+		if(vparams.isEnabled(VRenderParams::OptimizeBackFaceCulling))
+		{
+			BackFaceCullingOptimizer bfopt ;
+			bfopt.optimize(primitive_tab,vparams) ;
+		}
+
+		// Lance la methode de sorting
+
+		switch(vparams.sortMethod())
+		{
+			case VRenderParams::AdvancedTopologicalSort:
+			case VRenderParams::TopologicalSort: {
+																 TopologicalSortMethod *tsm = new TopologicalSortMethod() ;
+																 tsm-&gt;setBreakCycles(vparams.sortMethod() == VRenderParams::AdvancedTopologicalSort) ;
+																 sort_method = tsm ;
+															 }
+															 break ;
+
+			case VRenderParams::BSPSort: 				sort_method = new BSPSortMethod() ;
+																break ;
+
+			case VRenderParams::NoSorting: 			sort_method = new DontSortMethod() ;
+																break ;
+			default:
+																throw std::runtime_error(&quot;Unknown sorting method.&quot;) ;
+		}
+
+		sort_method-&gt;sortPrimitives(primitive_tab,vparams) ;
+
+		// Lance les optimisations. L'ordre est important.
+
+		if(vparams.isEnabled(VRenderParams::CullHiddenFaces))
+		{
+			VisibilityOptimizer vopt ;
+			vopt.optimize(primitive_tab,vparams) ;
+		}
+
+#ifdef A_FAIRE
+		if(vparams.isEnabled(VRenderParams::OptimizePrimitiveSplit))
+		{
+			PrimitiveSplitOptimizer psopt ;
+			psopt.optimize(primitive_tab) ;
+		}
+#endif
+		// Ecrit le fichier
+
+		switch(vparams.format())
+		{
+			case VRenderParams::EPS: exporter = new EPSExporter() ;
+											 break ;
+			case VRenderParams::PS:  exporter = new PSExporter() ;
+											 break ;
+			case VRenderParams::XFIG:exporter = new FIGExporter() ;
+											 break ;
+#ifdef A_FAIRE
+			case VRenderParams::SVG: exporter = new SVGExporter() ;
+											 break ;
+#endif
+			default:
+											 throw std::runtime_error(&quot;Sorry, this output format is not handled now. Only EPS and PS are currently supported.&quot;) ;
+		}
+
+		// sets background and black &amp; white options
+
+		GLfloat viewport[4],clearColor[4],lineWidth,pointSize ;
+
+		glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
+		glGetFloatv(GL_LINE_WIDTH, &amp;lineWidth);
+		glGetFloatv(GL_POINT_SIZE, &amp;pointSize);
+		glGetFloatv(GL_VIEWPORT, viewport);
+
+		lineWidth /= (float)max(viewport[2] - viewport[0],viewport[3]-viewport[1]) ;
+
+		// Sets which bounding box to use.
+
+		if(vparams.isEnabled(VRenderParams::TightenBoundingBox))
+			exporter-&gt;setBoundingBox(parserGL.xmin(),parserGL.ymin(),parserGL.xmax(),parserGL.ymax()) ;
+		else
+			exporter-&gt;setBoundingBox(viewport[0],viewport[1],viewport[0]+viewport[2],viewport[1]+viewport[3]) ;
+
+		exporter-&gt;setBlackAndWhite(vparams.isEnabled(VRenderParams::RenderBlackAndWhite)) ;
+		exporter-&gt;setClearBackground(vparams.isEnabled(VRenderParams::AddBackground)) ;
+		exporter-&gt;setClearColor(clearColor[0],clearColor[1],clearColor[2]) ;
+
+		exporter-&gt;exportToFile(vparams.filename(),primitive_tab,vparams) ;
+
+		// deletes primitives
+
+		for(unsigned int i=0;i&lt;primitive_tab.size();++i)
+			delete primitive_tab[i] ;
+
+		if(exporter != NULL) delete exporter ;
+		if(sort_method != NULL) delete sort_method ;
+	}
+	catch(exception&amp; e)
+	{
+		cout &lt;&lt; &quot;Render aborted: &quot; &lt;&lt; e.what() &lt;&lt; endl ;
+
+		if(exporter != NULL) delete exporter ;
+		if(sort_method != NULL) delete sort_method ;
+		if(feedbackBuffer != NULL) delete[] feedbackBuffer ;
+
+		throw e ;
+	}
+}
+
+VRenderParams::VRenderParams()
+{
+	_options = 0 ;
+	_format = EPS ;
+	_filename = NULL ;
+	_progress_function = NULL ;
+	_sortMethod = BSPSort ;
+}
+
+VRenderParams::~VRenderParams()
+{
+	if(_filename != NULL)
+		free(_filename) ;
+}
+
+
+void VRenderParams::progress(float f, const std::string&amp; progress_string)
+{
+	if(_progress_function != NULL)
+		_progress_function(f,progress_string) ;
+}
+
+void VRenderParams::setFilename(const char *fn)
+{
+	if(strlen(fn) &gt; 10000)
+		throw std::runtime_error(&quot;VectorialRender: filename too long.&quot;) ;
+
+	if(_filename != NULL)
+		free(_filename) ;
+
+	if((_filename = strdup(fn)) == NULL)
+		throw std::runtime_error(&quot;could not copy supplied filename. Out of memory ?&quot;) ;
+}
+
+void VRenderParams::setOption(VRenderOption opt,bool b)
+{
+	if(b)
+		_options |= opt ;
+	else
+		_options &amp;= ~opt ;
+}
+
+bool VRenderParams::isEnabled(VRenderOption opt)
+{
+	return (_options &amp; opt) &gt; 0 ;
+}

Added: trunk/lib/QGLViewer/VRender/VRender.h
===================================================================
--- trunk/lib/QGLViewer/VRender/VRender.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/VRender.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,117 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_H_
+#define _VRENDER_H_
+
+#include &lt;string&gt;
+
+namespace vrender
+{
+	class VRenderParams ;
+	typedef void (*RenderCB)(void *) ;
+	typedef void (*ProgressFunction)(float,const std::string&amp;) ;
+
+	void VectorialRender(RenderCB DrawFunc, void *callback_params, VRenderParams&amp; render_params) ;
+
+	class VRenderParams
+	{
+		public:
+			VRenderParams() ;
+			~VRenderParams() ;
+
+			enum VRenderSortMethod { NoSorting, BSPSort, TopologicalSort, AdvancedTopologicalSort };
+			enum VRenderFormat     { EPS, PS, XFIG, SVG };
+
+			enum VRenderOption {	CullHiddenFaces         = 0x1,
+						OptimizeBackFaceCulling = 0x4,
+						RenderBlackAndWhite     = 0x8,
+						AddBackground           = 0x10,
+						TightenBoundingBox      = 0x20 } ;
+
+			int sortMethod()    { return _sortMethod; }
+			void setSortMethod(VRenderParams::VRenderSortMethod s) { _sortMethod = s ; }
+
+			int format()        { return _format; }
+			void setFormat(VRenderFormat f) { _format = f; }
+
+			const char *filename() { return _filename ; }
+			void setFilename(const char *s) ;
+
+			void setOption(VRenderOption,bool) ;
+			bool isEnabled(VRenderOption) ;
+
+			void setProgressFunction(ProgressFunction pf) { _progress_function = pf ; }
+
+		private:
+			int _error;
+			VRenderSortMethod _sortMethod;
+			VRenderFormat     _format ;
+
+			ProgressFunction _progress_function ;
+
+			unsigned int _options; // _DrawMode; _ClearBG; _TightenBB;
+			char *_filename;
+
+			friend void VectorialRender(	RenderCB render_callback,
+							void *callback_params,
+							VRenderParams&amp; vparams);
+			friend class ParserGL ;
+			friend class Exporter ;
+			friend class BSPSortMethod ;
+			friend class VisibilityOptimizer ;
+			friend class TopologicalSortMethod ;
+			friend class TopologicalSortUtils ;
+
+			int&amp; error() { return _error ; }
+			int&amp; size()  { static int size=1000000; return size ; }
+
+			void progress(float,const std::string&amp;) ;
+	};
+}
+#endif
+

Added: trunk/lib/QGLViewer/VRender/Vector2.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector2.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Vector2.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,149 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;Vector2.h&quot;
+#include &quot;Vector3.h&quot;
+#include &lt;math.h&gt;
+
+#ifdef WIN32
+# include &lt;windows.h&gt;
+#endif
+
+using namespace vrender;
+using namespace std;
+
+const Vector2 Vector2::inf(FLT_MAX, FLT_MAX);
+
+//! Default constructor
+Vector2::Vector2 ()
+{
+  _xyz[0] = 0.0;
+  _xyz[1] = 0.0;
+}
+
+// -----------------------------------------------------------------------------
+//! Default destructor
+Vector2::~Vector2 ()
+{
+}
+
+// -----------------------------------------------------------------------------
+//! Copy constructor
+Vector2::Vector2 (const Vector2&amp; u)
+{
+  setXY(u[0],u[1]);
+}
+
+// -----------------------------------------------------------------------------
+//! Create a vector from real values
+Vector2::Vector2 (double x,double y)
+{
+  setXY(x,y);
+}
+
+Vector2::Vector2 (const Vector3&amp; u)
+{
+  _xyz[0] = u[0];
+  _xyz[1] = u[1];
+}
+
+// -----------------------------------------------------------------------------
+//! Inverse
+Vector2 vrender::operator- (const Vector2&amp; u)
+{
+  return Vector2(-u[0], -u[1]) ;
+}
+
+
+// -----------------------------------------------------------------------------
+//! Left multiplication by a real value
+Vector2 operator* (double r,const Vector2&amp; u)
+{
+  return Vector2(r*u[0], r*u[1]) ;
+}
+
+
+// -----------------------------------------------------------------------------
+//! Norm
+double Vector2::norm () const
+{
+  return sqrt( _xyz[0]*_xyz[0] + _xyz[1]*_xyz[1] );
+}
+
+// -----------------------------------------------------------------------------
+//! Square norm (self dot product)
+double Vector2::squareNorm () const
+{
+  return _xyz[0]*_xyz[0] + _xyz[1]*_xyz[1] ;
+}
+
+// -----------------------------------------------------------------------------
+//! Infinite norm
+double Vector2::infNorm() const
+{
+  return max(fabs(_xyz[0]),fabs(_xyz[1])) ;
+}
+
+
+// -----------------------------------------------------------------------------
+//! Out stream override: prints the 3 vector components
+std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out,const Vector2&amp; u)
+{
+  out &lt;&lt; u[0] &lt;&lt; &quot; &quot; &lt;&lt; u[1] ;
+  return ( out );
+}
+
+Vector2 Vector2::mini(const Vector2&amp; v1,const Vector2&amp; v2)
+{
+  return Vector2(min(v1[0],v2[0]),min(v1[1],v2[1])) ;
+}
+
+Vector2 Vector2::maxi(const Vector2&amp; v1,const Vector2&amp; v2)
+{
+  return Vector2(max(v1[0],v2[0]),max(v1[1],v2[1])) ;
+}
+

Added: trunk/lib/QGLViewer/VRender/Vector2.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector2.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Vector2.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,184 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_VECTOR2_H
+#define _VRENDER_VECTOR2_H
+
+#include &lt;stdexcept&gt;
+#include &lt;iostream&gt;
+
+namespace vrender
+{
+  class Vector3;
+
+  class Vector2
+	{
+		public:
+			// ---------------------------------------------------------------------------
+			//! @name Constant
+			//@{
+			static const Vector2 inf;
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Constructor(s) and destructor
+			//@{
+			Vector2 ();
+			~Vector2 ();
+			Vector2 (const Vector2&amp;);
+			Vector2 (const Vector3&amp; u);
+			Vector2 (double,double);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Access methods
+			//@{
+			inline double  x() const { return _xyz[0]; }
+			inline double  y() const { return _xyz[1]; }
+			inline void  setX(double r) { _xyz[0] = r; }
+			inline void  setY(double r) { _xyz[1] = r; }
+			inline void  setXY (double x,double y) { _xyz[0] = x; _xyz[1] = y; }
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Assignment
+			//@{
+			inline Vector2&amp; operator= (const Vector2&amp; u)  { _xyz[0] = u._xyz[0]; _xyz[1] = u._xyz[1]; return *this; }
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Comparisons
+			//@{
+			friend bool operator== (const Vector2&amp;,const Vector2&amp;);
+			friend bool operator!= (const Vector2&amp;,const Vector2&amp;);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Algebraic operations
+			//@{
+			inline Vector2&amp; operator+= (const Vector2&amp; v)
+			{
+				_xyz[0] += v._xyz[0];
+				_xyz[1] += v._xyz[1];
+				return *this;
+			}
+
+			inline Vector2&amp; operator-= (const Vector2&amp; v)
+			{
+				_xyz[0] -= v._xyz[0];
+				_xyz[1] -= v._xyz[1];
+				return *this;
+			}
+
+			inline Vector2&amp; operator*= (double f) { _xyz[0] *= f; _xyz[1] *= f; return *this;}
+			inline Vector2&amp; operator/= (double f) { _xyz[0] /= f; _xyz[1] /= f; return *this;}
+
+			friend Vector2 operator- (const Vector2&amp;);
+			static Vector2 mini(const Vector2&amp;,const Vector2&amp;) ;
+			static Vector2 maxi(const Vector2&amp;,const Vector2&amp;) ;
+
+			inline Vector2 operator+(const Vector2&amp; u) const
+			{
+				return Vector2(_xyz[0]+u._xyz[0],_xyz[1]+u._xyz[1]);
+			}
+			inline Vector2 operator-(const Vector2&amp; u) const
+			{
+				return Vector2(_xyz[0]-u._xyz[0],_xyz[1]-u._xyz[1]);
+			}
+
+			inline double    operator*(const Vector2&amp; u) const
+			{
+				return _xyz[0]*u._xyz[0] + _xyz[1]*u._xyz[1] ;
+			}
+
+			inline double operator^(const Vector2&amp; v) const
+			{
+				return _xyz[0]*v._xyz[1] - _xyz[1]*v._xyz[0] ;
+			}
+
+			Vector2 operator/ (double v) { return Vector2(_xyz[0]/v,_xyz[1]/v); }
+			Vector2 operator* (double v) { return Vector2(_xyz[0]*v,_xyz[1]*v); }
+
+			friend Vector2 operator* (double,const Vector2&amp;);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Metrics
+			//@{
+			double norm       () const;
+			double squareNorm () const;
+			double infNorm    () const; /// Should be used for most comparisons, for efficiency reasons.
+			//@}
+			// ---------------------------------------------------------------------------
+			//! @name Stream overrides
+			//@{
+			friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp;,const Vector2&amp;);
+			//@}
+
+			double  operator[] (int i) const
+			{
+				if((i &lt; 0)||(i &gt; 1))
+					throw std::runtime_error(&quot;Out of bounds in Vector2::operator[]&quot;) ;
+
+				return _xyz[i];
+			}
+
+			double&amp; operator[] (int i)
+			{
+				if((i &lt; 0)||(i &gt; 1))
+					throw std::runtime_error(&quot;Out of bounds in Vector2::operator[]&quot;) ;
+
+				return _xyz[i];
+			}
+
+		private:
+			double _xyz[2];  //!&lt; The 3 vector components
+
+	}; // interface of Vector2
+}
+
+#endif // _VECTOR2_H

Added: trunk/lib/QGLViewer/VRender/Vector3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector3.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Vector3.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,172 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;iostream&gt;
+#include &quot;Vector3.h&quot;
+#include &quot;NVector3.h&quot;
+#include &lt;math.h&gt;
+
+#ifdef WIN32
+# include &lt;windows.h&gt;
+#endif
+
+using namespace vrender;
+using namespace std;
+
+const Vector3 Vector3::inf(FLT_MAX, FLT_MAX, FLT_MAX); 
+
+Vector3::Vector3 ()
+{
+  _xyz[0] = 0.0;
+  _xyz[1] = 0.0;
+  _xyz[2] = 0.0;
+}
+
+// -----------------------------------------------------------------------------
+//! Default destructor
+Vector3::~Vector3 ()
+{
+}
+
+// -----------------------------------------------------------------------------
+//! Copy constructor
+Vector3::Vector3 (const Vector3&amp; u)
+{
+  setXYZ(u[0],u[1],u[2]);
+}
+
+// -----------------------------------------------------------------------------
+//! Copy constructor from a normalized vector
+Vector3::Vector3 (const NVector3&amp; u)
+{
+  setXYZ(u[0],u[1],u[2]);
+}
+
+// -----------------------------------------------------------------------------
+//! Create a vector from real values
+Vector3::Vector3 (double x,double y,double z)
+{
+  setXYZ(x,y,z);
+}
+// -----------------------------------------------------------------------------
+//! Assignment with a normalized vector
+Vector3&amp; Vector3::operator= (const NVector3&amp; u)
+{
+  _xyz[0] = u[0];
+  _xyz[1] = u[1];
+  _xyz[2] = u[2];
+  return ( *this );
+}
+
+// -----------------------------------------------------------------------------
+//! Self addition with a normalized vector
+Vector3&amp; Vector3::operator+= (const NVector3&amp; u)
+{
+  _xyz[0] += u[0];
+  _xyz[1] += u[1];
+  _xyz[2] += u[2];
+  return ( *this );
+}
+
+// -----------------------------------------------------------------------------
+//! Self substraction with a normalized vector
+Vector3&amp; Vector3::operator-= (const NVector3&amp; u)
+{
+  _xyz[0] -= u[0];
+  _xyz[1] -= u[1];
+  _xyz[2] -= u[2];
+  return ( *this );
+}
+
+// -----------------------------------------------------------------------------
+//! Left multiplication by a real value
+Vector3 vrender::operator* (double r,const Vector3&amp; u)
+{
+  return ( Vector3(r*u[0], r*u[1], r*u[2]) );
+}
+
+
+// -----------------------------------------------------------------------------
+//! Norm
+double Vector3::norm () const
+{
+  return sqrt( _xyz[0]*_xyz[0] + _xyz[1]*_xyz[1] + _xyz[2]*_xyz[2] );
+}
+
+// -----------------------------------------------------------------------------
+//! Square norm (self dot product)
+double Vector3::squareNorm () const
+{
+  return _xyz[0]*_xyz[0] + _xyz[1]*_xyz[1] + _xyz[2]*_xyz[2];
+}
+
+// -----------------------------------------------------------------------------
+//! Infinite norm
+double Vector3::infNorm() const
+{
+  return max(max(fabs(_xyz[0]),fabs(_xyz[1])),fabs(_xyz[2])) ;
+}
+
+
+// -----------------------------------------------------------------------------
+//! Out stream override: prints the 3 vector components
+std::ostream&amp; vrender::operator&lt;&lt; (std::ostream&amp; out,const Vector3&amp; u)
+{
+  out &lt;&lt; u[0] &lt;&lt; &quot; &quot; &lt;&lt; u[1] &lt;&lt; &quot; &quot; &lt;&lt; u[2];
+  return ( out );
+}
+
+Vector3 Vector3::mini(const Vector3&amp; v1,const Vector3&amp; v2)
+{
+  return Vector3(min(v1[0],v2[0]),min(v1[1],v2[1]),min(v1[2],v2[2])) ;
+}
+
+Vector3 Vector3::maxi(const Vector3&amp; v1,const Vector3&amp; v2)
+{
+  return Vector3(max(v1[0],v2[0]),max(v1[1],v2[1]),max(v1[2],v2[2])) ;
+}
+

Added: trunk/lib/QGLViewer/VRender/Vector3.h
===================================================================
--- trunk/lib/QGLViewer/VRender/Vector3.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/Vector3.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,198 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef _VRENDER_VECTOR3_H
+#define _VRENDER_VECTOR3_H
+
+#include &lt;stdexcept&gt;
+
+#ifndef FLT_MAX
+# define FLT_MAX 9.99E20f
+#endif
+
+namespace vrender
+{
+  class NVector3;
+
+	class Vector3
+	{
+		public:
+			// ---------------------------------------------------------------------------
+			//! @name Constant
+			//@{
+			static const Vector3 inf;
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Constructor(s) and destructor
+			//@{
+			Vector3 ();
+			~Vector3 ();
+			Vector3 (const Vector3&amp;);
+			Vector3 (const NVector3&amp;);
+			Vector3 (double, double, double);
+
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Access methods
+			//@{
+			inline double  x() const { return _xyz[0]; }
+			inline double  y() const { return _xyz[1]; }
+			inline double  z() const { return _xyz[2]; }
+			inline void  setX(double r) { _xyz[0] = r; }
+			inline void  setY(double r) { _xyz[1] = r; }
+			inline void  setZ(double r) { _xyz[2] = r; }
+			inline void  setXYZ (double x,double y,double z) { _xyz[0] = x; _xyz[1] = y; _xyz[2] = z; }
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Assignment
+			//@{
+			inline Vector3&amp; operator= (const Vector3&amp; u)  { _xyz[0] = u._xyz[0]; _xyz[1] = u._xyz[1]; _xyz[2] = u._xyz[2]; return *this; }
+			Vector3&amp; operator= (const NVector3&amp; u);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Comparisons
+			//@{
+			friend bool operator== (const Vector3&amp;,const Vector3&amp;);
+			friend bool operator!= (const Vector3&amp;,const Vector3&amp;);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Algebraic operations
+			//@{
+			inline Vector3&amp; operator+= (const Vector3&amp; v)
+			{
+				_xyz[0] += v._xyz[0];
+				_xyz[1] += v._xyz[1];
+				_xyz[2] += v._xyz[2];
+				return *this;
+			}
+
+			inline Vector3&amp; operator-= (const Vector3&amp; v)
+			{
+				_xyz[0] -= v._xyz[0];
+				_xyz[1] -= v._xyz[1];
+				_xyz[2] -= v._xyz[2];
+				return *this;
+			}
+
+			inline Vector3&amp; operator*= (double f) { _xyz[0] *= f; _xyz[1] *= f; _xyz[2] *= f; return *this;}
+			inline Vector3&amp; operator/= (double f) { _xyz[0] /= f; _xyz[1] /= f; _xyz[2] /= f; return *this;}
+
+			static Vector3 mini(const Vector3&amp;,const Vector3&amp;) ;
+			static Vector3 maxi(const Vector3&amp;,const Vector3&amp;) ;
+
+			Vector3&amp; operator-= (const NVector3&amp;);
+			Vector3&amp; operator+= (const NVector3&amp;);
+
+			friend Vector3 operator- (const Vector3&amp; u) { return Vector3(-u[0], -u[1], -u[2]); }
+
+			inline Vector3 operator+(const Vector3&amp; u) const
+			{
+				return Vector3(_xyz[0]+u._xyz[0],_xyz[1]+u._xyz[1],_xyz[2]+u._xyz[2]);
+			}
+			inline Vector3 operator-(const Vector3&amp; u) const
+			{
+				return Vector3(_xyz[0]-u._xyz[0],_xyz[1]-u._xyz[1],_xyz[2]-u._xyz[2]);
+			}
+
+			inline double    operator*(const Vector3&amp; u) const
+			{
+				return _xyz[0]*u._xyz[0] + _xyz[1]*u._xyz[1] + _xyz[2]*u._xyz[2];
+			}
+
+			inline Vector3 operator^(const Vector3&amp; v) const
+			{
+				return Vector3(	_xyz[1]*v._xyz[2] - _xyz[2]*v._xyz[1],
+											_xyz[2]*v._xyz[0] - _xyz[0]*v._xyz[2],
+											_xyz[0]*v._xyz[1] - _xyz[1]*v._xyz[0]);
+			}
+
+			Vector3 operator/ (double v) { return Vector3(_xyz[0]/v,_xyz[1]/v,_xyz[2]/v); }
+			Vector3 operator* (double v) { return Vector3(_xyz[0]*v,_xyz[1]*v,_xyz[2]*v); }
+
+			friend Vector3 operator* (double,const Vector3&amp;);
+			//@}
+
+			// ---------------------------------------------------------------------------
+			//! @name Metrics
+			//@{
+			double norm       () const;
+			double squareNorm () const;
+			double infNorm    () const; /// Should be used for most comparisons, for efficiency reasons.
+			//@}
+			// ---------------------------------------------------------------------------
+			//! @name Stream overrides
+			//@{
+			friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp;,const Vector3&amp;);
+			//@}
+
+			double  operator[] (int i) const
+			{
+				if((i &lt; 0)||(i &gt; 2))
+					throw std::runtime_error(&quot;Out of bounds in Vector3::operator[]&quot;) ;
+
+				return _xyz[i];
+			}
+
+			double&amp; operator[] (int i)
+			{
+				if((i &lt; 0)||(i &gt; 2))
+					throw std::runtime_error(&quot;Out of bounds in Vector3::operator[]&quot;) ;
+
+				return _xyz[i];
+			}
+
+		private:
+			double _xyz[3];  //!&lt; The 3 vector components
+
+	}; // interface of Vector3
+}
+#endif // _VECTOR3_H

Added: trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/VisibilityOptimizer.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,283 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &lt;vector&gt;
+#include &quot;VRender.h&quot;
+#include &quot;Optimizer.h&quot;
+#include &quot;Primitive.h&quot;
+#include &quot;gpc.h&quot;
+#include &quot;math.h&quot;
+
+#undef DEBUG_EPSRENDER__SHOW1
+#ifdef DEBUG_EPSRENDER__SHOW1
+# include &quot;../qglviewer.h&quot;
+#endif
+
+using namespace vrender ;
+using namespace std ;
+
+#ifdef A_FAIRE
+void VisibilityOptimizer::optimize(vector&lt;PtrPrimitive&gt;&amp; primitives,float&amp; percentage_finished,string&amp; message)
+#else
+void VisibilityOptimizer::optimize(vector&lt;PtrPrimitive&gt;&amp; primitives,VRenderParams&amp; vparams)
+#endif
+{
+#ifdef DEBUG_VO
+	cout &lt;&lt; &quot;Optimizing visibility.&quot; &lt;&lt; endl ;
+#endif
+	int N = primitives.size()/200 + 1 ;
+
+#ifdef DEBUG_EPSRENDER__SHOW1
+//	cout &lt;&lt; &quot;Showing viewer.&quot; &lt;&lt; endl ;
+//	myViewer viewer ;
+//	viewer.show();
+	double minx =  FLT_MAX ;
+	double miny =  FLT_MAX ;
+	double maxx = -FLT_MAX ;
+	double maxy = -FLT_MAX ;
+	for(unsigned int i=0;i&lt;primitives.size();++i)
+		for(int j=0;j&lt;primitives[i]-&gt;nbVertices();++j)
+		{
+			if(maxx &lt; primitives[i]-&gt;vertex(j).x()) maxx = primitives[i]-&gt;vertex(j).x() ;
+			if(maxy &lt; primitives[i]-&gt;vertex(j).y()) maxy = primitives[i]-&gt;vertex(j).y() ;
+			if(minx &gt; primitives[i]-&gt;vertex(j).x()) minx = primitives[i]-&gt;vertex(j).x() ;
+			if(miny &gt; primitives[i]-&gt;vertex(j).y()) miny = primitives[i]-&gt;vertex(j).y() ;
+		}
+
+	glMatrixMode(GL_PROJECTION) ;
+	glLoadIdentity() ;
+	glOrtho(minx,maxx,miny,maxy,-1,1) ;
+	glMatrixMode(GL_MODELVIEW) ;
+	glLoadIdentity() ;
+
+	cout &lt;&lt; &quot;Window set to &quot; &lt;&lt; minx &lt;&lt; &quot; &quot; &lt;&lt; maxx &lt;&lt; &quot; &quot; &lt;&lt; miny &lt;&lt; &quot; &quot; &lt;&lt; maxy &lt;&lt; endl ;
+	glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT) ;
+	glLineWidth(3.0) ;
+#endif
+
+	int nb_culled = 0 ;
+
+	// Ca serait pas mal mieux avec une interface c++...
+
+	gpc_polygon cumulated_union ;
+	cumulated_union.num_contours = 0 ;
+	cumulated_union.hole = NULL ;
+	cumulated_union.contour = NULL ;
+	int nboptimised = 0 ;
+
+	for(int pindex = primitives.size() - 1; pindex &gt;= 0;--pindex,++nboptimised)
+		if(primitives[pindex] != NULL)
+		{
+#ifdef A_FAIRE
+			percentage_finished = pindex / (float)primitives.size() ;
+#endif
+
+			if(primitives[pindex]-&gt;nbVertices() &gt; 1)
+			{
+#ifdef DEBUG_VO
+				if(pindex%50==0)
+				{
+					char buff[500] ;
+					sprintf(buff,&quot;Left: % 6ld - Culled: % 6ld&quot;, (long)pindex,(long)nb_culled) ;
+					fprintf(stdout,buff);
+
+					for(unsigned int j=0;j&lt;strlen(buff);++j)
+						fprintf(stdout,&quot;\b&quot;) ;
+
+					fflush(stdout) ;
+				}
+#endif
+
+				try
+				{
+					PtrPrimitive p(primitives[pindex]) ;
+					gpc_polygon difference ;
+					gpc_polygon new_poly ;
+					gpc_polygon new_poly_reduced ;
+					new_poly.num_contours = 0 ;
+					new_poly.hole = NULL ;
+					new_poly.contour = NULL ;
+					new_poly_reduced.num_contours = 0 ;
+					new_poly_reduced.hole = NULL ;
+					new_poly_reduced.contour = NULL ;
+
+					// 1 - creates a gpc_polygon corresponding to the current primitive
+
+					gpc_vertex_list *new_poly_verts = new gpc_vertex_list ;
+					gpc_vertex_list *new_poly_reduced_verts = new gpc_vertex_list ;
+
+					double mx = 0.0 ;
+					double my = 0.0 ;
+
+					if(p-&gt;nbVertices() == 2)
+					{
+						new_poly_verts-&gt;num_vertices = 4 ;
+						new_poly_verts-&gt;vertex = new gpc_vertex[4] ;
+						new_poly_reduced_verts-&gt;num_vertices = 4 ;
+						new_poly_reduced_verts-&gt;vertex = new gpc_vertex[4] ;
+
+						double deps = 0.001 ;
+						double du = p-&gt;vertex(1).y()-p-&gt;vertex(0).y() ;
+						double dv = p-&gt;vertex(1).x()-p-&gt;vertex(0).x() ;
+						double n = sqrt(du*du+dv*dv) ;
+						du *= deps/n ;
+						dv *= deps/n ;
+						new_poly_verts-&gt;vertex[0].x = p-&gt;vertex(0).x() + du ;
+						new_poly_verts-&gt;vertex[0].y = p-&gt;vertex(0).y() + dv ;
+						new_poly_verts-&gt;vertex[1].x = p-&gt;vertex(1).x() + du ;
+						new_poly_verts-&gt;vertex[1].y = p-&gt;vertex(1).y() + dv ;
+						new_poly_verts-&gt;vertex[2].x = p-&gt;vertex(1).x() - du ;
+						new_poly_verts-&gt;vertex[2].y = p-&gt;vertex(1).y() - dv ;
+						new_poly_verts-&gt;vertex[3].x = p-&gt;vertex(0).x() - du ;
+						new_poly_verts-&gt;vertex[3].y = p-&gt;vertex(0).y() - dv ;
+
+						new_poly_reduced_verts-&gt;vertex[0].x = p-&gt;vertex(0).x() + du ;
+						new_poly_reduced_verts-&gt;vertex[0].y = p-&gt;vertex(0).y() + dv ;
+						new_poly_reduced_verts-&gt;vertex[1].x = p-&gt;vertex(1).x() + du ;
+						new_poly_reduced_verts-&gt;vertex[1].y = p-&gt;vertex(1).y() + dv ;
+						new_poly_reduced_verts-&gt;vertex[2].x = p-&gt;vertex(1).x() - du ;
+						new_poly_reduced_verts-&gt;vertex[2].y = p-&gt;vertex(1).y() - dv ;
+						new_poly_reduced_verts-&gt;vertex[3].x = p-&gt;vertex(0).x() - du ;
+						new_poly_reduced_verts-&gt;vertex[3].y = p-&gt;vertex(0).y() - dv ;
+					}
+					else
+					{
+						new_poly_verts-&gt;num_vertices = p-&gt;nbVertices() ;
+						new_poly_verts-&gt;vertex = new gpc_vertex[p-&gt;nbVertices()] ;
+
+						for(int i=0;i&lt;p-&gt;nbVertices();++i)
+						{
+							new_poly_verts-&gt;vertex[i].x = p-&gt;vertex(i).x() ;
+							new_poly_verts-&gt;vertex[i].y = p-&gt;vertex(i).y() ;
+							mx += p-&gt;vertex(i).x() ;
+							my += p-&gt;vertex(i).y() ;
+						}
+						mx /= p-&gt;nbVertices() ;
+						my /= p-&gt;nbVertices() ;
+
+						new_poly_reduced_verts-&gt;num_vertices = p-&gt;nbVertices() ;
+						new_poly_reduced_verts-&gt;vertex = new gpc_vertex[p-&gt;nbVertices()] ;
+
+						for(int j=0;j&lt;p-&gt;nbVertices();++j)
+						{
+							new_poly_reduced_verts-&gt;vertex[j].x = mx + (p-&gt;vertex(j).x() - mx)*0.999 ;
+							new_poly_reduced_verts-&gt;vertex[j].y = my + (p-&gt;vertex(j).y() - my)*0.999 ;
+						}
+					}
+					gpc_add_contour(&amp;new_poly,new_poly_verts,false) ;
+					gpc_add_contour(&amp;new_poly_reduced,new_poly_reduced_verts,false) ;
+
+					// 2 - computes the difference between this polygon, and the union of the
+					// 	preceeding ones.
+
+					gpc_polygon_clip(GPC_DIFF,&amp;new_poly_reduced,&amp;cumulated_union,&amp;difference) ;
+
+					// 3 - checks the difference. If void, the primitive is not visible: skip it
+					// 	and go to next primitive.
+
+					if(difference.num_contours == 0)
+					{
+						++nb_culled ;
+						delete p ;
+						primitives[pindex] = NULL ;
+						continue ;
+					}
+
+					// 4 - The primitive is visible. Let's add it to the cumulated union of
+					// 	primitives.
+
+					if(p-&gt;nbVertices() &gt; 2)
+					{
+						gpc_polygon cumulated_union_tmp ;
+						cumulated_union_tmp.num_contours = 0 ;
+						cumulated_union_tmp.hole = NULL ;
+						cumulated_union_tmp.contour = NULL ;
+
+						gpc_polygon_clip(GPC_UNION,&amp;new_poly,&amp;cumulated_union,&amp;cumulated_union_tmp) ;
+
+						gpc_free_polygon(&amp;cumulated_union) ;
+						cumulated_union = cumulated_union_tmp ;
+					}
+
+					gpc_free_polygon(&amp;new_poly) ;
+					gpc_free_polygon(&amp;new_poly_reduced) ;
+					gpc_free_polygon(&amp;difference) ;
+#ifdef DEBUG_EPSRENDER__SHOW1
+					glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT) ;
+
+					glColor3f(1.0,0.0,0.0) ;
+
+					for(int i=0;i&lt;cumulated_union.num_contours;++i)
+					{
+						glBegin(GL_LINE_LOOP) ;
+						for(int j=0;j&lt;cumulated_union.contour[i].num_vertices;++j)
+							glVertex2f(cumulated_union.contour[i].vertex[j].x,cumulated_union.contour[i].vertex[j].y) ;
+						glEnd() ;
+					}
+
+					glFlush() ;
+					glXSwapBuffers(glXGetCurrentDisplay(),glXGetCurrentDrawable()) ;
+#endif
+				}
+				catch(exception&amp; )
+				{
+					; // std::cout &lt;&lt; &quot;Could not treat primitive &quot; &lt;&lt; pindex &lt;&lt; &quot;: internal gpc error.&quot; &lt;&lt; endl ;
+				}
+			}
+
+			if(nboptimised%N==0)
+				vparams.progress(nboptimised/(float)primitives.size(),string(&quot;Visibility optimization&quot;)) ;
+		}
+
+#ifdef DEBUG_VO
+	cout &lt;&lt; nb_culled &lt;&lt; &quot; primitives culled over &quot; &lt;&lt; primitives.size() &lt;&lt; &quot;.&quot; &lt;&lt; endl ;
+#endif
+
+	gpc_free_polygon(&amp;cumulated_union) ;
+}
+
+

Added: trunk/lib/QGLViewer/VRender/gpc.cpp
===================================================================
--- trunk/lib/QGLViewer/VRender/gpc.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/gpc.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,2552 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+/*
+===========================================================================
+
+Project:   Generic Polygon Clipper
+
+           A new algorithm for calculating the difference, intersection,
+           exclusive-or or union of arbitrary polygon sets.
+
+File:      gpc.c
+Author:    Alan Murta (email: <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">gpc at cs.man.ac.uk</A>)
+Version:   2.32
+Date:      17th December 2004
+
+Copyright: (C) 1997-2004, Advanced Interfaces Group,
+           University of Manchester.
+
+           This software is free for non-commercial use. It may be copied,
+           modified, and redistributed provided that this copyright notice
+           is preserved on all copies. The intellectual property rights of
+           the algorithms used reside with the University of Manchester
+           Advanced Interfaces Group.
+
+           You may not use this software, in whole or in part, in support
+           of any commercial product without the express consent of the
+           author.
+
+           There is no warranty or other guarantee of fitness of this
+           software for any purpose. It is provided solely &quot;as is&quot;.
+
+===========================================================================
+*/
+
+
+/*
+===========================================================================
+                                Includes
+===========================================================================
+*/
+
+#include &lt;stdexcept&gt;
+#include &quot;gpc.h&quot;
+#include &lt;stdlib.h&gt;
+#include &lt;float.h&gt;
+#include &lt;math.h&gt;
+
+using namespace std ;
+
+/*
+===========================================================================
+                                Constants
+===========================================================================
+*/
+
+#ifndef TRUE
+#define FALSE              0
+#define TRUE               1
+#endif
+
+#define LEFT               0
+#define RIGHT              1
+
+#define ABOVE              0
+#define BELOW              1
+
+#define CLIP               0
+#define SUBJ               1
+
+#define INVERT_TRISTRIPS   FALSE
+
+
+/*
+===========================================================================
+                                 Macros
+===========================================================================
+*/
+
+#define EQ(a, b)           (fabs((a) - (b)) &lt;= GPC_EPSILON)
+
+#define PREV_INDEX(i, n)   ((i - 1 + n) % n)
+#define NEXT_INDEX(i, n)   ((i + 1    ) % n)
+
+#define OPTIMAL(v, i, n)   ((v[PREV_INDEX(i, n)].y != v[i].y) || \
+                            (v[NEXT_INDEX(i, n)].y != v[i].y))
+
+#define FWD_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y &gt;= v[i].vertex.y) \
+                         &amp;&amp; (v[NEXT_INDEX(i, n)].vertex.y &gt; v[i].vertex.y))
+
+#define NOT_FMAX(v, i, n)   (v[NEXT_INDEX(i, n)].vertex.y &gt; v[i].vertex.y)
+
+#define REV_MIN(v, i, n)   ((v[PREV_INDEX(i, n)].vertex.y &gt; v[i].vertex.y) \
+                         &amp;&amp; (v[NEXT_INDEX(i, n)].vertex.y &gt;= v[i].vertex.y))
+
+#define NOT_RMAX(v, i, n)   (v[PREV_INDEX(i, n)].vertex.y &gt; v[i].vertex.y)
+
+#define VERTEX(e,p,s,x,y)  {add_vertex(&amp;((e)-&gt;outp[(p)]-&gt;v[(s)]), x, y); \
+                            (e)-&gt;outp[(p)]-&gt;active++;}
+
+#define P_EDGE(d,e,p,i,j)  {(d)= (e); \
+                            do {(d)= (d)-&gt;prev;} while (!(d)-&gt;outp[(p)]); \
+                            (i)= (d)-&gt;bot.x + (d)-&gt;dx * ((j)-(d)-&gt;bot.y);}
+
+#define N_EDGE(d,e,p,i,j)  {(d)= (e); \
+                            do {(d)= (d)-&gt;next;} while (!(d)-&gt;outp[(p)]); \
+                            (i)= (d)-&gt;bot.x + (d)-&gt;dx * ((j)-(d)-&gt;bot.y);}
+
+#define MALLOC(p, b, s, t) {if ((b) &gt; 0) { \
+                            p= (t*)malloc(b); if (!(p)) { \
+                            fprintf(stderr, &quot;gpc malloc failure: %s\n&quot;, s); \
+                            exit(0);}} else p= NULL;}
+
+#define FREE(p)            {if (p) {free(p); (p)= NULL;}}
+
+
+/*
+===========================================================================
+                            Private Data Types
+===========================================================================
+*/
+
+typedef enum                        /* Edge intersection classes         */
+{
+  NUL,                              /* Empty non-intersection            */
+  EMX,                              /* External maximum                  */
+  ELI,                              /* External left intermediate        */
+  TED,                              /* Top edge                          */
+  ERI,                              /* External right intermediate       */
+  RED,                              /* Right edge                        */
+  IMM,                              /* Internal maximum and minimum      */
+  IMN,                              /* Internal minimum                  */
+  EMN,                              /* External minimum                  */
+  EMM,                              /* External maximum and minimum      */
+  LED,                              /* Left edge                         */
+  ILI,                              /* Internal left intermediate        */
+  BED,                              /* Bottom edge                       */
+  IRI,                              /* Internal right intermediate       */
+  IMX,                              /* Internal maximum                  */
+  FUL                               /* Full non-intersection             */
+} vertex_type;
+
+typedef enum                        /* Horizontal edge states            */
+{
+  NH,                               /* No horizontal edge                */
+  BH,                               /* Bottom horizontal edge            */
+  TH                                /* Top horizontal edge               */
+} h_state;
+
+typedef enum                        /* Edge bundle state                 */
+{
+  UNBUNDLED,                        /* Isolated edge not within a bundle */
+  BUNDLE_HEAD,                      /* Bundle head node                  */
+  BUNDLE_TAIL                       /* Passive bundle tail node          */
+} bundle_state;
+
+typedef struct v_shape              /* Internal vertex list datatype     */
+{
+  double              x;            /* X coordinate component            */
+  double              y;            /* Y coordinate component            */
+  struct v_shape     *next;         /* Pointer to next vertex in list    */
+} vertex_node;
+
+class polygon_node              /* Internal contour / tristrip type  */
+{
+	public:
+		polygon_node(): next(0),proxy(0) { v[0]=0; v[1]=0; }
+
+		int                 active;       /* Active flag / vertex count        */
+		int                 hole;         /* Hole / external contour flag      */
+		vertex_node        *v[2];         /* Left and right vertex list ptrs   */
+		polygon_node       *next;         /* Pointer to next polygon contour   */
+		polygon_node       *proxy;        /* Pointer to actual structure used  */
+} ;
+
+class edge_node
+{
+	public:
+		edge_node()
+			: prev(0),next(0),pred(0),succ(0),next_bound(0)
+			{
+				outp[0] = 0 ;
+				outp[1] = 0 ;
+			}
+		gpc_vertex          vertex;       /* Piggy-backed contour vertex data  */
+		gpc_vertex          bot;          /* Edge lower (x, y) coordinate      */
+		gpc_vertex          top;          /* Edge upper (x, y) coordinate      */
+		double              xb;           /* Scanbeam bottom x coordinate      */
+		double              xt;           /* Scanbeam top x coordinate         */
+		double              dx;           /* Change in x for a unit y increase */
+		int                 type;         /* Clip / subject edge flag          */
+		int                 bundle[2][2]; /* Bundle edge flags                 */
+		int                 bside[2];     /* Bundle left / right indicators    */
+		bundle_state        bstate[2];    /* Edge bundle state                 */
+		polygon_node       *outp[2];      /* Output polygon / tristrip pointer */
+		edge_node  *prev;         			 /* Previous edge in the AET          */
+		edge_node  *next;         			 /* Next edge in the AET              */
+		edge_node  *pred;         			 /* Edge connected at the lower end   */
+		edge_node  *succ;         			 /* Edge connected at the upper end   */
+		edge_node  *next_bound;   			 /* Pointer to next bound in LMT      */
+} ;
+
+class lmt_node          					 /* Local minima table                */
+{
+	public:
+		lmt_node() : first_bound(0),next(0) {}
+		double              y;            /* Y coordinate at local minimum     */
+		edge_node          *first_bound;  /* Pointer to bound list             */
+		lmt_node   			 *next;         /* Pointer to next local minimum     */
+} ;
+
+typedef struct sbt_t_shape          /* Scanbeam tree                     */
+{
+  double              y;            /* Scanbeam node y value             */
+  struct sbt_t_shape *less;         /* Pointer to nodes with lower y     */
+  struct sbt_t_shape *more;         /* Pointer to nodes with higher y    */
+} sb_tree;
+
+typedef struct it_shape             /* Intersection table                */
+{
+  edge_node          *ie[2];        /* Intersecting edge (bundle) pair   */
+  gpc_vertex          point;        /* Point of intersection             */
+  struct it_shape    *next;         /* The next intersection table node  */
+} it_node;
+
+typedef struct st_shape             /* Sorted edge table                 */
+{
+  edge_node          *edge;         /* Pointer to AET edge               */
+  double              xb;           /* Scanbeam bottom x coordinate      */
+  double              xt;           /* Scanbeam top x coordinate         */
+  double              dx;           /* Change in x for a unit y increase */
+  struct st_shape    *prev;         /* Previous edge in sorted list      */
+} st_node;
+
+typedef struct bbox_shape           /* Contour axis-aligned bounding box */
+{
+  double             xmin;          /* Minimum x coordinate              */
+  double             ymin;          /* Minimum y coordinate              */
+  double             xmax;          /* Maximum x coordinate              */
+  double             ymax;          /* Maximum y coordinate              */
+} bbox;
+
+
+/*
+===========================================================================
+                               Global Data
+===========================================================================
+*/
+
+/* Horizontal edge state transitions within scanbeam boundary */
+const h_state next_h_state[3][6]=
+{
+  /*        ABOVE     BELOW     CROSS */
+  /*        L   R     L   R     L   R */
+  /* NH */ {BH, TH,   TH, BH,   NH, NH},
+  /* BH */ {NH, NH,   NH, NH,   TH, TH},
+  /* TH */ {NH, NH,   NH, NH,   BH, BH}
+};
+
+
+/*
+===========================================================================
+                             Private Functions
+===========================================================================
+*/
+
+static void reset_it(it_node **it)
+{
+  it_node *itn;
+
+  while (*it)
+  {
+    itn= (*it)-&gt;next;
+    FREE(*it);
+    *it= itn;
+  }
+}
+
+
+static void reset_lmt(lmt_node **lmt)
+{
+  lmt_node *lmtn;
+
+  while (*lmt)
+  {
+    lmtn= (*lmt)-&gt;next;
+    FREE(*lmt);
+    *lmt= lmtn;
+  }
+}
+
+
+static void insert_bound(edge_node **b, edge_node *e)
+{
+  edge_node *existing_bound;
+
+  if (!*b)
+  {
+    /* Link node e to the tail of the list */
+    *b= e;
+  }
+  else
+  {
+    /* Do primary sort on the x field */
+    if (e[0].bot.x &lt; (*b)[0].bot.x)
+    {
+      /* Insert a new node mid-list */
+      existing_bound= *b;
+      *b= e;
+      (*b)-&gt;next_bound= existing_bound;
+    }
+    else
+    {
+      if (e[0].bot.x == (*b)[0].bot.x)
+      {
+        /* Do secondary sort on the dx field */
+        if (e[0].dx &lt; (*b)[0].dx)
+        {
+          /* Insert a new node mid-list */
+          existing_bound= *b;
+          *b= e;
+          (*b)-&gt;next_bound= existing_bound;
+        }
+        else
+        {
+          /* Head further down the list */
+          insert_bound(&amp;((*b)-&gt;next_bound), e);
+        }
+      }
+      else
+      {
+        /* Head further down the list */
+        insert_bound(&amp;((*b)-&gt;next_bound), e);
+      }
+    }
+  }
+}
+
+
+static edge_node **bound_list(lmt_node **lmt, double y)
+{
+  lmt_node *existing_node;
+
+  if (!*lmt)
+  {
+    /* Add node onto the tail end of the LMT */
+    MALLOC(*lmt, sizeof(lmt_node), &quot;LMT insertion&quot;, lmt_node);
+    (*lmt)-&gt;y= y;
+    (*lmt)-&gt;first_bound= NULL;
+    (*lmt)-&gt;next= NULL;
+    return &amp;((*lmt)-&gt;first_bound);
+  }
+  else
+    if (y &lt; (*lmt)-&gt;y)
+    {
+      /* Insert a new LMT node before the current node */
+      existing_node= *lmt;
+      MALLOC(*lmt, sizeof(lmt_node), &quot;LMT insertion&quot;, lmt_node);
+      (*lmt)-&gt;y= y;
+      (*lmt)-&gt;first_bound= NULL;
+      (*lmt)-&gt;next= existing_node;
+      return &amp;((*lmt)-&gt;first_bound);
+    }
+    else
+      if (y &gt; (*lmt)-&gt;y)
+        /* Head further up the LMT */
+        return bound_list(&amp;((*lmt)-&gt;next), y);
+      else
+        /* Use this existing LMT node */
+        return &amp;((*lmt)-&gt;first_bound);
+}
+
+
+static void add_to_sbtree(int *entries, sb_tree **sbtree, double y)
+{
+  if (!*sbtree)
+  {
+    /* Add a new tree node here */
+    MALLOC(*sbtree, sizeof(sb_tree), &quot;scanbeam tree insertion&quot;, sb_tree);
+    (*sbtree)-&gt;y= y;
+    (*sbtree)-&gt;less= NULL;
+    (*sbtree)-&gt;more= NULL;
+    (*entries)++;
+  }
+  else
+  {
+    if ((*sbtree)-&gt;y &gt; y)
+    {
+    /* Head into the 'less' sub-tree */
+      add_to_sbtree(entries, &amp;((*sbtree)-&gt;less), y);
+    }
+    else
+    {
+      if ((*sbtree)-&gt;y &lt; y)
+      {
+        /* Head into the 'more' sub-tree */
+        add_to_sbtree(entries, &amp;((*sbtree)-&gt;more), y);
+      }
+    }
+  }
+}
+
+
+static void build_sbt(int *entries, double *sbt, sb_tree *sbtree)
+{
+  if (sbtree-&gt;less)
+    build_sbt(entries, sbt, sbtree-&gt;less);
+  sbt[*entries]= sbtree-&gt;y;
+  (*entries)++;
+  if (sbtree-&gt;more)
+    build_sbt(entries, sbt, sbtree-&gt;more);
+}
+
+
+static void free_sbtree(sb_tree **sbtree)
+{
+  if (*sbtree)
+  {
+    free_sbtree(&amp;((*sbtree)-&gt;less));
+    free_sbtree(&amp;((*sbtree)-&gt;more));
+    FREE(*sbtree);
+  }
+}
+
+
+static int count_optimal_vertices(gpc_vertex_list c)
+{
+  int result= 0, i;
+
+  /* Ignore non-contributing contours */
+  if (c.num_vertices &gt; 0)
+  {
+    for (i= 0; i &lt; c.num_vertices; i++)
+      /* Ignore superfluous vertices embedded in horizontal edges */
+      if (OPTIMAL(c.vertex, i, c.num_vertices))
+        result++;
+  }
+  return result;
+}
+
+
+static edge_node *build_lmt(lmt_node **lmt, sb_tree **sbtree,
+                            int *sbt_entries, gpc_polygon *p, int type,
+                            gpc_op op)
+{
+  int          c, i, min, max, num_edges, v, num_vertices;
+  int          total_vertices= 0, e_index=0;
+  edge_node   *e, *edge_table;
+
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+    total_vertices+= count_optimal_vertices(p-&gt;contour[c]);
+
+  /* Create the entire input polygon edge table in one go */
+  MALLOC(edge_table, total_vertices * sizeof(edge_node), &quot;edge table creation&quot;, edge_node);
+  for(int k=0;k&lt;total_vertices;++k)
+	  edge_table[k] = edge_node() ;
+
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+  {
+    if (p-&gt;contour[c].num_vertices &lt; 0)
+    {
+      /* Ignore the non-contributing contour and repair the vertex count */
+      p-&gt;contour[c].num_vertices= -p-&gt;contour[c].num_vertices;
+    }
+    else
+    {
+      /* Perform contour optimisation */
+      num_vertices= 0;
+      for (i= 0; i &lt; p-&gt;contour[c].num_vertices; i++)
+        if (OPTIMAL(p-&gt;contour[c].vertex, i, p-&gt;contour[c].num_vertices))
+        {
+          edge_table[num_vertices].vertex.x= p-&gt;contour[c].vertex[i].x;
+          edge_table[num_vertices].vertex.y= p-&gt;contour[c].vertex[i].y;
+
+          /* Record vertex in the scanbeam table */
+          add_to_sbtree(sbt_entries, sbtree,
+                        edge_table[num_vertices].vertex.y);
+
+          num_vertices++;
+        }
+
+      /* Do the contour forward pass */
+      for (min= 0; min &lt; num_vertices; min++)
+      {
+        /* If a forward local minimum... */
+        if (FWD_MIN(edge_table, min, num_vertices))
+        {
+          /* Search for the next local maximum... */
+          num_edges= 1;
+          max= NEXT_INDEX(min, num_vertices);
+          while (NOT_FMAX(edge_table, max, num_vertices))
+          {
+            num_edges++;
+            max= NEXT_INDEX(max, num_vertices);
+          }
+
+          /* Build the next edge list */
+          e= &amp;edge_table[e_index];
+          e_index+= num_edges;
+          v= min;
+          e[0].bstate[BELOW]= UNBUNDLED;
+          e[0].bundle[BELOW][CLIP]= FALSE;
+          e[0].bundle[BELOW][SUBJ]= FALSE;
+          for (i= 0; i &lt; num_edges; i++)
+          {
+            e[i].xb= edge_table[v].vertex.x;
+            e[i].bot.x= edge_table[v].vertex.x;
+            e[i].bot.y= edge_table[v].vertex.y;
+
+            v= NEXT_INDEX(v, num_vertices);
+
+            e[i].top.x= edge_table[v].vertex.x;
+            e[i].top.y= edge_table[v].vertex.y;
+            e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
+                       (e[i].top.y - e[i].bot.y);
+            e[i].type= type;
+            e[i].outp[ABOVE]= NULL;
+            e[i].outp[BELOW]= NULL;
+            e[i].next= NULL;
+            e[i].prev= NULL;
+            e[i].succ= ((num_edges &gt; 1) &amp;&amp; (i &lt; (num_edges - 1))) ?
+                       &amp;(e[i + 1]) : NULL;
+            e[i].pred= ((num_edges &gt; 1) &amp;&amp; (i &gt; 0)) ? &amp;(e[i - 1]) : NULL;
+            e[i].next_bound= NULL;
+            e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
+            e[i].bside[SUBJ]= LEFT;
+          }
+          insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
+        }
+      }
+
+      /* Do the contour reverse pass */
+      for (min= 0; min &lt; num_vertices; min++)
+      {
+      /* If a reverse local minimum... */
+        if (REV_MIN(edge_table, min, num_vertices))
+        {
+          /* Search for the previous local maximum... */
+          num_edges= 1;
+          max= PREV_INDEX(min, num_vertices);
+          while (NOT_RMAX(edge_table, max, num_vertices))
+          {
+            num_edges++;
+            max= PREV_INDEX(max, num_vertices);
+          }
+
+          /* Build the previous edge list */
+          e= &amp;edge_table[e_index];
+          e_index+= num_edges;
+          v= min;
+          e[0].bstate[BELOW]= UNBUNDLED;
+          e[0].bundle[BELOW][CLIP]= FALSE;
+          e[0].bundle[BELOW][SUBJ]= FALSE;
+          for (i= 0; i &lt; num_edges; i++)
+          {
+            e[i].xb= edge_table[v].vertex.x;
+            e[i].bot.x= edge_table[v].vertex.x;
+            e[i].bot.y= edge_table[v].vertex.y;
+
+            v= PREV_INDEX(v, num_vertices);
+
+            e[i].top.x= edge_table[v].vertex.x;
+            e[i].top.y= edge_table[v].vertex.y;
+            e[i].dx= (edge_table[v].vertex.x - e[i].bot.x) /
+                       (e[i].top.y - e[i].bot.y);
+            e[i].type= type;
+            e[i].outp[ABOVE]= NULL;
+            e[i].outp[BELOW]= NULL;
+            e[i].next= NULL;
+            e[i].prev= NULL;
+            e[i].succ= ((num_edges &gt; 1) &amp;&amp; (i &lt; (num_edges - 1))) ?
+                       &amp;(e[i + 1]) : NULL;
+            e[i].pred= ((num_edges &gt; 1) &amp;&amp; (i &gt; 0)) ? &amp;(e[i - 1]) : NULL;
+            e[i].next_bound= NULL;
+            e[i].bside[CLIP]= (op == GPC_DIFF) ? RIGHT : LEFT;
+            e[i].bside[SUBJ]= LEFT;
+          }
+          insert_bound(bound_list(lmt, edge_table[min].vertex.y), e);
+        }
+      }
+    }
+  }
+  return edge_table;
+}
+
+
+static void add_edge_to_aet(edge_node **aet, edge_node *edge, edge_node *prev)
+{
+  if (!*aet)
+  {
+    /* Append edge onto the tail end of the AET */
+    *aet= edge;
+    edge-&gt;prev= prev;
+    edge-&gt;next= NULL;
+  }
+  else
+  {
+    /* Do primary sort on the xb field */
+    if (edge-&gt;xb &lt; (*aet)-&gt;xb)
+    {
+      /* Insert edge here (before the AET edge) */
+      edge-&gt;prev= prev;
+      edge-&gt;next= *aet;
+      (*aet)-&gt;prev= edge;
+      *aet= edge;
+    }
+    else
+    {
+      if (edge-&gt;xb == (*aet)-&gt;xb)
+      {
+        /* Do secondary sort on the dx field */
+        if (edge-&gt;dx &lt; (*aet)-&gt;dx)
+        {
+          /* Insert edge here (before the AET edge) */
+          edge-&gt;prev= prev;
+          edge-&gt;next= *aet;
+          (*aet)-&gt;prev= edge;
+          *aet= edge;
+        }
+        else
+        {
+          /* Head further into the AET */
+          add_edge_to_aet(&amp;((*aet)-&gt;next), edge, *aet);
+        }
+      }
+      else
+      {
+        /* Head further into the AET */
+        add_edge_to_aet(&amp;((*aet)-&gt;next), edge, *aet);
+      }
+    }
+  }
+}
+
+
+static void add_intersection(it_node **it, edge_node *edge0, edge_node *edge1,
+                             double x, double y)
+{
+  it_node *existing_node;
+
+  if (!*it)
+  {
+    /* Append a new node to the tail of the list */
+    MALLOC(*it, sizeof(it_node), &quot;IT insertion&quot;, it_node);
+    (*it)-&gt;ie[0]= edge0;
+    (*it)-&gt;ie[1]= edge1;
+    (*it)-&gt;point.x= x;
+    (*it)-&gt;point.y= y;
+    (*it)-&gt;next= NULL;
+  }
+  else
+  {
+    if ((*it)-&gt;point.y &gt; y)
+    {
+      /* Insert a new node mid-list */
+      existing_node= *it;
+      MALLOC(*it, sizeof(it_node), &quot;IT insertion&quot;, it_node);
+      (*it)-&gt;ie[0]= edge0;
+      (*it)-&gt;ie[1]= edge1;
+      (*it)-&gt;point.x= x;
+      (*it)-&gt;point.y= y;
+      (*it)-&gt;next= existing_node;
+    }
+    else
+      /* Head further down the list */
+      add_intersection(&amp;((*it)-&gt;next), edge0, edge1, x, y);
+  }
+}
+
+
+static void add_st_edge(st_node **st, it_node **it, edge_node *edge,
+                        double dy)
+{
+  st_node *existing_node;
+  double   den, r, x, y;
+
+  if (!*st)
+  {
+    /* Append edge onto the tail end of the ST */
+    MALLOC(*st, sizeof(st_node), &quot;ST insertion&quot;, st_node);
+    (*st)-&gt;edge= edge;
+    (*st)-&gt;xb= edge-&gt;xb;
+    (*st)-&gt;xt= edge-&gt;xt;
+    (*st)-&gt;dx= edge-&gt;dx;
+    (*st)-&gt;prev= NULL;
+  }
+  else
+  {
+    den= ((*st)-&gt;xt - (*st)-&gt;xb) - (edge-&gt;xt - edge-&gt;xb);
+
+    /* If new edge and ST edge don't cross */
+    if ((edge-&gt;xt &gt;= (*st)-&gt;xt) || (edge-&gt;dx == (*st)-&gt;dx) ||
+        (fabs(den) &lt;= DBL_EPSILON))
+    {
+      /* No intersection - insert edge here (before the ST edge) */
+      existing_node= *st;
+      MALLOC(*st, sizeof(st_node), &quot;ST insertion&quot;, st_node);
+      (*st)-&gt;edge= edge;
+      (*st)-&gt;xb= edge-&gt;xb;
+      (*st)-&gt;xt= edge-&gt;xt;
+      (*st)-&gt;dx= edge-&gt;dx;
+      (*st)-&gt;prev= existing_node;
+    }
+    else
+    {
+      /* Compute intersection between new edge and ST edge */
+      r= (edge-&gt;xb - (*st)-&gt;xb) / den;
+      x= (*st)-&gt;xb + r * ((*st)-&gt;xt - (*st)-&gt;xb);
+      y= r * dy;
+
+      /* Insert the edge pointers and the intersection point in the IT */
+      add_intersection(it, (*st)-&gt;edge, edge, x, y);
+
+      /* Head further into the ST */
+      add_st_edge(&amp;((*st)-&gt;prev), it, edge, dy);
+    }
+  }
+}
+
+
+static void build_intersection_table(it_node **it, edge_node *aet, double dy)
+{
+  st_node   *st, *stp;
+  edge_node *edge;
+
+  /* Build intersection table for the current scanbeam */
+  reset_it(it);
+  st= NULL;
+
+  /* Process each AET edge */
+  for (edge= aet; edge; edge= edge-&gt;next)
+  {
+    if ((edge-&gt;bstate[ABOVE] == BUNDLE_HEAD) ||
+         edge-&gt;bundle[ABOVE][CLIP] || edge-&gt;bundle[ABOVE][SUBJ])
+      add_st_edge(&amp;st, it, edge, dy);
+  }
+
+  /* Free the sorted edge table */
+  while (st)
+  {
+    stp= st-&gt;prev;
+    FREE(st);
+    st= stp;
+  }
+}
+
+static int count_contours(polygon_node *polygon)
+{
+  int          nc, nv;
+  vertex_node *v, *nextv;
+
+  for (nc= 0; polygon; polygon= polygon-&gt;next)
+    if (polygon-&gt;active)
+    {
+      /* Count the vertices in the current contour */
+      nv= 0;
+      for (v= polygon-&gt;proxy-&gt;v[LEFT]; v; v= v-&gt;next)
+        nv++;
+
+      /* Record valid vertex counts in the active field */
+      if (nv &gt; 2)
+      {
+        polygon-&gt;active= nv;
+        nc++;
+      }
+      else
+      {
+        /* Invalid contour: just free the heap */
+        for (v= polygon-&gt;proxy-&gt;v[LEFT]; v; v= nextv)
+        {
+          nextv= v-&gt;next;
+          FREE(v);
+        }
+        polygon-&gt;active= 0;
+      }
+    }
+  return nc;
+}
+
+
+static void add_left(polygon_node *p, double x, double y)
+{
+  vertex_node *nv;
+
+  if(p == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+
+  /* Create a new vertex node and set its fields */
+  MALLOC(nv, sizeof(vertex_node), &quot;vertex node creation&quot;, vertex_node);
+  nv-&gt;x= x;
+  nv-&gt;y= y;
+
+  /* Add vertex nv to the left end of the polygon's vertex list */
+  nv-&gt;next= p-&gt;proxy-&gt;v[LEFT];
+
+  /* Update proxy-&gt;[LEFT] to point to nv */
+  p-&gt;proxy-&gt;v[LEFT]= nv;
+}
+
+
+static void merge_left(polygon_node *p, polygon_node *q, polygon_node *list)
+{
+  polygon_node *target;
+
+  if(p == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+  if(q == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+
+  /* Label contour as a hole */
+  q-&gt;proxy-&gt;hole= TRUE;
+
+  if (p-&gt;proxy != q-&gt;proxy)
+  {
+    /* Assign p's vertex list to the left end of q's list */
+    p-&gt;proxy-&gt;v[RIGHT]-&gt;next= q-&gt;proxy-&gt;v[LEFT];
+    q-&gt;proxy-&gt;v[LEFT]= p-&gt;proxy-&gt;v[LEFT];
+
+    /* Redirect any p-&gt;proxy references to q-&gt;proxy */
+
+    for (target= p-&gt;proxy; list; list= list-&gt;next)
+    {
+      if (list-&gt;proxy == target)
+      {
+        list-&gt;active= FALSE;
+        list-&gt;proxy= q-&gt;proxy;
+      }
+    }
+  }
+}
+
+
+static void add_right(polygon_node *p, double x, double y)
+{
+  vertex_node *nv = 0;
+
+  if(p == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+
+  /* Create a new vertex node and set its fields */
+  MALLOC(nv, sizeof(vertex_node), &quot;vertex node creation&quot;, vertex_node);
+  nv-&gt;x= x;
+  nv-&gt;y= y;
+  nv-&gt;next= NULL;
+
+  /* Add vertex nv to the right end of the polygon's vertex list */
+  p-&gt;proxy-&gt;v[RIGHT]-&gt;next= nv;
+
+  /* Update proxy-&gt;v[RIGHT] to point to nv */
+  p-&gt;proxy-&gt;v[RIGHT]= nv;
+}
+
+
+static void merge_right(polygon_node *p, polygon_node *q, polygon_node *list)
+{
+  polygon_node *target = 0;
+
+  if(p == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+  if(q == NULL) throw runtime_error(&quot;GPC: Something's wrong.&quot;) ;
+
+
+  /* Label contour as external */
+  q-&gt;proxy-&gt;hole= FALSE;
+
+  if (p-&gt;proxy != q-&gt;proxy)
+  {
+    /* Assign p's vertex list to the right end of q's list */
+    q-&gt;proxy-&gt;v[RIGHT]-&gt;next= p-&gt;proxy-&gt;v[LEFT];
+    q-&gt;proxy-&gt;v[RIGHT]= p-&gt;proxy-&gt;v[RIGHT];
+
+    /* Redirect any p-&gt;proxy references to q-&gt;proxy */
+    for (target= p-&gt;proxy; list; list= list-&gt;next)
+    {
+      if (list-&gt;proxy == target)
+      {
+        list-&gt;active= FALSE;
+        list-&gt;proxy= q-&gt;proxy;
+      }
+    }
+  }
+}
+
+
+static void add_local_min(polygon_node **p, edge_node *edge,
+                          double x, double y)
+{
+  polygon_node *existing_min = 0;
+  vertex_node  *nv;
+
+  existing_min= *p;
+
+  MALLOC(*p, sizeof(polygon_node), &quot;polygon node creation&quot;, polygon_node);
+  **p = polygon_node() ;
+
+  /* Create a new vertex node and set its fields */
+  MALLOC(nv, sizeof(vertex_node), &quot;vertex node creation&quot;, vertex_node);
+  *nv = vertex_node() ;
+
+  nv-&gt;x= x;
+  nv-&gt;y= y;
+  nv-&gt;next= NULL;
+
+  /* Initialise proxy to point to p itself */
+  (*p)-&gt;proxy= (*p);
+  (*p)-&gt;active= TRUE;
+  (*p)-&gt;next= existing_min;
+
+  /* Make v[LEFT] and v[RIGHT] point to new vertex nv */
+  (*p)-&gt;v[LEFT]= nv;
+  (*p)-&gt;v[RIGHT]= nv;
+
+  /* Assign polygon p to the edge */
+  edge-&gt;outp[ABOVE]= *p;
+}
+
+
+static int count_tristrips(polygon_node *tn)
+{
+  int total;
+
+  for (total= 0; tn; tn= tn-&gt;next)
+    if (tn-&gt;active &gt; 2)
+      total++;
+  return total;
+}
+
+
+static void add_vertex(vertex_node **t, double x, double y)
+{
+  if (!(*t))
+  {
+    MALLOC(*t, sizeof(vertex_node), &quot;tristrip vertex creation&quot;, vertex_node);
+    (*t)-&gt;x= x;
+    (*t)-&gt;y= y;
+    (*t)-&gt;next= NULL;
+  }
+  else
+    /* Head further down the list */
+    add_vertex(&amp;((*t)-&gt;next), x, y);
+}
+
+
+static void new_tristrip(polygon_node **tn, edge_node *edge,
+                         double x, double y)
+{
+  if (!(*tn))
+  {
+    MALLOC(*tn, sizeof(polygon_node), &quot;tristrip node creation&quot;, polygon_node);
+	 **tn = polygon_node() ;
+
+    (*tn)-&gt;next= NULL;
+    (*tn)-&gt;v[LEFT]= NULL;
+    (*tn)-&gt;v[RIGHT]= NULL;
+    (*tn)-&gt;active= 1;
+    add_vertex(&amp;((*tn)-&gt;v[LEFT]), x, y);
+    edge-&gt;outp[ABOVE]= *tn;
+  }
+  else
+    /* Head further down the list */
+    new_tristrip(&amp;((*tn)-&gt;next), edge, x, y);
+}
+
+
+static bbox *create_contour_bboxes(gpc_polygon *p)
+{
+  bbox *box;
+  int   c, v;
+
+  MALLOC(box, p-&gt;num_contours * sizeof(bbox), &quot;Bounding box creation&quot;, bbox);
+
+  /* Construct contour bounding boxes */
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+  {
+    /* Initialise bounding box extent */
+    box[c].xmin= DBL_MAX;
+    box[c].ymin= DBL_MAX;
+    box[c].xmax= -DBL_MAX;
+    box[c].ymax= -DBL_MAX;
+
+    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
+    {
+      /* Adjust bounding box */
+      if (p-&gt;contour[c].vertex[v].x &lt; box[c].xmin)
+        box[c].xmin= p-&gt;contour[c].vertex[v].x;
+      if (p-&gt;contour[c].vertex[v].y &lt; box[c].ymin)
+        box[c].ymin= p-&gt;contour[c].vertex[v].y;
+      if (p-&gt;contour[c].vertex[v].x &gt; box[c].xmax)
+        box[c].xmax= p-&gt;contour[c].vertex[v].x;
+      if (p-&gt;contour[c].vertex[v].y &gt; box[c].ymax)
+          box[c].ymax= p-&gt;contour[c].vertex[v].y;
+    }
+  }
+  return box;
+}
+
+
+static void minimax_test(gpc_polygon *subj, gpc_polygon *clip, gpc_op op)
+{
+  bbox *s_bbox, *c_bbox;
+  int   s, c, *o_table, overlap;
+
+  s_bbox= create_contour_bboxes(subj);
+  c_bbox= create_contour_bboxes(clip);
+
+  MALLOC(o_table, subj-&gt;num_contours * clip-&gt;num_contours * sizeof(int),
+         &quot;overlap table creation&quot;, int);
+
+  /* Check all subject contour bounding boxes against clip boxes */
+  for (s= 0; s &lt; subj-&gt;num_contours; s++)
+    for (c= 0; c &lt; clip-&gt;num_contours; c++)
+      o_table[c * subj-&gt;num_contours + s]=
+             (!((s_bbox[s].xmax &lt; c_bbox[c].xmin) ||
+                (s_bbox[s].xmin &gt; c_bbox[c].xmax))) &amp;&amp;
+             (!((s_bbox[s].ymax &lt; c_bbox[c].ymin) ||
+                (s_bbox[s].ymin &gt; c_bbox[c].ymax)));
+
+  /* For each clip contour, search for any subject contour overlaps */
+  for (c= 0; c &lt; clip-&gt;num_contours; c++)
+  {
+    overlap= 0;
+    for (s= 0; (!overlap) &amp;&amp; (s &lt; subj-&gt;num_contours); s++)
+      overlap= o_table[c * subj-&gt;num_contours + s];
+
+    if (!overlap)
+      /* Flag non contributing status by negating vertex count */
+      clip-&gt;contour[c].num_vertices = -clip-&gt;contour[c].num_vertices;
+  }
+
+  if (op == GPC_INT)
+  {
+    /* For each subject contour, search for any clip contour overlaps */
+    for (s= 0; s &lt; subj-&gt;num_contours; s++)
+    {
+      overlap= 0;
+      for (c= 0; (!overlap) &amp;&amp; (c &lt; clip-&gt;num_contours); c++)
+        overlap= o_table[c * subj-&gt;num_contours + s];
+
+      if (!overlap)
+        /* Flag non contributing status by negating vertex count */
+        subj-&gt;contour[s].num_vertices = -subj-&gt;contour[s].num_vertices;
+    }
+  }
+
+  FREE(s_bbox);
+  FREE(c_bbox);
+  FREE(o_table);
+}
+
+
+/*
+===========================================================================
+                             Public Functions
+===========================================================================
+*/
+
+void gpc_free_polygon(gpc_polygon *p)
+{
+  int c;
+
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+    FREE(p-&gt;contour[c].vertex);
+  FREE(p-&gt;hole);
+  FREE(p-&gt;contour);
+  p-&gt;num_contours= 0;
+}
+
+/* Unused and fscanf creates compilation warnings
+void gpc_read_polygon(FILE *fp, int read_hole_flags, gpc_polygon *p)
+{
+  int c, v;
+
+  fscanf(fp, &quot;%d&quot;, &amp;(p-&gt;num_contours));
+  MALLOC(p-&gt;hole, p-&gt;num_contours * sizeof(int),
+         &quot;hole flag array creation&quot;, int);
+  MALLOC(p-&gt;contour, p-&gt;num_contours
+         * sizeof(gpc_vertex_list), &quot;contour creation&quot;, gpc_vertex_list);
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+  {
+    fscanf(fp, &quot;%d&quot;, &amp;(p-&gt;contour[c].num_vertices));
+
+    if (read_hole_flags)
+      fscanf(fp, &quot;%d&quot;, &amp;(p-&gt;hole[c]));
+    else
+      p-&gt;hole[c]= FALSE; // Assume all contours to be external
+
+    MALLOC(p-&gt;contour[c].vertex, p-&gt;contour[c].num_vertices
+           * sizeof(gpc_vertex), &quot;vertex creation&quot;, gpc_vertex);
+    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
+      fscanf(fp, &quot;%lf %lf&quot;, &amp;(p-&gt;contour[c].vertex[v].x),
+                            &amp;(p-&gt;contour[c].vertex[v].y));
+  }
+}
+*/
+
+void gpc_write_polygon(FILE *fp, int write_hole_flags, gpc_polygon *p)
+{
+  int c, v;
+
+  fprintf(fp, &quot;%d\n&quot;, p-&gt;num_contours);
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+  {
+    fprintf(fp, &quot;%d\n&quot;, p-&gt;contour[c].num_vertices);
+
+    if (write_hole_flags)
+      fprintf(fp, &quot;%d\n&quot;, p-&gt;hole[c]);
+
+    for (v= 0; v &lt; p-&gt;contour[c].num_vertices; v++)
+      fprintf(fp, &quot;% .*lf % .*lf\n&quot;,
+              DBL_DIG, p-&gt;contour[c].vertex[v].x,
+              DBL_DIG, p-&gt;contour[c].vertex[v].y);
+  }
+}
+
+
+void gpc_add_contour(gpc_polygon *p, gpc_vertex_list *new_contour, int hole)
+{
+  int             *extended_hole, c, v;
+  gpc_vertex_list *extended_contour;
+
+  /* Create an extended hole array */
+  MALLOC(extended_hole, (p-&gt;num_contours + 1)
+         * sizeof(int), &quot;contour hole addition&quot;, int);
+
+  /* Create an extended contour array */
+  MALLOC(extended_contour, (p-&gt;num_contours + 1)
+         * sizeof(gpc_vertex_list), &quot;contour addition&quot;, gpc_vertex_list);
+
+  /* Copy the old contour and hole data into the extended arrays */
+  for (c= 0; c &lt; p-&gt;num_contours; c++)
+  {
+    extended_hole[c]= p-&gt;hole[c];
+    extended_contour[c]= p-&gt;contour[c];
+  }
+
+  /* Copy the new contour and hole onto the end of the extended arrays */
+  c= p-&gt;num_contours;
+  extended_hole[c]= hole;
+  extended_contour[c].num_vertices= new_contour-&gt;num_vertices;
+  MALLOC(extended_contour[c].vertex, new_contour-&gt;num_vertices
+         * sizeof(gpc_vertex), &quot;contour addition&quot;, gpc_vertex);
+  for (v= 0; v &lt; new_contour-&gt;num_vertices; v++)
+    extended_contour[c].vertex[v]= new_contour-&gt;vertex[v];
+
+  /* Dispose of the old contour */
+  FREE(p-&gt;contour);
+  FREE(p-&gt;hole);
+
+  /* Update the polygon information */
+  p-&gt;num_contours++;
+  p-&gt;hole= extended_hole;
+  p-&gt;contour= extended_contour;
+}
+
+
+void gpc_polygon_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
+                      gpc_polygon *result)
+{
+  sb_tree       *sbtree= NULL;
+  it_node       *it= NULL, *intersect=0;
+  edge_node     *edge=0, *prev_edge=0, *next_edge=0, *succ_edge=0, *e0=0, *e1=0;
+  edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL;
+  lmt_node      *lmt= NULL, *local_min=0;
+  polygon_node  *out_poly= NULL, *p=0, *q=0, *poly=0, *npoly=0, *cf= NULL;
+  vertex_node   *vtx=0, *nv=0;
+  h_state        horiz[2];
+  int            in[2], exists[2], parity[2]= {LEFT, LEFT};
+  int            c, v, contributing=0, search, scanbeam= 0, sbt_entries= 0;
+  int            vclass=0, bl=0, br=0, tl=0, tr=0;
+  double        *sbt= NULL, xb, px, yb, yt=0.0, dy=0.0, ix, iy;
+
+  /* Test for trivial NULL result cases */
+  if (((subj-&gt;num_contours == 0) &amp;&amp; (clip-&gt;num_contours == 0))
+   || ((subj-&gt;num_contours == 0) &amp;&amp; ((op == GPC_INT) || (op == GPC_DIFF)))
+   || ((clip-&gt;num_contours == 0) &amp;&amp;  (op == GPC_INT)))
+  {
+    result-&gt;num_contours= 0;
+    result-&gt;hole= NULL;
+    result-&gt;contour= NULL;
+    return;
+  }
+
+  /* Identify potentialy contributing contours */
+  if (((op == GPC_INT) || (op == GPC_DIFF))
+   &amp;&amp; (subj-&gt;num_contours &gt; 0) &amp;&amp; (clip-&gt;num_contours &gt; 0))
+    minimax_test(subj, clip, op);
+
+  /* Build LMT */
+  if (subj-&gt;num_contours &gt; 0)
+    s_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, subj, SUBJ, op);
+  if (clip-&gt;num_contours &gt; 0)
+    c_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, clip, CLIP, op);
+
+  /* Return a NULL result if no contours contribute */
+  if (lmt == NULL)
+  {
+    result-&gt;num_contours= 0;
+    result-&gt;hole= NULL;
+    result-&gt;contour= NULL;
+    reset_lmt(&amp;lmt);
+    FREE(s_heap);
+    FREE(c_heap);
+    return;
+  }
+
+  /* Build scanbeam table from scanbeam tree */
+  MALLOC(sbt, sbt_entries * sizeof(double), &quot;sbt creation&quot;, double);
+  build_sbt(&amp;scanbeam, sbt, sbtree);
+  scanbeam= 0;
+  free_sbtree(&amp;sbtree);
+
+  /* Allow pointer re-use without causing memory leak */
+  if (subj == result)
+    gpc_free_polygon(subj);
+  if (clip == result)
+    gpc_free_polygon(clip);
+
+  /* Invert clip polygon for difference operation */
+  if (op == GPC_DIFF)
+    parity[CLIP]= RIGHT;
+
+  local_min= lmt;
+
+  /* Process each scanbeam */
+  while (scanbeam &lt; sbt_entries)
+  {
+    /* Set yb and yt to the bottom and top of the scanbeam */
+    yb= sbt[scanbeam++];
+    if (scanbeam &lt; sbt_entries)
+    {
+      yt= sbt[scanbeam];
+      dy= yt - yb;
+    }
+
+    /* === SCANBEAM BOUNDARY PROCESSING ================================ */
+
+    /* If LMT node corresponding to yb exists */
+    if (local_min)
+    {
+      if (local_min-&gt;y == yb)
+      {
+        /* Add edges starting at this local minimum to the AET */
+        for (edge= local_min-&gt;first_bound; edge; edge= edge-&gt;next_bound)
+          add_edge_to_aet(&amp;aet, edge, NULL);
+
+        local_min= local_min-&gt;next;
+      }
+    }
+
+    /* Set dummy previous x value */
+    px= -DBL_MAX;
+
+    /* Create bundles within AET */
+    e0= aet;
+    e1= aet;
+
+    /* Set up bundle fields of first edge */
+    aet-&gt;bundle[ABOVE][ aet-&gt;type]= (aet-&gt;top.y != yb);
+    aet-&gt;bundle[ABOVE][!aet-&gt;type]= FALSE;
+    aet-&gt;bstate[ABOVE]= UNBUNDLED;
+
+    for (next_edge= aet-&gt;next; next_edge; next_edge= next_edge-&gt;next)
+    {
+      /* Set up bundle fields of next edge */
+      next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]= (next_edge-&gt;top.y != yb);
+      next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= FALSE;
+      next_edge-&gt;bstate[ABOVE]= UNBUNDLED;
+
+      /* Bundle edges above the scanbeam boundary if they coincide */
+      if (next_edge-&gt;bundle[ABOVE][next_edge-&gt;type])
+      {
+        if (EQ(e0-&gt;xb, next_edge-&gt;xb) &amp;&amp; EQ(e0-&gt;dx, next_edge-&gt;dx)
+	 &amp;&amp; (e0-&gt;top.y != yb))
+        {
+          next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]^=
+            e0-&gt;bundle[ABOVE][ next_edge-&gt;type];
+          next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]=
+            e0-&gt;bundle[ABOVE][!next_edge-&gt;type];
+          next_edge-&gt;bstate[ABOVE]= BUNDLE_HEAD;
+          e0-&gt;bundle[ABOVE][CLIP]= FALSE;
+          e0-&gt;bundle[ABOVE][SUBJ]= FALSE;
+          e0-&gt;bstate[ABOVE]= BUNDLE_TAIL;
+        }
+        e0= next_edge;
+      }
+    }
+
+    horiz[CLIP]= NH;
+    horiz[SUBJ]= NH;
+
+    /* Process each edge at this scanbeam boundary */
+    for (edge= aet; edge; edge= edge-&gt;next)
+    {
+      exists[CLIP]= edge-&gt;bundle[ABOVE][CLIP] +
+                   (edge-&gt;bundle[BELOW][CLIP] &lt;&lt; 1);
+      exists[SUBJ]= edge-&gt;bundle[ABOVE][SUBJ] +
+                   (edge-&gt;bundle[BELOW][SUBJ] &lt;&lt; 1);
+
+      if (exists[CLIP] || exists[SUBJ])
+      {
+        /* Set bundle side */
+        edge-&gt;bside[CLIP]= parity[CLIP];
+        edge-&gt;bside[SUBJ]= parity[SUBJ];
+
+        /* Determine contributing status and quadrant occupancies */
+        switch (op)
+        {
+        case GPC_DIFF:
+        case GPC_INT:
+          contributing= (exists[CLIP] &amp;&amp; (parity[SUBJ] || horiz[SUBJ]))
+                     || (exists[SUBJ] &amp;&amp; (parity[CLIP] || horiz[CLIP]))
+                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
+                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
+          br= (parity[CLIP])
+           &amp;&amp; (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+           &amp;&amp; (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        case GPC_XOR:
+          contributing= exists[CLIP] || exists[SUBJ];
+          br= (parity[CLIP])
+            ^ (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+            ^ (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        case GPC_UNION:
+          contributing= (exists[CLIP] &amp;&amp; (!parity[SUBJ] || horiz[SUBJ]))
+                     || (exists[SUBJ] &amp;&amp; (!parity[CLIP] || horiz[CLIP]))
+                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
+                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
+          br= (parity[CLIP])
+           || (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+           || (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        }
+
+        /* Update parity */
+        parity[CLIP]^= edge-&gt;bundle[ABOVE][CLIP];
+        parity[SUBJ]^= edge-&gt;bundle[ABOVE][SUBJ];
+
+        /* Update horizontal state */
+        if (exists[CLIP])
+          horiz[CLIP]=
+            next_h_state[horiz[CLIP]]
+                        [((exists[CLIP] - 1) &lt;&lt; 1) + parity[CLIP]];
+        if (exists[SUBJ])
+          horiz[SUBJ]=
+            next_h_state[horiz[SUBJ]]
+                        [((exists[SUBJ] - 1) &lt;&lt; 1) + parity[SUBJ]];
+
+        vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);
+
+        if (contributing)
+        {
+          xb= edge-&gt;xb;
+
+          switch (vclass)
+          {
+          case EMN:
+          case IMN:
+            add_local_min(&amp;out_poly, edge, xb, yb);
+            px= xb;
+            cf= edge-&gt;outp[ABOVE];
+            break;
+          case ERI:
+            if (xb != px)
+            {
+              add_right(cf, xb, yb);
+              px= xb;
+            }
+            edge-&gt;outp[ABOVE]= cf;
+            cf= NULL;
+            break;
+          case ELI:
+            add_left(edge-&gt;outp[BELOW], xb, yb);
+            px= xb;
+            cf= edge-&gt;outp[BELOW];
+            break;
+          case EMX:
+            if (xb != px)
+            {
+              add_left(cf, xb, yb);
+              px= xb;
+            }
+            merge_right(cf, edge-&gt;outp[BELOW], out_poly);
+            cf= NULL;
+            break;
+          case ILI:
+            if (xb != px)
+            {
+              add_left(cf, xb, yb);
+              px= xb;
+            }
+            edge-&gt;outp[ABOVE]= cf;
+            cf= NULL;
+            break;
+          case IRI:
+            add_right(edge-&gt;outp[BELOW], xb, yb);
+            px= xb;
+            cf= edge-&gt;outp[BELOW];
+            edge-&gt;outp[BELOW]= NULL;
+            break;
+          case IMX:
+            if (xb != px)
+            {
+              add_right(cf, xb, yb);
+              px= xb;
+            }
+            merge_left(cf, edge-&gt;outp[BELOW], out_poly);
+            cf= NULL;
+            edge-&gt;outp[BELOW]= NULL;
+            break;
+          case IMM:
+            if (xb != px)
+	    {
+              add_right(cf, xb, yb);
+              px= xb;
+	    }
+            merge_left(cf, edge-&gt;outp[BELOW], out_poly);
+            edge-&gt;outp[BELOW]= NULL;
+            add_local_min(&amp;out_poly, edge, xb, yb);
+            cf= edge-&gt;outp[ABOVE];
+            break;
+          case EMM:
+            if (xb != px)
+	    {
+              add_left(cf, xb, yb);
+              px= xb;
+	    }
+            merge_right(cf, edge-&gt;outp[BELOW], out_poly);
+            edge-&gt;outp[BELOW]= NULL;
+            add_local_min(&amp;out_poly, edge, xb, yb);
+            cf= edge-&gt;outp[ABOVE];
+            break;
+          case LED:
+            if (edge-&gt;bot.y == yb)
+              add_left(edge-&gt;outp[BELOW], xb, yb);
+            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
+            px= xb;
+            break;
+          case RED:
+            if (edge-&gt;bot.y == yb)
+              add_right(edge-&gt;outp[BELOW], xb, yb);
+            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
+            px= xb;
+            break;
+          default:
+            break;
+          } /* End of switch */
+        } /* End of contributing conditional */
+      } /* End of edge exists conditional */
+    } /* End of AET loop */
+
+    /* Delete terminating edges from the AET, otherwise compute xt */
+    for (edge= aet; edge; edge= edge-&gt;next)
+    {
+      if (edge-&gt;top.y == yb)
+      {
+        prev_edge= edge-&gt;prev;
+        next_edge= edge-&gt;next;
+        if (prev_edge)
+          prev_edge-&gt;next= next_edge;
+        else
+          aet= next_edge;
+        if (next_edge)
+          next_edge-&gt;prev= prev_edge;
+
+        /* Copy bundle head state to the adjacent tail edge if required */
+        if ((edge-&gt;bstate[BELOW] == BUNDLE_HEAD) &amp;&amp; prev_edge)
+	{
+          if (prev_edge-&gt;bstate[BELOW] == BUNDLE_TAIL)
+          {
+            prev_edge-&gt;outp[BELOW]= edge-&gt;outp[BELOW];
+            prev_edge-&gt;bstate[BELOW]= UNBUNDLED;
+            if (prev_edge-&gt;prev)
+              if (prev_edge-&gt;prev-&gt;bstate[BELOW] == BUNDLE_TAIL)
+                prev_edge-&gt;bstate[BELOW]= BUNDLE_HEAD;
+	  }
+	}
+      }
+      else
+      {
+        if (edge-&gt;top.y == yt)
+          edge-&gt;xt= edge-&gt;top.x;
+        else
+          edge-&gt;xt= edge-&gt;bot.x + edge-&gt;dx * (yt - edge-&gt;bot.y);
+      }
+    }
+
+    if (scanbeam &lt; sbt_entries)
+    {
+      /* === SCANBEAM INTERIOR PROCESSING ============================== */
+
+      build_intersection_table(&amp;it, aet, dy);
+
+      /* Process each node in the intersection table */
+      for (intersect= it; intersect; intersect= intersect-&gt;next)
+      {
+        e0= intersect-&gt;ie[0];
+        e1= intersect-&gt;ie[1];
+
+        /* Only generate output for contributing intersections */
+        if ((e0-&gt;bundle[ABOVE][CLIP] || e0-&gt;bundle[ABOVE][SUBJ])
+         &amp;&amp; (e1-&gt;bundle[ABOVE][CLIP] || e1-&gt;bundle[ABOVE][SUBJ]))
+	{
+          p= e0-&gt;outp[ABOVE];
+          q= e1-&gt;outp[ABOVE];
+          ix= intersect-&gt;point.x;
+          iy= intersect-&gt;point.y + yb;
+
+          in[CLIP]= ( e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e0-&gt;bside[CLIP])
+                 || ( e1-&gt;bundle[ABOVE][CLIP] &amp;&amp;  e1-&gt;bside[CLIP])
+                 || (!e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e1-&gt;bundle[ABOVE][CLIP]
+                     &amp;&amp; e0-&gt;bside[CLIP] &amp;&amp; e1-&gt;bside[CLIP]);
+          in[SUBJ]= ( e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e0-&gt;bside[SUBJ])
+                 || ( e1-&gt;bundle[ABOVE][SUBJ] &amp;&amp;  e1-&gt;bside[SUBJ])
+                 || (!e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e1-&gt;bundle[ABOVE][SUBJ]
+                     &amp;&amp; e0-&gt;bside[SUBJ] &amp;&amp; e1-&gt;bside[SUBJ]);
+
+          /* Determine quadrant occupancies */
+          switch (op)
+          {
+          case GPC_DIFF:
+          case GPC_INT:
+            tr= (in[CLIP])
+             &amp;&amp; (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          case GPC_XOR:
+            tr= (in[CLIP])
+              ^ (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          case GPC_UNION:
+            tr= (in[CLIP])
+             || (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          }
+
+          vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);
+
+          switch (vclass)
+          {
+          case EMN:
+            add_local_min(&amp;out_poly, e0, ix, iy);
+            e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+            break;
+          case ERI:
+            if (p)
+            {
+              add_right(p, ix, iy);
+              e1-&gt;outp[ABOVE]= p;
+              e0-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case ELI:
+            if (q)
+            {
+              add_left(q, ix, iy);
+              e0-&gt;outp[ABOVE]= q;
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case EMX:
+            if (p &amp;&amp; q)
+            {
+              add_left(p, ix, iy);
+              merge_right(p, q, out_poly);
+              e0-&gt;outp[ABOVE]= NULL;
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IMN:
+            add_local_min(&amp;out_poly, e0, ix, iy);
+            e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+            break;
+          case ILI:
+            if (p)
+            {
+              add_left(p, ix, iy);
+              e1-&gt;outp[ABOVE]= p;
+              e0-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IRI:
+            if (q)
+            {
+              add_right(q, ix, iy);
+              e0-&gt;outp[ABOVE]= q;
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IMX:
+            if (p &amp;&amp; q)
+            {
+              add_right(p, ix, iy);
+              merge_left(p, q, out_poly);
+              e0-&gt;outp[ABOVE]= NULL;
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IMM:
+            if (p &amp;&amp; q)
+            {
+              add_right(p, ix, iy);
+              merge_left(p, q, out_poly);
+              add_local_min(&amp;out_poly, e0, ix, iy);
+              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+            }
+            break;
+          case EMM:
+            if (p &amp;&amp; q)
+            {
+              add_left(p, ix, iy);
+              merge_right(p, q, out_poly);
+              add_local_min(&amp;out_poly, e0, ix, iy);
+              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+            }
+            break;
+          default:
+            break;
+          } /* End of switch */
+	} /* End of contributing intersection conditional */
+
+        /* Swap bundle sides in response to edge crossing */
+        if (e0-&gt;bundle[ABOVE][CLIP])
+	  e1-&gt;bside[CLIP]= !e1-&gt;bside[CLIP];
+        if (e1-&gt;bundle[ABOVE][CLIP])
+	  e0-&gt;bside[CLIP]= !e0-&gt;bside[CLIP];
+        if (e0-&gt;bundle[ABOVE][SUBJ])
+	  e1-&gt;bside[SUBJ]= !e1-&gt;bside[SUBJ];
+        if (e1-&gt;bundle[ABOVE][SUBJ])
+	  e0-&gt;bside[SUBJ]= !e0-&gt;bside[SUBJ];
+
+        /* Swap e0 and e1 bundles in the AET */
+        prev_edge= e0-&gt;prev;
+        next_edge= e1-&gt;next;
+        if (next_edge)
+          next_edge-&gt;prev= e0;
+
+        if (e0-&gt;bstate[ABOVE] == BUNDLE_HEAD)
+        {
+          search= TRUE;
+          while (search)
+          {
+            prev_edge= prev_edge-&gt;prev;
+            if (prev_edge)
+            {
+              if (prev_edge-&gt;bstate[ABOVE] != BUNDLE_TAIL)
+                search= FALSE;
+            }
+            else
+              search= FALSE;
+          }
+        }
+        if (!prev_edge)
+        {
+          aet-&gt;prev= e1;
+          e1-&gt;next= aet;
+          aet= e0-&gt;next;
+        }
+        else
+        {
+          prev_edge-&gt;next-&gt;prev= e1;
+          e1-&gt;next= prev_edge-&gt;next;
+          prev_edge-&gt;next= e0-&gt;next;
+        }
+		  if(e0-&gt;next == NULL) throw runtime_error(&quot;GPC internal error.&quot;) ;
+		  if(e1-&gt;next == NULL) throw runtime_error(&quot;GPC internal error.&quot;) ;
+        e0-&gt;next-&gt;prev= prev_edge;
+        e1-&gt;next-&gt;prev= e1;
+        e0-&gt;next= next_edge;
+      } /* End of IT loop*/
+
+      /* Prepare for next scanbeam */
+      for (edge= aet; edge; edge= next_edge)
+      {
+        next_edge= edge-&gt;next;
+        succ_edge= edge-&gt;succ;
+
+        if ((edge-&gt;top.y == yt) &amp;&amp; succ_edge)
+        {
+          /* Replace AET edge by its successor */
+          succ_edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
+          succ_edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
+          succ_edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
+          succ_edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
+          prev_edge= edge-&gt;prev;
+          if (prev_edge)
+            prev_edge-&gt;next= succ_edge;
+          else
+            aet= succ_edge;
+          if (next_edge)
+            next_edge-&gt;prev= succ_edge;
+          succ_edge-&gt;prev= prev_edge;
+          succ_edge-&gt;next= next_edge;
+        }
+        else
+        {
+          /* Update this edge */
+          edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
+          edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
+          edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
+          edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
+          edge-&gt;xb= edge-&gt;xt;
+	      }
+        edge-&gt;outp[ABOVE]= NULL;
+      }
+    }
+  } /* === END OF SCANBEAM PROCESSING ================================== */
+
+  /* Generate result polygon from out_poly */
+  result-&gt;contour= NULL;
+  result-&gt;hole= NULL;
+  result-&gt;num_contours= count_contours(out_poly);
+  if (result-&gt;num_contours &gt; 0)
+  {
+    MALLOC(result-&gt;hole, result-&gt;num_contours
+           * sizeof(int), &quot;hole flag table creation&quot;, int);
+    MALLOC(result-&gt;contour, result-&gt;num_contours
+           * sizeof(gpc_vertex_list), &quot;contour creation&quot;, gpc_vertex_list);
+
+    c= 0;
+    for (poly= out_poly; poly; poly= npoly)
+    {
+      npoly= poly-&gt;next;
+      if (poly-&gt;active)
+      {
+        result-&gt;hole[c]= poly-&gt;proxy-&gt;hole;
+        result-&gt;contour[c].num_vertices= poly-&gt;active;
+        MALLOC(result-&gt;contour[c].vertex,
+          result-&gt;contour[c].num_vertices * sizeof(gpc_vertex),
+          &quot;vertex creation&quot;, gpc_vertex);
+
+        v= result-&gt;contour[c].num_vertices - 1;
+        for (vtx= poly-&gt;proxy-&gt;v[LEFT]; vtx; vtx= nv)
+        {
+          nv= vtx-&gt;next;
+          result-&gt;contour[c].vertex[v].x= vtx-&gt;x;
+          result-&gt;contour[c].vertex[v].y= vtx-&gt;y;
+          FREE(vtx);
+          v--;
+        }
+        c++;
+      }
+      FREE(poly);
+    }
+  }
+  else
+  {
+    for (poly= out_poly; poly; poly= npoly)
+    {
+      npoly= poly-&gt;next;
+      FREE(poly);
+    }
+  }
+
+  /* Tidy up */
+  reset_it(&amp;it);
+  reset_lmt(&amp;lmt);
+  FREE(c_heap);
+  FREE(s_heap);
+  FREE(sbt);
+}
+
+
+void gpc_free_tristrip(gpc_tristrip *t)
+{
+  int s;
+
+  for (s= 0; s &lt; t-&gt;num_strips; s++)
+    FREE(t-&gt;strip[s].vertex);
+  FREE(t-&gt;strip);
+  t-&gt;num_strips= 0;
+}
+
+
+void gpc_polygon_to_tristrip(gpc_polygon *s, gpc_tristrip *t)
+{
+  gpc_polygon c;
+
+  c.num_contours= 0;
+  c.hole= NULL;
+  c.contour= NULL;
+  gpc_tristrip_clip(GPC_DIFF, s, &amp;c, t);
+}
+
+
+void gpc_tristrip_clip(gpc_op op, gpc_polygon *subj, gpc_polygon *clip,
+                       gpc_tristrip *result)
+{
+  sb_tree       *sbtree= NULL;
+  it_node       *it= NULL, *intersect;
+  edge_node     *edge=0, *prev_edge=0, *next_edge=0, *succ_edge=0, *e0=0, *e1=0;
+  edge_node     *aet= NULL, *c_heap= NULL, *s_heap= NULL, *cf=0;
+  lmt_node      *lmt= NULL, *local_min;
+  polygon_node  *tlist= NULL, *tn, *tnn, *p, *q;
+  vertex_node   *lt, *ltn, *rt, *rtn;
+  h_state        horiz[2];
+  vertex_type    cft = NUL;
+  int            in[2], exists[2], parity[2]= {LEFT, LEFT};
+  int            s, v, contributing=0, search, scanbeam= 0, sbt_entries= 0;
+  int            vclass=0, bl=0, br=0, tl=0, tr=0;
+  double        *sbt= NULL, xb, px, nx, yb, yt=0.0, dy=0.0, ix, iy;
+
+  /* Test for trivial NULL result cases */
+  if (((subj-&gt;num_contours == 0) &amp;&amp; (clip-&gt;num_contours == 0))
+   || ((subj-&gt;num_contours == 0) &amp;&amp; ((op == GPC_INT) || (op == GPC_DIFF)))
+   || ((clip-&gt;num_contours == 0) &amp;&amp;  (op == GPC_INT)))
+  {
+    result-&gt;num_strips= 0;
+    result-&gt;strip= NULL;
+    return;
+  }
+
+  /* Identify potentialy contributing contours */
+  if (((op == GPC_INT) || (op == GPC_DIFF))
+   &amp;&amp; (subj-&gt;num_contours &gt; 0) &amp;&amp; (clip-&gt;num_contours &gt; 0))
+    minimax_test(subj, clip, op);
+
+  /* Build LMT */
+  if (subj-&gt;num_contours &gt; 0)
+    s_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, subj, SUBJ, op);
+  if (clip-&gt;num_contours &gt; 0)
+    c_heap= build_lmt(&amp;lmt, &amp;sbtree, &amp;sbt_entries, clip, CLIP, op);
+
+  /* Return a NULL result if no contours contribute */
+  if (lmt == NULL)
+  {
+    result-&gt;num_strips= 0;
+    result-&gt;strip= NULL;
+    reset_lmt(&amp;lmt);
+    FREE(s_heap);
+    FREE(c_heap);
+    return;
+  }
+
+  /* Build scanbeam table from scanbeam tree */
+  MALLOC(sbt, sbt_entries * sizeof(double), &quot;sbt creation&quot;, double);
+  build_sbt(&amp;scanbeam, sbt, sbtree);
+  scanbeam= 0;
+  free_sbtree(&amp;sbtree);
+
+  /* Invert clip polygon for difference operation */
+  if (op == GPC_DIFF)
+    parity[CLIP]= RIGHT;
+
+  local_min= lmt;
+
+  /* Process each scanbeam */
+  while (scanbeam &lt; sbt_entries)
+  {
+    /* Set yb and yt to the bottom and top of the scanbeam */
+    yb= sbt[scanbeam++];
+    if (scanbeam &lt; sbt_entries)
+    {
+      yt= sbt[scanbeam];
+      dy= yt - yb;
+    }
+
+    /* === SCANBEAM BOUNDARY PROCESSING ================================ */
+
+    /* If LMT node corresponding to yb exists */
+    if (local_min)
+    {
+      if (local_min-&gt;y == yb)
+      {
+        /* Add edges starting at this local minimum to the AET */
+        for (edge= local_min-&gt;first_bound; edge; edge= edge-&gt;next_bound)
+          add_edge_to_aet(&amp;aet, edge, NULL);
+
+        local_min= local_min-&gt;next;
+      }
+    }
+
+    /* Set dummy previous x value */
+    px= -DBL_MAX;
+
+    /* Create bundles within AET */
+    e0= aet;
+    e1= aet;
+
+    /* Set up bundle fields of first edge */
+    aet-&gt;bundle[ABOVE][ aet-&gt;type]= (aet-&gt;top.y != yb);
+    aet-&gt;bundle[ABOVE][!aet-&gt;type]= FALSE;
+    aet-&gt;bstate[ABOVE]= UNBUNDLED;
+
+    for (next_edge= aet-&gt;next; next_edge; next_edge= next_edge-&gt;next)
+    {
+      /* Set up bundle fields of next edge */
+      next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]= (next_edge-&gt;top.y != yb);
+      next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]= FALSE;
+      next_edge-&gt;bstate[ABOVE]= UNBUNDLED;
+
+      /* Bundle edges above the scanbeam boundary if they coincide */
+      if (next_edge-&gt;bundle[ABOVE][next_edge-&gt;type])
+      {
+        if (EQ(e0-&gt;xb, next_edge-&gt;xb) &amp;&amp; EQ(e0-&gt;dx, next_edge-&gt;dx)
+	 &amp;&amp; (e0-&gt;top.y != yb))
+        {
+          next_edge-&gt;bundle[ABOVE][ next_edge-&gt;type]^=
+            e0-&gt;bundle[ABOVE][ next_edge-&gt;type];
+          next_edge-&gt;bundle[ABOVE][!next_edge-&gt;type]=
+            e0-&gt;bundle[ABOVE][!next_edge-&gt;type];
+          next_edge-&gt;bstate[ABOVE]= BUNDLE_HEAD;
+          e0-&gt;bundle[ABOVE][CLIP]= FALSE;
+          e0-&gt;bundle[ABOVE][SUBJ]= FALSE;
+          e0-&gt;bstate[ABOVE]= BUNDLE_TAIL;
+        }
+        e0= next_edge;
+      }
+    }
+
+    horiz[CLIP]= NH;
+    horiz[SUBJ]= NH;
+
+    /* Process each edge at this scanbeam boundary */
+    for (edge= aet; edge; edge= edge-&gt;next)
+    {
+      exists[CLIP]= edge-&gt;bundle[ABOVE][CLIP] +
+                   (edge-&gt;bundle[BELOW][CLIP] &lt;&lt; 1);
+      exists[SUBJ]= edge-&gt;bundle[ABOVE][SUBJ] +
+                   (edge-&gt;bundle[BELOW][SUBJ] &lt;&lt; 1);
+
+      if (exists[CLIP] || exists[SUBJ])
+      {
+        /* Set bundle side */
+        edge-&gt;bside[CLIP]= parity[CLIP];
+        edge-&gt;bside[SUBJ]= parity[SUBJ];
+
+        /* Determine contributing status and quadrant occupancies */
+        switch (op)
+        {
+        case GPC_DIFF:
+        case GPC_INT:
+          contributing= (exists[CLIP] &amp;&amp; (parity[SUBJ] || horiz[SUBJ]))
+                     || (exists[SUBJ] &amp;&amp; (parity[CLIP] || horiz[CLIP]))
+                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
+                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
+          br= (parity[CLIP])
+           &amp;&amp; (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+           &amp;&amp; (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+           &amp;&amp; (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        case GPC_XOR:
+          contributing= exists[CLIP] || exists[SUBJ];
+          br= (parity[CLIP])
+            ^ (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+            ^ (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+            ^ (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        case GPC_UNION:
+          contributing= (exists[CLIP] &amp;&amp; (!parity[SUBJ] || horiz[SUBJ]))
+                     || (exists[SUBJ] &amp;&amp; (!parity[CLIP] || horiz[CLIP]))
+                     || (exists[CLIP] &amp;&amp; exists[SUBJ]
+                     &amp;&amp; (parity[CLIP] == parity[SUBJ]));
+          br= (parity[CLIP])
+           || (parity[SUBJ]);
+          bl= (parity[CLIP] ^ edge-&gt;bundle[ABOVE][CLIP])
+           || (parity[SUBJ] ^ edge-&gt;bundle[ABOVE][SUBJ]);
+          tr= (parity[CLIP] ^ (horiz[CLIP]!=NH))
+           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH));
+          tl= (parity[CLIP] ^ (horiz[CLIP]!=NH) ^ edge-&gt;bundle[BELOW][CLIP])
+           || (parity[SUBJ] ^ (horiz[SUBJ]!=NH) ^ edge-&gt;bundle[BELOW][SUBJ]);
+          break;
+        }
+
+        /* Update parity */
+        parity[CLIP]^= edge-&gt;bundle[ABOVE][CLIP];
+        parity[SUBJ]^= edge-&gt;bundle[ABOVE][SUBJ];
+
+        /* Update horizontal state */
+        if (exists[CLIP])
+          horiz[CLIP]=
+            next_h_state[horiz[CLIP]]
+                        [((exists[CLIP] - 1) &lt;&lt; 1) + parity[CLIP]];
+        if (exists[SUBJ])
+          horiz[SUBJ]=
+            next_h_state[horiz[SUBJ]]
+                        [((exists[SUBJ] - 1) &lt;&lt; 1) + parity[SUBJ]];
+
+        vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);
+
+        if (contributing)
+        {
+          xb= edge-&gt;xb;
+
+          switch (vclass)
+          {
+          case EMN:
+            new_tristrip(&amp;tlist, edge, xb, yb);
+            cf= edge;
+            break;
+          case ERI:
+            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
+            if (xb != cf-&gt;xb)
+              VERTEX(edge, ABOVE, RIGHT, xb, yb);
+            cf= NULL;
+            break;
+          case ELI:
+            VERTEX(edge, BELOW, LEFT, xb, yb);
+            edge-&gt;outp[ABOVE]= NULL;
+            cf= edge;
+            break;
+          case EMX:
+            if (xb != cf-&gt;xb)
+              VERTEX(edge, BELOW, RIGHT, xb, yb);
+            edge-&gt;outp[ABOVE]= NULL;
+            cf= NULL;
+            break;
+          case IMN:
+            if (cft == LED)
+	    {
+              if (cf-&gt;bot.y != yb)
+                VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
+              new_tristrip(&amp;tlist, cf, cf-&gt;xb, yb);
+	    }
+            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
+            VERTEX(edge, ABOVE, RIGHT, xb, yb);
+            break;
+          case ILI:
+            new_tristrip(&amp;tlist, edge, xb, yb);
+            cf= edge;
+            cft= ILI;
+            break;
+          case IRI:
+            if (cft == LED)
+	    {
+              if (cf-&gt;bot.y != yb)
+                VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
+              new_tristrip(&amp;tlist, cf, cf-&gt;xb, yb);
+	    }
+            VERTEX(edge, BELOW, RIGHT, xb, yb);
+            edge-&gt;outp[ABOVE]= NULL;
+            break;
+          case IMX:
+            VERTEX(edge, BELOW, LEFT, xb, yb);
+            edge-&gt;outp[ABOVE]= NULL;
+            cft= IMX;
+            break;
+	  case IMM:
+            VERTEX(edge, BELOW, LEFT, xb, yb);
+            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
+            if (xb != cf-&gt;xb)
+              VERTEX(cf, ABOVE, RIGHT, xb, yb);
+            cf= edge;
+            break;
+          case EMM:
+            VERTEX(edge, BELOW, RIGHT, xb, yb);
+            edge-&gt;outp[ABOVE]= NULL;
+            new_tristrip(&amp;tlist, edge, xb, yb);
+            cf= edge;
+            break;
+          case LED:
+            if (edge-&gt;bot.y == yb)
+              VERTEX(edge, BELOW, LEFT, xb, yb);
+            edge-&gt;outp[ABOVE]= edge-&gt;outp[BELOW];
+            cf= edge;
+            cft= LED;
+            break;
+          case RED:
+            edge-&gt;outp[ABOVE]= cf-&gt;outp[ABOVE];
+            if (cft == LED)
+	    {
+              if (cf-&gt;bot.y == yb)
+	      {
+                VERTEX(edge, BELOW, RIGHT, xb, yb);
+	      }
+              else
+	      {
+                if (edge-&gt;bot.y == yb)
+		{
+                  VERTEX(cf, BELOW, LEFT, cf-&gt;xb, yb);
+                  VERTEX(edge, BELOW, RIGHT, xb, yb);
+		}
+	      }
+	    }
+            else
+	    {
+              VERTEX(edge, BELOW, RIGHT, xb, yb);
+              VERTEX(edge, ABOVE, RIGHT, xb, yb);
+	    }
+            cf= NULL;
+            break;
+          default:
+            break;
+          } /* End of switch */
+        } /* End of contributing conditional */
+      } /* End of edge exists conditional */
+    } /* End of AET loop */
+
+    /* Delete terminating edges from the AET, otherwise compute xt */
+    for (edge= aet; edge; edge= edge-&gt;next)
+    {
+      if (edge-&gt;top.y == yb)
+      {
+        prev_edge= edge-&gt;prev;
+        next_edge= edge-&gt;next;
+        if (prev_edge)
+          prev_edge-&gt;next= next_edge;
+        else
+          aet= next_edge;
+        if (next_edge)
+          next_edge-&gt;prev= prev_edge;
+
+        /* Copy bundle head state to the adjacent tail edge if required */
+        if ((edge-&gt;bstate[BELOW] == BUNDLE_HEAD) &amp;&amp; prev_edge)
+	{
+          if (prev_edge-&gt;bstate[BELOW] == BUNDLE_TAIL)
+          {
+            prev_edge-&gt;outp[BELOW]= edge-&gt;outp[BELOW];
+            prev_edge-&gt;bstate[BELOW]= UNBUNDLED;
+            if (prev_edge-&gt;prev)
+              if (prev_edge-&gt;prev-&gt;bstate[BELOW] == BUNDLE_TAIL)
+                prev_edge-&gt;bstate[BELOW]= BUNDLE_HEAD;
+	  }
+	}
+      }
+      else
+      {
+        if (edge-&gt;top.y == yt)
+          edge-&gt;xt= edge-&gt;top.x;
+        else
+          edge-&gt;xt= edge-&gt;bot.x + edge-&gt;dx * (yt - edge-&gt;bot.y);
+      }
+    }
+
+    if (scanbeam &lt; sbt_entries)
+    {
+      /* === SCANBEAM INTERIOR PROCESSING ============================== */
+
+      build_intersection_table(&amp;it, aet, dy);
+
+      /* Process each node in the intersection table */
+      for (intersect= it; intersect; intersect= intersect-&gt;next)
+      {
+        e0= intersect-&gt;ie[0];
+        e1= intersect-&gt;ie[1];
+
+        /* Only generate output for contributing intersections */
+        if ((e0-&gt;bundle[ABOVE][CLIP] || e0-&gt;bundle[ABOVE][SUBJ])
+         &amp;&amp; (e1-&gt;bundle[ABOVE][CLIP] || e1-&gt;bundle[ABOVE][SUBJ]))
+	{
+          p= e0-&gt;outp[ABOVE];
+          q= e1-&gt;outp[ABOVE];
+          ix= intersect-&gt;point.x;
+          iy= intersect-&gt;point.y + yb;
+
+          in[CLIP]= ( e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e0-&gt;bside[CLIP])
+                 || ( e1-&gt;bundle[ABOVE][CLIP] &amp;&amp;  e1-&gt;bside[CLIP])
+                 || (!e0-&gt;bundle[ABOVE][CLIP] &amp;&amp; !e1-&gt;bundle[ABOVE][CLIP]
+                     &amp;&amp; e0-&gt;bside[CLIP] &amp;&amp; e1-&gt;bside[CLIP]);
+          in[SUBJ]= ( e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e0-&gt;bside[SUBJ])
+                 || ( e1-&gt;bundle[ABOVE][SUBJ] &amp;&amp;  e1-&gt;bside[SUBJ])
+                 || (!e0-&gt;bundle[ABOVE][SUBJ] &amp;&amp; !e1-&gt;bundle[ABOVE][SUBJ]
+                     &amp;&amp; e0-&gt;bside[SUBJ] &amp;&amp; e1-&gt;bside[SUBJ]);
+
+          /* Determine quadrant occupancies */
+          switch (op)
+          {
+          case GPC_DIFF:
+          case GPC_INT:
+            tr= (in[CLIP])
+             &amp;&amp; (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             &amp;&amp; (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          case GPC_XOR:
+            tr= (in[CLIP])
+              ^ (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+              ^ (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          case GPC_UNION:
+            tr= (in[CLIP])
+             || (in[SUBJ]);
+            tl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ]);
+            br= (in[CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            bl= (in[CLIP] ^ e1-&gt;bundle[ABOVE][CLIP] ^ e0-&gt;bundle[ABOVE][CLIP])
+             || (in[SUBJ] ^ e1-&gt;bundle[ABOVE][SUBJ] ^ e0-&gt;bundle[ABOVE][SUBJ]);
+            break;
+          }
+
+          vclass= tr + (tl &lt;&lt; 1) + (br &lt;&lt; 2) + (bl &lt;&lt; 3);
+
+          switch (vclass)
+          {
+          case EMN:
+            new_tristrip(&amp;tlist, e1, ix, iy);
+            e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
+            break;
+          case ERI:
+            if (p)
+            {
+              P_EDGE(prev_edge, e0, ABOVE, px, iy);
+              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+              VERTEX(e0, ABOVE, RIGHT, ix, iy);
+              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+              e0-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case ELI:
+            if (q)
+            {
+              N_EDGE(next_edge, e1, ABOVE, nx, iy);
+              VERTEX(e1, ABOVE, LEFT, ix, iy);
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case EMX:
+            if (p &amp;&amp; q)
+            {
+              VERTEX(e0, ABOVE, LEFT, ix, iy);
+              e0-&gt;outp[ABOVE]= NULL;
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IMN:
+            P_EDGE(prev_edge, e0, ABOVE, px, iy);
+            VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+            N_EDGE(next_edge, e1, ABOVE, nx, iy);
+            VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+            new_tristrip(&amp;tlist, prev_edge, px, iy);
+            e1-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
+            VERTEX(e1, ABOVE, RIGHT, ix, iy);
+            new_tristrip(&amp;tlist, e0, ix, iy);
+            next_edge-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+            VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+            break;
+          case ILI:
+            if (p)
+            {
+              VERTEX(e0, ABOVE, LEFT, ix, iy);
+              N_EDGE(next_edge, e1, ABOVE, nx, iy);
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+              e1-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+              e0-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IRI:
+            if (q)
+            {
+              VERTEX(e1, ABOVE, RIGHT, ix, iy);
+              P_EDGE(prev_edge, e0, ABOVE, px, iy);
+              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
+              e1-&gt;outp[ABOVE]= NULL;
+            }
+            break;
+          case IMX:
+            if (p &amp;&amp; q)
+            {
+              VERTEX(e0, ABOVE, RIGHT, ix, iy);
+              VERTEX(e1, ABOVE, LEFT, ix, iy);
+              e0-&gt;outp[ABOVE]= NULL;
+              e1-&gt;outp[ABOVE]= NULL;
+              P_EDGE(prev_edge, e0, ABOVE, px, iy);
+              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+              new_tristrip(&amp;tlist, prev_edge, px, iy);
+              N_EDGE(next_edge, e1, ABOVE, nx, iy);
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+              next_edge-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+            }
+            break;
+          case IMM:
+            if (p &amp;&amp; q)
+            {
+              VERTEX(e0, ABOVE, RIGHT, ix, iy);
+              VERTEX(e1, ABOVE, LEFT, ix, iy);
+              P_EDGE(prev_edge, e0, ABOVE, px, iy);
+              VERTEX(prev_edge, ABOVE, LEFT, px, iy);
+              new_tristrip(&amp;tlist, prev_edge, px, iy);
+              N_EDGE(next_edge, e1, ABOVE, nx, iy);
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+              e1-&gt;outp[ABOVE]= prev_edge-&gt;outp[ABOVE];
+              VERTEX(e1, ABOVE, RIGHT, ix, iy);
+              new_tristrip(&amp;tlist, e0, ix, iy);
+              next_edge-&gt;outp[ABOVE]= e0-&gt;outp[ABOVE];
+              VERTEX(next_edge, ABOVE, RIGHT, nx, iy);
+            }
+            break;
+          case EMM:
+            if (p &amp;&amp; q)
+            {
+              VERTEX(e0, ABOVE, LEFT, ix, iy);
+              new_tristrip(&amp;tlist, e1, ix, iy);
+              e0-&gt;outp[ABOVE]= e1-&gt;outp[ABOVE];
+            }
+            break;
+          default:
+            break;
+          } /* End of switch */
+	} /* End of contributing intersection conditional */
+
+        /* Swap bundle sides in response to edge crossing */
+        if (e0-&gt;bundle[ABOVE][CLIP])
+	  e1-&gt;bside[CLIP]= !e1-&gt;bside[CLIP];
+        if (e1-&gt;bundle[ABOVE][CLIP])
+	  e0-&gt;bside[CLIP]= !e0-&gt;bside[CLIP];
+        if (e0-&gt;bundle[ABOVE][SUBJ])
+	  e1-&gt;bside[SUBJ]= !e1-&gt;bside[SUBJ];
+        if (e1-&gt;bundle[ABOVE][SUBJ])
+	  e0-&gt;bside[SUBJ]= !e0-&gt;bside[SUBJ];
+
+        /* Swap e0 and e1 bundles in the AET */
+        prev_edge= e0-&gt;prev;
+        next_edge= e1-&gt;next;
+        if (e1-&gt;next)
+          e1-&gt;next-&gt;prev= e0;
+
+        if (e0-&gt;bstate[ABOVE] == BUNDLE_HEAD)
+        {
+          search= TRUE;
+          while (search)
+          {
+            prev_edge= prev_edge-&gt;prev;
+            if (prev_edge)
+            {
+              if (prev_edge-&gt;bundle[ABOVE][CLIP]
+               || prev_edge-&gt;bundle[ABOVE][SUBJ]
+               || (prev_edge-&gt;bstate[ABOVE] == BUNDLE_HEAD))
+                search= FALSE;
+            }
+            else
+              search= FALSE;
+          }
+        }
+        if (!prev_edge)
+        {
+           e1-&gt;next= aet;
+           aet= e0-&gt;next;
+        }
+        else
+        {
+          e1-&gt;next= prev_edge-&gt;next;
+          prev_edge-&gt;next= e0-&gt;next;
+        }
+        e0-&gt;next-&gt;prev= prev_edge;
+        e1-&gt;next-&gt;prev= e1;
+        e0-&gt;next= next_edge;
+      } /* End of IT loop*/
+
+      /* Prepare for next scanbeam */
+      for (edge= aet; edge; edge= next_edge)
+      {
+        next_edge= edge-&gt;next;
+        succ_edge= edge-&gt;succ;
+
+        if ((edge-&gt;top.y == yt) &amp;&amp; succ_edge)
+        {
+          /* Replace AET edge by its successor */
+          succ_edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
+          succ_edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
+          succ_edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
+          succ_edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
+          prev_edge= edge-&gt;prev;
+          if (prev_edge)
+            prev_edge-&gt;next= succ_edge;
+          else
+            aet= succ_edge;
+          if (next_edge)
+            next_edge-&gt;prev= succ_edge;
+          succ_edge-&gt;prev= prev_edge;
+          succ_edge-&gt;next= next_edge;
+        }
+        else
+        {
+          /* Update this edge */
+          edge-&gt;outp[BELOW]= edge-&gt;outp[ABOVE];
+          edge-&gt;bstate[BELOW]= edge-&gt;bstate[ABOVE];
+          edge-&gt;bundle[BELOW][CLIP]= edge-&gt;bundle[ABOVE][CLIP];
+          edge-&gt;bundle[BELOW][SUBJ]= edge-&gt;bundle[ABOVE][SUBJ];
+          edge-&gt;xb= edge-&gt;xt;
+        }
+        edge-&gt;outp[ABOVE]= NULL;
+      }
+    }
+  } /* === END OF SCANBEAM PROCESSING ================================== */
+
+  /* Generate result tristrip from tlist */
+  result-&gt;strip= NULL;
+  result-&gt;num_strips= count_tristrips(tlist);
+  if (result-&gt;num_strips &gt; 0)
+  {
+    MALLOC(result-&gt;strip, result-&gt;num_strips * sizeof(gpc_vertex_list),
+           &quot;tristrip list creation&quot;, gpc_vertex_list);
+
+    s= 0;
+    for (tn= tlist; tn; tn= tnn)
+    {
+      tnn= tn-&gt;next;
+
+      if (tn-&gt;active &gt; 2)
+      {
+        /* Valid tristrip: copy the vertices and free the heap */
+        result-&gt;strip[s].num_vertices= tn-&gt;active;
+        MALLOC(result-&gt;strip[s].vertex, tn-&gt;active * sizeof(gpc_vertex),
+               &quot;tristrip creation&quot;, gpc_vertex);
+        v= 0;
+        if (INVERT_TRISTRIPS)
+        {
+          lt= tn-&gt;v[RIGHT];
+          rt= tn-&gt;v[LEFT];
+        }
+        else
+        {
+          lt= tn-&gt;v[LEFT];
+          rt= tn-&gt;v[RIGHT];
+        }
+        while (lt || rt)
+        {
+          if (lt)
+          {
+            ltn= lt-&gt;next;
+            result-&gt;strip[s].vertex[v].x= lt-&gt;x;
+            result-&gt;strip[s].vertex[v].y= lt-&gt;y;
+            v++;
+            FREE(lt);
+            lt= ltn;
+          }
+          if (rt)
+          {
+            rtn= rt-&gt;next;
+            result-&gt;strip[s].vertex[v].x= rt-&gt;x;
+            result-&gt;strip[s].vertex[v].y= rt-&gt;y;
+            v++;
+            FREE(rt);
+            rt= rtn;
+          }
+        }
+        s++;
+      }
+      else
+      {
+        /* Invalid tristrip: just free the heap */
+        for (lt= tn-&gt;v[LEFT]; lt; lt= ltn)
+        {
+          ltn= lt-&gt;next;
+          FREE(lt);
+        }
+        for (rt= tn-&gt;v[RIGHT]; rt; rt=rtn)
+        {
+          rtn= rt-&gt;next;
+          FREE(rt);
+        }
+      }
+      FREE(tn);
+    }
+  }
+
+  /* Tidy up */
+  reset_it(&amp;it);
+  reset_lmt(&amp;lmt);
+  FREE(c_heap);
+  FREE(s_heap);
+  FREE(sbt);
+}
+
+/*
+===========================================================================
+                           End of file: gpc.c
+===========================================================================
+*/

Added: trunk/lib/QGLViewer/VRender/gpc.h
===================================================================
--- trunk/lib/QGLViewer/VRender/gpc.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRender/gpc.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,182 @@
+/*
+ This file is part of the VRender library.
+ Copyright (C) 2005 Cyril Soler (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Cyril.Soler at imag.fr</A>)
+ Version 1.0.0, released on June 27, 2005.
+
+ <A HREF="http://artis.imag.fr/Members/Cyril.Soler/VRender">http://artis.imag.fr/Members/Cyril.Soler/VRender</A>
+
+ VRender is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ VRender is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with VRender; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+*/
+
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+/*
+===========================================================================
+
+Project:   Generic Polygon Clipper
+
+           A new algorithm for calculating the difference, intersection,
+           exclusive-or or union of arbitrary polygon sets.
+
+File:      gpc.h
+Author:    Alan Murta (email: <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">gpc at cs.man.ac.uk</A>)
+Version:   2.32
+Date:      17th December 2004
+
+Copyright: (C) 1997-2004, Advanced Interfaces Group,
+           University of Manchester.
+
+           This software is free for non-commercial use. It may be copied,
+           modified, and redistributed provided that this copyright notice
+           is preserved on all copies. The intellectual property rights of
+           the algorithms used reside with the University of Manchester
+           Advanced Interfaces Group.
+
+           You may not use this software, in whole or in part, in support
+           of any commercial product without the express consent of the
+           author.
+
+           There is no warranty or other guarantee of fitness of this
+           software for any purpose. It is provided solely &quot;as is&quot;.
+
+===========================================================================
+*/
+
+#ifndef __gpc_h
+#define __gpc_h
+
+#include &lt;stdio.h&gt;
+
+
+/*
+===========================================================================
+                               Constants
+===========================================================================
+*/
+
+/* Increase GPC_EPSILON to encourage merging of near coincident edges    */
+
+//#define GPC_EPSILON (DBL_EPSILON)
+#define GPC_EPSILON 1e-7
+
+#define GPC_VERSION &quot;2.32&quot;
+
+
+/*
+===========================================================================
+                           Public Data Types
+===========================================================================
+*/
+
+typedef enum                        /* Set operation type                */
+{
+  GPC_DIFF,                         /* Difference                        */
+  GPC_INT,                          /* Intersection                      */
+  GPC_XOR,                          /* Exclusive or                      */
+  GPC_UNION                         /* Union                             */
+} gpc_op;
+
+typedef struct                      /* Polygon vertex structure          */
+{
+  double              x;            /* Vertex x component                */
+  double              y;            /* vertex y component                */
+} gpc_vertex;
+
+typedef struct                      /* Vertex list structure             */
+{
+  int                 num_vertices; /* Number of vertices in list        */
+  gpc_vertex         *vertex;       /* Vertex array pointer              */
+} gpc_vertex_list;
+
+typedef struct                      /* Polygon set structure             */
+{
+  int                 num_contours; /* Number of contours in polygon     */
+  int                *hole;         /* Hole / external contour flags     */
+  gpc_vertex_list    *contour;      /* Contour array pointer             */
+} gpc_polygon;
+
+typedef struct                      /* Tristrip set structure            */
+{
+  int                 num_strips;   /* Number of tristrips               */
+  gpc_vertex_list    *strip;        /* Tristrip array pointer            */
+} gpc_tristrip;
+
+
+/*
+===========================================================================
+                       Public Function Prototypes
+===========================================================================
+*/
+
+void gpc_read_polygon        (FILE            *infile_ptr,
+                              int              read_hole_flags,
+                              gpc_polygon     *polygon);
+
+void gpc_write_polygon       (FILE            *outfile_ptr,
+                              int              write_hole_flags,
+                              gpc_polygon     *polygon);
+
+void gpc_add_contour         (gpc_polygon     *polygon,
+                              gpc_vertex_list *contour,
+                              int              hole);
+
+void gpc_polygon_clip        (gpc_op           set_operation,
+                              gpc_polygon     *subject_polygon,
+                              gpc_polygon     *clip_polygon,
+                              gpc_polygon     *result_polygon);
+
+void gpc_tristrip_clip       (gpc_op           set_operation,
+                              gpc_polygon     *subject_polygon,
+                              gpc_polygon     *clip_polygon,
+                              gpc_tristrip    *result_tristrip);
+
+void gpc_polygon_to_tristrip (gpc_polygon     *polygon,
+                              gpc_tristrip    *tristrip);
+
+void gpc_free_polygon        (gpc_polygon     *polygon);
+
+void gpc_free_tristrip       (gpc_tristrip    *tristrip);
+
+#endif
+
+
+/*
+===========================================================================
+                           End of file: gpc.h
+===========================================================================
+*/

Added: trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt3.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,123 @@
+/****************************************************************************
+** Form implementation generated from reading ui file 'VRenderInterface.Qt3.ui'
+**
+** Created: &#268;t b&#345;e 13 19:58:46 2008
+**
+** WARNING! All changes made in this file will be lost!
+****************************************************************************/
+
+#include &quot;VRenderInterface.Qt3.h&quot;
+
+#include &lt;qvariant.h&gt;
+#include &lt;qpushbutton.h&gt;
+#include &lt;qcheckbox.h&gt;
+#include &lt;qlabel.h&gt;
+#include &lt;qcombobox.h&gt;
+#include &lt;qlayout.h&gt;
+#include &lt;qtooltip.h&gt;
+#include &lt;qwhatsthis.h&gt;
+
+/*
+ *  Constructs a VRenderInterface as a child of 'parent', with the
+ *  name 'name' and widget flags set to 'f'.
+ *
+ *  The dialog will by default be modeless, unless you set 'modal' to
+ *  TRUE to construct a modal dialog.
+ */
+VRenderInterface::VRenderInterface( QWidget* parent, const char* name, bool modal, WFlags fl )
+    : QDialog( parent, name, modal, fl )
+{
+    if ( !name )
+	setName( &quot;VRenderInterface&quot; );
+    VRenderInterfaceLayout = new QVBoxLayout( this, 5, 6, &quot;VRenderInterfaceLayout&quot;); 
+
+    includeHidden = new QCheckBox( this, &quot;includeHidden&quot; );
+    VRenderInterfaceLayout-&gt;addWidget( includeHidden );
+
+    cullBackFaces = new QCheckBox( this, &quot;cullBackFaces&quot; );
+    VRenderInterfaceLayout-&gt;addWidget( cullBackFaces );
+
+    blackAndWhite = new QCheckBox( this, &quot;blackAndWhite&quot; );
+    VRenderInterfaceLayout-&gt;addWidget( blackAndWhite );
+
+    colorBackground = new QCheckBox( this, &quot;colorBackground&quot; );
+    VRenderInterfaceLayout-&gt;addWidget( colorBackground );
+
+    tightenBBox = new QCheckBox( this, &quot;tightenBBox&quot; );
+    VRenderInterfaceLayout-&gt;addWidget( tightenBBox );
+
+    layout3 = new QHBoxLayout( 0, 0, 6, &quot;layout3&quot;); 
+
+    sortLabel = new QLabel( this, &quot;sortLabel&quot; );
+    layout3-&gt;addWidget( sortLabel );
+
+    sortMethod = new QComboBox( FALSE, this, &quot;sortMethod&quot; );
+    layout3-&gt;addWidget( sortMethod );
+    VRenderInterfaceLayout-&gt;addLayout( layout3 );
+    spacer1 = new QSpacerItem( 31, 41, QSizePolicy::Minimum, QSizePolicy::Expanding );
+    VRenderInterfaceLayout-&gt;addItem( spacer1 );
+
+    Layout4 = new QHBoxLayout( 0, 0, 6, &quot;Layout4&quot;); 
+
+    SaveButton = new QPushButton( this, &quot;SaveButton&quot; );
+    Layout4-&gt;addWidget( SaveButton );
+
+    CancelButton = new QPushButton( this, &quot;CancelButton&quot; );
+    Layout4-&gt;addWidget( CancelButton );
+    VRenderInterfaceLayout-&gt;addLayout( Layout4 );
+    languageChange();
+    resize( QSize(298, 245).expandedTo(minimumSizeHint()) );
+    clearWState( WState_Polished );
+
+    // signals and slots connections
+    connect( SaveButton, SIGNAL( clicked() ), this, SLOT( accept() ) );
+    connect( CancelButton, SIGNAL( clicked() ), this, SLOT( reject() ) );
+
+    // tab order
+    setTabOrder( SaveButton, CancelButton );
+    setTabOrder( CancelButton, includeHidden );
+    setTabOrder( includeHidden, cullBackFaces );
+    setTabOrder( cullBackFaces, blackAndWhite );
+    setTabOrder( blackAndWhite, colorBackground );
+    setTabOrder( colorBackground, tightenBBox );
+    setTabOrder( tightenBBox, sortMethod );
+}
+
+/*
+ *  Destroys the object and frees any allocated resources
+ */
+VRenderInterface::~VRenderInterface()
+{
+    // no need to delete child widgets, Qt does it all for us
+}
+
+/*
+ *  Sets the strings of the subwidgets using the current
+ *  language.
+ */
+void VRenderInterface::languageChange()
+{
+    setCaption( tr( &quot;Vectorial rendering options&quot; ) );
+    includeHidden-&gt;setText( tr( &quot;Include hidden parts&quot; ) );
+    QToolTip::add( includeHidden, tr( &quot;Hidden poligons are also included in the output (usually twice bigger)&quot; ) );
+    cullBackFaces-&gt;setText( tr( &quot;Cull back faces&quot; ) );
+    QToolTip::add( cullBackFaces, tr( &quot;Back faces (non clockwise point ordering) are removed from the output&quot; ) );
+    blackAndWhite-&gt;setText( tr( &quot;Black and white&quot; ) );
+    QToolTip::add( blackAndWhite, tr( &quot;Black and white rendering&quot; ) );
+    colorBackground-&gt;setText( tr( &quot;Color background&quot; ) );
+    QToolTip::add( colorBackground, tr( &quot;Use current background color instead of white&quot; ) );
+    tightenBBox-&gt;setText( tr( &quot;Tighten bounding box&quot; ) );
+    QToolTip::add( tightenBBox, tr( &quot;Fit output bounding box to current display&quot; ) );
+    sortLabel-&gt;setText( tr( &quot;Sort method :&quot; ) );
+    QToolTip::add( sortLabel, tr( &quot;Polygon depth sorting method&quot; ) );
+    sortMethod-&gt;clear();
+    sortMethod-&gt;insertItem( tr( &quot;No sorting&quot; ) );
+    sortMethod-&gt;insertItem( tr( &quot;BSP &quot; ) );
+    sortMethod-&gt;insertItem( tr( &quot;Topological&quot; ) );
+    sortMethod-&gt;insertItem( tr( &quot;Advanced topological&quot; ) );
+    sortMethod-&gt;setCurrentItem( 3 );
+    QToolTip::add( sortMethod, tr( &quot;Polygon depth sorting method&quot; ) );
+    SaveButton-&gt;setText( tr( &quot;Save&quot; ) );
+    CancelButton-&gt;setText( tr( &quot;Cancel&quot; ) );
+}
+

Added: trunk/lib/QGLViewer/VRenderInterface.Qt3.ui
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt3.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt3.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,211 @@
+&lt;!DOCTYPE UI&gt;&lt;UI version=&quot;3.0&quot; stdsetdef=&quot;1&quot;&gt;
+&lt;class&gt;VRenderInterface&lt;/class&gt;
+&lt;widget class=&quot;QDialog&quot;&gt;
+    &lt;property name=&quot;name&quot;&gt;
+        &lt;cstring&gt;VRenderInterface&lt;/cstring&gt;
+    &lt;/property&gt;
+    &lt;property name=&quot;geometry&quot;&gt;
+        &lt;rect&gt;
+            &lt;x&gt;0&lt;/x&gt;
+            &lt;y&gt;0&lt;/y&gt;
+            &lt;width&gt;298&lt;/width&gt;
+            &lt;height&gt;245&lt;/height&gt;
+        &lt;/rect&gt;
+    &lt;/property&gt;
+    &lt;property name=&quot;caption&quot;&gt;
+        &lt;string&gt;Vectorial rendering options&lt;/string&gt;
+    &lt;/property&gt;
+    &lt;vbox&gt;
+        &lt;property name=&quot;name&quot;&gt;
+            &lt;cstring&gt;unnamed&lt;/cstring&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;margin&quot;&gt;
+            &lt;number&gt;5&lt;/number&gt;
+        &lt;/property&gt;
+        &lt;property name=&quot;spacing&quot;&gt;
+            &lt;number&gt;6&lt;/number&gt;
+        &lt;/property&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;includeHidden&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Include hidden parts&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Hidden poligons are also included in the output (usually twice bigger)&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;cullBackFaces&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Cull back faces&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Back faces (non clockwise point ordering) are removed from the output&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;blackAndWhite&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Black and white&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Black and white rendering&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;colorBackground&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Color background&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Use current background color instead of white&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QCheckBox&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;tightenBBox&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;text&quot;&gt;
+                &lt;string&gt;Tighten bounding box&lt;/string&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                &lt;string&gt;Fit output bounding box to current display&lt;/string&gt;
+            &lt;/property&gt;
+        &lt;/widget&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;layout3&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;widget class=&quot;QLabel&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;sortLabel&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Sort method :&lt;/string&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QComboBox&quot;&gt;
+                    &lt;item&gt;
+                        &lt;property name=&quot;text&quot;&gt;
+                            &lt;string&gt;No sorting&lt;/string&gt;
+                        &lt;/property&gt;
+                    &lt;/item&gt;
+                    &lt;item&gt;
+                        &lt;property name=&quot;text&quot;&gt;
+                            &lt;string&gt;BSP &lt;/string&gt;
+                        &lt;/property&gt;
+                    &lt;/item&gt;
+                    &lt;item&gt;
+                        &lt;property name=&quot;text&quot;&gt;
+                            &lt;string&gt;Topological&lt;/string&gt;
+                        &lt;/property&gt;
+                    &lt;/item&gt;
+                    &lt;item&gt;
+                        &lt;property name=&quot;text&quot;&gt;
+                            &lt;string&gt;Advanced topological&lt;/string&gt;
+                        &lt;/property&gt;
+                    &lt;/item&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;sortMethod&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;currentItem&quot;&gt;
+                        &lt;number&gt;3&lt;/number&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;toolTip&quot; stdset=&quot;0&quot;&gt;
+                        &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+        &lt;spacer&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;spacer1&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;orientation&quot;&gt;
+                &lt;enum&gt;Vertical&lt;/enum&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;sizeType&quot;&gt;
+                &lt;enum&gt;Expanding&lt;/enum&gt;
+            &lt;/property&gt;
+            &lt;property name=&quot;sizeHint&quot;&gt;
+                &lt;size&gt;
+                    &lt;width&gt;31&lt;/width&gt;
+                    &lt;height&gt;41&lt;/height&gt;
+                &lt;/size&gt;
+            &lt;/property&gt;
+        &lt;/spacer&gt;
+        &lt;widget class=&quot;QLayoutWidget&quot;&gt;
+            &lt;property name=&quot;name&quot;&gt;
+                &lt;cstring&gt;Layout4&lt;/cstring&gt;
+            &lt;/property&gt;
+            &lt;hbox&gt;
+                &lt;property name=&quot;name&quot;&gt;
+                    &lt;cstring&gt;unnamed&lt;/cstring&gt;
+                &lt;/property&gt;
+                &lt;property name=&quot;margin&quot;&gt;
+                    &lt;number&gt;0&lt;/number&gt;
+                &lt;/property&gt;
+                &lt;property name=&quot;spacing&quot;&gt;
+                    &lt;number&gt;6&lt;/number&gt;
+                &lt;/property&gt;
+                &lt;widget class=&quot;QPushButton&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;SaveButton&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Save&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+                &lt;widget class=&quot;QPushButton&quot;&gt;
+                    &lt;property name=&quot;name&quot;&gt;
+                        &lt;cstring&gt;CancelButton&lt;/cstring&gt;
+                    &lt;/property&gt;
+                    &lt;property name=&quot;text&quot;&gt;
+                        &lt;string&gt;Cancel&lt;/string&gt;
+                    &lt;/property&gt;
+                &lt;/widget&gt;
+            &lt;/hbox&gt;
+        &lt;/widget&gt;
+    &lt;/vbox&gt;
+&lt;/widget&gt;
+&lt;connections&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;SaveButton&lt;/sender&gt;
+        &lt;signal&gt;clicked()&lt;/signal&gt;
+        &lt;receiver&gt;VRenderInterface&lt;/receiver&gt;
+        &lt;slot&gt;accept()&lt;/slot&gt;
+    &lt;/connection&gt;
+    &lt;connection&gt;
+        &lt;sender&gt;CancelButton&lt;/sender&gt;
+        &lt;signal&gt;clicked()&lt;/signal&gt;
+        &lt;receiver&gt;VRenderInterface&lt;/receiver&gt;
+        &lt;slot&gt;reject()&lt;/slot&gt;
+    &lt;/connection&gt;
+&lt;/connections&gt;
+&lt;tabstops&gt;
+    &lt;tabstop&gt;SaveButton&lt;/tabstop&gt;
+    &lt;tabstop&gt;CancelButton&lt;/tabstop&gt;
+    &lt;tabstop&gt;includeHidden&lt;/tabstop&gt;
+    &lt;tabstop&gt;cullBackFaces&lt;/tabstop&gt;
+    &lt;tabstop&gt;blackAndWhite&lt;/tabstop&gt;
+    &lt;tabstop&gt;colorBackground&lt;/tabstop&gt;
+    &lt;tabstop&gt;tightenBBox&lt;/tabstop&gt;
+    &lt;tabstop&gt;sortMethod&lt;/tabstop&gt;
+&lt;/tabstops&gt;
+&lt;layoutdefaults spacing=&quot;6&quot; margin=&quot;11&quot;/&gt;
+&lt;/UI&gt;

Added: trunk/lib/QGLViewer/VRenderInterface.Qt4.ui
===================================================================
--- trunk/lib/QGLViewer/VRenderInterface.Qt4.ui	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/VRenderInterface.Qt4.ui	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,214 @@
+&lt;ui version=&quot;4.0&quot; &gt;
+ &lt;author&gt;&lt;/author&gt;
+ &lt;comment&gt;&lt;/comment&gt;
+ &lt;exportmacro&gt;&lt;/exportmacro&gt;
+ &lt;class&gt;VRenderInterface&lt;/class&gt;
+ &lt;widget class=&quot;QDialog&quot; name=&quot;VRenderInterface&quot; &gt;
+  &lt;property name=&quot;geometry&quot; &gt;
+   &lt;rect&gt;
+    &lt;x&gt;0&lt;/x&gt;
+    &lt;y&gt;0&lt;/y&gt;
+    &lt;width&gt;298&lt;/width&gt;
+    &lt;height&gt;224&lt;/height&gt;
+   &lt;/rect&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;windowTitle&quot; &gt;
+   &lt;string&gt;Vectorial rendering options&lt;/string&gt;
+  &lt;/property&gt;
+  &lt;layout class=&quot;QVBoxLayout&quot; &gt;
+   &lt;property name=&quot;margin&quot; &gt;
+    &lt;number&gt;5&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;property name=&quot;spacing&quot; &gt;
+    &lt;number&gt;6&lt;/number&gt;
+   &lt;/property&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;includeHidden&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Hidden poligons are also included in the output (usually twice bigger)&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Include hidden parts&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;cullBackFaces&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Back faces (non clockwise point ordering) are removed from the output&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Cull back faces&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;blackAndWhite&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Black and white rendering&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Black and white&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;colorBackground&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Use current background color instead of white&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Color background&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QCheckBox&quot; name=&quot;tightenBBox&quot; &gt;
+     &lt;property name=&quot;toolTip&quot; &gt;
+      &lt;string&gt;Fit output bounding box to current display&lt;/string&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;text&quot; &gt;
+      &lt;string&gt;Tighten bounding box&lt;/string&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;11&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QLabel&quot; name=&quot;sortLabel&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Sort method :&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QComboBox&quot; name=&quot;sortMethod&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Polygon depth sorting method&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;currentIndex&quot; &gt;
+        &lt;number&gt;0&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;No sorting&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;BSP &lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;Topological&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;Advanced topological&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;spacer&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Vertical&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeType&quot; &gt;
+      &lt;enum&gt;QSizePolicy::Expanding&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;sizeHint&quot; &gt;
+      &lt;size&gt;
+       &lt;width&gt;31&lt;/width&gt;
+       &lt;height&gt;41&lt;/height&gt;
+      &lt;/size&gt;
+     &lt;/property&gt;
+    &lt;/spacer&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; &gt;
+     &lt;property name=&quot;margin&quot; &gt;
+      &lt;number&gt;0&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;spacing&quot; &gt;
+      &lt;number&gt;6&lt;/number&gt;
+     &lt;/property&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;SaveButton&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Save&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;CancelButton&quot; &gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Cancel&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+  &lt;/layout&gt;
+ &lt;/widget&gt;
+ &lt;layoutdefault spacing=&quot;6&quot; margin=&quot;11&quot; /&gt;
+ &lt;pixmapfunction&gt;qPixmapFromMimeSource&lt;/pixmapfunction&gt;
+ &lt;tabstops&gt;
+  &lt;tabstop&gt;SaveButton&lt;/tabstop&gt;
+  &lt;tabstop&gt;CancelButton&lt;/tabstop&gt;
+  &lt;tabstop&gt;includeHidden&lt;/tabstop&gt;
+  &lt;tabstop&gt;cullBackFaces&lt;/tabstop&gt;
+  &lt;tabstop&gt;blackAndWhite&lt;/tabstop&gt;
+  &lt;tabstop&gt;colorBackground&lt;/tabstop&gt;
+  &lt;tabstop&gt;tightenBBox&lt;/tabstop&gt;
+  &lt;tabstop&gt;sortMethod&lt;/tabstop&gt;
+ &lt;/tabstops&gt;
+ &lt;resources/&gt;
+ &lt;connections&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;SaveButton&lt;/sender&gt;
+   &lt;signal&gt;released()&lt;/signal&gt;
+   &lt;receiver&gt;VRenderInterface&lt;/receiver&gt;
+   &lt;slot&gt;accept()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;16&lt;/x&gt;
+     &lt;y&gt;210&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;35&lt;/x&gt;
+     &lt;y&gt;176&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;CancelButton&lt;/sender&gt;
+   &lt;signal&gt;released()&lt;/signal&gt;
+   &lt;receiver&gt;VRenderInterface&lt;/receiver&gt;
+   &lt;slot&gt;reject()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;225&lt;/x&gt;
+     &lt;y&gt;198&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;211&lt;/x&gt;
+     &lt;y&gt;180&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+ &lt;/connections&gt;
+&lt;/ui&gt;

Added: trunk/lib/QGLViewer/camera.cpp
===================================================================
--- trunk/lib/QGLViewer/camera.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/camera.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,2010 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;camera.h&quot;
+#include &quot;qglviewer.h&quot;
+
+using namespace std;
+using namespace qglviewer;
+
+/*! Default constructor.
+
+ sceneCenter() is set to (0,0,0) and sceneRadius() is set to 1.0. type() is Camera::PERSPECTIVE,
+ with a \c M_PI/4 fieldOfView().
+
+ See IODistance(), physicalDistanceToScreen(), physicalScreenWidth() and focusDistance()
+ documentations for default stereo parameter values. */
+Camera::Camera()
+  : fieldOfView_(M_PI/4.0f)
+{
+  // #CONNECTION# Camera copy constructor
+  interpolationKfi_ = new KeyFrameInterpolator;
+  // Requires the interpolationKfi_
+  setFrame(new ManipulatedCameraFrame());
+
+  // #CONNECTION# All these default values identical in initFromDOMElement.
+
+  // Requires fieldOfView() to define focusDistance()
+  setSceneRadius(1.0);
+
+  // Initial value (only scaled after this)
+  orthoCoef_ = tan(fieldOfView()/2.0);
+
+  // Also defines the revolveAroundPoint(), which changes orthoCoef_. Requires a frame().
+  setSceneCenter(Vec(0.0, 0.0, 0.0));
+
+  // Requires fieldOfView() when called with ORTHOGRAPHIC. Attention to projectionMatrix_ below.
+  setType(PERSPECTIVE);
+
+  // #CONNECTION# initFromDOMElement default values
+  setZNearCoefficient(0.005f);
+  setZClippingCoefficient(sqrt(3.0));
+
+  // Dummy values
+  setScreenWidthAndHeight(600, 400);
+
+  // Stereo parameters
+  setIODistance(0.062f);
+  setPhysicalDistanceToScreen(0.5f);
+  setPhysicalScreenWidth(0.4f);
+  // focusDistance is set from setFieldOfView()
+
+  // #CONNECTION# Camera copy constructor
+  for (unsigned short j=0; j&lt;16; ++j)
+    {
+      modelViewMatrix_[j] = ((j%5 == 0) ? 1.0 : 0.0);
+      // #CONNECTION# computeProjectionMatrix() is lazy and assumes 0.0 almost everywhere.
+      projectionMatrix_[j] = 0.0;
+    }
+  computeProjectionMatrix();
+}
+
+/*! Virtual destructor.
+
+ The frame() is deleted, but the different keyFrameInterpolator() are \e not deleted (in case they
+ are shared). */
+Camera::~Camera()
+{
+  delete frame_;
+  delete interpolationKfi_;
+}
+
+
+/*! Copy constructor. Performs a deep copy using operator=(). */
+Camera::Camera(const Camera&amp; camera)
+ : QObject()
+{
+  // #CONNECTION# Camera constructor
+  interpolationKfi_ = new KeyFrameInterpolator;
+  // Requires the interpolationKfi_
+  setFrame(new ManipulatedCameraFrame());
+
+  for (unsigned short j=0; j&lt;16; ++j)
+    {
+      modelViewMatrix_[j] = ((j%5 == 0) ? 1.0 : 0.0);
+      // #CONNECTION# computeProjectionMatrix() is lazy and assumes 0.0 almost everywhere.
+      projectionMatrix_[j] = 0.0;
+    }
+
+  (*this)=camera;
+}
+
+/*! Equal operator.
+
+ All the parameters of \p camera are copied. The frame() pointer is not modified, but its
+ Frame::position() and Frame::orientation() are set to those of \p camera.
+
+ \attention The Camera screenWidth() and screenHeight() are set to those of \p camera. If your
+ Camera is associated with a QGLViewer, you should update these value after the call to this method:
+ \code
+ *(camera()) = otherCamera;
+ camera()-&gt;setScreenWidthAndHeight(width(), height());
+ \endcode
+ The same applies to sceneCenter() and sceneRadius(), if needed. */
+Camera&amp; Camera::operator=(const Camera&amp; camera)
+{
+  setScreenWidthAndHeight(camera.screenWidth(), camera.screenHeight());
+  setFieldOfView(camera.fieldOfView());
+  setSceneRadius(camera.sceneRadius());
+  setSceneCenter(camera.sceneCenter());
+  setZNearCoefficient(camera.zNearCoefficient());
+  setZClippingCoefficient(camera.zClippingCoefficient());
+  setType(camera.type());
+
+  // Stereo parameters
+  setIODistance(camera.IODistance());
+  setFocusDistance(camera.focusDistance());
+  setPhysicalScreenWidth(camera.physicalScreenWidth());
+  setPhysicalDistanceToScreen(camera.physicalDistanceToScreen());
+
+  orthoCoef_ = camera.orthoCoef_;
+
+  // frame_ and interpolationKfi_ pointers are not shared.
+  frame_-&gt;setReferenceFrame(NULL);
+  frame_-&gt;setPosition(camera.position());
+  frame_-&gt;setOrientation(camera.orientation());
+
+  interpolationKfi_-&gt;resetInterpolation();
+
+  kfi_ = camera.kfi_;
+
+  computeProjectionMatrix();
+  computeModelViewMatrix();
+
+  return *this;
+}
+
+/*! Sets Camera screenWidth() and screenHeight() (expressed in pixels).
+
+You should not call this method when the Camera is associated with a QGLViewer, since the
+latter automatically updates these values when it is resized (hence overwritting your values).
+
+Non-positive dimension are silently replaced by a 1 pixel value to ensure frustrum coherence.
+
+If your Camera is used without a QGLViewer (offscreen rendering, shadow maps), use setAspectRatio()
+instead to define the projection matrix. */
+void Camera::setScreenWidthAndHeight(int width, int height)
+{
+  // Prevent negative and zero dimensions that would cause divisions by zero.
+	screenWidth_  = width &gt; 0 ? width : 1;
+	screenHeight_ = height &gt; 0 ? height : 1;
+}
+
+/*! Returns the near clipping plane distance used by the Camera projection matrix.
+
+ The clipping planes' positions depend on the sceneRadius() and sceneCenter() rather than being fixed
+ small-enough and large-enough values. A good scene dimension approximation will hence result in an
+ optimal precision of the z-buffer.
+
+ The near clipping plane is positioned at a distance equal to zClippingCoefficient() * sceneRadius()
+ in front of the sceneCenter():
+ \code
+ zNear = distanceToSceneCenter() - zClippingCoefficient()*sceneRadius();
+ \endcode
+
+ In order to prevent negative or too small zNear() values (which would degrade the z precision),
+ zNearCoefficient() is used when the Camera is inside the sceneRadius() sphere:
+ \code
+ const float zMin = zNearCoefficient() * zClippingCoefficient() * sceneRadius();
+ if (zNear &lt; zMin)
+   zNear = zMin;
+ // With an ORTHOGRAPHIC type, the value is simply clamped to 0.0
+ \endcode
+
+ See also the zFar(), zClippingCoefficient() and zNearCoefficient() documentations.
+
+ If you need a completely different zNear computation, overload the zNear() and zFar() methods in a
+ new class that publicly inherits from Camera and use QGLViewer::setCamera():
+ \code
+ class myCamera :: public qglviewer::Camera
+ {
+   virtual float Camera::zNear() const { return 0.001; };
+   virtual float Camera::zFar() const { return 100.0; };
+ }
+ \endcode
+
+ See the &lt;a href=&quot;../examples/standardCamera.html&quot;&gt;standardCamera example&lt;/a&gt; for an application.
+
+ \attention The value is always positive although the clipping plane is positioned at a negative z
+ value in the Camera coordinate system. This follows the \c gluPerspective standard. */
+float Camera::zNear() const
+{
+  float z = distanceToSceneCenter() - zClippingCoefficient()*sceneRadius();
+
+  // Prevents negative or null zNear values.
+  const float zMin = zNearCoefficient() * zClippingCoefficient() * sceneRadius();
+  if (z &lt; zMin)
+    switch (type())
+      {
+      case Camera::PERSPECTIVE  : z = zMin; break;
+      case Camera::ORTHOGRAPHIC : z = 0.0;  break;
+      }
+  return z;
+}
+
+/*! Returns the far clipping plane distance used by the Camera projection matrix.
+
+The far clipping plane is positioned at a distance equal to zClippingCoefficient() * sceneRadius()
+behind the sceneCenter():
+\code
+zFar = distanceToSceneCenter() + zClippingCoefficient()*sceneRadius();
+\endcode
+
+See the zNear() documentation for details. */
+float Camera::zFar() const
+{
+  return distanceToSceneCenter() + zClippingCoefficient()*sceneRadius();
+}
+
+/*! Defines the Camera type().
+
+Prefix the type with Camera, as in: \code camera()-&gt;setType(Camera::ORTHOGRAPHIC); // or even
+qglviewer::Camera::ORTHOGRAPHIC if you do not use namespace \endcode */
+void Camera::setType(Type type)
+{
+  // make ORTHOGRAPHIC frustum fit PERSPECTIVE (at least in plane normal to viewDirection(), passing
+  // through RAP) Done only when CHANGING type since orthoCoef_ may have been changed with a
+  // setRevolveAroundPoint() in the meantime.
+  if ( (type == Camera::ORTHOGRAPHIC) &amp;&amp; (type_ == Camera::PERSPECTIVE) )
+    orthoCoef_ = tan(fieldOfView()/2.0);
+  type_ = type;
+}
+
+/*! Sets the Camera frame().
+
+If you want to move the Camera, use setPosition() and setOrientation() or one of the Camera
+positioning methods (lookAt(), fitSphere(), showEntireScene()...) instead.
+
+If you want to save the Camera position(), there's no need to call this method either. Use
+addKeyFrameToPath() and playPath() instead.
+
+This method is actually mainly useful if you derive the ManipulatedCameraFrame class and want to
+use an instance of your new class to move the Camera.
+
+A \c NULL \p mcf pointer will silently be ignored. The calling method is responsible for
+deleting the previous frame() pointer if needed in order to prevent memory leaks. */
+void Camera::setFrame(ManipulatedCameraFrame* const mcf)
+{
+  if (!mcf)
+    return;
+
+  frame_ = mcf;
+  interpolationKfi_-&gt;setFrame(frame());
+}
+
+/*! Returns the distance from the Camera center to sceneCenter(), projected along the Camera Z axis.
+  Used by zNear() and zFar() to optimize the Z range. */
+float Camera::distanceToSceneCenter() const
+{
+  return fabs((frame()-&gt;coordinatesOf(sceneCenter())).z);
+}
+
+
+/*! Returns the \p halfWidth and \p halfHeight of the Camera orthographic frustum.
+
+ These values are only valid and used when the Camera is of type() Camera::ORTHOGRAPHIC. They are
+ expressed in OpenGL units and are used by loadProjectionMatrix() to define the projection matrix
+ using:
+ \code
+ glOrtho( -halfWidth, halfWidth, -halfHeight, halfHeight, zNear(), zFar() )
+ \endcode
+
+ These values are proportional to the Camera (z projected) distance to the revolveAroundPoint().
+ When zooming on the object, the Camera is translated forward \e and its frustum is narrowed, making
+ the object appear bigger on screen, as intuitively expected.
+
+ Overload this method to change this behavior if desired, as is done in the 
+ &lt;a href=&quot;../examples/standardCamera.html&quot;&gt;standardCamera example&lt;/a&gt;. */
+void Camera::getOrthoWidthHeight(GLdouble&amp; halfWidth, GLdouble&amp; halfHeight) const
+{
+  const float dist = orthoCoef_ * fabs(cameraCoordinatesOf(revolveAroundPoint()).z);
+  //#CONNECTION# fitScreenRegion
+  halfWidth  = dist * ((aspectRatio() &lt; 1.0) ? 1.0 : aspectRatio());
+  halfHeight = dist * ((aspectRatio() &lt; 1.0) ? 1.0/aspectRatio() : 1.0);
+}
+
+
+/*! Computes the projection matrix associated with the Camera.
+
+ If type() is Camera::PERSPECTIVE, defines a \c GL_PROJECTION matrix similar to what would \c
+ gluPerspective() do using the fieldOfView(), window aspectRatio(), zNear() and zFar() parameters.
+
+ If type() is Camera::ORTHOGRAPHIC, the projection matrix is as what \c glOrtho() would do.
+ Frustum's width and height are set using getOrthoWidthHeight().
+
+ Both types use zNear() and zFar() to place clipping planes. These values are determined from
+ sceneRadius() and sceneCenter() so that they best fit the scene size.
+
+ Use getProjectionMatrix() to retrieve this matrix. Overload loadProjectionMatrix() if you want your
+ Camera to use an exotic projection matrix.
+
+ \note You must call this method if your Camera is not associated with a QGLViewer and is used for
+ offscreen computations (using (un)projectedCoordinatesOf() for instance). loadProjectionMatrix()
+ does it otherwise. */
+void Camera::computeProjectionMatrix() const
+{
+  const float ZNear = zNear();
+  const float ZFar  = zFar();
+
+  switch (type())
+    {
+    case Camera::PERSPECTIVE:
+      {
+	// #CONNECTION# all non null coefficients were set to 0.0 in constructor.
+	const float f = 1.0/tan(fieldOfView()/2.0);
+	projectionMatrix_[0]  = f/aspectRatio();
+	projectionMatrix_[5]  = f;
+	projectionMatrix_[10] = (ZNear + ZFar) / (ZNear - ZFar);
+	projectionMatrix_[11] = -1.0;
+	projectionMatrix_[14] = 2.0 * ZNear * ZFar / (ZNear - ZFar);
+	projectionMatrix_[15] = 0.0;
+	// same as gluPerspective( 180.0*fieldOfView()/M_PI, aspectRatio(), zNear(), zFar() );
+	break;
+      }
+    case Camera::ORTHOGRAPHIC:
+      {
+	GLdouble w, h;
+	getOrthoWidthHeight(w,h);
+	projectionMatrix_[0]  = 1.0/w;
+	projectionMatrix_[5]  = 1.0/h;
+	projectionMatrix_[10] = -2.0/(ZFar - ZNear);
+	projectionMatrix_[11] = 0.0;
+	projectionMatrix_[14] = -(ZFar + ZNear)/(ZFar - ZNear);
+	projectionMatrix_[15] = 1.0;
+	// same as glOrtho( -w, w, -h, h, zNear(), zFar() );
+	break;
+      }
+    }
+}
+
+/*! Computes the modelView matrix associated with the Camera's position() and orientation().
+
+ This matrix converts from the world coordinates system to the Camera coordinates system, so that
+ coordinates can then be projected on screen using the projection matrix (see computeProjectionMatrix()).
+
+ Use getModelViewMatrix() to retrieve this matrix.
+
+ \note You must call this method if your Camera is not associated with a QGLViewer and is used for
+ offscreen computations (using (un)projectedCoordinatesOf() for instance). loadModelViewMatrix()
+ does it otherwise. */
+void Camera::computeModelViewMatrix() const
+{
+  const Quaternion q = frame()-&gt;orientation();
+
+  const double q00 = 2.0l * q[0] * q[0];
+  const double q11 = 2.0l * q[1] * q[1];
+  const double q22 = 2.0l * q[2] * q[2];
+
+  const double q01 = 2.0l * q[0] * q[1];
+  const double q02 = 2.0l * q[0] * q[2];
+  const double q03 = 2.0l * q[0] * q[3];
+
+  const double q12 = 2.0l * q[1] * q[2];
+  const double q13 = 2.0l * q[1] * q[3];
+
+  const double q23 = 2.0l * q[2] * q[3];
+
+  modelViewMatrix_[0] = 1.0l - q11 - q22;
+  modelViewMatrix_[1] =        q01 - q23;
+  modelViewMatrix_[2] =        q02 + q13;
+  modelViewMatrix_[3] = 0.0l;
+
+  modelViewMatrix_[4] =        q01 + q23;
+  modelViewMatrix_[5] = 1.0l - q22 - q00;
+  modelViewMatrix_[6] =        q12 - q03;
+  modelViewMatrix_[7] = 0.0l;
+
+  modelViewMatrix_[8] =        q02 - q13;
+  modelViewMatrix_[9] =        q12 + q03;
+  modelViewMatrix_[10] = 1.0l - q11 - q00;
+  modelViewMatrix_[11] = 0.0l;
+
+  const Vec t = q.inverseRotate(frame()-&gt;position());
+
+  modelViewMatrix_[12] = -t.x;
+  modelViewMatrix_[13] = -t.y;
+  modelViewMatrix_[14] = -t.z;
+  modelViewMatrix_[15] = 1.0l;
+}
+
+
+/*! Loads the OpenGL \c GL_PROJECTION matrix with the Camera projection matrix.
+
+ The Camera projection matrix is computed using computeProjectionMatrix().
+
+ When \p reset is \c true (default), the method clears the previous projection matrix by calling \c
+ glLoadIdentity before setting the matrix. Setting \p reset to \c false is useful for \c GL_SELECT
+ mode, to combine the pushed matrix with a picking matrix. See QGLViewer::beginSelection() for details.
+
+ This method is used by QGLViewer::preDraw() (called before user's QGLViewer::draw() method) to
+ set the \c GL_PROJECTION matrix according to the viewer's QGLViewer::camera() settings.
+
+ Use getProjectionMatrix() to retrieve this matrix. Overload this method if you want your Camera to
+ use an exotic projection matrix. See also loadModelViewMatrix().
+
+ \attention \c glMatrixMode is set to \c GL_PROJECTION.
+
+ \attention If you use several OpenGL contexts and bypass the Qt main refresh loop, you should call
+ QGLWidget::makeCurrent() before this method in order to activate the right OpenGL context. */
+void Camera::loadProjectionMatrix(bool reset) const
+{
+  // WARNING: makeCurrent must be called by every calling method
+  glMatrixMode(GL_PROJECTION);
+
+  if (reset)
+    glLoadIdentity();
+
+  computeProjectionMatrix();
+
+  glMultMatrixd(projectionMatrix_);
+}
+
+/*! Loads the OpenGL \c GL_MODELVIEW matrix with the modelView matrix corresponding to the Camera.
+
+ Calls computeModelViewMatrix() to compute the Camera's modelView matrix.
+
+ This method is used by QGLViewer::preDraw() (called before user's QGLViewer::draw() method) to
+ set the \c GL_MODELVIEW matrix according to the viewer's QGLViewer::camera() position() and
+ orientation().
+
+ As a result, the vertices used in QGLViewer::draw() can be defined in the so called world
+ coordinate system. They are multiplied by this matrix to get converted to the Camera coordinate
+ system, before getting projected using the \c GL_PROJECTION matrix (see loadProjectionMatrix()).
+
+ When \p reset is \c true (default), the method loads (overwrites) the \c GL_MODELVIEW matrix. Setting
+ \p reset to \c false simply calls \c glMultMatrixd (might be useful for some applications).
+
+ Overload this method or simply call glLoadMatrixd() at the beginning of QGLViewer::draw() if you
+ want your Camera to use an exotic modelView matrix. See also loadProjectionMatrix().
+
+ getModelViewMatrix() returns the 4x4 modelView matrix.
+
+ \attention glMatrixMode is set to \c GL_MODELVIEW
+
+ \attention If you use several OpenGL contexts and bypass the Qt main refresh loop, you should call
+ QGLWidget::makeCurrent() before this method in order to activate the right OpenGL context. */
+void Camera::loadModelViewMatrix(bool reset) const
+{
+  // WARNING: makeCurrent must be called by every calling method
+  glMatrixMode(GL_MODELVIEW);
+  computeModelViewMatrix();
+  if (reset)
+    glLoadMatrixd(modelViewMatrix_);
+  else
+    glMultMatrixd(modelViewMatrix_);
+}
+
+/*! Same as loadProjectionMatrix() but for a stereo setup.
+
+ Only the Camera::PERSPECTIVE type() is supported for stereo mode. See
+ QGLViewer::setStereoDisplay().
+
+ Uses focusDistance(), IODistance(), and physicalScreenWidth() to compute cameras
+ offset and asymmetric frustums.
+
+ When \p leftBuffer is \c true, computes the projection matrix associated to the left eye (right eye
+ otherwise). See also loadModelViewMatrixStereo().
+
+ See the &lt;a href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer&lt;/a&gt; and the &lt;a
+ href=&quot;../examples/contribs.html#anaglyph&quot;&gt;anaglyph&lt;/a&gt; examples for an illustration.
+
+ To retrieve this matrix, use a code like:
+ \code
+ glMatrixMode(GL_PROJECTION);
+ glPushMatrix();
+ loadProjectionMatrixStereo(left_or_right);
+ glGetFloatv(GL_PROJECTION_MATRIX, m);
+ glPopMatrix();
+ \endcode
+ Note that getProjectionMatrix() always returns the mono-vision matrix.
+
+ \attention glMatrixMode is set to \c GL_PROJECTION. */
+void Camera::loadProjectionMatrixStereo(bool leftBuffer) const
+{
+  float left, right, bottom, top;
+  float screenHalfWidth, halfWidth, side, shift, delta;
+
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+
+  switch (type())
+    {
+    case Camera::PERSPECTIVE:
+      // compute half width of screen,
+      // corresponding to zero parallax plane to deduce decay of cameras
+      screenHalfWidth = focusDistance() * tan(horizontalFieldOfView() / 2.0);
+      shift = screenHalfWidth * IODistance() / physicalScreenWidth();
+      // should be * current y  / y total
+      // to take into account that the window doesn't cover the entire screen
+
+      // compute half width of &quot;view&quot; at znear and the delta corresponding to
+      // the shifted camera to deduce what to set for asymmetric frustums
+      halfWidth = zNear() * tan(horizontalFieldOfView() / 2.0);
+      delta  = shift * zNear() / focusDistance();
+      side   = leftBuffer ? -1.0 : 1.0;
+
+      left   = -halfWidth + side * delta;
+      right  =  halfWidth + side * delta;
+      top    = halfWidth / aspectRatio();
+      bottom = -top;
+      glFrustum(left, right, bottom, top, zNear(), zFar() );
+      break;
+
+    case Camera::ORTHOGRAPHIC:
+      qWarning(&quot;Camera::setProjectionMatrixStereo: Stereo not available with Ortho mode&quot;);
+      break;
+    }
+}
+
+/*! Same as loadModelViewMatrix() but for a stereo setup.
+
+ Only the Camera::PERSPECTIVE type() is supported for stereo mode. See
+ QGLViewer::setStereoDisplay().
+
+ The modelView matrix is almost identical to the mono-vision one. It is simply translated along its
+ horizontal axis by a value that depends on stereo parameters (see focusDistance(),
+ IODistance(), and physicalScreenWidth()).
+
+ When \p leftBuffer is \c true, computes the modelView matrix associated to the left eye (right eye
+ otherwise).
+
+ loadProjectionMatrixStereo() explains how to retrieve to resulting matrix.
+
+ See the &lt;a href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer&lt;/a&gt; and the &lt;a
+ href=&quot;../examples/contribs.html#anaglyph&quot;&gt;anaglyph&lt;/a&gt; examples for an illustration.
+
+ \attention glMatrixMode is set to \c GL_MODELVIEW. */
+void Camera::loadModelViewMatrixStereo(bool leftBuffer) const
+{
+  // WARNING: makeCurrent must be called by every calling method
+  glMatrixMode(GL_MODELVIEW);
+
+  float halfWidth = focusDistance() * tan(horizontalFieldOfView() / 2.0);
+  float shift     = halfWidth * IODistance() / physicalScreenWidth(); // * current window width / full screen width
+
+  computeModelViewMatrix();
+  if (leftBuffer)
+    modelViewMatrix_[12] -= shift;
+  else
+    modelViewMatrix_[12] += shift;
+  glLoadMatrixd(modelViewMatrix_);
+}
+
+/*! Fills \p m with the Camera projection matrix values.
+
+ Calls computeProjectionMatrix() to define the Camera projection matrix.
+
+ This matrix only reflects the Camera's internal parameters and it may differ from the \c
+ GL_PROJECTION matrix retrieved using \c glGetDoublev(GL_PROJECTION_MATRIX, m). It actually
+ represents the state of the \c GL_PROJECTION after QGLViewer::preDraw(), at the beginning of
+ QGLViewer::draw(). If you modified the \c GL_PROJECTION matrix (for instance using
+ QGLViewer::startScreenCoordinatesSystem()), the two results differ.
+ 
+ The result is an OpenGL 4x4 matrix, which is given in \e column-major order (see \c glMultMatrix
+ man page for details).
+
+ See also getModelViewMatrix() and setFromProjectionMatrix(). */
+void Camera::getProjectionMatrix(GLdouble m[16]) const
+{
+  // May not be needed, but easier and more robust like this.
+  computeProjectionMatrix();
+  for (unsigned short i=0; i&lt;16; ++i)
+    m[i] = projectionMatrix_[i];
+}
+
+/*! Fills \p m with the Camera modelView matrix values.
+
+ First calls computeModelViewMatrix() to define the Camera modelView matrix.
+
+ Note that this matrix is usually \e not the one you would get from a \c
+ glGetDoublev(GL_MODELVIEW_MATRIX, m). It actually represents the state of the \c
+ GL_MODELVIEW after QGLViewer::preDraw(), at the beginning of QGLViewer::draw(). It converts from
+ the world to the Camera coordinate system. As soon as you modify the \c GL_MODELVIEW in your
+ QGLViewer::draw() method, the two matrices differ.
+
+ The result is an OpenGL 4x4 matrix, which is given in \e column-major order (see \c glMultMatrix
+ man page for details).
+
+ See also getProjectionMatrix() and setFromModelViewMatrix(). */
+void Camera::getModelViewMatrix(GLdouble m[16]) const
+{
+  // May not be needed, but easier like this.
+  // Prevents from retrieving matrix in stereo mode -&gt; overwrites shifted value.
+  computeModelViewMatrix();
+  for (unsigned short i=0; i&lt;16; ++i)
+    m[i] = modelViewMatrix_[i];
+}
+
+/*! Fills \p m with the product of the ModelView and Projection matrices.
+
+  Calls getModelViewMatrix() and getProjectionMatrix() and then fills \p m with the product of these two matrices. */
+void Camera::getModelViewProjectionMatrix(GLdouble m[16]) const
+{
+  GLdouble mv[16];
+  GLdouble proj[16];
+  getModelViewMatrix(mv);
+  getProjectionMatrix(proj);
+	
+  for (unsigned short i=0; i&lt;4; ++i)
+  {
+    for (unsigned short j=0; j&lt;4; ++j)
+    {
+      double sum = 0.0;
+      for (unsigned short k=0; k&lt;4; ++k)
+        sum += proj[i+4*k]*mv[k+4*j];
+      m[i+4*j] = sum;
+    }
+  }
+}
+
+#ifndef DOXYGEN
+void Camera::getProjectionMatrix(GLfloat m[16]) const
+{
+  qWarning(&quot;Warning : Camera::getProjectionMatrix requires a GLdouble matrix array&quot;);
+  static GLdouble mat[16];
+  getProjectionMatrix(mat);
+  for (int i=0; i&lt;16; ++i)
+    m[i] = float(mat[i]);
+}
+
+void Camera::getModelViewMatrix(GLfloat m[16]) const
+{
+  qWarning(&quot;Warning : Camera::getModelViewMatrix requires a GLdouble matrix array&quot;);
+  static GLdouble mat[16];
+  getModelViewMatrix(mat);
+  for (int i=0; i&lt;16; ++i)
+    m[i] = float(mat[i]);
+}
+#endif
+
+/*! Sets the sceneRadius() value. Negative values are ignored.
+
+\attention This methods also sets focusDistance() to sceneRadius() / tan(fieldOfView()/2) and
+flySpeed() to 1% of sceneRadius(). */
+void Camera::setSceneRadius(float radius)
+{
+  if (radius &lt;= 0.0)
+    {
+      qWarning(&quot;Scene radius must be positive - Ignoring value&quot;);
+      return;
+    }
+
+  sceneRadius_ = radius;
+
+  setFocusDistance(sceneRadius() / tan(fieldOfView()/2.0));
+
+  frame()-&gt;setFlySpeed(0.01*sceneRadius());
+}
+
+/*! Similar to setSceneRadius() and setSceneCenter(), but the scene limits are defined by a (world
+  axis aligned) bounding box. */
+void Camera::setSceneBoundingBox(const Vec&amp; min, const Vec&amp; max)
+{
+  setSceneCenter((min+max)/2.0);
+  setSceneRadius(0.5*(max-min).norm());
+}
+
+
+/*! Sets the sceneCenter().
+
+ \attention This method also sets the revolveAroundPoint() to sceneCenter(). */
+void Camera::setSceneCenter(const Vec&amp; center)
+{
+  sceneCenter_ = center;
+  setRevolveAroundPoint(sceneCenter());
+}
+
+/*! setSceneCenter() to the result of pointUnderPixel(\p pixel).
+
+  Returns \c true if a pointUnderPixel() was found and sceneCenter() was actually changed.
+
+  See also setRevolveAroundPointFromPixel(). See the pointUnderPixel() documentation. */
+bool Camera::setSceneCenterFromPixel(const QPoint&amp; pixel)
+{
+  bool found;
+  Vec point = pointUnderPixel(pixel, found);
+  if (found)
+    setSceneCenter(point);
+  return found;
+}
+
+/*! Changes the revolveAroundPoint() to \p rap (defined in the world coordinate system). */
+void Camera::setRevolveAroundPoint(const Vec&amp; rap)
+{
+  const float prevDist = fabs(cameraCoordinatesOf(revolveAroundPoint()).z);
+
+  frame()-&gt;setRevolveAroundPoint(rap);
+
+  // orthoCoef_ is used to compensate for changes of the revolveAroundPoint, so that the image does
+  // not change when the revolveAroundPoint is changed in ORTHOGRAPHIC mode.
+  const float newDist = fabs(cameraCoordinatesOf(revolveAroundPoint()).z);
+  // Prevents division by zero when rap is set to camera position
+  if ((prevDist &gt; 1E-9) &amp;&amp; (newDist &gt; 1E-9))
+    orthoCoef_ *= prevDist / newDist;
+}
+
+/*! The revolveAroundPoint() is set to the point located under \p pixel on screen.
+
+Returns \c true if a pointUnderPixel() was found. If no point was found under \p pixel, the
+revolveAroundPoint() is left unchanged.
+
+\p pixel is expressed in Qt format (origin in the upper left corner of the window). See
+pointUnderPixel().
+
+See also setSceneCenterFromPixel(). */
+bool Camera::setRevolveAroundPointFromPixel(const QPoint&amp; pixel)
+{
+  bool found;
+  Vec point = pointUnderPixel(pixel, found);
+  if (found)
+    setRevolveAroundPoint(point);
+  return found;
+}
+
+/*! Returns the ratio between pixel and OpenGL units at \p position.
+
+ A line of \c n * pixelGLRatio() OpenGL units, located at \p position in the world coordinates
+ system, will be projected with a length of \c n pixels on screen.
+
+ Use this method to scale objects so that they have a constant pixel size on screen. The following
+ code will draw a 20 pixel line, starting at sceneCenter() and always directed along the screen
+ vertical direction:
+ \code
+ glBegin(GL_LINES);
+ glVertex3fv(sceneCenter());
+ glVertex3fv(sceneCenter() + 20 * pixelGLRatio(sceneCenter()) * camera()-&gt;upVector());
+ glEnd();
+ \endcode */
+float Camera::pixelGLRatio(const Vec&amp; position) const
+{
+  switch (type())
+    {
+    case Camera::PERSPECTIVE :
+      return 2.0 * fabs((frame()-&gt;coordinatesOf(position)).z) * tan(fieldOfView()/2.0) / screenHeight();
+    case Camera::ORTHOGRAPHIC :
+      {
+	GLdouble w, h;
+	getOrthoWidthHeight(w,h);
+	return 2.0 * h / screenHeight();
+      }
+    }
+  // Bad compilers complain
+  return 1.0;
+}
+
+/*! Changes the Camera fieldOfView() so that the entire scene (defined by QGLViewer::sceneCenter()
+ and QGLViewer::sceneRadius()) is visible from the Camera position().
+
+ The position() and orientation() of the Camera are not modified and you first have to orientate the
+ Camera in order to actually see the scene (see lookAt(), showEntireScene() or fitSphere()).
+
+ This method is especially useful for \e shadow \e maps computation. Use the Camera positioning
+ tools (setPosition(), lookAt()) to position a Camera at the light position. Then use this method to
+ define the fieldOfView() so that the shadow map resolution is optimally used:
+ \code
+ // The light camera needs size hints in order to optimize its fieldOfView
+ lightCamera-&gt;setSceneRadius(sceneRadius());
+ lightCamera-&gt;setSceneCenter(sceneCenter());
+
+ // Place the light camera.
+ lightCamera-&gt;setPosition(lightFrame-&gt;position());
+ lightCamera-&gt;lookAt(sceneCenter());
+ lightCamera-&gt;setFOVToFitScene();
+ \endcode
+
+ See the (soon available) shadowMap contribution example for a practical implementation.
+
+ \attention The fieldOfView() is clamped to M_PI/2.0. This happens when the Camera is at a distance
+ lower than sqrt(2.0) * sceneRadius() from the sceneCenter(). It optimizes the shadow map
+ resolution, although it may miss some parts of the scene. */
+void Camera::setFOVToFitScene()
+{
+  if (distanceToSceneCenter() &gt; sqrt(2.0)*sceneRadius())
+    setFieldOfView(2.0 * asin(sceneRadius() / distanceToSceneCenter()));
+  else
+    setFieldOfView(M_PI / 2.0f);
+}
+
+/*! Makes the Camera smoothly zoom on the pointUnderPixel() \p pixel.
+
+ Nothing happens if no pointUnderPixel() is found. Otherwise a KeyFrameInterpolator is created that
+ animates the Camera on a one second path that brings the Camera closer to the point under \p pixel.
+
+ See also interpolateToFitScene(). */
+void Camera::interpolateToZoomOnPixel(const QPoint&amp; pixel)
+{
+  const float coef = 0.1f;
+
+  bool found;
+  Vec target = pointUnderPixel(pixel, found);
+
+  if (!found)
+    return;
+
+  if (interpolationKfi_-&gt;interpolationIsStarted())
+    interpolationKfi_-&gt;stopInterpolation();
+
+  interpolationKfi_-&gt;deletePath();
+  interpolationKfi_-&gt;addKeyFrame(*(frame()));
+
+  interpolationKfi_-&gt;addKeyFrame(Frame(0.3f*frame()-&gt;position() + 0.7f*target, frame()-&gt;orientation()), 0.4f);
+
+  // Small hack: attach a temporary frame to take advantage of lookAt without modifying frame
+  static ManipulatedCameraFrame* tempFrame = new ManipulatedCameraFrame();
+  ManipulatedCameraFrame* const originalFrame = frame();
+  tempFrame-&gt;setPosition(coef*frame()-&gt;position() + (1.0-coef)*target);
+  tempFrame-&gt;setOrientation(frame()-&gt;orientation());
+  setFrame(tempFrame);
+  lookAt(target);
+  setFrame(originalFrame);
+
+  interpolationKfi_-&gt;addKeyFrame(*(tempFrame), 1.0);
+
+  interpolationKfi_-&gt;startInterpolation();
+}
+
+/*! Interpolates the Camera on a one second KeyFrameInterpolator path so that the entire scene fits
+ the screen at the end.
+
+ The scene is defined by its sceneCenter() and its sceneRadius(). See showEntireScene().
+
+ The orientation() of the Camera is not modified. See also interpolateToZoomOnPixel(). */
+void Camera::interpolateToFitScene()
+{
+  if (interpolationKfi_-&gt;interpolationIsStarted())
+    interpolationKfi_-&gt;stopInterpolation();
+
+  interpolationKfi_-&gt;deletePath();
+  interpolationKfi_-&gt;addKeyFrame(*(frame()));
+
+  // Small hack:  attach a temporary frame to take advantage of lookAt without modifying frame
+  static ManipulatedCameraFrame* tempFrame = new ManipulatedCameraFrame();
+  ManipulatedCameraFrame* const originalFrame = frame();
+  tempFrame-&gt;setPosition(frame()-&gt;position());
+  tempFrame-&gt;setOrientation(frame()-&gt;orientation());
+  setFrame(tempFrame);
+  showEntireScene();
+  setFrame(originalFrame);
+
+  interpolationKfi_-&gt;addKeyFrame(*(tempFrame));
+
+  interpolationKfi_-&gt;startInterpolation();
+}
+
+
+/*! Smoothly interpolates the Camera on a KeyFrameInterpolator path so that it goes to \p fr.
+ 
+  \p fr is expressed in world coordinates. \p duration tunes the interpolation speed (default is
+  1 second).
+  
+  See also interpolateToFitScene() and interpolateToZoomOnPixel(). */
+void Camera::interpolateTo(const Frame&amp; fr, float duration)
+{
+  if (interpolationKfi_-&gt;interpolationIsStarted())
+    interpolationKfi_-&gt;stopInterpolation();
+
+  interpolationKfi_-&gt;deletePath();
+  interpolationKfi_-&gt;addKeyFrame(*(frame()));
+  interpolationKfi_-&gt;addKeyFrame(fr, duration);
+
+  interpolationKfi_-&gt;startInterpolation();
+}
+
+
+/*! Returns the coordinates of the 3D point located at pixel (x,y) on screen.
+
+ Calls a \c glReadPixel to get the pixel depth and applies an unprojectedCoordinatesOf() to the
+ result. \p found indicates whether a point was found or not (i.e. background pixel, result's depth
+ is zFar() in that case).
+
+ \p x and \p y are expressed in pixel units with an origin in the upper left corner. Use
+ screenHeight() - y to convert to OpenGL standard.
+
+ \attention This method assumes that a GL context is available, and that its content was drawn using
+ the Camera (i.e. using its projection and modelview matrices). This method hence cannot be used for
+ offscreen Camera computations. Use cameraCoordinatesOf() and worldCoordinatesOf() to perform
+ similar operations in that case.
+
+ \note The precision of the z-Buffer highly depends on how the zNear() and zFar() values are fitted
+ to your scene. Loose boundaries will result in imprecision along the viewing direction. */
+Vec Camera::pointUnderPixel(const QPoint&amp; pixel, bool&amp; found) const
+{
+  float depth;
+  // Qt uses upper corner for its origin while GL uses the lower corner.
+  glReadPixels(pixel.x(), screenHeight()-1-pixel.y(), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &amp;depth);
+  found = depth &lt; 1.0;
+  Vec point(pixel.x(), pixel.y(), depth);
+  point = unprojectedCoordinatesOf(point);
+  return point;
+}
+
+/*! Moves the Camera so that the entire scene is visible.
+
+ Simply calls fitSphere() on a sphere defined by sceneCenter() and sceneRadius().
+
+ You will typically use this method in QGLViewer::init() after you defined a new sceneRadius(). */
+void Camera::showEntireScene()
+{
+  fitSphere(sceneCenter(), sceneRadius());
+}
+
+/*! Moves the Camera so that its sceneCenter() is projected on the center of the window. The
+ orientation() and fieldOfView() are unchanged.
+
+ Simply projects the current position on a line passing through sceneCenter(). See also
+ showEntireScene().*/
+void Camera::centerScene()
+{
+  frame()-&gt;projectOnLine(sceneCenter(), viewDirection());
+}
+
+/*! Sets the Camera orientation(), so that it looks at point \p target (defined in the world
+ coordinate system).
+
+ The Camera position() is not modified. Simply setViewDirection().
+
+ See also setUpVector(), setOrientation(), showEntireScene(), fitSphere() and fitBoundingBox(). */
+void Camera::lookAt(const Vec&amp; target)
+{
+  setViewDirection(target - position());
+}
+
+/*! Moves the Camera so that the sphere defined by (\p center, \p radius) is visible and fits the window.
+
+ The Camera is simply translated along its viewDirection() so that the sphere fits the screen. Its
+ orientation() and its fieldOfView() are unchanged.
+
+ You should therefore orientate the Camera before you call this method. See lookAt(),
+ setOrientation() and setUpVector(). */
+void Camera::fitSphere(const Vec&amp; center, float radius)
+{
+  float distance = 0.0f;
+  switch (type())
+    {
+    case Camera::PERSPECTIVE :
+      {
+	const float yview = radius / sin(fieldOfView()/2.0);
+	const float xview = radius / sin(horizontalFieldOfView()/2.0);
+	distance = qMax(xview,yview);
+	break;
+      }
+    case Camera::ORTHOGRAPHIC :
+      {
+	distance = ((center-revolveAroundPoint()) * viewDirection()) + (radius / orthoCoef_);
+	break;
+      }
+    }
+  Vec newPos(center - distance * viewDirection());
+  frame()-&gt;setPositionWithConstraint(newPos);
+}
+
+/*! Moves the Camera so that the (world axis aligned) bounding box (\p min, \p max) is entirely
+  visible, using fitSphere(). */
+void Camera::fitBoundingBox(const Vec&amp; min, const Vec&amp; max)
+{
+  float diameter = qMax(fabs(max[1]-min[1]), fabs(max[0]-min[0]));
+  diameter = qMax(fabsf(max[2]-min[2]), diameter);
+  fitSphere(0.5*(min+max), 0.5*diameter);
+}
+
+/*! Moves the Camera so that the rectangular screen region defined by \p rectangle (pixel units,
+  with origin in the upper left corner) fits the screen.
+
+  The Camera is translated (its orientation() is unchanged) so that \p rectangle is entirely
+  visible. Since the pixel coordinates only define a \e frustum in 3D, it's the intersection of this
+  frustum with a plane (orthogonal to the viewDirection() and passing through the sceneCenter())
+  that is used to define the 3D rectangle that is eventually fitted. */
+void Camera::fitScreenRegion(const QRect&amp; rectangle)
+{
+  const Vec vd = viewDirection();
+  const float distToPlane = distanceToSceneCenter();
+  const QPoint center = rectangle.center();
+
+  Vec orig, dir;
+  convertClickToLine( center, orig, dir );
+  Vec newCenter = orig + distToPlane / (dir*vd) * dir;
+
+  convertClickToLine( QPoint(rectangle.x(), center.y()), orig, dir );
+  const Vec pointX = orig + distToPlane / (dir*vd) * dir;
+
+  convertClickToLine( QPoint(center.x(), rectangle.y()), orig, dir );
+  const Vec pointY = orig + distToPlane / (dir*vd) * dir;
+
+  float distance = 0.0f;
+  switch (type())
+    {
+    case Camera::PERSPECTIVE :
+      {
+	const float distX = (pointX-newCenter).norm() / sin(horizontalFieldOfView()/2.0);
+	const float distY = (pointY-newCenter).norm() / sin(fieldOfView()/2.0);
+	distance = qMax(distX, distY);
+	break;
+      }
+    case Camera::ORTHOGRAPHIC :
+      {
+	const float dist = ((newCenter-revolveAroundPoint()) * vd);
+	//#CONNECTION# getOrthoWidthHeight
+	const float distX = (pointX-newCenter).norm() / orthoCoef_ / ((aspectRatio() &lt; 1.0) ? 1.0 : aspectRatio());
+	const float distY = (pointY-newCenter).norm() / orthoCoef_ / ((aspectRatio() &lt; 1.0) ? 1.0/aspectRatio() : 1.0);
+	distance = dist + qMax(distX, distY);
+	break;
+      }
+    }
+
+  Vec newPos(newCenter - distance * vd);
+  frame()-&gt;setPositionWithConstraint(newPos);
+}
+
+/*! Rotates the Camera so that its upVector() becomes \p up (defined in the world coordinate
+ system).
+
+ The Camera is rotated around an axis orthogonal to \p up and to the current upVector() direction.
+ Use this method in order to define the Camera horizontal plane.
+
+ When \p noMove is set to \c false, the orientation modification is compensated by a translation, so
+ that the revolveAroundPoint() stays projected at the same position on screen. This is especially
+ useful when the Camera is an observer of the scene (default mouse binding).
+
+ When \p noMove is \c true (default), the Camera position() is left unchanged, which is an intuitive
+ behavior when the Camera is in a walkthrough fly mode (see the QGLViewer::MOVE_FORWARD and
+ QGLViewer::MOVE_BACKWARD QGLViewer::MouseAction). */
+void Camera::setUpVector(const Vec&amp; up, bool noMove)
+{
+  Quaternion q(Vec(0.0, 1.0, 0.0), frame()-&gt;transformOf(up));
+
+  if (!noMove)
+    frame()-&gt;setPosition(revolveAroundPoint() - (frame()-&gt;orientation()*q).rotate(frame()-&gt;coordinatesOf(revolveAroundPoint())));
+
+  frame()-&gt;rotate(q);
+
+  // Useful in fly mode to keep the horizontal direction.
+  frame()-&gt;updateFlyUpVector();
+}
+
+/*! Sets the orientation() of the Camera using polar coordinates.
+
+ \p theta rotates the Camera around its Y axis, and \e then \p phi rotates it around its X axis.
+ The polar coordinates are defined in the world coordinates system: \p theta = \p phi = 0 means
+ that the Camera is directed towards the world Z axis. Both angles are expressed in radians.
+
+ See also setUpVector(). The position() of the Camera is unchanged, you may want to call showEntireScene()
+ after this method to move the Camera.
+
+ This method can be useful to create Quicktime VR panoramic sequences, see the
+ QGLViewer::saveSnapshot() documentation for details. */
+void Camera::setOrientation(float theta, float phi)
+{
+  Vec axis(0.0, 1.0, 0.0);
+  const Quaternion rot1(axis, theta);
+  axis = Vec(-cos(theta), 0., sin(theta));
+  const Quaternion rot2(axis, phi);
+  setOrientation(rot1 * rot2);
+}
+
+/*! Sets the Camera orientation(), defined in the world coordinate system. */
+void Camera::setOrientation(const Quaternion&amp; q)
+{
+  frame()-&gt;setOrientation(q);
+  frame()-&gt;updateFlyUpVector();
+}
+
+/*! Rotates the Camera so that its viewDirection() is \p direction (defined in the world coordinate
+ system).
+
+ The Camera position() is not modified. The Camera is rotated so that the horizon (defined by its
+ upVector()) is preserved. See also lookAt() and setUpVector(). */
+void Camera::setViewDirection(const Vec&amp; direction)
+{
+  if (direction.squaredNorm() &lt; 1E-10)
+    return;
+
+  Vec xAxis = direction ^ upVector();
+  if (xAxis.squaredNorm() &lt; 1E-10)
+    {
+      // target is aligned with upVector, this means a rotation around X axis
+      // X axis is then unchanged, let's keep it !
+      xAxis = frame()-&gt;inverseTransformOf(Vec(1.0, 0.0, 0.0));
+    }
+
+  Quaternion q;
+  q.setFromRotatedBasis(xAxis, xAxis^direction, -direction);
+  frame()-&gt;setOrientationWithConstraint(q);
+}
+
+// Compute a 3 by 3 determinant.
+static float det(float m00,float m01,float m02,
+		 float m10,float m11,float m12,
+		 float m20,float m21,float m22)
+{
+  return m00*m11*m22 + m01*m12*m20 + m02*m10*m21 - m20*m11*m02 - m10*m01*m22 - m00*m21*m12;
+}
+
+// Computes the index of element [i][j] in a \c float matrix[3][4].
+static inline unsigned int ind(unsigned int i, unsigned int j)
+{
+  return (i*4+j);
+}
+
+
+/*! Sets the Camera's position() and orientation() from an OpenGL ModelView matrix.
+
+This enables a Camera initialisation from an other OpenGL application. \p modelView is a 16 GLdouble
+vector representing a valid OpenGL ModelView matrix, such as one can get using:
+\code
+GLdouble mvm[16];
+glGetDoublev(GL_MODELVIEW_MATRIX, mvm);
+myCamera-&gt;setFromModelViewMatrix(mvm);
+\endcode
+
+After this method has been called, getModelViewMatrix() returns a matrix equivalent to \p
+modelView.
+
+Only the orientation() and position() of the Camera are modified.
+
+\note If you defined your matrix as \c GLdouble \c mvm[4][4], pass \c &amp;(mvm[0][0]) as a
+parameter. */
+void Camera::setFromModelViewMatrix(const GLdouble* const modelViewMatrix)
+{
+  // Get upper left (rotation) matrix
+  double upperLeft[3][3];
+  for (int i=0; i&lt;3; ++i)
+    for (int j=0; j&lt;3; ++j)
+      upperLeft[i][j] = modelViewMatrix[i*4+j];
+
+  // Transform upperLeft into the associated Quaternion
+  Quaternion q;
+  q.setFromRotationMatrix(upperLeft);
+
+  setOrientation(q);
+  setPosition(-q.rotate(Vec(modelViewMatrix[12], modelViewMatrix[13], modelViewMatrix[14])));
+}
+
+/*! Defines the Camera position(), orientation() and fieldOfView() from a projection matrix.
+
+ \p matrix has to be given in the format used by vision algorithm. It has 3 lines and 4 columns. It
+ transforms a point from the world homogeneous coordinate system (4 coordinates: \c sx, \c sy, \c sz
+ and \c s) into a point in the screen homogeneous coordinate system (3 coordinates: \c sx, \c sy,
+ and \c s, where \c x and \c y are the pixel coordinates on the screen).
+
+ Its three lines correspond to the homogeneous coordinates of the normals to the planes x=0, y=0 and
+ z=0, defined in the Camera coordinate system.
+
+ The elements of the matrix are ordered in line major order: you can call \c
+ setFromProjectionMatrix(&amp;(matrix[0][0])) if you defined your matrix as a \c float \c matrix[3][4].
+
+ \attention Passing the result of getProjectionMatrix() or getModelViewMatrix() to this method is
+ not possible (purposefully incompatible matrix dimensions). \p matrix is more likely to be the
+ product of these two matrices, without the last line.
+
+ Use setFromModelViewMatrix() to set position() and orientation() from a \c GL_MODELVIEW matrix.
+ fieldOfView() can also be retrieved from a \e perspective \c GL_PROJECTION matrix using 2.0 *
+ atan(1.0/projectionMatrix[5]).
+
+ This code was written by Sylvain Paris. */
+void Camera::setFromProjectionMatrix(const float matrix[12])
+{
+  // The 3 lines of the matrix are the normals to the planes x=0, y=0, z=0
+  // in the camera CS. As we normalize them, we do not need the 4th coordinate.
+  Vec line_0(matrix[ind(0,0)],matrix[ind(0,1)],matrix[ind(0,2)]);
+  Vec line_1(matrix[ind(1,0)],matrix[ind(1,1)],matrix[ind(1,2)]);
+  Vec line_2(matrix[ind(2,0)],matrix[ind(2,1)],matrix[ind(2,2)]);
+
+  line_0.normalize();
+  line_1.normalize();
+  line_2.normalize();
+
+  // The camera position is at (0,0,0) in the camera CS so it is the
+  // intersection of the 3 planes. It can be seen as the kernel
+  // of the 3x4 projection matrix. We calculate it through 4 dimensional
+  // vectorial product. We go directly into 3D that is to say we directly
+  // divide the first 3 coordinates by the 4th one.
+
+  // We derive the 4 dimensional vectorial product formula from the
+  // computation of a 4x4 determinant that is developped according to
+  // its 4th column. This implies some 3x3 determinants.
+  const Vec cam_pos = Vec(det(matrix[ind(0,1)],matrix[ind(0,2)],matrix[ind(0,3)],
+			      matrix[ind(1,1)],matrix[ind(1,2)],matrix[ind(1,3)],
+			      matrix[ind(2,1)],matrix[ind(2,2)],matrix[ind(2,3)]),
+
+			   -det(matrix[ind(0,0)],matrix[ind(0,2)],matrix[ind(0,3)],
+				matrix[ind(1,0)],matrix[ind(1,2)],matrix[ind(1,3)],
+				matrix[ind(2,0)],matrix[ind(2,2)],matrix[ind(2,3)]),
+
+			   det(matrix[ind(0,0)],matrix[ind(0,1)],matrix[ind(0,3)],
+			       matrix[ind(1,0)],matrix[ind(1,1)],matrix[ind(1,3)],
+			       matrix[ind(2,0)],matrix[ind(2,1)],matrix[ind(2,3)])) /
+
+    (-det(matrix[ind(0,0)],matrix[ind(0,1)],matrix[ind(0,2)],
+	  matrix[ind(1,0)],matrix[ind(1,1)],matrix[ind(1,2)],
+	  matrix[ind(2,0)],matrix[ind(2,1)],matrix[ind(2,2)]));
+
+  // We compute the rotation matrix column by column.
+
+  // GL Z axis is front facing.
+  Vec column_2 = -line_2;
+
+  // X-axis is almost like line_0 but should be orthogonal to the Z axis.
+  Vec column_0 = ((column_2^line_0)^column_2);
+  column_0.normalize();
+
+  // Y-axis is almost like line_1 but should be orthogonal to the Z axis.
+  // Moreover line_1 is downward oriented as the screen CS.
+  Vec column_1 = -((column_2^line_1)^column_2);
+  column_1.normalize();
+
+  double rot[3][3];
+  rot[0][0] = column_0[0];
+  rot[1][0] = column_0[1];
+  rot[2][0] = column_0[2];
+
+  rot[0][1] = column_1[0];
+  rot[1][1] = column_1[1];
+  rot[2][1] = column_1[2];
+
+  rot[0][2] = column_2[0];
+  rot[1][2] = column_2[1];
+  rot[2][2] = column_2[2];
+
+  // We compute the field of view
+
+  // line_1^column_0 -&gt; vector of intersection line between
+  // y_screen=0 and x_camera=0 plane.
+  // column_2*(...)  -&gt; cos of the angle between Z vector et y_screen=0 plane
+  // * 2 -&gt; field of view = 2 * half angle
+
+  // We need some intermediate values.
+  Vec dummy = line_1^column_0;
+  dummy.normalize();
+  float fov = acos(column_2*dummy) * 2.0;
+
+  // We set the camera.
+  Quaternion q;
+  q.setFromRotationMatrix(rot);
+  setOrientation(q);
+  setPosition(cam_pos);
+  setFieldOfView(fov);
+}
+
+
+/*
+	// persp : projectionMatrix_[0]  = f/aspectRatio();
+void Camera::setFromProjectionMatrix(const GLdouble* projectionMatrix)
+{
+  QString message;
+  if ((fabs(projectionMatrix[1]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[2]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[3]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[4]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[6]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[7]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[8]) &gt; 1E-3) ||
+      (fabs(projectionMatrix[9]) &gt; 1E-3))
+    message = &quot;Non null coefficient in projection matrix - Aborting&quot;;
+  else
+    if ((fabs(projectionMatrix[11]+1.0) &lt; 1E-5) &amp;&amp; (fabs(projectionMatrix[15]) &lt; 1E-5))
+      {
+	if (projectionMatrix[5] &lt; 1E-4)
+	  message=&quot;Negative field of view in Camera::setFromProjectionMatrix&quot;;
+	else
+	  setType(Camera::PERSPECTIVE);
+      }
+    else
+      if ((fabs(projectionMatrix[11]) &lt; 1E-5) &amp;&amp; (fabs(projectionMatrix[15]-1.0) &lt; 1E-5))
+	setType(Camera::ORTHOGRAPHIC);
+      else
+	message = &quot;Unable to determine camera type in setFromProjectionMatrix - Aborting&quot;;
+
+  if (!message.isEmpty())
+    {
+      qWarning(message);
+      return;
+    }
+
+  switch (type())
+    {
+    case Camera::PERSPECTIVE:
+      {
+	setFieldOfView(2.0 * atan(1.0/projectionMatrix[5]));
+	const float far = projectionMatrix[14] / (2.0 * (1.0 + projectionMatrix[10]));
+	const float near = (projectionMatrix[10]+1.0) / (projectionMatrix[10]-1.0) * far;
+	setSceneRadius((far-near)/2.0);
+	setSceneCenter(position() + (near + sceneRadius())*viewDirection());
+	break;
+      }
+    case Camera::ORTHOGRAPHIC:
+      {
+	GLdouble w, h;
+	getOrthoWidthHeight(w,h);
+	projectionMatrix_[0]  = 1.0/w;
+	projectionMatrix_[5]  = 1.0/h;
+	projectionMatrix_[10] = -2.0/(ZFar - ZNear);
+	projectionMatrix_[11] = 0.0;
+	projectionMatrix_[14] = -(ZFar + ZNear)/(ZFar - ZNear);
+	projectionMatrix_[15] = 1.0;
+	// same as glOrtho( -w, w, -h, h, zNear(), zFar() );
+	break;
+      }
+    }
+}
+*/
+
+///////////////////////// Camera to world transform ///////////////////////
+
+/*! Same as cameraCoordinatesOf(), but with \c float[3] parameters (\p src and \p res may be identical pointers). */
+void Camera::getCameraCoordinatesOf(const float src[3], float res[3]) const
+{
+  Vec r = cameraCoordinatesOf(Vec(src));
+  for (int i=0; i&lt;3; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as worldCoordinatesOf(), but with \c float[3] parameters (\p src and \p res may be identical pointers). */
+void Camera::getWorldCoordinatesOf(const float src[3], float res[3]) const
+{
+  Vec r = worldCoordinatesOf(Vec(src));
+  for (int i=0; i&lt;3; ++i)
+    res[i] = r[i];
+}
+
+/*! Fills \p viewport with the Camera OpenGL viewport.
+
+This method is mainly used in conjunction with \c gluProject, which requires such a viewport.
+Returned values are (0, screenHeight(), screenWidth(), - screenHeight()), so that the origin is
+located in the \e upper left corner of the window (Qt style coordinate system). */
+void Camera::getViewport(GLint viewport[4]) const
+{
+  viewport[0] = 0;
+  viewport[1] = screenHeight();
+  viewport[2] = screenWidth();
+  viewport[3] = -screenHeight();
+}
+
+/*! Returns the screen projected coordinates of a point \p src defined in the \p frame coordinate
+ system.
+
+ When \p frame in \c NULL (default), \p src is expressed in the world coordinate system.
+
+ The x and y coordinates of the returned Vec are expressed in pixel, (0,0) being the \e upper left
+ corner of the window. The z coordinate ranges between 0.0 (near plane) and 1.0 (excluded, far
+ plane). See the \c gluProject man page for details.
+
+ unprojectedCoordinatesOf() performs the inverse transformation.
+
+ See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem example&lt;/a&gt;.
+
+ This method only uses the intrinsic Camera parameters (see getModelViewMatrix(),
+ getProjectionMatrix() and getViewport()) and is completely independent of the OpenGL \c
+ GL_MODELVIEW, \c GL_PROJECTION and viewport matrices. You can hence define a virtual Camera and use
+ this method to compute projections out of a classical rendering context.
+
+ \attention However, if your Camera is not attached to a QGLViewer (used for offscreen computations
+ for instance), make sure the Camera matrices are updated before calling this method. Call
+ computeModelViewMatrix() and computeProjectionMatrix() to do so.
+
+ If you call this method several times with no change in the matrices, consider precomputing the
+ projection times modelview matrix to save computation time if required (\c P x \c M in the \c
+ gluProject man page). */
+Vec Camera::projectedCoordinatesOf(const Vec&amp; src, const Frame* frame) const
+{
+  GLdouble x,y,z;
+  static GLint viewport[4];
+  getViewport(viewport);
+
+  if (frame)
+    {
+      const Vec tmp = frame-&gt;inverseCoordinatesOf(src);
+      gluProject(tmp.x,tmp.y,tmp.z, modelViewMatrix_, projectionMatrix_, viewport,  &amp;x,&amp;y,&amp;z);
+    }
+  else
+    gluProject(src.x,src.y,src.z, modelViewMatrix_, projectionMatrix_, viewport,  &amp;x,&amp;y,&amp;z);
+
+  return Vec(x,y,z);
+}
+
+/*! Returns the world unprojected coordinates of a point \p src defined in the screen coordinate
+ system.
+
+ The \p src.x and \p src.y input values are expressed in pixels, (0,0) being the \e upper left corner
+ of the window. \p src.z is a depth value ranging in [0..1[ (near and far plane respectively). See
+ the \c gluUnProject man page for details.
+
+ The result is expressed in the \p frame coordinate system. When \p frame is \c NULL (default), the
+ result is expressed in the world coordinates system. The possible \p frame Frame::referenceFrame()
+ are taken into account.
+
+ projectedCoordinatesOf() performs the inverse transformation.
+
+ This method only uses the intrinsic Camera parameters (see getModelViewMatrix(),
+ getProjectionMatrix() and getViewport()) and is completely independent of the OpenGL \c
+ GL_MODELVIEW, \c GL_PROJECTION and viewport matrices. You can hence define a virtual Camera and use
+ this method to compute un-projections out of a classical rendering context.
+
+ \attention However, if your Camera is not attached to a QGLViewer (used for offscreen computations
+ for instance), make sure the Camera matrices are updated before calling this method (use
+ computeModelViewMatrix(), computeProjectionMatrix()). See also setScreenWidthAndHeight().
+
+ This method is not computationally optimized. If you call it several times with no change in the
+ matrices, you should buffer the entire inverse projection matrix (modelview, projection and then
+ viewport) to speed-up the queries. See the \c gluUnProject man page for details. */
+Vec Camera::unprojectedCoordinatesOf(const Vec&amp; src, const Frame* frame) const
+{
+  GLdouble x,y,z;
+  static GLint viewport[4];
+  getViewport(viewport);
+  gluUnProject(src.x,src.y,src.z, modelViewMatrix_,  projectionMatrix_,  viewport,  &amp;x,&amp;y,&amp;z);
+  if (frame)
+    return frame-&gt;coordinatesOf(Vec(x,y,z));
+  else
+    return Vec(x,y,z);
+}
+
+/*! Same as projectedCoordinatesOf(), but with \c float parameters (\p src and \p res can be identical pointers). */
+void Camera::getProjectedCoordinatesOf(const float src[3], float res[3], const Frame* frame) const
+{
+  Vec r = projectedCoordinatesOf(Vec(src), frame);
+  for (int i=0; i&lt;3; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as unprojectedCoordinatesOf(), but with \c float parameters (\p src and \p res can be identical pointers). */
+void Camera::getUnprojectedCoordinatesOf(const float src[3], float res[3], const Frame* frame) const
+{
+  Vec r = unprojectedCoordinatesOf(Vec(src), frame);
+  for (int i=0; i&lt;3; ++i)
+    res[i] = r[i];
+}
+
+/////////////////////////////////////  KFI /////////////////////////////////////////
+
+/*! Returns the KeyFrameInterpolator that defines the Camera path number \p i.
+
+If path \p i is not defined for this index, the method returns a \c NULL pointer. */
+KeyFrameInterpolator* Camera::keyFrameInterpolator(int i) const
+{
+  if (kfi_.contains(i))
+    return kfi_[i];
+  else
+    return NULL;
+}
+
+/*! Sets the KeyFrameInterpolator that defines the Camera path of index \p i.
+
+ The previous keyFrameInterpolator() is lost and should be deleted by the calling method if
+ needed.
+
+ The KeyFrameInterpolator::interpolated() signal of \p kfi probably needs to be connected to the
+ Camera's associated QGLViewer::updateGL() slot, so that when the Camera position is interpolated
+ using \p kfi, every interpolation step updates the display:
+ \code
+ myViewer.camera()-&gt;deletePath(3);
+ myViewer.camera()-&gt;setKeyFrameInterpolator(3, myKeyFrameInterpolator);
+ connect(myKeyFrameInterpolator, SIGNAL(interpolated()), myViewer, SLOT(updateGL());
+ \endcode
+
+ \note These connections are done automatically when a Camera is attached to a QGLViewer, or when a
+ new KeyFrameInterpolator is defined using the QGLViewer::addKeyFrameKeyboardModifiers() and
+ QGLViewer::pathKey() (default is Alt+F[1-12]). See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt;
+ for details. */
+void Camera::setKeyFrameInterpolator(int i, KeyFrameInterpolator* const kfi)
+{
+  if (kfi)
+    kfi_[i] = kfi;
+  else
+    kfi_.remove(i);
+}
+
+/*! Adds the current Camera position() and orientation() as a keyFrame to the path number \p i.
+
+This method can also be used if you simply want to save a Camera point of view (a path made of a
+single keyFrame). Use playPath() to make the Camera play the keyFrame path (resp. restore
+the point of view). Use deletePath() to clear the path.
+
+The default keyboard shortcut for this method is Alt+F[1-12]. Set QGLViewer::pathKey() and
+QGLViewer::addKeyFrameKeyboardModifiers().
+
+If you use directly this method and the keyFrameInterpolator(i) does not exist, a new one is
+created. Its KeyFrameInterpolator::interpolated() signal should then be connected to the
+QGLViewer::updateGL() slot (see setKeyFrameInterpolator()). */
+void Camera::addKeyFrameToPath(int i)
+{
+  if (!kfi_.contains(i))
+    setKeyFrameInterpolator(i, new KeyFrameInterpolator(frame()));
+
+  kfi_[i]-&gt;addKeyFrame(*(frame()));
+}
+
+/*! Makes the Camera follow the path of keyFrameInterpolator() number \p i.
+
+ If the interpolation is started, it stops it instead.
+
+ This method silently ignores undefined (empty) paths (see keyFrameInterpolator()).
+
+ The default keyboard shortcut for this method is F[1-12]. Set QGLViewer::pathKey() and
+ QGLViewer::playPathKeyboardModifiers(). */
+void Camera::playPath(int i)
+{
+  if (kfi_.contains(i))
+    if (kfi_[i]-&gt;interpolationIsStarted())
+      kfi_[i]-&gt;stopInterpolation();
+    else
+      kfi_[i]-&gt;startInterpolation();
+}
+
+/*! Resets the path of the keyFrameInterpolator() number \p i.
+
+If this path is \e not being played (see playPath() and
+KeyFrameInterpolator::interpolationIsStarted()), resets it to is its starting position (see
+KeyFrameInterpolator::resetInterpolation()). If the path is played, simply stops interpolation. */
+void Camera::resetPath(int i)
+{
+  if (kfi_.contains(i))
+    if ((kfi_[i]-&gt;interpolationIsStarted()))
+      kfi_[i]-&gt;stopInterpolation();
+    else
+      {
+	kfi_[i]-&gt;resetInterpolation();
+	kfi_[i]-&gt;interpolateAtTime(kfi_[i]-&gt;interpolationTime());
+      }
+}
+
+/*! Deletes the keyFrameInterpolator() of index \p i.
+
+Disconnect the keyFrameInterpolator() KeyFrameInterpolator::interpolated() signal before deleting the
+keyFrameInterpolator() if needed:
+\code
+disconnect(camera()-&gt;keyFrameInterpolator(i), SIGNAL(interpolated()), this, SLOT(updateGL()));
+camera()-&gt;deletePath(i);
+\endcode */
+void Camera::deletePath(int i)
+{
+  if (kfi_.contains(i))
+    {
+      kfi_[i]-&gt;stopInterpolation();
+      delete kfi_[i];
+      kfi_.remove(i);
+    }
+}
+
+/*! Draws all the Camera paths defined by the keyFrameInterpolator().
+
+ Simply calls KeyFrameInterpolator::drawPath() for all the defined paths. The path color is the
+ current \c glColor().
+
+ \attention The OpenGL state is modified by this method: see KeyFrameInterpolator::drawPath(). */
+void Camera::drawAllPaths()
+{
+  for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = kfi_.begin(), end=kfi_.end(); it != end; ++it)
+#if QT_VERSION &gt;= 0x040000
+    (it.value())-&gt;drawPath(3, 5, sceneRadius());
+#else
+    (it.data())-&gt;drawPath(3, 5, sceneRadius());
+#endif
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns an XML \c QDomElement that represents the Camera.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ Concatenates the Camera parameters, the ManipulatedCameraFrame::domElement() and the paths'
+ KeyFrameInterpolator::domElement().
+
+ Use initFromDOMElement() to restore the Camera state from the resulting \c QDomElement.
+
+ If you want to save the Camera state in a file, use:
+ \code
+  QDomDocument document(&quot;myCamera&quot;);
+  doc.appendChild( myCamera-&gt;domElement(&quot;Camera&quot;, document) );
+
+  QFile f(&quot;myCamera.xml&quot;);
+  if (f.open(IO_WriteOnly))
+    {
+      QTextStream out(&amp;f);
+      document.save(out, 2);
+    }
+ \endcode
+
+ Note that the QGLViewer::camera() is automatically saved by QGLViewer::saveStateToFile() when a
+ QGLViewer is closed. Use QGLViewer::restoreStateFromFile() to restore it back. */
+QDomElement Camera::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement de = document.createElement(name);
+  QDomElement paramNode = document.createElement(&quot;Parameters&quot;);
+  paramNode.setAttribute(&quot;fieldOfView&quot;, QString::number(fieldOfView()));
+  paramNode.setAttribute(&quot;zNearCoefficient&quot;, QString::number(zNearCoefficient()));
+  paramNode.setAttribute(&quot;zClippingCoefficient&quot;, QString::number(zClippingCoefficient()));
+  paramNode.setAttribute(&quot;orthoCoef&quot;, QString::number(orthoCoef_));
+  paramNode.setAttribute(&quot;sceneRadius&quot;, QString::number(sceneRadius()));
+  paramNode.appendChild(sceneCenter().domElement(&quot;SceneCenter&quot;, document));
+
+  switch (type())
+    {
+    case Camera::PERSPECTIVE  :	paramNode.setAttribute(&quot;Type&quot;, &quot;PERSPECTIVE&quot;); break;
+    case Camera::ORTHOGRAPHIC :	paramNode.setAttribute(&quot;Type&quot;, &quot;ORTHOGRAPHIC&quot;); break;
+    }
+  de.appendChild(paramNode);
+
+  QDomElement stereoNode = document.createElement(&quot;Stereo&quot;);
+  stereoNode.setAttribute(&quot;IODist&quot;, QString::number(IODistance()));
+  stereoNode.setAttribute(&quot;distToScreen&quot;, QString::number(physicalDistanceToScreen()));
+  stereoNode.setAttribute(&quot;focusDistance&quot;, QString::number(focusDistance()));
+  stereoNode.setAttribute(&quot;physScreenWidth&quot;, QString::number(physicalScreenWidth()));
+  de.appendChild(stereoNode);
+
+  de.appendChild(frame()-&gt;domElement(&quot;ManipulatedCameraFrame&quot;, document));
+
+  // KeyFrame paths
+  for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = kfi_.begin(), end=kfi_.end(); it != end; ++it)
+    {
+#if QT_VERSION &gt;= 0x040000
+      QDomElement kfNode = (it.value())-&gt;domElement(&quot;KeyFrameInterpolator&quot;, document);
+#else
+      QDomElement kfNode = (it.data())-&gt;domElement(&quot;KeyFrameInterpolator&quot;, document);
+#endif
+      kfNode.setAttribute(&quot;index&quot;, QString::number(it.key()));
+      de.appendChild(kfNode);
+    }
+
+  return de;
+}
+
+/*! Restores the Camera state from a \c QDomElement created by domElement().
+
+ Use the following code to retrieve a Camera state from a file created using domElement():
+ \code
+ // Load DOM from file
+ QDomDocument document;
+ QFile f(&quot;myCamera.xml&quot;);
+ if (f.open(IO_ReadOnly))
+ {
+   document.setContent(&amp;f);
+   f.close();
+ }
+
+ // Parse the DOM tree
+ QDomElement main = document.documentElement();
+ myCamera-&gt;initFromDOMElement(main);
+ \endcode
+
+ The frame() pointer is not modified by this method. The frame() state is however modified.
+
+ \attention The original keyFrameInterpolator() are deleted and should be copied first if they are shared. */
+void Camera::initFromDOMElement(const QDomElement&amp; element)
+{
+  QDomElement child=element.firstChild().toElement();
+
+  for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = kfi_.begin(), end=kfi_.end(); it != end; ++it)
+    deletePath(it.key());
+
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;Parameters&quot;)
+	{
+	  // #CONNECTION# Default values set in constructor
+	  setFieldOfView(DomUtils::floatFromDom(child, &quot;fieldOfView&quot;, M_PI/4.0f));
+	  setZNearCoefficient(DomUtils::floatFromDom(child, &quot;zNearCoefficient&quot;, 0.005f));
+	  setZClippingCoefficient(DomUtils::floatFromDom(child, &quot;zClippingCoefficient&quot;, sqrt(3.0)));
+	  orthoCoef_ = DomUtils::floatFromDom(child, &quot;orthoCoef&quot;, tan(fieldOfView()/2.0));
+	  setSceneRadius(DomUtils::floatFromDom(child, &quot;sceneRadius&quot;, sceneRadius()));
+
+	  setType(PERSPECTIVE);
+	  QString type = child.attribute(&quot;Type&quot;, &quot;PERSPECTIVE&quot;);
+	  if (type == &quot;PERSPECTIVE&quot;)  setType(Camera::PERSPECTIVE);
+	  if (type == &quot;ORTHOGRAPHIC&quot;) setType(Camera::ORTHOGRAPHIC);
+
+      QDomElement child2=child.firstChild().toElement();
+      while (!child2.isNull())
+	  {
+	    /* Although the scene does not change when a camera is loaded, restore the saved center and radius values. 
+	       Mainly useful when a the viewer is restored on startup, with possible additional cameras. */
+	    if (child2.tagName() == &quot;SceneCenter&quot;)
+	      setSceneCenter(Vec(child2));
+
+	    child2 = child2.nextSibling().toElement();
+	  }
+	}
+
+      if (child.tagName() == &quot;ManipulatedCameraFrame&quot;)
+	frame()-&gt;initFromDOMElement(child);
+
+      if (child.tagName() == &quot;Stereo&quot;)
+	{
+	  setIODistance(DomUtils::floatFromDom(child, &quot;IODist&quot;, 0.062f));
+	  setPhysicalDistanceToScreen(DomUtils::floatFromDom(child, &quot;distToScreen&quot;, 0.5f));
+	  setFocusDistance(DomUtils::floatFromDom(child, &quot;focusDistance&quot;, focusDistance()));
+	  setPhysicalScreenWidth(DomUtils::floatFromDom(child, &quot;physScreenWidth&quot;, 0.4f));
+	}
+
+      if (child.tagName() == &quot;KeyFrameInterpolator&quot;)
+	{
+	  int index = DomUtils::intFromDom(child, &quot;index&quot;, 0);
+	  setKeyFrameInterpolator(index, new KeyFrameInterpolator(frame()));
+	  if (keyFrameInterpolator(index))
+	    keyFrameInterpolator(index)-&gt;initFromDOMElement(child);
+	}
+
+      child = child.nextSibling().toElement();
+    }
+}
+
+/*! Gives the coefficients of a 3D half-line passing through the Camera eye and pixel (x,y).
+
+ The origin of the half line (eye position) is stored in \p orig, while \p dir contains the properly
+ oriented and normalized direction of the half line.
+
+ \p x and \p y are expressed in Qt format (origin in the upper left corner). Use screenHeight() - y
+ to convert to OpenGL units.
+
+ This method is useful for analytical intersection in a selection method.
+
+ See the &lt;a href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration. */
+void Camera::convertClickToLine(const QPoint&amp; pixel, Vec&amp; orig, Vec&amp; dir) const
+{
+  switch (type())
+    {
+    case Camera::PERSPECTIVE:
+      orig = position();
+      dir = Vec( ((2.0 * pixel.x() / screenWidth()) - 1.0) * tan(fieldOfView()/2.0) * aspectRatio(),
+		 ((2.0 * (screenHeight()-pixel.y()) / screenHeight()) - 1.0) * tan(fieldOfView()/2.0),
+		 -1.0 );
+      dir = worldCoordinatesOf(dir) - orig;
+      dir.normalize();
+      break;
+
+    case Camera::ORTHOGRAPHIC:
+      {
+	GLdouble w,h;
+	getOrthoWidthHeight(w,h);
+	orig = Vec((2.0 * pixel.x() / screenWidth() - 1.0)*w, -(2.0 * pixel.y() / screenHeight() - 1.0)*h, 0.0);
+	orig = worldCoordinatesOf(orig);
+	dir = viewDirection();
+	break;
+      }
+    }
+}
+
+#ifndef DOXYGEN
+/*! This method has been deprecated in libQGLViewer version 2.2.0 */
+void Camera::drawCamera(float, float, float)
+{
+  qWarning(&quot;drawCamera is deprecated. Use Camera::draw() instead.&quot;);
+}
+#endif
+
+/*! Draws a representation of the Camera in the 3D world.
+
+The near and far planes are drawn as quads, the frustum is drawn using lines and the camera up
+vector is represented by an arrow to disambiguate the drawing. See the 
+&lt;a href=&quot;../examples/standardCamera.html&quot;&gt;standardCamera example&lt;/a&gt; for an illustration.
+
+Note that the current \c glColor and \c glPolygonMode are used to draw the near and far planes. See
+the &lt;a href=&quot;../examples/frustumCulling.html&quot;&gt;frustumCulling example&lt;/a&gt; for an example of
+semi-transparent plane drawing. Similarly, the current \c glLineWidth and \c glColor is used to draw
+the frustum outline.
+
+When \p drawFarPlane is \c false, only the near plane is drawn. \p scale can be used to scale the
+drawing: a value of 1.0 (default) will draw the Camera's frustum at its actual size.
+
+This method assumes that the \c glMatrixMode is \c GL_MODELVIEW and that the current ModelView
+matrix corresponds to the world coordinate system (as it is at the beginning of QGLViewer::draw()).
+The Camera is then correctly positioned and orientated.
+
+\note The drawing of a QGLViewer's own QGLViewer::camera() should not be visible, but may create
+artefacts due to numerical imprecisions. */
+void Camera::draw(bool drawFarPlane, float scale) const
+{
+  glPushMatrix();
+  glMultMatrixd(frame()-&gt;worldMatrix());
+
+  // 0 is the upper left coordinates of the near corner, 1 for the far one
+  Vec points[2];
+
+  points[0].z = scale * zNear();
+  points[1].z = scale * zFar();
+
+  switch (type())
+    {
+    case Camera::PERSPECTIVE:
+      {
+	points[0].y = points[0].z * tan(fieldOfView()/2.0);
+	points[0].x = points[0].y * aspectRatio();
+
+	const float ratio = points[1].z / points[0].z;
+
+	points[1].y = ratio * points[0].y;
+	points[1].x = ratio * points[0].x;
+	break;
+      }
+    case Camera::ORTHOGRAPHIC:
+      {
+	GLdouble hw, hh;
+	getOrthoWidthHeight(hw, hh);
+	points[0].x = points[1].x = scale * float(hw);
+	points[0].y = points[1].y = scale * float(hh);
+	break;
+      }
+    }
+
+  const int farIndex = drawFarPlane?1:0;
+
+  // Near and (optionally) far plane(s)
+  glBegin(GL_QUADS);
+  for (int i=farIndex; i&gt;=0; --i)
+    {
+      glNormal3f(0.0, 0.0, (i==0)?1.0:-1.0);
+      glVertex3f( points[i].x,  points[i].y, -points[i].z);
+      glVertex3f(-points[i].x,  points[i].y, -points[i].z);
+      glVertex3f(-points[i].x, -points[i].y, -points[i].z);
+      glVertex3f( points[i].x, -points[i].y, -points[i].z);
+    }
+  glEnd();
+
+  // Up arrow
+  const float arrowHeight    = 1.5f * points[0].y;
+  const float baseHeight     = 1.2f * points[0].y;
+  const float arrowHalfWidth = 0.5f * points[0].x;
+  const float baseHalfWidth  = 0.3f * points[0].x;
+
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  // Base
+  glBegin(GL_QUADS);
+  glVertex3f(-baseHalfWidth, points[0].y, -points[0].z);
+  glVertex3f( baseHalfWidth, points[0].y, -points[0].z);
+  glVertex3f( baseHalfWidth, baseHeight,  -points[0].z);
+  glVertex3f(-baseHalfWidth, baseHeight,  -points[0].z);
+  glEnd();
+
+  // Arrow
+  glBegin(GL_TRIANGLES);
+  glVertex3f( 0.0f,           arrowHeight, -points[0].z);
+  glVertex3f(-arrowHalfWidth, baseHeight,  -points[0].z);
+  glVertex3f( arrowHalfWidth, baseHeight,  -points[0].z);
+  glEnd();
+  
+  // Frustum lines
+  switch (type())
+    {
+    case Camera::PERSPECTIVE :
+      glBegin(GL_LINES);
+      glVertex3f(0.0f, 0.0f, 0.0f);
+      glVertex3f( points[farIndex].x,  points[farIndex].y, -points[farIndex].z);
+      glVertex3f(0.0f, 0.0f, 0.0f);
+      glVertex3f(-points[farIndex].x,  points[farIndex].y, -points[farIndex].z);
+      glVertex3f(0.0f, 0.0f, 0.0f);
+      glVertex3f(-points[farIndex].x, -points[farIndex].y, -points[farIndex].z);
+      glVertex3f(0.0f, 0.0f, 0.0f);
+      glVertex3f( points[farIndex].x, -points[farIndex].y, -points[farIndex].z);
+      glEnd();
+      break;
+    case Camera::ORTHOGRAPHIC :
+      if (drawFarPlane)
+	{
+	  glBegin(GL_LINES);
+	  glVertex3f( points[0].x,  points[0].y, -points[0].z);
+	  glVertex3f( points[1].x,  points[1].y, -points[1].z);
+	  glVertex3f(-points[0].x,  points[0].y, -points[0].z);
+	  glVertex3f(-points[1].x,  points[1].y, -points[1].z);
+	  glVertex3f(-points[0].x, -points[0].y, -points[0].z);
+	  glVertex3f(-points[1].x, -points[1].y, -points[1].z);
+	  glVertex3f( points[0].x, -points[0].y, -points[0].z);
+	  glVertex3f( points[1].x, -points[1].y, -points[1].z);
+	  glEnd();
+	}
+    }
+
+  glPopMatrix();
+}
+
+
+/*! Returns the 6 plane equations of the Camera frustum.
+
+The six 4-component vectors of \p coef respectively correspond to the left, right, near, far, top
+and bottom Camera frustum planes. Each vector holds a plane equation of the form:
+\code
+a*x + b*y + c*z + d = 0 
+\endcode
+where \c a, \c b, \c c and \c d are the 4 components of each vector, in that order.
+
+See the &lt;a href=&quot;../examples/frustumCulling.html&quot;&gt;frustumCulling example&lt;/a&gt; for an application.
+
+This format is compatible with the \c glClipPlane() function. One camera frustum plane can hence be
+applied in an other viewer to visualize the culling results:
+\code
+ // Retrieve plance equations
+ GLdouble coef[6][4];
+ mainViewer-&gt;camera()-&gt;getFrustumPlanesCoefficients(coef);
+
+ // These two additional clipping planes (which must have been enabled)
+ // will reproduce the mainViewer's near and far clipping.
+ glClipPlane(GL_CLIP_PLANE0, coef[2]);
+ glClipPlane(GL_CLIP_PLANE1, coef[3]);
+\endcode */
+void Camera::getFrustumPlanesCoefficients(GLdouble coef[6][4]) const
+{
+  // Computed once and for all
+  const Vec pos          = position();
+  const Vec viewDir      = viewDirection();
+  const Vec up           = upVector();
+  const Vec right        = rightVector();
+  const float posViewDir = pos * viewDir;
+
+  static Vec normal[6];
+  static GLdouble dist[6];
+  
+  switch (type())
+    {
+    case Camera::PERSPECTIVE :
+      {
+	const float hhfov = horizontalFieldOfView() / 2.0;
+	const float chhfov = cos(hhfov);
+	const float shhfov = sin(hhfov);
+	normal[0] = - shhfov * viewDir;
+	normal[1] = normal[0] + chhfov * right;
+	normal[0] = normal[0] - chhfov * right;
+	
+	normal[2] = -viewDir;
+	normal[3] =  viewDir;
+	
+	const float hfov = fieldOfView() / 2.0;
+	const float chfov = cos(hfov);
+	const float shfov = sin(hfov);
+	normal[4] = - shfov * viewDir;
+	normal[5] = normal[4] - chfov * up;
+	normal[4] = normal[4] + chfov * up;
+
+	for (int i=0; i&lt;2; ++i)
+	  dist[i] = pos * normal[i];
+	for (int j=4; j&lt;6; ++j)
+	  dist[j] = pos * normal[j];
+
+	// Natural equations are:
+	// dist[0,1,4,5] = pos * normal[0,1,4,5];
+	// dist[2] = (pos + zNear() * viewDir) * normal[2];
+	// dist[3] = (pos + zFar()  * viewDir) * normal[3];
+
+	// 2 times less computations using expanded/merged equations. Dir vectors are normalized.
+	const float posRightCosHH = chhfov * pos * right;
+	dist[0] = -shhfov * posViewDir;
+	dist[1] = dist[0] + posRightCosHH;
+	dist[0] = dist[0] - posRightCosHH;
+	const float posUpCosH = chfov * pos * up;
+	dist[4] = - shfov * posViewDir;
+	dist[5] = dist[4] - posUpCosH;
+	dist[4] = dist[4] + posUpCosH;
+	
+	break;
+      }
+    case Camera::ORTHOGRAPHIC :
+      normal[0] = -right;
+      normal[1] =  right;
+      normal[4] =  up;
+      normal[5] = -up;
+
+      GLdouble hw, hh;
+      getOrthoWidthHeight(hw, hh);
+      dist[0] = (pos - hw * right) * normal[0];
+      dist[1] = (pos + hw * right) * normal[1];
+      dist[4] = (pos + hh * up) * normal[4];
+      dist[5] = (pos - hh * up) * normal[5];
+      break;
+    }
+
+  // Front and far planes are identical for both camera types.
+  normal[2] = -viewDir;
+  normal[3] =  viewDir;
+  dist[2] = -posViewDir - zNear();
+  dist[3] =  posViewDir + zFar();
+
+  for (int i=0; i&lt;6; ++i)
+    {
+      coef[i][0] = GLdouble(normal[i].x);
+      coef[i][1] = GLdouble(normal[i].y);
+      coef[i][2] = GLdouble(normal[i].z);
+      coef[i][3] = dist[i];
+    }
+}

Added: trunk/lib/QGLViewer/camera.h
===================================================================
--- trunk/lib/QGLViewer/camera.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/camera.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,584 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_CAMERA_H
+#define QGLVIEWER_CAMERA_H
+
+#include &quot;manipulatedCameraFrame.h&quot;
+#include &quot;keyFrameInterpolator.h&quot;
+
+namespace qglviewer {
+  /*! \brief A perspective or orthographic camera.
+  \class Camera camera.h QGLViewer/camera.h
+
+  A Camera defines some intrinsic parameters (fieldOfView(), position(), viewDirection(),
+  upVector()...) and useful positioning tools that ease its placement (showEntireScene(),
+  fitSphere(), lookAt()...). It exports its associated OpenGL projection and modelview matrices and
+  can interactively be modified using the mouse.
+
+  &lt;h3&gt;Mouse manipulation&lt;/h3&gt;
+
+  The position() and orientation() of the Camera are defined by a ManipulatedCameraFrame (retrieved
+  using frame()). These methods are just convenient wrappers to the equivalent Frame methods. This
+  also means that the Camera frame() can be attached to a Frame::referenceFrame() which enables
+  complex Camera setups.
+
+  Different displacements can be performed using the mouse. The list of possible actions is defined
+  by the QGLViewer::MouseAction enum. Use QGLViewer::setMouseBinding() to attach a specific action
+  to an arbitrary mouse button-state key binding. These actions are detailed in the &lt;a
+  href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;.
+
+  The default button binding are: QGLViewer::ROTATE (left), QGLViewer::ZOOM (middle) and
+  QGLViewer::TRANSLATE (right). With this configuration, the Camera \e observes a scene and rotates
+  around its revolveAroundPoint(). You can switch between this mode and a fly mode using the
+  QGLViewer::CAMERA_MODE (see QGLViewer::toggleCameraMode()) keyboard shortcut (default is 'Space').
+
+  &lt;h3&gt;Other functionalities&lt;/h3&gt;
+
+  The type() of the Camera can be Camera::ORTHOGRAPHIC or Camera::PERSPECTIVE (see Type()).
+  fieldOfView() is meaningless with Camera::ORTHOGRAPHIC.
+
+  The near and far planes of the Camera are fitted to the scene and determined from
+  QGLViewer::sceneRadius(), QGLViewer::sceneCenter() and zClippingCoefficient() by the zNear() and
+  zFar() methods. Reasonable values on the scene extends hence have to be provided to the QGLViewer
+  in order for the Camera to correctly display the scene. High level positioning methods also use
+  this information (showEntireScene(), centerScene()...).
+
+  A Camera holds KeyFrameInterpolator that can be used to save Camera positions and paths. You can
+  interactively addKeyFrameToPath() to a given path using the default \c Alt+F[1-12] shortcuts. Use
+  playPath() to make the Camera follow the path (default shortcut is F[1-12]). See the &lt;a
+  href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details on key customization.
+
+  Use cameraCoordinatesOf() and worldCoordinatesOf() to convert to and from the Camera frame()
+  coordinate system. projectedCoordinatesOf() and unprojectedCoordinatesOf() will convert from
+  screen to 3D coordinates. convertClickToLine() is very useful for analytical object selection.
+
+  Stereo display is possible on machines with quad buffer capabilities (with Camera::PERSPECTIVE
+  type() only). Test the &lt;a href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt; to check.
+
+  A Camera can also be used outside of a QGLViewer or even without OpenGL for its coordinate system
+  conversion capabilities. Note however that some of them explicitly rely on the presence of a
+  Z-buffer. \nosubgrouping */
+  class QGLVIEWER_EXPORT Camera : public QObject
+  {
+#ifndef DOXYGEN
+    friend class ::QGLViewer;
+#endif
+
+    Q_OBJECT
+
+  public:
+    Camera();
+    virtual ~Camera();
+
+    Camera(const Camera&amp; camera);
+    Camera&amp; operator=(const Camera&amp; camera);
+
+
+    /*! Enumerates the two possible types of Camera.
+
+    See type() and setType(). This type mainly defines different Camera projection matrix (see
+    loadProjectionMatrix()). Many other methods (pointUnderPixel(), convertClickToLine(),
+    projectedCoordinatesOf(), pixelGLRatio()...) take this Type into account. */
+    enum Type { PERSPECTIVE, ORTHOGRAPHIC };
+
+    /*! @name Position and orientation */
+    //@{
+  public:
+    /*! Returns the Camera position (the eye), defined in the world coordinate system.
+
+    Use setPosition() to set the Camera position. Other convenient methods are showEntireScene() or
+    fitSphere(). Actually returns \c frame()-&gt;position().
+
+    This position corresponds to the projection center of a Camera::PERSPECTIVE Camera. It is not
+    located in the image plane, which is at a zNear() distance ahead. */
+    Vec position() const { return frame()-&gt;position(); };
+
+    /*! Returns the normalized up vector of the Camera, defined in the world coordinate system.
+
+    Set using setUpVector() or setOrientation(). It is orthogonal to viewDirection() and to
+    rightVector().
+
+    It corresponds to the Y axis of the associated frame() (actually returns
+    frame()-&gt;inverseTransformOf(Vec(0.0, 1.0, 0.0)) ). */
+    Vec upVector() const
+    {
+      return frame()-&gt;inverseTransformOf(Vec(0.0, 1.0, 0.0));
+    }
+    /*! Returns the normalized view direction of the Camera, defined in the world coordinate system.
+
+    Change this value using setViewDirection(), lookAt() or setOrientation(). It is orthogonal to
+    upVector() and to rightVector().
+
+    This corresponds to the negative Z axis of the frame() ( frame()-&gt;inverseTransformOf(Vec(0.0,
+    0.0, -1.0)) ). */
+    Vec viewDirection() const { return frame()-&gt;inverseTransformOf(Vec(0.0, 0.0, -1.0)); };
+
+    /*! Returns the normalized right vector of the Camera, defined in the world coordinate system.
+
+    This vector lies in the Camera horizontal plane, directed along the X axis (orthogonal to
+    upVector() and to viewDirection()). Set using setUpVector(), lookAt() or setOrientation().
+
+    Simply returns frame()-&gt;inverseTransformOf(Vec(1.0, 0.0, 0.0)). */
+    Vec rightVector() const
+    {
+      return frame()-&gt;inverseTransformOf(Vec(1.0, 0.0, 0.0));
+    }
+
+    /*! Returns the Camera orientation, defined in the world coordinate system.
+
+    Actually returns \c frame()-&gt;orientation(). Use setOrientation(), setUpVector() or lookAt() to
+    set the Camera orientation. */
+    Quaternion orientation() const { return frame()-&gt;orientation(); };
+
+    void setFromModelViewMatrix(const GLdouble* const modelViewMatrix);
+    void setFromProjectionMatrix(const float matrix[12]);
+
+  public slots:
+    /*! Sets the Camera position() (the eye), defined in the world coordinate system. */
+    void setPosition(const Vec&amp; pos) { frame()-&gt;setPosition(pos); };
+    void setOrientation(const Quaternion&amp; q);
+    void setOrientation(float theta, float phi);
+    void setUpVector(const Vec&amp; up, bool noMove=true);
+    void setViewDirection(const Vec&amp; direction);
+    //@}
+
+
+    /*! @name Positioning tools */
+    //@{
+  public slots:
+    void lookAt(const Vec&amp; target);
+    void showEntireScene();
+    void fitSphere(const Vec&amp; center, float radius);
+    void fitBoundingBox(const Vec&amp; min, const Vec&amp; max);
+    void fitScreenRegion(const QRect&amp; rectangle);
+    void centerScene();
+    void interpolateToZoomOnPixel(const QPoint&amp; pixel);
+    void interpolateToFitScene();
+    void interpolateTo(const Frame&amp; fr, float duration);
+    //@}
+
+
+    /*! @name Frustum */
+    //@{
+  public:
+    /*! Returns the Camera::Type of the Camera.
+
+    Set by setType(). Mainly used by loadProjectionMatrix().
+
+    A Camera::PERSPECTIVE Camera uses a classical projection mainly defined by its fieldOfView().
+
+    With a Camera::ORTHOGRAPHIC type(), the fieldOfView() is meaningless and the width and height of
+    the Camera frustum are inferred from the distance to the revolveAroundPoint() using
+    getOrthoWidthHeight().
+
+    Both types use zNear() and zFar() (to define their clipping planes) and aspectRatio() (for
+    frustum shape). */
+    Type type() const { return type_; };
+
+    /*! Returns the vertical field of view of the Camera (in radians).
+
+    Value is set using setFieldOfView(). Default value is pi/4 radians. This value is meaningless if
+    the Camera type() is Camera::ORTHOGRAPHIC.
+
+    The field of view corresponds the one used in \c gluPerspective (see manual). It sets the Y
+    (vertical) aperture of the Camera. The X (horizontal) angle is inferred from the window aspect
+    ratio (see aspectRatio() and horizontalFieldOfView()).
+
+    Use setFOVToFitScene() to adapt the fieldOfView() to a given scene. */
+    float fieldOfView() const { return fieldOfView_; };
+
+    /*! Returns the horizontal field of view of the Camera (in radians).
+
+    Value is set using setHorizontalFieldOfView() or setFieldOfView(). These values
+    are always linked by:
+    \code
+    horizontalFieldOfView() = 2.0 * atan ( tan(fieldOfView()/2.0) * aspectRatio() ).
+    \endcode */
+    float horizontalFieldOfView() const { return 2.0 * atan ( tan(fieldOfView()/2.0) * aspectRatio() ); };
+
+    /*! Returns the Camera aspect ratio defined by screenWidth() / screenHeight().
+
+    When the Camera is attached to a QGLViewer, these values and hence the aspectRatio() are
+    automatically fitted to the viewer's window aspect ratio using setScreenWidthAndHeight(). */
+    float aspectRatio() const { return static_cast&lt;float&gt;(screenWidth_)/static_cast&lt;float&gt;(screenHeight_); };
+    /*! Returns the width (in pixels) of the Camera screen.
+
+    Set using setScreenWidthAndHeight(). This value is automatically fitted to the QGLViewer's
+    window dimensions when the Camera is attached to a QGLViewer. See also QGLWidget::width() */
+    int screenWidth() const { return screenWidth_; };
+    /*! Returns the height (in pixels) of the Camera screen.
+
+    Set using setScreenWidthAndHeight(). This value is automatically fitted to the QGLViewer's
+    window dimensions when the Camera is attached to a QGLViewer. See also QGLWidget::height() */
+    int screenHeight() const { return screenHeight_; };
+    void getViewport(GLint viewport[4]) const;
+    float pixelGLRatio(const Vec&amp; position) const;
+
+    /*! Returns the coefficient which is used to set zNear() when the Camera is inside the sphere
+    defined by sceneCenter() and zClippingCoefficient() * sceneRadius().
+
+    In that case, the zNear() value is set to zNearCoefficient() * zClippingCoefficient() *
+    sceneRadius(). See the zNear() documentation for details.
+
+    Default value is 0.005, which is appropriate for most applications. In case you need a high
+    dynamic ZBuffer precision, you can increase this value (~0.1). A lower value will prevent
+    clipping of very close objects at the expense of a worst Z precision.
+
+    Only meaningful when Camera type is Camera::PERSPECTIVE. */
+    float zNearCoefficient() const { return zNearCoef_; };
+    /*! Returns the coefficient used to position the near and far clipping planes.
+
+    The near (resp. far) clipping plane is positioned at a distance equal to zClippingCoefficient() *
+    sceneRadius() in front of (resp. behind) the sceneCenter(). This garantees an optimal use of
+    the z-buffer range and minimizes aliasing. See the zNear() and zFar() documentations.
+
+    Default value is square root of 3.0 (so that a cube of size sceneRadius() is not clipped).
+
+    However, since the sceneRadius() is used for other purposes (see showEntireScene(), flySpeed(),
+    ...) and you may want to change this value to define more precisely the location of the clipping
+    planes. See also zNearCoefficient().
+
+    For a total control on clipping planes' positions, an other option is to overload the zNear()
+    and zFar() methods. See the &lt;a href=&quot;../examples/standardCamera.html&quot;&gt;standardCamera example&lt;/a&gt;.
+
+    \attention When QGLViewer::cameraPathAreEdited(), this value is set to 5.0 so that the Camera
+    paths are not clipped. The previous zClippingCoefficient() value is restored back when you leave
+    this mode. */
+    float zClippingCoefficient() const { return zClippingCoef_; }
+
+    virtual float zNear() const;
+    virtual float zFar()  const;
+    virtual void getOrthoWidthHeight(GLdouble&amp; halfWidth, GLdouble&amp; halfHeight) const;
+    void getFrustumPlanesCoefficients(GLdouble coef[6][4]) const;
+
+  public slots:
+    void setType(Type type);
+
+    /*! Sets the vertical fieldOfView() of the Camera (in radians).
+
+    Note that focusDistance() is set to sceneRadius() / tan(fieldOfView()/2) by this method. */
+    void setFieldOfView(float fov) { fieldOfView_ = fov; setFocusDistance(sceneRadius() / tan(fov/2.0)); };
+
+    /*! Sets the horizontalFieldOfView() of the Camera (in radians).
+
+    horizontalFieldOfView() and fieldOfView() are linked by the aspectRatio(). This method actually
+    calls setFieldOfView(( 2.0 * atan (tan(hfov / 2.0) / aspectRatio()) )) so that a call to
+    horizontalFieldOfView() returns the expected value. */
+    void setHorizontalFieldOfView(float hfov) { setFieldOfView( 2.0 * atan (tan(hfov / 2.0) / aspectRatio()) ); };
+
+    void setFOVToFitScene();
+
+    /*! Defines the Camera aspectRatio().
+
+    This value is actually inferred from the screenWidth() / screenHeight() ratio. You should use
+    setScreenWidthAndHeight() instead.
+
+    This method might however be convenient when the Camera is not associated with a QGLViewer. It
+    actually sets the screenHeight() to 100 and the screenWidth() accordingly. See also
+    setFOVToFitScene().
+
+    \note If you absolutely need an aspectRatio() that does not correspond to your viewer's window
+    dimensions, overload loadProjectionMatrix() or multiply the created GL_PROJECTION matrix by a
+    scaled diagonal matrix in your QGLViewer::draw() method. */
+    void setAspectRatio(float aspect) { setScreenWidthAndHeight(int(100.0*aspect), 100); };
+
+    void setScreenWidthAndHeight(int width, int height);
+    /*! Sets the zNearCoefficient() value. */
+    void setZNearCoefficient(float coef) { zNearCoef_ = coef; };
+    /*! Sets the zClippingCoefficient() value. */
+    void setZClippingCoefficient(float coef) { zClippingCoef_ = coef; }
+    //@}
+
+
+    /*! @name Scene radius and center */
+    //@{
+  public:
+    /*! Returns the radius of the scene observed by the Camera.
+
+    You need to provide such an approximation of the scene dimensions so that the Camera can adapt
+    its zNear() and zFar() values. See the sceneCenter() documentation.
+
+    See also setSceneBoundingBox().
+
+    Note that QGLViewer::sceneRadius() (resp. QGLViewer::setSceneRadius()) simply call this method
+    (resp. setSceneRadius()) on its associated QGLViewer::camera(). */
+    float sceneRadius() const { return sceneRadius_; };
+
+    /*! Returns the position of the scene center, defined in the world coordinate system.
+
+    The scene observed by the Camera should be roughly centered on this position, and included in a
+    sceneRadius() sphere. This approximate description of the scene permits a zNear() and zFar()
+    clipping planes definition, and allows convenient positioning methods such as showEntireScene().
+
+    Default value is (0,0,0) (world origin). Use setSceneCenter() to change it. See also
+    setSceneBoundingBox().
+
+    Note that QGLViewer::sceneCenter() (resp. QGLViewer::setSceneCenter()) simply call this method
+    (resp. setSceneCenter()) on its associated QGLViewer::camera(). */
+    Vec sceneCenter() const { return sceneCenter_; };
+    float distanceToSceneCenter() const;
+
+  public slots:
+    void setSceneRadius(float radius);
+    void setSceneCenter(const Vec&amp; center);
+    bool setSceneCenterFromPixel(const QPoint&amp; pixel);
+    void setSceneBoundingBox(const Vec&amp; min, const Vec&amp; max);
+    //@}
+
+
+    /*! @name Revolve Around Point */
+    //@{
+ public slots:
+    void setRevolveAroundPoint(const Vec&amp; rap);
+    bool setRevolveAroundPointFromPixel(const QPoint&amp; pixel);
+
+  public:
+    /*! The point the Camera revolves around with the QGLViewer::ROTATE mouse binding. Defined in world coordinate system.
+
+    Default value is the sceneCenter().
+
+    \attention setSceneCenter() changes this value. */
+    Vec revolveAroundPoint() const { return frame()-&gt;revolveAroundPoint(); };
+    //@}
+
+
+    /*! @name Associated frame */
+    //@{
+  public:
+    /*! Returns the ManipulatedCameraFrame attached to the Camera.
+
+    This ManipulatedCameraFrame defines its position() and orientation() and can translate mouse
+    events into Camera displacement. Set using setFrame(). */
+    ManipulatedCameraFrame* frame() const { return frame_; };
+  public slots:
+    void setFrame(ManipulatedCameraFrame* const mcf);
+    //@}
+
+
+    /*! @name KeyFramed paths */
+    //@{
+   public:
+    KeyFrameInterpolator* keyFrameInterpolator(int i) const;
+
+public slots:
+    void setKeyFrameInterpolator(int i, KeyFrameInterpolator* const kfi);
+
+    virtual void addKeyFrameToPath(int i);
+    virtual void playPath(int i);
+    virtual void deletePath(int i);
+    virtual void resetPath(int i);
+    virtual void drawAllPaths();
+    //@}
+
+
+    /*! @name OpenGL matrices */
+    //@{
+  public:
+    virtual void loadProjectionMatrix(bool reset=true) const;
+    virtual void loadModelViewMatrix(bool reset=true) const;
+    void computeProjectionMatrix() const;
+    void computeModelViewMatrix() const;
+
+    virtual void loadProjectionMatrixStereo(bool leftBuffer=true) const;
+    virtual void loadModelViewMatrixStereo(bool leftBuffer=true) const;
+
+    void getProjectionMatrix(GLdouble m[16]) const;
+    void getModelViewMatrix(GLdouble m[16]) const;
+	void getModelViewProjectionMatrix(GLdouble m[16]) const;
+
+#ifndef DOXYGEN
+    // Required for windows which otherwise silently fills
+    void getProjectionMatrix(GLfloat m[16]) const;
+    void getModelViewMatrix(GLfloat m[16]) const;
+#endif
+    //@}
+
+    
+    /*! @name Drawing */
+    //@{
+#ifndef DOXYGEN
+    static void drawCamera(float scale=1.0, float aspectRatio=1.33, float fieldOfView=M_PI/4.0);
+#endif
+    virtual void draw(bool drawFarPlane=true, float scale=1.0) const;
+    //@}
+
+    
+    /*! @name World to Camera coordinate systems conversions */
+    //@{
+  public:
+    /*! Returns the Camera frame coordinates of a point \p src defined in world coordinates.
+
+    worldCoordinatesOf() performs the inverse transformation.
+
+    Note that the point coordinates are simply converted in a different coordinate system. They are
+    not projected on screen. Use projectedCoordinatesOf() for that. */
+    Vec cameraCoordinatesOf(const Vec&amp; src) const { return frame()-&gt;coordinatesOf(src); };
+    /*! Returns the world coordinates of the point whose position \p src is defined in the Camera
+    coordinate system.
+
+    cameraCoordinatesOf() performs the inverse transformation. */
+    Vec worldCoordinatesOf(const Vec&amp; src) const { return frame()-&gt;inverseCoordinatesOf(src); };
+    void getCameraCoordinatesOf(const float src[3], float res[3]) const;
+    void getWorldCoordinatesOf(const float src[3], float res[3]) const;
+    //@}
+
+
+    /*! @name 2D screen to 3D world coordinate systems conversions */
+    //@{
+  public:
+    Vec projectedCoordinatesOf(const Vec&amp; src, const Frame* frame=NULL) const;
+    Vec unprojectedCoordinatesOf(const Vec&amp; src, const Frame* frame=NULL) const;
+    void getProjectedCoordinatesOf(const float src[3], float res[3], const Frame* frame=NULL) const;
+    void getUnprojectedCoordinatesOf(const float src[3], float res[3], const Frame* frame=NULL) const;
+    void convertClickToLine(const QPoint&amp; pixel, Vec&amp; orig, Vec&amp; dir) const;
+    Vec pointUnderPixel(const QPoint&amp; pixel, bool&amp; found) const;
+    //@}
+
+
+    /*! @name Fly speed */
+    //@{
+  public:
+    /*! Returns the fly speed of the Camera.
+
+    Simply returns frame()-&gt;flySpeed(). See the ManipulatedCameraFrame::flySpeed() documentation.
+    This value is only meaningful when the MouseAction bindings is QGLViewer::MOVE_FORWARD or
+    QGLViewer::MOVE_BACKWARD.
+
+    Set to 0.5% of the sceneRadius() by setSceneRadius(). See also setFlySpeed(). */
+    float flySpeed() const { return frame()-&gt;flySpeed(); };
+  public slots:
+    /*! Sets the Camera flySpeed().
+
+    \attention This value is modified by setSceneRadius(). */
+    void setFlySpeed(float speed) { frame()-&gt;setFlySpeed(speed); };
+    //@}
+
+
+    /*! @name Stereo parameters */
+    //@{
+  public:
+    /*! Returns the user's inter-ocular distance (in meters). Default value is 0.062m, which fits most people.
+
+    loadProjectionMatrixStereo() uses this value to define the Camera offset and frustum. See
+    setIODistance(). */
+    float IODistance() const { return IODistance_; };
+
+    /*! Returns the physical distance between the user's eyes and the screen (in meters).
+
+    Default value is 0.5m.
+
+    Used by loadModelViewMatrixStereo() and loadProjectionMatrixStereo() for stereo display. Value
+    is set using setPhysicalDistanceToScreen().
+
+    physicalDistanceToScreen() and focusDistance() represent the same distance. The first one is
+    expressed in physical real world units, while the latter is expressed in OpenGL virtual world
+    units. Use their ratio to convert distances between these worlds.
+
+    Use the following code to detect a reality center configuration (using its screen aspect ratio)
+    and to automatically set physical distances accordingly:
+    \code
+    QDesktopWidget screen;
+    if (fabs((float)screen.width() / (float)screen.height()) &gt; 2.0)
+    {
+      camera()-&gt;setPhysicalDistanceToScreen(4.0);
+      camera()-&gt;setPhysicalScreenWidth(10.0);
+    }
+    \endcode */
+    float physicalDistanceToScreen() const { return physicalDistanceToScreen_; };
+
+    /*! Returns the physical screen width, in meters. Default value is 0.4m (average monitor).
+
+    Used for stereo display only (see loadModelViewMatrixStereo() and loadProjectionMatrixStereo()).
+    Set using setPhysicalScreenWidth().
+
+    See physicalDistanceToScreen() for reality center automatic configuration. */
+    float physicalScreenWidth() const { return physicalScreenWidth_; };
+
+    /*! Returns the focus distance used by stereo display, expressed in OpenGL units.
+
+    This is the distance in the virtual world between the Camera and the plane where the horizontal
+    stereo parallax is null (the stereo left and right images are superimposed).
+
+    This distance is the virtual world equivalent of the real-world physicalDistanceToScreen().
+
+    \attention This value is modified by QGLViewer::setSceneRadius(), setSceneRadius() and
+    setFieldOfView(). When one of these values is modified, focusDistance() is set to sceneRadius()
+    / tan(fieldOfView()/2), which provides good results. */
+    float focusDistance() const { return focusDistance_; };
+  public slots:
+    /*! Sets the IODistance(). */
+    void setIODistance(float distance) { IODistance_ = distance; };
+
+    /*! Sets the physicalDistanceToScreen(). */
+    void setPhysicalDistanceToScreen(float distance) { physicalDistanceToScreen_ = distance; };
+
+    /*! Sets the physical screen (monitor or projected wall) width (in meters). */
+    void setPhysicalScreenWidth(float width) { physicalScreenWidth_ = width; };
+
+    /*! Sets the focusDistance(), in OpenGL scene units. */
+    void setFocusDistance(float distance) { focusDistance_ = distance; };
+    //@}
+
+
+    /*! @name XML representation */
+    //@{
+  public:
+    virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  public slots:
+    virtual void initFromDOMElement(const QDomElement&amp; element);
+    //@}
+
+
+  private:
+    // F r a m e
+    ManipulatedCameraFrame* frame_;
+
+    // C a m e r a   p a r a m e t e r s
+    int screenWidth_, screenHeight_;  // size of the window, in pixels
+    float fieldOfView_; // in radians
+    Vec sceneCenter_;
+    float sceneRadius_; // OpenGL units
+    float zNearCoef_;
+    float zClippingCoef_;
+    float orthoCoef_;
+    Type type_; // PERSPECTIVE or ORTHOGRAPHIC
+    mutable GLdouble modelViewMatrix_[16]; // Buffered model view matrix.
+    mutable GLdouble projectionMatrix_[16]; // Buffered projection matrix.
+
+    // S t e r e o   p a r a m e t e r s
+    float IODistance_;		     // inter-ocular distance, in meters
+    float focusDistance_;	     // in scene units
+    float physicalDistanceToScreen_; // in meters
+    float physicalScreenWidth_;	     // in meters
+
+    // P o i n t s   o f   V i e w s   a n d   K e y F r a m e s
+    QMap&lt;int, KeyFrameInterpolator*&gt; kfi_;
+    KeyFrameInterpolator* interpolationKfi_;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_CAMERA_H

Added: trunk/lib/QGLViewer/config.h
===================================================================
--- trunk/lib/QGLViewer/config.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/config.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,131 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+///////////////////////////////////////////////////////////////////
+//               libQGLViewer configuration file                 //
+//  Modify these settings according to your local configuration  //
+///////////////////////////////////////////////////////////////////
+
+#ifndef QGLVIEWER_CONFIG_H
+#define QGLVIEWER_CONFIG_H
+
+#define QGLVIEWER_VERSION 0x020206
+
+// Needed for Qt &lt; 4 (?)
+#ifndef QT_CLEAN_NAMESPACE
+# define QT_CLEAN_NAMESPACE
+#endif
+
+// Get QT_VERSION and other Qt flags
+// Cannot use &lt;QtCore/qglobal.h&gt; for backward compatibility
+#include &lt;qglobal.h&gt;
+
+#if QT_VERSION &lt; 0x030000
+# ifdef _OS_WIN32_
+#  define Q_OS_WIN32
+# endif
+#endif
+
+// Win 32 DLL export macros
+#ifdef Q_OS_WIN32
+# ifndef M_PI
+#  define M_PI 3.14159265358979323846f
+# endif
+# ifndef QGLVIEWER_STATIC
+#  ifdef CREATE_QGLVIEWER_DLL
+#   define QGLVIEWER_EXPORT  __declspec(dllexport)
+#  else
+#   define QGLVIEWER_EXPORT  __declspec(dllimport)
+#  endif
+# endif
+# ifndef __MINGW32__
+#  pragma warning( disable : 4251 ) // DLL interface, needed with Visual 6
+#  pragma warning( disable : 4786 ) // identifier truncated to 255 in browser information (Visual 6).
+# endif
+#endif // Q_OS_WIN32
+
+// For other architectures, this macro is empty
+#ifndef QGLVIEWER_EXPORT
+# define QGLVIEWER_EXPORT
+#endif
+
+// OpenGL includes - Included here and hence shared by all the files that need OpenGL headers.
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QGLWidget&gt;
+#else
+# include &lt;qgl.h&gt;
+#endif
+
+// Old Qt versions require GLUT for text rendering
+#define QGLVIEWER_QT_VERSION_WITHOUT_GLUT 0x030100
+#if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
+# ifdef Q_OS_MAC
+#  include &lt;GLUT/glut.h&gt;
+# else
+#  ifdef Q_OS_WIN32
+#   include &lt;glut.h&gt;
+#  else
+#   include &lt;GL/glut.h&gt;
+#  endif
+# endif
+#endif
+
+// Container classes interfaces changed a lot in Qt.
+// Compatibility patches are all grouped here.
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QList&gt;
+# include &lt;QVector&gt;
+#else
+# define qMax(a,b) QMAX(a,b)
+# if QT_VERSION &gt;= 0x030000
+#  include &lt;qptrlist.h&gt;
+#  include &lt;qvaluevector.h&gt;
+# else
+#  pragma warning( disable : 4530 ) // exception handler but unwind semantics. Use \GX option
+#  include &lt;vector&gt; // also defines std::max and std::abs
+#  define QVector std::vector
+#  undef Q_UNUSED
+#  define Q_UNUSED(x) (void)x;
+#  include &lt;qlist.h&gt;
+// So that there is no need to make Qt2 specific cases
+#  define QPtrList QList
+#  define QPtrListIterator QListIterator
+# endif
+#endif
+
+// For deprecated methods
+// #define __WHERE__ &quot;In file &quot;&lt;&lt;__FILE__&lt;&lt;&quot;, line &quot;&lt;&lt;__LINE__&lt;&lt;&quot;: &quot;
+// #define orientationAxisAngle(x,y,z,a) { std::cout &lt;&lt; __WHERE__ &lt;&lt; &quot;getOrientationAxisAngle().&quot; &lt;&lt; std::endl; exit(0); }
+
+// Patch for gcc version &lt;= 2.95. Seems to no longer be needed with recent Qt versions.
+// Uncomment these lines if you have error message dealing with operator &lt;&lt; on QStrings
+// #if defined(__GNUC__) &amp;&amp; defined(__GNUC_MINOR__) &amp;&amp; (__GNUC__ &lt; 3) &amp;&amp; (__GNUC_MINOR__ &lt; 96)
+// # include &lt;iostream&gt;
+// # include &lt;qstring.h&gt;
+// std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const QString&amp; str)
+// { out &lt;&lt; str.latin1();  return out; }
+// #endif
+
+#endif // QGLVIEWER_CONFIG_H

Added: trunk/lib/QGLViewer/constraint.cpp
===================================================================
--- trunk/lib/QGLViewer/constraint.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/constraint.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,293 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;constraint.h&quot;
+#include &quot;frame.h&quot;
+#include &quot;camera.h&quot;
+
+using namespace qglviewer;
+using namespace std;
+
+////////////////////////////////////////////////////////////////////////////////
+//                                  Constraint                                //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Default constructor.
+
+translationConstraintType() and rotationConstraintType() are set to AxisPlaneConstraint::FREE.
+translationConstraintDirection() and rotationConstraintDirection() are set to (0,0,0). */
+AxisPlaneConstraint::AxisPlaneConstraint()
+  : translationConstraintType_(FREE), rotationConstraintType_(FREE)
+{
+  // Do not use set since setRotationConstraintType needs a read.
+}
+
+/*! Simply calls setTranslationConstraintType() and setTranslationConstraintDirection(). */
+void AxisPlaneConstraint::setTranslationConstraint(Type type, const Vec&amp; direction)
+{
+  setTranslationConstraintType(type);
+  setTranslationConstraintDirection(direction);
+}
+
+/*! Defines the translationConstraintDirection(). The coordinate system where \p direction is expressed depends on your class implementation. */
+void AxisPlaneConstraint::setTranslationConstraintDirection(const Vec&amp; direction)
+{
+  if ((translationConstraintType()!=AxisPlaneConstraint::FREE) &amp;&amp; (translationConstraintType()!=AxisPlaneConstraint::FORBIDDEN))
+    {
+      const float norm = direction.norm();
+      if (norm &lt; 1E-8)
+	{
+	  qWarning(&quot;AxisPlaneConstraint::setTranslationConstraintDir: null vector for translation constraint&quot;);
+	  translationConstraintType_ = AxisPlaneConstraint::FREE;
+	}
+      else
+	translationConstraintDir_ = direction/norm;
+    }
+}
+
+/*! Simply calls setRotationConstraintType() and setRotationConstraintDirection(). */
+void AxisPlaneConstraint::setRotationConstraint(Type type, const Vec&amp; direction)
+{
+  setRotationConstraintType(type);
+  setRotationConstraintDirection(direction);
+}
+
+/*! Defines the rotationConstraintDirection(). The coordinate system where \p direction is expressed depends on your class implementation. */
+void AxisPlaneConstraint::setRotationConstraintDirection(const Vec&amp; direction)
+{
+  if ((rotationConstraintType()!=AxisPlaneConstraint::FREE) &amp;&amp; (rotationConstraintType()!=AxisPlaneConstraint::FORBIDDEN))
+    {
+      float norm = direction.norm();
+      if (norm &lt; 1E-8)
+	{
+	  qWarning(&quot;AxisPlaneConstraint::setRotationConstraintDir: null vector for rotation constraint&quot;);
+	  rotationConstraintType_ = AxisPlaneConstraint::FREE;
+	}
+      else
+	rotationConstraintDir_ = direction/norm;
+    }
+}
+
+/*! Set the Type() of the rotationConstraintType(). Default is AxisPlaneConstraint::FREE.
+
+ Depending on this value, the Frame will freely rotate (AxisPlaneConstraint::FREE), will only be able
+ to rotate around an axis (AxisPlaneConstraint::AXIS), or will not able to rotate at all
+ (AxisPlaneConstraint::FORBIDDEN).
+
+ Use Frame::setOrientation() to define the orientation of the constrained Frame before it gets
+ constrained.
+
+ \attention An AxisPlaneConstraint::PLANE Type() is not meaningful for rotational constraints and
+ will be ignored. */
+void AxisPlaneConstraint::setRotationConstraintType(Type type)
+{
+  if (rotationConstraintType() == AxisPlaneConstraint::PLANE)
+    {
+      qWarning(&quot;AxisPlaneConstraint::setRotationConstraintType: the PLANE type cannot be used for a rotation constraints&quot;);
+      return;
+    }
+
+  rotationConstraintType_ = type;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//                               LocalConstraint                              //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Depending on translationConstraintType(), constrain \p translation to be along an axis or
+  limited to a plane defined in the Frame local coordinate system by
+  translationConstraintDirection(). */
+void LocalConstraint::constrainTranslation(Vec&amp; translation, Frame* const frame)
+{
+  Vec proj;
+  switch (translationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      proj = frame-&gt;rotation().rotate(translationConstraintDirection());
+      translation.projectOnPlane(proj);
+      break;
+    case AxisPlaneConstraint::AXIS:
+      proj = frame-&gt;rotation().rotate(translationConstraintDirection());
+      translation.projectOnAxis(proj);
+      break;
+    case AxisPlaneConstraint::FORBIDDEN:
+      translation = Vec(0.0, 0.0, 0.0);
+      break;
+    }
+}
+
+/*! When rotationConstraintType() is AxisPlaneConstraint::AXIS, constrain \p rotation to be a rotation
+  around an axis whose direction is defined in the Frame local coordinate system by
+  rotationConstraintDirection(). */
+void LocalConstraint::constrainRotation(Quaternion&amp; rotation, Frame* const)
+{
+  switch (rotationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      break;
+    case AxisPlaneConstraint::AXIS:
+      {
+	Vec axis = rotationConstraintDirection();
+	Vec quat = Vec(rotation[0], rotation[1], rotation[2]);
+	quat.projectOnAxis(axis);
+	rotation = Quaternion(quat, 2.0*acos(rotation[3]));
+      }
+      break;
+    case AxisPlaneConstraint::FORBIDDEN:
+      rotation = Quaternion(); // identity
+      break;
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//                               WorldConstraint                              //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Depending on translationConstraintType(), constrain \p translation to be along an axis or
+  limited to a plane defined in the world coordinate system by
+  translationConstraintDirection(). */
+void WorldConstraint::constrainTranslation(Vec&amp; translation, Frame* const frame)
+{
+  Vec proj;
+  switch (translationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      if (frame-&gt;referenceFrame())
+	{
+	  proj = frame-&gt;referenceFrame()-&gt;transformOf(translationConstraintDirection());
+	  translation.projectOnPlane(proj);
+	}
+      else
+	translation.projectOnPlane(translationConstraintDirection());
+      break;
+    case AxisPlaneConstraint::AXIS:
+      if (frame-&gt;referenceFrame())
+	{
+	  proj = frame-&gt;referenceFrame()-&gt;transformOf(translationConstraintDirection());
+	  translation.projectOnAxis(proj);
+	}
+      else
+	translation.projectOnAxis(translationConstraintDirection());
+      break;
+    case AxisPlaneConstraint::FORBIDDEN:
+      translation = Vec(0.0, 0.0, 0.0);
+      break;
+    }
+}
+
+/*! When rotationConstraintType() is AxisPlaneConstraint::AXIS, constrain \p rotation to be a rotation
+  around an axis whose direction is defined in the world coordinate system by
+  rotationConstraintDirection(). */
+void WorldConstraint::constrainRotation(Quaternion&amp; rotation, Frame* const frame)
+{
+  switch (rotationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      break;
+    case AxisPlaneConstraint::AXIS:
+      {
+	Vec quat(rotation[0], rotation[1], rotation[2]);
+	Vec axis = frame-&gt;transformOf(rotationConstraintDirection());
+	quat.projectOnAxis(axis);
+	rotation = Quaternion(quat, 2.0*acos(rotation[3]));
+	break;
+      }
+    case AxisPlaneConstraint::FORBIDDEN:
+      rotation = Quaternion(); // identity
+      break;
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//                               CameraConstraint                              //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Creates a CameraConstraint, whose constrained directions are defined in the \p camera coordinate
+  system. */
+CameraConstraint::CameraConstraint(const Camera* const camera)
+  : AxisPlaneConstraint(), camera_(camera)
+{}
+
+/*! Depending on translationConstraintType(), constrain \p translation to be along an axis or
+  limited to a plane defined in the camera() coordinate system by
+  translationConstraintDirection(). */
+void CameraConstraint::constrainTranslation(Vec&amp; translation, Frame* const frame)
+{
+  Vec proj;
+  switch (translationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      proj = camera()-&gt;frame()-&gt;inverseTransformOf(translationConstraintDirection());
+      if (frame-&gt;referenceFrame())
+	proj = frame-&gt;referenceFrame()-&gt;transformOf(proj);
+      translation.projectOnPlane(proj);
+      break;
+    case AxisPlaneConstraint::AXIS:
+      proj = camera()-&gt;frame()-&gt;inverseTransformOf(translationConstraintDirection());
+      if (frame-&gt;referenceFrame())
+	proj = frame-&gt;referenceFrame()-&gt;transformOf(proj);
+      translation.projectOnAxis(proj);
+      break;
+    case AxisPlaneConstraint::FORBIDDEN:
+      translation = Vec(0.0, 0.0, 0.0);
+      break;
+    }
+}
+
+/*! When rotationConstraintType() is AxisPlaneConstraint::AXIS, constrain \p rotation to be a rotation
+  around an axis whose direction is defined in the camera() coordinate system by
+  rotationConstraintDirection(). */
+void CameraConstraint::constrainRotation(Quaternion&amp; rotation, Frame* const frame)
+{
+  switch (rotationConstraintType())
+    {
+    case AxisPlaneConstraint::FREE:
+      break;
+    case AxisPlaneConstraint::PLANE:
+      break;
+    case AxisPlaneConstraint::AXIS:
+      {
+	Vec axis = frame-&gt;transformOf(camera()-&gt;frame()-&gt;inverseTransformOf(rotationConstraintDirection()));
+	Vec quat = Vec(rotation[0], rotation[1], rotation[2]);
+	quat.projectOnAxis(axis);
+	rotation = Quaternion(quat, 2.0*acos(rotation[3]));
+      }
+      break;
+    case AxisPlaneConstraint::FORBIDDEN:
+      rotation = Quaternion(); // identity
+      break;
+    }
+}

Added: trunk/lib/QGLViewer/constraint.h
===================================================================
--- trunk/lib/QGLViewer/constraint.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/constraint.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,341 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_CONSTRAINT_H
+#define QGLVIEWER_CONSTRAINT_H
+
+#include &quot;vec.h&quot;
+#include &quot;quaternion.h&quot;
+
+namespace qglviewer {
+  class Frame;
+  class Camera;
+
+  /*! \brief An interface class for Frame constraints.
+  \class Constraint constraint.h QGLViewer/constraint.h
+
+  This class defines the interface for the Constraints that can be applied to a Frame to limit its
+  motion. Use Frame::setConstraint() to associate a Constraint to a Frame (default is a \c NULL
+  Frame::constraint()).
+
+  &lt;h3&gt;How does it work ?&lt;/h3&gt;
+
+  The Constraint acts as a filter on the translation and rotation Frame increments.
+  constrainTranslation() and constrainRotation() should be overloaded to specify the constraint
+  behavior: the desired displacement is given as a parameter that can optionally be modified.
+
+  Here is how the Frame::translate() and Frame::rotate() methods use the Constraint:
+  \code
+  Frame::translate(Vec&amp; T)
+  {
+    if (constraint())
+      constraint()-&gt;constrainTranslation(T, this);
+    t += T;
+  }
+
+  Frame::rotate(Quaternion&amp; Q)
+  {
+    if (constraint())
+      constraint()-&gt;constrainRotation(Q, this);
+    q *= Q;
+  }
+  \endcode
+
+  The default behavior of constrainTranslation() and constrainRotation() is empty (meaning no
+  filtering).
+
+  The Frame which uses the Constraint is passed as a parameter to the constrainTranslation() and
+  constrainRotation() methods, so that they can have access to its current state (mainly
+  Frame::position() and Frame::orientation()). It is not \c const for versatility reasons, but
+  directly modifying it should be avoided.
+
+  \attention Frame::setTranslation(), Frame::setRotation() and similar methods will actually indeed
+  set the frame position and orientation, without taking the constraint into account. Use the \e
+  WithConstraint versions of these methods to enforce the Constraint.
+
+  &lt;h3&gt;Implemented Constraints&lt;/h3&gt;
+
+  Classical axial and plane Constraints are provided for convenience: see the LocalConstraint,
+  WorldConstraint and CameraConstraint classes' documentations.
+
+  Try the &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt; and &lt;a
+  href=&quot;../examples/constrainedCamera.html&quot;&gt;constrainedCamera&lt;/a&gt; examples for an illustration.
+
+  &lt;h3&gt;Creating new Constraints&lt;/h3&gt;
+
+  The implementation of a new Constraint class simply consists in overloading the filtering methods:
+  \code
+  // This Constraint enforces that the Frame cannot have a negative z world coordinate.
+  class myConstraint : public Constraint
+  {
+  public:
+    virtual void constrainTranslation(Vec&amp; t, Frame * const fr)
+      {
+        // Express t in the world coordinate system.
+        const Vec tWorld = fr-&gt;inverseTransformOf(t);
+	if (fr-&gt;position().z + tWorld.z &lt; 0.0) // check the new fr z coordinate
+	  t.z = fr-&gt;transformOf(-fr-&gt;position().z); // t.z is clamped so that next z position is 0.0
+      }
+  };
+  \endcode
+
+  Note that the translation (resp. rotation) parameter passed to constrainTranslation() (resp.
+  constrainRotation()) is expressed in the \e local Frame coordinate system. Here, we use the
+  Frame::transformOf() and Frame::inverseTransformOf() method to convert it to and from the world
+  coordinate system.
+
+  Combined constraints can easily be achieved by creating a new class that applies the different
+  constraint filters:
+  \code
+  myConstraint::constrainTranslation(Vec&amp; v, Frame* const fr)
+  {
+    constraint1-&gt;constrainTranslation(v, fr);
+    constraint2-&gt;constrainTranslation(v, fr);
+    // and so on, with possible branches, tests, loops...
+  }
+  \endcode
+  */
+  class QGLVIEWER_EXPORT Constraint
+  {
+  public:
+    /*! Virtual destructor. Empty. */
+    virtual ~Constraint() {};
+
+    /*! Filters the translation applied to the \p frame. This default implementation is empty (no
+      filtering).
+
+    Overload this method in your own Constraint class to define a new translation constraint. \p
+    frame is the Frame to which is applied the translation. It is not defined \c const, but you
+    should refrain from directly changing its value in the constraint. Use its Frame::position() and
+    update the \p translation accordingly instead.
+
+    \p translation is expressed in local frame coordinate system. Use Frame::inverseTransformOf() to
+    express it in the world coordinate system if needed. */
+    virtual void constrainTranslation(Vec&amp; translation, Frame* const frame) { Q_UNUSED(translation); Q_UNUSED(frame); };
+    /*! Filters the rotation applied to the \p frame. This default implementation is empty (no
+      filtering).
+
+    Overload this method in your own Constraint class to define a new rotation constraint. See
+    constrainTranslation() for details.
+
+    Use Frame::inverseTransformOf() on the \p rotation Quaternion::axis() to express \p rotation in
+    the world coordinate system if needed. */
+    virtual void constrainRotation(Quaternion&amp; rotation, Frame* const frame) { Q_UNUSED(rotation); Q_UNUSED(frame); };
+  };
+
+  /*!
+   \brief An abstract class for Frame Constraints defined by an axis or a plane.
+   \class AxisPlaneConstraint constraint.h QGLViewer/constraint.h
+
+   AxisPlaneConstraint is an interface for (translation and/or rotation) Constraint that are defined
+   by a direction. translationConstraintType() and rotationConstraintType() define how this
+   direction should be interpreted: as an axis (AxisPlaneConstraint::AXIS) or as a plane normal
+   (AxisPlaneConstraint::PLANE). See the Type() documentation for details.
+
+   The three implementations of this class: LocalConstraint, WorldConstraint and CameraConstraint
+   differ by the coordinate system in which this direction is expressed.
+
+   Different implementations of this class are illustrated in the
+   &lt;a href=&quot;../examples/constrainedCamera.html&quot;&gt;contrainedCamera&lt;/a&gt; and
+   &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt; examples.
+
+   \attention When applied, the rotational Constraint may not intuitively follow the mouse
+   displacement. A solution would be to directly measure the rotation angle in screen coordinates,
+   but that would imply to know the QGLViewer::camera(), so that we can compute the projected
+   coordinates of the rotation center (as is done with the QGLViewer::SCREEN_ROTATE binding).
+   However, adding an extra pointer to the QGLViewer::camera() in all the AxisPlaneConstraint
+   derived classes (which the user would have to update in a multi-viewer application) was judged as
+   an overkill. */
+  class QGLVIEWER_EXPORT AxisPlaneConstraint : public Constraint
+  {
+  public:
+    AxisPlaneConstraint();
+    /*! Virtual destructor. Empty. */
+    virtual ~AxisPlaneConstraint() {};
+
+    /*! Type lists the different types of translation and rotation constraints that are available.
+
+    It specifies the meaning of the constraint direction (see translationConstraintDirection() and
+    rotationConstraintDirection()): as an axis direction (AxisPlaneConstraint::AXIS) or a plane
+    normal (AxisPlaneConstraint::PLANE). AxisPlaneConstraint::FREE means no constraint while
+    AxisPlaneConstraint::FORBIDDEN completely forbids the translation and/or the rotation.
+
+    See translationConstraintType() and rotationConstraintType().
+
+    \attention The AxisPlaneConstraint::PLANE Type is not valid for rotational constraint.
+
+    New derived classes can use their own extended enum for specific constraints:
+    \code
+    class MyAxisPlaneConstraint : public AxisPlaneConstraint
+    {
+    public:
+      enum MyType { FREE, AXIS, PLANE, FORBIDDEN, CUSTOM };
+      virtual void constrainTranslation(Vec &amp;translation, Frame *const frame)
+      {
+        // translationConstraintType() is simply an int. CUSTOM Type is handled seamlessly.
+        switch (translationConstraintType())
+	{
+	case MyAxisPlaneConstraint::FREE: ... break;
+	case MyAxisPlaneConstraint::CUSTOM: ... break;
+	}
+      };
+
+      MyAxisPlaneConstraint* c = new MyAxisPlaneConstraint();
+      // Note the Type conversion
+      c-&gt;setTranslationConstraintType(AxisPlaneConstraint::Type(MyAxisPlaneConstraint::CUSTOM));
+    };
+    \endcode */
+    enum Type { FREE, AXIS, PLANE, FORBIDDEN };
+
+    /*! @name Translation constraint */
+    //@{
+    /*! Overloading of Constraint::constrainTranslation(). Empty */
+    virtual void constrainTranslation(Vec&amp; translation, Frame* const frame) { Q_UNUSED(translation); Q_UNUSED(frame); };
+
+    void setTranslationConstraint(Type type, const Vec&amp; direction);
+    /*! Sets the Type() of the translationConstraintType(). Default is AxisPlaneConstraint::FREE. */
+    void setTranslationConstraintType(Type type) { translationConstraintType_ = type; };
+    void setTranslationConstraintDirection(const Vec&amp; direction);
+
+    /*! Returns the translation constraint Type().
+
+    Depending on this value, the Frame will freely translate (AxisPlaneConstraint::FREE), will only
+    be able to translate along an axis direction (AxisPlaneConstraint::AXIS), will be forced to stay
+    into a plane (AxisPlaneConstraint::PLANE) or will not able to translate at all
+    (AxisPlaneConstraint::FORBIDDEN).
+
+    Use Frame::setPosition() to define the position of the constrained Frame before it gets
+    constrained. */
+    Type translationConstraintType() const { return translationConstraintType_; };
+    /*! Returns the direction used by the translation constraint.
+
+    It represents the axis direction (AxisPlaneConstraint::AXIS) or the plane normal
+    (AxisPlaneConstraint::PLANE) depending on the translationConstraintType(). It is undefined for
+    AxisPlaneConstraint::FREE or AxisPlaneConstraint::FORBIDDEN.
+
+    The AxisPlaneConstraint derived classes express this direction in different coordinate system
+    (camera for CameraConstraint, local for LocalConstraint, and world for WorldConstraint). This
+    value can be modified with setTranslationConstraintDirection(). */
+    Vec translationConstraintDirection() const { return translationConstraintDir_; };
+    //@}
+
+    /*! @name Rotation constraint */
+    //@{
+    /*! Overloading of Constraint::constrainRotation(). Empty. */
+    virtual void constrainRotation(Quaternion&amp; rotation, Frame* const frame) { Q_UNUSED(rotation); Q_UNUSED(frame); };
+
+    void setRotationConstraint(Type type, const Vec&amp; direction);
+    void setRotationConstraintType(Type type);
+    void setRotationConstraintDirection(const Vec&amp; direction);
+
+    /*! Returns the rotation constraint Type(). */
+    Type rotationConstraintType() const { return rotationConstraintType_; };
+    /*! Returns the axis direction used by the rotation constraint.
+
+    This direction is defined only when rotationConstraintType() is AxisPlaneConstraint::AXIS.
+
+    The AxisPlaneConstraint derived classes express this direction in different coordinate system
+    (camera for CameraConstraint, local for LocalConstraint, and world for WorldConstraint). This
+    value can be modified with setRotationConstraintDirection(). */
+    Vec rotationConstraintDirection() const { return rotationConstraintDir_; };
+    //@}
+
+  private:
+    // int and not Type to allow for overloading and new types definition.
+    Type translationConstraintType_;
+    Type rotationConstraintType_;
+
+    Vec translationConstraintDir_;
+    Vec rotationConstraintDir_;
+  };
+
+
+  /*! \brief An AxisPlaneConstraint defined in the Frame local coordinate system.
+  \class LocalConstraint constraint.h QGLViewer/constraint.h
+
+  The translationConstraintDirection() and rotationConstraintDirection() are expressed in the Frame
+  local coordinate system (see Frame::referenceFrame()).
+
+  See the &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt; example for an illustration. */
+  class QGLVIEWER_EXPORT LocalConstraint : public AxisPlaneConstraint
+  {
+  public:
+    /*! Virtual destructor. Empty. */
+    virtual ~LocalConstraint() {};
+
+    virtual void constrainTranslation(Vec&amp;     translation, Frame* const frame);
+    virtual void constrainRotation   (Quaternion&amp; rotation, Frame* const frame);
+  };
+
+
+
+  /*! \brief An AxisPlaneConstraint defined in the world coordinate system.
+    \class WorldConstraint constraint.h QGLViewer/constraint.h
+
+  The translationConstraintDirection() and rotationConstraintDirection() are expressed in world
+  coordinate system.
+
+  See the &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt; and &lt;a
+  href=&quot;../examples/multiView.html&quot;&gt;multiView&lt;/a&gt; examples for an illustration. */
+  class QGLVIEWER_EXPORT WorldConstraint : public AxisPlaneConstraint
+  {
+  public:
+    /*! Virtual destructor. Empty. */
+    virtual ~WorldConstraint() {};
+
+    virtual void constrainTranslation(Vec&amp;     translation, Frame* const frame);
+    virtual void constrainRotation   (Quaternion&amp; rotation, Frame* const frame);
+  };
+
+
+
+  /*! \brief An AxisPlaneConstraint defined in the camera coordinate system.
+  \class CameraConstraint constraint.h QGLViewer/constraint.h
+
+  The translationConstraintDirection() and rotationConstraintDirection() are expressed in the
+  associated camera() coordinate system.
+
+  See the &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt; and &lt;a
+  href=&quot;../examples/constrainedCamera.html&quot;&gt;constrainedCamera&lt;/a&gt; examples for an illustration. */
+  class QGLVIEWER_EXPORT CameraConstraint : public AxisPlaneConstraint
+  {
+  public:
+    explicit CameraConstraint(const Camera* const camera);
+    /*! Virtual destructor. Empty. */
+    virtual ~CameraConstraint() {};
+
+    virtual void constrainTranslation(Vec&amp;     translation, Frame* const frame);
+    virtual void constrainRotation   (Quaternion&amp; rotation, Frame* const frame);
+
+    /*! Returns the associated Camera. Set using the CameraConstraint constructor. */
+    const Camera* camera() const { return camera_; };
+
+  private:
+    const Camera* const camera_;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_CONSTRAINT_H

Added: trunk/lib/QGLViewer/domUtils.h
===================================================================
--- trunk/lib/QGLViewer/domUtils.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/domUtils.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,153 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#if QT_VERSION &gt; 0x040000
+# include &lt;QDom&gt;
+# include &lt;QString&gt;
+# include &lt;QStringList&gt;
+# include &lt;QColor&gt;
+#else
+# include &lt;qdom.h&gt;
+# include &lt;qstring.h&gt;
+# include &lt;qstringlist.h&gt;
+# include &lt;qcolor.h&gt;
+#endif
+
+#include &lt;math.h&gt;
+
+#ifndef DOXYGEN
+
+// QDomElement loading with syntax checking.
+class DomUtils
+{
+private:
+  static void warning(const QString&amp; message)
+  {
+#if QT_VERSION &gt;= 0x040000
+    qWarning(message.toLatin1().constData());
+#else
+    qWarning(message.latin1());
+#endif
+  }
+
+public:
+  static float floatFromDom(const QDomElement&amp; e, const QString&amp; attribute, float defValue)
+  {
+    float value = defValue;
+    if (e.hasAttribute(attribute))
+      {
+	const QString s = e.attribute(attribute);
+	bool ok;
+	s.toFloat(&amp;ok);
+	if (ok)
+	  value = s.toFloat();
+	else
+	  warning(&quot;Bad float syntax for attribute \&quot;&quot;+attribute+&quot;\&quot; in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot;. Setting value to &quot;+QString::number(value)+&quot;.&quot;);
+      }
+    else
+      warning(&quot;\&quot;&quot;+attribute+&quot;\&quot; attribute missing in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot;. Setting value to &quot;+QString::number(value)+&quot;.&quot;);
+
+#if defined(isnan)
+    // The &quot;isnan&quot; method may not be available on all platforms.
+    // Find its equivalent or simply remove these two lines
+    if (isnan(value))
+      warning(&quot;Warning, attribute \&quot;&quot;+attribute+&quot;\&quot; initialized to Not a Number in \&quot;&quot;+e.tagName()+&quot;\&quot;&quot;);
+#endif
+
+    return value;
+  }
+
+  static int intFromDom(const QDomElement&amp; e, const QString&amp; attribute, int defValue)
+  {
+    int value = defValue;
+    if (e.hasAttribute(attribute))
+      {
+	const QString s = e.attribute(attribute);
+	bool ok;
+	s.toInt(&amp;ok);
+	if (ok)
+	  value = s.toInt();
+	else
+	  warning(&quot;Bad integer syntax for attribute \&quot;&quot;+attribute+&quot;\&quot; in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot;. Setting value to &quot;+QString::number(value)+&quot;.&quot;);
+      }
+    else
+      warning(&quot;\&quot;&quot;+attribute+&quot;\&quot; attribute missing in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot;. Setting value to &quot;+QString::number(value)+&quot;.&quot;);
+    return value;
+  }
+
+  static bool boolFromDom(const QDomElement&amp; e, const QString&amp; attribute, bool defValue)
+  {
+    bool value = defValue;
+    if (e.hasAttribute(attribute))
+      {
+	const QString s = e.attribute(attribute);
+#if QT_VERSION &gt;= 0x040000
+	if (s.toLower() == QString(&quot;true&quot;))
+#else
+	if (s.lower() == QString(&quot;true&quot;))
+#endif
+	  value = true;
+#if QT_VERSION &gt;= 0x040000
+	else if (s.toLower() == QString(&quot;false&quot;))
+#else
+	else if (s.lower() == QString(&quot;false&quot;))
+#endif
+	  value = false;
+	else
+	  {
+	    warning(&quot;Bad boolean syntax for attribute \&quot;&quot;+attribute+&quot;\&quot; in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot; (should be \&quot;true\&quot; or \&quot;false\&quot;).&quot;);
+	    warning(&quot;Setting value to &quot;+(value?QString(&quot;true.&quot;):QString(&quot;false.&quot;)));
+	  }
+      }
+    else
+      warning(&quot;\&quot;&quot;+attribute+&quot;\&quot; attribute missing in initialization of \&quot;&quot;+e.tagName()+&quot;\&quot;. Setting value to &quot;+(value?QString(&quot;true.&quot;):QString(&quot;false.&quot;)));
+    return value;
+  }
+
+  static QDomElement QColorDomElement(const QColor&amp; color, const QString&amp; name, QDomDocument&amp; doc)
+  {
+    QDomElement de = doc.createElement(name);
+    de.setAttribute(&quot;red&quot;, QString::number(color.red()));
+    de.setAttribute(&quot;green&quot;, QString::number(color.green()));
+    de.setAttribute(&quot;blue&quot;, QString::number(color.blue()));
+    return de;
+  }
+
+  static QColor QColorFromDom(const QDomElement&amp; e)
+  {
+    int color[3];
+    QStringList attribute;
+    attribute &lt;&lt; &quot;red&quot; &lt;&lt; &quot;green&quot; &lt;&lt; &quot;blue&quot;;
+#if QT_VERSION &gt;= 0x040000
+    for (int i=0; i&lt;attribute.count(); ++i)
+#else
+    for (unsigned int i=0; i&lt;attribute.count(); ++i)
+#endif
+      color[i] = DomUtils::intFromDom(e, attribute[i], 0);
+    return QColor(color[0], color[1], color[2]);
+  }
+};
+
+#endif // DOXYGEN

Added: trunk/lib/QGLViewer/frame.cpp
===================================================================
--- trunk/lib/QGLViewer/frame.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/frame.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,1140 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;frame.h&quot;
+#include &lt;math.h&gt;
+
+using namespace qglviewer;
+using namespace std;
+
+
+/*! Creates a default Frame.
+
+  Its position() is (0,0,0) and it has an identity orientation() Quaternion. The referenceFrame()
+  and the constraint() are \c NULL. */
+Frame::Frame()
+  : constraint_(NULL), referenceFrame_(NULL)
+{}
+
+/*! Creates a Frame with a position() and an orientation().
+
+ See the Vec and Quaternion documentations for convenient constructors and methods.
+
+ The Frame is defined in the world coordinate system (its referenceFrame() is \c NULL). It
+ has a \c NULL associated constraint(). */
+Frame::Frame(const Vec&amp; position, const Quaternion&amp; orientation)
+  : t_(position), q_(orientation), constraint_(NULL), referenceFrame_(NULL)
+{}
+
+/*! Equal operator.
+
+  The referenceFrame() and constraint() pointers are copied.
+
+  \attention Signal and slot connections are not copied. */
+Frame&amp; Frame::operator=(const Frame&amp; frame)
+{
+  // Automatic compiler generated version would not emit the modified signals as is done in
+  // setTranslationAndRotation.
+  setTranslationAndRotation(frame.translation(), frame.rotation());
+  setConstraint(frame.constraint());
+  setReferenceFrame(frame.referenceFrame());
+  return *this;
+}
+
+/*! Copy constructor.
+
+  The translation() and rotation() as well as constraint() and referenceFrame() pointers are
+  copied. */
+Frame::Frame(const Frame&amp; frame)
+  : QObject()
+{
+  (*this) = frame;
+}
+
+/////////////////////////////// MATRICES //////////////////////////////////////
+
+/*! Returns the 4x4 OpenGL transformation matrix represented by the Frame.
+
+  This method should be used in conjunction with \c glMultMatrixd() to modify the OpenGL modelview
+  matrix from a Frame hierarchy. With this Frame hierarchy:
+  \code
+  Frame* body     = new Frame();
+  Frame* leftArm  = new Frame();
+  Frame* rightArm = new Frame();
+  leftArm-&gt;setReferenceFrame(body);
+  rightArm-&gt;setReferenceFrame(body);
+  \endcode
+
+  The associated OpenGL drawing code should look like:
+  \code
+  void Viewer::draw()
+  {
+    glPushMatrix();
+    glMultMatrixd(body-&gt;matrix());
+    drawBody();
+
+    glPushMatrix();
+    glMultMatrixd(leftArm-&gt;matrix());
+    drawArm();
+    glPopMatrix();
+
+    glPushMatrix();
+    glMultMatrixd(rightArm-&gt;matrix());
+    drawArm();
+    glPopMatrix();
+
+    glPopMatrix();
+  }
+  \endcode
+  Note the use of nested \c glPushMatrix() and \c glPopMatrix() blocks to represent the frame hierarchy: \c
+  leftArm and \c rightArm are both correctly drawn with respect to the \c body coordinate system.
+
+  This matrix only represents the local Frame transformation (i.e. with respect to the
+  referenceFrame()). Use worldMatrix() to get the full Frame transformation matrix (i.e. from the
+  world to the Frame coordinate system). These two match when the referenceFrame() is \c NULL.
+
+  The result is only valid until the next call to matrix(), getMatrix(), worldMatrix() or
+  getWorldMatrix(). Use it immediately (as above) or use getMatrix() instead.
+
+  \attention The OpenGL format of the result is the transpose of the actual mathematical European
+  representation (translation is on the last \e line instead of the last \e column).
+
+  \note The scaling factor of the 4x4 matrix is 1.0. */
+const GLdouble* Frame::matrix() const
+{
+  static GLdouble m[4][4];
+  getMatrix(m);
+  return (const GLdouble*)(m);
+}
+
+/*! \c GLdouble[4][4] version of matrix(). See also getWorldMatrix() and matrix(). */
+void Frame::getMatrix(GLdouble m[4][4]) const
+{
+  q_.getMatrix(m);
+
+  m[3][0] = t_[0];
+  m[3][1] = t_[1];
+  m[3][2] = t_[2];
+}
+
+/*! \c GLdouble[16] version of matrix(). See also getWorldMatrix() and matrix(). */
+void Frame::getMatrix(GLdouble m[16]) const
+{
+  q_.getMatrix(m);
+
+  m[12] = t_[0];
+  m[13] = t_[1];
+  m[14] = t_[2];
+}
+
+/*! Returns a Frame representing the inverse of the Frame space transformation.
+
+  The rotation() of the new Frame is the Quaternion::inverse() of the original rotation.
+  Its translation() is the negated inverse rotated image of the original translation.
+
+  If a Frame is considered as a space rigid transformation (translation and rotation), the inverse()
+  Frame performs the inverse transformation.
+
+  Only the local Frame transformation (i.e. defined with respect to the referenceFrame()) is inverted.
+  Use worldInverse() for a global inverse.
+
+  The resulting Frame has the same referenceFrame() as the Frame and a \c NULL constraint().
+
+  \note The scaling factor of the 4x4 matrix is 1.0. */
+Frame Frame::inverse() const
+{
+  Frame fr(-(q_.inverseRotate(t_)), q_.inverse());
+  fr.setReferenceFrame(referenceFrame());
+  return fr;
+}
+
+/*! Returns the 4x4 OpenGL transformation matrix represented by the Frame.
+
+  This method should be used in conjunction with \c glMultMatrixd() to modify
+  the OpenGL modelview matrix from a Frame:
+  \code
+  // The modelview here corresponds to the world coordinate system.
+  Frame fr(pos, Quaternion(from, to));
+  glPushMatrix();
+  glMultMatrixd(fr.worldMatrix());
+  // draw object in the fr coordinate system.
+  glPopMatrix();
+  \endcode
+
+  This matrix represents the global Frame transformation: the entire referenceFrame() hierarchy is
+  taken into account to define the Frame transformation from the world coordinate system. Use
+  matrix() to get the local Frame transformation matrix (i.e. defined with respect to the
+  referenceFrame()). These two match when the referenceFrame() is \c NULL.
+
+  The OpenGL format of the result is the transpose of the actual mathematical European
+  representation (translation is on the last \e line instead of the last \e column).
+
+  \attention The result is only valid until the next call to matrix(), getMatrix(), worldMatrix() or
+  getWorldMatrix(). Use it immediately (as above) or use getWorldMatrix() instead.
+
+  \note The scaling factor of the 4x4 matrix is 1.0. */
+const GLdouble* Frame::worldMatrix() const
+{
+  // This test is done for efficiency reasons (creates lots of temp objects otherwise).
+  if (referenceFrame())
+  {
+    static Frame fr;
+    fr.setTranslation(position());
+    fr.setRotation(orientation());
+    return fr.matrix();
+  }
+  else
+    return matrix();
+}
+
+/*! float[4][4] parameter version of worldMatrix(). See also getMatrix() and matrix(). */
+void Frame::getWorldMatrix(GLdouble m[4][4]) const
+{
+  const GLdouble* mat = worldMatrix();
+  for (int i=0; i&lt;4; ++i)
+    for (int j=0; j&lt;4; ++j)
+      m[i][j] = mat[i*4+j];
+}
+
+/*! float[16] parameter version of worldMatrix(). See also getMatrix() and matrix(). */
+void Frame::getWorldMatrix(GLdouble m[16]) const
+{
+  const GLdouble* mat = worldMatrix();
+  for (int i=0; i&lt;16; ++i)
+      m[i] = mat[i];
+}
+
+/*! This is an overloaded method provided for convenience. Same as setFromMatrix(). */
+void Frame::setFromMatrix(const GLdouble m[4][4])
+{
+  if (fabs(m[3][3]) &lt; 1E-8)
+    {
+      qWarning(&quot;Frame::setFromMatrix: Null homogeneous coefficient&quot;);
+      return;
+    }
+
+  double rot[3][3];
+  for (int i=0; i&lt;3; ++i)
+    {
+      t_[i] = m[3][i] / m[3][3];
+      for (int j=0; j&lt;3; ++j)
+	// Beware of the transposition (OpenGL to European math)
+	rot[i][j] = m[j][i] / m[3][3];
+    }
+  q_.setFromRotationMatrix(rot);
+  emit modified();
+}
+
+/*! Sets the Frame from an OpenGL matrix representation (rotation in the upper left 3x3 matrix and
+ translation on the last line).
+
+ Hence, if a code fragment looks like:
+ \code
+ GLdouble m[16]={...};
+ glMultMatrixd(m);
+ \endcode
+ It is equivalent to write:
+ \code
+ Frame fr;
+ fr.setFromMatrix(m);
+ glMultMatrixd(fr.matrix());
+ \endcode
+
+ Using this conversion, you can benefit from the powerful Frame transformation methods to translate
+ points and vectors to and from the Frame coordinate system to any other Frame coordinate system
+ (including the world coordinate system). See coordinatesOf() and transformOf().
+
+ Emits the modified() signal. See also matrix(), getMatrix() and
+ Quaternion::setFromRotationMatrix().
+
+ \attention A Frame does not contain a scale factor. The possible scaling in \p m will not be
+ converted into the Frame by this method. */
+void Frame::setFromMatrix(const GLdouble m[16])
+{
+  GLdouble mat[4][4];
+  for (int i=0; i&lt;4; ++i)
+    for (int j=0; j&lt;4; ++j)
+      mat[i][j] = m[i*4+j];
+  setFromMatrix(mat);
+}
+
+//////////////////// SET AND GET LOCAL TRANSLATION AND ROTATION ///////////////////////////////
+
+
+/*! Same as setTranslation(), but with \p float parameters. */
+void Frame::setTranslation(float x, float y, float z)
+{
+  setTranslation(Vec(x, y, z));
+}
+
+/*! Fill \c x, \c y and \c z with the translation() of the Frame. */
+void Frame::getTranslation(float&amp; x, float&amp; y, float&amp; z) const
+{
+  const Vec t = translation();
+  x = t[0];
+  y = t[1];
+  z = t[2];
+}
+
+/*! Same as setRotation() but with \c float Quaternion parameters. */
+void Frame::setRotation(double q0, double q1, double q2, double q3)
+{
+  setRotation(Quaternion(q0, q1, q2, q3));
+}
+
+/*! The \p q are set to the rotation() of the Frame.
+
+See Quaternion::Quaternion(double, double, double, double) for details on \c q. */
+void Frame::getRotation(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3) const
+{
+  const Quaternion q = rotation();
+  q0 = q[0];
+  q1 = q[1];
+  q2 = q[2];
+  q3 = q[3];
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Translates the Frame of \p t (defined in the Frame coordinate system).
+
+  The translation actually applied to the Frame may differ from \p t since it can be filtered by the
+  constraint(). Use translate(Vec&amp;) or setTranslationWithConstraint() to retrieve the filtered
+  translation value. Use setTranslation() to directly translate the Frame without taking the
+  constraint() into account.
+
+  See also rotate(const Quaternion&amp;). Emits the modified() signal. */
+void Frame::translate(const Vec&amp; t)
+{
+  Vec tbis = t;
+  translate(tbis);
+}
+
+/*! Same as translate(const Vec&amp;) but \p t may be modified to satisfy the translation constraint().
+  Its new value corresponds to the translation that has actually been applied to the Frame. */
+void Frame::translate(Vec&amp; t)
+{
+  if (constraint())
+    constraint()-&gt;constrainTranslation(t, this);
+  t_ += t;
+  emit modified();
+}
+
+/*! Same as translate(const Vec&amp;) but with \c float parameters. */
+void Frame::translate(float x, float y, float z)
+{
+  Vec t(x,y,z);
+  translate(t);
+}
+
+/*! Same as translate(Vec&amp;) but with \c float parameters. */
+void Frame::translate(float&amp; x, float&amp; y, float&amp; z)
+{
+  Vec t(x,y,z);
+  translate(t);
+  x = t[0];
+  y = t[1];
+  z = t[2];
+}
+
+/*! Rotates the Frame by \p q (defined in the Frame coordinate system): R = R*q.
+
+  The rotation actually applied to the Frame may differ from \p q since it can be filtered by the
+  constraint(). Use rotate(Quaternion&amp;) or setRotationWithConstraint() to retrieve the filtered
+  rotation value. Use setRotation() to directly rotate the Frame without taking the constraint()
+  into account.
+
+  See also translate(const Vec&amp;). Emits the modified() signal. */
+void Frame::rotate(const Quaternion&amp; q)
+{
+  Quaternion qbis = q;
+  rotate(qbis);
+}
+
+/*! Same as rotate(const Quaternion&amp;) but \p q may be modified to satisfy the rotation constraint().
+  Its new value corresponds to the rotation that has actually been applied to the Frame. */
+void Frame::rotate(Quaternion&amp; q)
+{
+  if (constraint())
+    constraint()-&gt;constrainRotation(q, this);
+  q_ *= q;
+  q_.normalize(); // Prevents numerical drift
+  emit modified();
+}
+
+/*! Same as rotate(Quaternion&amp;) but with \c float Quaternion parameters. */
+void Frame::rotate(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3)
+{
+  Quaternion q(q0,q1,q2,q3);
+  rotate(q);
+  q0 = q[0];
+  q1 = q[1];
+  q2 = q[2];
+  q3 = q[3];
+}
+
+/*! Same as rotate(const Quaternion&amp;) but with \c float Quaternion parameters. */
+void Frame::rotate(double q0, double q1, double q2, double q3)
+{
+  Quaternion q(q0,q1,q2,q3);
+  rotate(q);
+}
+
+/*! Makes the Frame rotate() by \p rotation around \p point.
+
+  \p point is defined in the world coordinate system, while the \p rotation axis is defined in the
+  Frame coordinate system.
+
+  If the Frame has a constraint(), \p rotation is first constrained using
+  Constraint::constrainRotation(). The translation which results from the filtered rotation around
+  \p point is then computed and filtered using Constraint::constrainTranslation(). The new \p
+  rotation value corresponds to the rotation that has actually been applied to the Frame.
+
+  Emits the modified() signal. */
+void Frame::rotateAroundPoint(Quaternion&amp; rotation, const Vec&amp; point)
+{
+  if (constraint())
+    constraint()-&gt;constrainRotation(rotation, this);
+  q_ *= rotation;
+  q_.normalize(); // Prevents numerical drift
+  Vec trans = point + Quaternion(inverseTransformOf(rotation.axis()), rotation.angle()).rotate(position()-point) - t_;
+  if (constraint())
+    constraint()-&gt;constrainTranslation(trans, this);
+  t_ += trans;
+  emit modified();
+}
+
+/*! Same as rotateAroundPoint(), but with a \c const \p rotation Quaternion. Note that the actual
+  rotation may differ since it can be filtered by the constraint(). */
+void Frame::rotateAroundPoint(const Quaternion&amp; rotation, const Vec&amp; point)
+{
+  Quaternion rot = rotation;
+  rotateAroundPoint(rot, point);
+}
+
+//////////////////// SET AND GET WORLD POSITION AND ORIENTATION ///////////////////////////////
+
+/*! Sets the position() of the Frame, defined in the world coordinate system. Emits the modified()
+  signal.
+
+Use setTranslation() to define the \e local frame translation (with respect to the
+referenceFrame()). The potential constraint() of the Frame is not taken into account, use
+setPositionWithConstraint() instead. */
+void Frame::setPosition(const Vec&amp; position)
+{
+  if (referenceFrame())
+    setTranslation(referenceFrame()-&gt;coordinatesOf(position));
+  else
+    setTranslation(position);
+}
+
+/*! Same as setPosition(), but with \c float parameters. */
+void Frame::setPosition(float x, float y, float z)
+{
+  setPosition(Vec(x, y, z));
+}
+
+/*! Same as successive calls to setPosition() and then setOrientation().
+
+Only one modified() signal is emitted, which is convenient if this signal is connected to a
+QGLViewer::updateGL() slot. See also setTranslationAndRotation() and
+setPositionAndOrientationWithConstraint(). */
+void Frame::setPositionAndOrientation(const Vec&amp; position, const Quaternion&amp; orientation)
+{
+  if (referenceFrame())
+    {
+      t_ = referenceFrame()-&gt;coordinatesOf(position);
+      q_ = referenceFrame()-&gt;orientation().inverse() * orientation;
+    }
+  else
+    {
+      t_ = position;
+      q_ = orientation;
+    }
+  emit modified();
+}
+
+
+/*! Same as successive calls to setTranslation() and then setRotation().
+
+Only one modified() signal is emitted, which is convenient if this signal is connected to a
+QGLViewer::updateGL() slot. See also setPositionAndOrientation() and
+setTranslationAndRotationWithConstraint(). */
+void Frame::setTranslationAndRotation(const Vec&amp; translation, const Quaternion&amp; rotation)
+{
+  t_ = translation;
+  q_ = rotation;
+  emit modified();
+}
+
+
+/*! \p x, \p y and \p z are set to the position() of the Frame. */
+void Frame::getPosition(float&amp; x, float&amp; y, float&amp; z) const
+{
+  Vec p = position();
+  x = p.x;
+  y = p.y;
+  z = p.z;
+}
+
+/*! Sets the orientation() of the Frame, defined in the world coordinate system. Emits the modified() signal.
+
+Use setRotation() to define the \e local frame rotation (with respect to the referenceFrame()). The
+potential constraint() of the Frame is not taken into account, use setOrientationWithConstraint()
+instead. */
+void Frame::setOrientation(const Quaternion&amp; orientation)
+{
+  if (referenceFrame())
+    setRotation(referenceFrame()-&gt;orientation().inverse() * orientation);
+  else
+    setRotation(orientation);
+}
+
+/*! Same as setOrientation(), but with \c float parameters. */
+void Frame::setOrientation(double q0, double q1, double q2, double q3)
+{
+  setOrientation(Quaternion(q0, q1, q2, q3));
+}
+
+/*! Get the current orientation of the frame (same as orientation()).
+  Parameters are the orientation Quaternion values.
+  See also setOrientation(). */
+
+/*! The \p q are set to the orientation() of the Frame.
+
+See Quaternion::Quaternion(double, double, double, double) for details on \c q. */
+void Frame::getOrientation(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3) const
+{
+  Quaternion o = orientation();
+  q0 = o[0];
+  q1 = o[1];
+  q2 = o[2];
+  q3 = o[3];
+}
+
+/*! Returns the orientation of the Frame, defined in the world coordinate system. See also
+  position(), setOrientation() and rotation(). */
+Quaternion Frame::orientation() const
+{
+  Quaternion res = rotation();
+  const Frame* fr = referenceFrame();
+  while (fr != NULL)
+    {
+      res = fr-&gt;rotation() * res;
+      fr  = fr-&gt;referenceFrame();
+    }
+  return res;
+}
+
+
+////////////////////// C o n s t r a i n t   V e r s i o n s  //////////////////////////
+
+/*! Same as setTranslation(), but \p translation is modified so that the potential constraint() of the
+  Frame is satisfied.
+
+  Emits the modified() signal. See also setRotationWithConstraint() and setPositionWithConstraint(). */
+void Frame::setTranslationWithConstraint(Vec&amp; translation)
+{
+  Vec deltaT = translation - this-&gt;translation();
+  if (constraint())
+    constraint()-&gt;constrainTranslation(deltaT, this);
+
+  setTranslation(this-&gt;translation() + deltaT);
+  translation = this-&gt;translation();
+}
+
+/*! Same as setRotation(), but \p rotation is modified so that the potential constraint() of the
+  Frame is satisfied.
+
+  Emits the modified() signal. See also setTranslationWithConstraint() and setOrientationWithConstraint(). */
+void Frame::setRotationWithConstraint(Quaternion&amp; rotation)
+{
+  Quaternion deltaQ = this-&gt;rotation().inverse() * rotation;
+  if (constraint())
+    constraint()-&gt;constrainRotation(deltaQ, this);
+
+  // Prevent numerical drift
+  deltaQ.normalize();
+
+  setRotation(this-&gt;rotation() * deltaQ);
+  q_.normalize();
+  rotation = this-&gt;rotation();
+}
+
+/*! Same as setTranslationAndRotation(), but \p translation and \p orientation are modified to
+  satisfy the constraint(). Emits the modified() signal. */
+void Frame::setTranslationAndRotationWithConstraint(Vec&amp; translation, Quaternion&amp; rotation)
+{
+  Vec deltaT = translation - this-&gt;translation();
+  Quaternion deltaQ = this-&gt;rotation().inverse() * rotation;
+
+  if (constraint())
+    {
+      constraint()-&gt;constrainTranslation(deltaT, this);
+      constraint()-&gt;constrainRotation(deltaQ, this);
+    }
+
+  // Prevent numerical drift
+  deltaQ.normalize();
+
+  t_ += deltaT;
+  q_ *= deltaQ;
+  q_.normalize();
+
+  translation = this-&gt;translation();
+  rotation = this-&gt;rotation();
+
+  emit modified();
+}
+
+/*! Same as setPosition(), but \p position is modified so that the potential constraint() of the
+  Frame is satisfied. See also setOrientationWithConstraint() and setTranslationWithConstraint(). */
+void Frame::setPositionWithConstraint(Vec&amp; position)
+{
+  if (referenceFrame())
+    position = referenceFrame()-&gt;coordinatesOf(position);
+
+  setTranslationWithConstraint(position);
+}
+
+/*! Same as setOrientation(), but \p orientation is modified so that the potential constraint() of the Frame
+  is satisfied. See also setPositionWithConstraint() and setRotationWithConstraint(). */
+void Frame::setOrientationWithConstraint(Quaternion&amp; orientation)
+{
+  if (referenceFrame())
+    orientation = referenceFrame()-&gt;orientation().inverse() * orientation;
+
+  setRotationWithConstraint(orientation);
+}
+
+/*! Same as setPositionAndOrientation() but \p position and \p orientation are modified to satisfy
+the constraint. Emits the modified() signal. */
+void Frame::setPositionAndOrientationWithConstraint(Vec&amp; position, Quaternion&amp; orientation)
+{
+  if (referenceFrame())
+    {
+      position = referenceFrame()-&gt;coordinatesOf(position);
+      orientation = referenceFrame()-&gt;orientation().inverse() * orientation;
+    }
+  setTranslationAndRotationWithConstraint(position, orientation);
+}
+
+
+///////////////////////////// REFERENCE FRAMES ///////////////////////////////////////
+
+/*! Sets the referenceFrame() of the Frame.
+
+The Frame translation() and rotation() are then defined in the referenceFrame() coordinate system.
+Use position() and orientation() to express these in the world coordinate system.
+
+Emits the modified() signal if \p refFrame differs from the current referenceFrame().
+
+Using this method, you can create a hierarchy of Frames. This hierarchy needs to be a tree, which
+root is the world coordinate system (i.e. a \c NULL referenceFrame()). A warning is printed and no
+action is performed if setting \p refFrame as the referenceFrame() would create a loop in the Frame
+hierarchy (see settingAsReferenceFrameWillCreateALoop()). */
+void Frame::setReferenceFrame(const Frame* const refFrame)
+{
+  if (settingAsReferenceFrameWillCreateALoop(refFrame))
+    qWarning(&quot;Frame::setReferenceFrame would create a loop in Frame hierarchy&quot;);
+  else
+    {
+      bool identical = (referenceFrame_ == refFrame);
+      referenceFrame_ = refFrame;
+      if (!identical)
+	emit modified();
+    }
+}
+
+/*! Returns \c true if setting \p frame as the Frame's referenceFrame() would create a loop in the
+  Frame hierarchy. */
+bool Frame::settingAsReferenceFrameWillCreateALoop(const Frame* const frame)
+{
+  const Frame* f = frame;
+  while (f != NULL)
+    {
+      if (f == this)
+	return true;
+      f = f-&gt;referenceFrame();
+    }
+  return false;
+}
+
+///////////////////////// FRAME TRANSFORMATIONS OF 3D POINTS //////////////////////////////
+
+/*! Returns the Frame coordinates of a point \p src defined in the world coordinate system (converts
+ from world to Frame).
+
+ inverseCoordinatesOf() performs the inverse convertion. transformOf() converts 3D vectors instead
+ of 3D coordinates.
+
+ See the &lt;a href=&quot;../examples/frameTransform.html&quot;&gt;frameTransform example&lt;/a&gt; for an
+ illustration. */
+Vec Frame::coordinatesOf(const Vec&amp; src) const
+{
+  if (referenceFrame())
+    return localCoordinatesOf(referenceFrame()-&gt;coordinatesOf(src));
+  else
+    return localCoordinatesOf(src);
+}
+
+/*! Returns the world coordinates of the point whose position in the Frame coordinate system is \p
+  src (converts from Frame to world).
+
+  coordinatesOf() performs the inverse convertion. Use inverseTransformOf() to transform 3D vectors
+  instead of 3D coordinates. */
+Vec Frame::inverseCoordinatesOf(const Vec&amp; src) const
+{
+  const Frame* fr = this;
+  Vec res = src;
+  while (fr != NULL)
+    {
+      res = fr-&gt;localInverseCoordinatesOf(res);
+      fr  = fr-&gt;referenceFrame();
+    }
+  return res;
+}
+
+/*! Returns the Frame coordinates of a point \p src defined in the referenceFrame() coordinate
+  system (converts from referenceFrame() to Frame).
+
+  localInverseCoordinatesOf() performs the inverse convertion. See also localTransformOf(). */
+Vec Frame::localCoordinatesOf(const Vec&amp; src) const
+{
+  return rotation().inverseRotate(src - translation());
+}
+
+/*! Returns the referenceFrame() coordinates of a point \p src defined in the Frame coordinate
+ system (converts from Frame to referenceFrame()).
+
+ localCoordinatesOf() performs the inverse convertion. See also localInverseTransformOf(). */
+Vec Frame::localInverseCoordinatesOf(const Vec&amp; src) const
+{
+  return rotation().rotate(src) + translation();
+}
+
+/*! Returns the Frame coordinates of the point whose position in the \p from coordinate system is \p
+  src (converts from \p from to Frame).
+
+  coordinatesOfIn() performs the inverse transformation. */
+Vec Frame::coordinatesOfFrom(const Vec&amp; src, const Frame* const from) const
+{
+  if (this == from)
+    return src;
+  else
+    if (referenceFrame())
+      return localCoordinatesOf(referenceFrame()-&gt;coordinatesOfFrom(src, from));
+    else
+      return localCoordinatesOf(from-&gt;inverseCoordinatesOf(src));
+}
+
+/*! Returns the \p in coordinates of the point whose position in the Frame coordinate system is \p
+  src (converts from Frame to \p in).
+
+  coordinatesOfFrom() performs the inverse transformation. */
+Vec Frame::coordinatesOfIn(const Vec&amp; src, const Frame* const in) const
+{
+  const Frame* fr = this;
+  Vec res = src;
+  while ((fr != NULL) &amp;&amp; (fr != in))
+    {
+      res = fr-&gt;localInverseCoordinatesOf(res);
+      fr  = fr-&gt;referenceFrame();
+    }
+
+  if (fr != in)
+    // in was not found in the branch of this, res is now expressed in the world
+    // coordinate system. Simply convert to in coordinate system.
+    res = in-&gt;coordinatesOf(res);
+
+  return res;
+}
+
+////// float[3] versions
+
+/*! Same as coordinatesOf(), but with \c float parameters. */
+void Frame::getCoordinatesOf(const float src[3], float res[3]) const
+{
+  const Vec r = coordinatesOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as inverseCoordinatesOf(), but with \c float parameters. */
+void Frame::getInverseCoordinatesOf(const float src[3], float res[3]) const
+{
+  const Vec r = inverseCoordinatesOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as localCoordinatesOf(), but with \c float parameters. */
+void Frame::getLocalCoordinatesOf(const float src[3], float res[3]) const
+{
+  const Vec r = localCoordinatesOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+  /*! Same as localInverseCoordinatesOf(), but with \c float parameters. */
+void Frame::getLocalInverseCoordinatesOf(const float src[3], float res[3]) const
+{
+  const Vec r = localInverseCoordinatesOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as coordinatesOfIn(), but with \c float parameters. */
+void Frame::getCoordinatesOfIn(const float src[3], float res[3], const Frame* const in) const
+{
+  const Vec r = coordinatesOfIn(Vec(src), in);
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as coordinatesOfFrom(), but with \c float parameters. */
+void Frame::getCoordinatesOfFrom(const float src[3], float res[3], const Frame* const from) const
+{
+  const Vec r = coordinatesOfFrom(Vec(src), from);
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+
+///////////////////////// FRAME TRANSFORMATIONS OF VECTORS //////////////////////////////
+
+/*! Returns the Frame transform of a vector \p src defined in the world coordinate system (converts
+ vectors from world to Frame).
+
+ inverseTransformOf() performs the inverse transformation. coordinatesOf() converts 3D coordinates
+ instead of 3D vectors (here only the rotational part of the transformation is taken into account).
+
+ See the &lt;a href=&quot;../examples/frameTransform.html&quot;&gt;frameTransform example&lt;/a&gt; for an
+ illustration. */
+Vec Frame::transformOf(const Vec&amp; src) const
+{
+  if (referenceFrame())
+    return localTransformOf(referenceFrame()-&gt;transformOf(src));
+  else
+    return localTransformOf(src);
+}
+
+/*! Returns the world transform of the vector whose coordinates in the Frame coordinate
+  system is \p src (converts vectors from Frame to world).
+
+  transformOf() performs the inverse transformation. Use inverseCoordinatesOf() to transform 3D
+  coordinates instead of 3D vectors. */
+Vec Frame::inverseTransformOf(const Vec&amp; src) const
+{
+  const Frame* fr = this;
+  Vec res = src;
+  while (fr != NULL)
+    {
+      res = fr-&gt;localInverseTransformOf(res);
+      fr  = fr-&gt;referenceFrame();
+    }
+  return res;
+}
+
+/*! Returns the Frame transform of a vector \p src defined in the referenceFrame() coordinate system
+  (converts vectors from referenceFrame() to Frame).
+
+  localInverseTransformOf() performs the inverse transformation. See also localCoordinatesOf(). */
+Vec Frame::localTransformOf(const Vec&amp; src) const
+{
+  return rotation().inverseRotate(src);
+}
+
+/*! Returns the referenceFrame() transform of a vector \p src defined in the Frame coordinate
+ system (converts vectors from Frame to referenceFrame()).
+
+ localTransformOf() performs the inverse transformation. See also localInverseCoordinatesOf(). */
+Vec Frame::localInverseTransformOf(const Vec&amp; src) const
+{
+  return rotation().rotate(src);
+}
+
+/*! Returns the Frame transform of the vector whose coordinates in the \p from coordinate system is \p
+  src (converts vectors from \p from to Frame).
+
+  transformOfIn() performs the inverse transformation. */
+Vec Frame::transformOfFrom(const Vec&amp; src, const Frame* const from) const
+{
+  if (this == from)
+    return src;
+  else
+    if (referenceFrame())
+      return localTransformOf(referenceFrame()-&gt;transformOfFrom(src, from));
+    else
+      return localTransformOf(from-&gt;inverseTransformOf(src));
+}
+
+/*! Returns the \p in transform of the vector whose coordinates in the Frame coordinate system is \p
+  src (converts vectors from Frame to \p in).
+
+  transformOfFrom() performs the inverse transformation. */
+Vec Frame::transformOfIn(const Vec&amp; src, const Frame* const in) const
+{
+  const Frame* fr = this;
+  Vec    res = src;
+  while ((fr != NULL) &amp;&amp; (fr != in))
+    {
+      res = fr-&gt;localInverseTransformOf(res);
+      fr  = fr-&gt;referenceFrame();
+    }
+
+  if (fr != in)
+    // in was not found in the branch of this, res is now expressed in the world
+    // coordinate system. Simply convert to in coordinate system.
+    res = in-&gt;transformOf(res);
+
+  return res;
+}
+
+/////////////////  float[3] versions  //////////////////////
+
+/*! Same as transformOf(), but with \c float parameters. */
+void Frame::getTransformOf(const float src[3], float res[3]) const
+{
+  Vec r = transformOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as inverseTransformOf(), but with \c float parameters. */
+void Frame::getInverseTransformOf(const float src[3], float res[3]) const
+{
+  Vec r = inverseTransformOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as localTransformOf(), but with \c float parameters. */
+void Frame::getLocalTransformOf(const float src[3], float res[3]) const
+{
+  Vec r = localTransformOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as localInverseTransformOf(), but with \c float parameters. */
+void Frame::getLocalInverseTransformOf(const float src[3], float res[3]) const
+{
+  Vec r = localInverseTransformOf(Vec(src));
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as transformOfIn(), but with \c float parameters. */
+void Frame::getTransformOfIn(const float src[3], float res[3], const Frame* const in) const
+{
+  Vec r = transformOfIn(Vec(src), in);
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+/*! Same as transformOfFrom(), but with \c float parameters. */
+void Frame::getTransformOfFrom(const float src[3], float res[3], const Frame* const from) const
+{
+  Vec r = transformOfFrom(Vec(src), from);
+  for (int i=0; i&lt;3 ; ++i)
+    res[i] = r[i];
+}
+
+////////////////////////////      STATE      //////////////////////////////
+
+/*! Returns an XML \c QDomElement that represents the Frame.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ The resulting QDomElement looks like:
+ \code
+ &lt;name&gt;
+   &lt;position x=&quot;..&quot; y=&quot;..&quot; z=&quot;..&quot; /&gt;
+   &lt;orientation q0=&quot;..&quot; q1=&quot;..&quot; q2=&quot;..&quot; q3=&quot;..&quot; /&gt;
+ &lt;/name&gt;
+ \endcode
+
+ Use initFromDOMElement() to restore the Frame state from the resulting \c QDomElement.
+
+ See Vec::domElement() for a complete example. See also Quaternion::domElement(),
+ Camera::domElement()...
+
+ \attention The constraint() and referenceFrame() are not saved in the QDomElement. */
+QDomElement Frame::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  // TODO: use translation and rotation instead when referenceFrame is coded...
+  QDomElement e = document.createElement(name);
+  e.appendChild(position().domElement(&quot;position&quot;, document));
+  e.appendChild(orientation().domElement(&quot;orientation&quot;, document));
+  return e;
+}
+
+/*! Restores the Frame state from a \c QDomElement created by domElement().
+
+ See domElement() for the \c QDomElement syntax. See the Vec::initFromDOMElement() and
+ Quaternion::initFromDOMElement() documentations for details on default values if an argument is
+ missing.
+
+ \attention The constraint() and referenceFrame() are not restored by this method and are left
+ unchanged. */
+void Frame::initFromDOMElement(const QDomElement&amp; element)
+{
+  // TODO: use translation and rotation instead when referenceFrame is coded...
+
+  // Reset default values. Attention: destroys constraint.
+  // *this = Frame();
+  // This instead ? Better : what is not set is not changed.
+  // setPositionAndOrientation(Vec(), Quaternion());
+
+  QDomElement child=element.firstChild().toElement();
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;position&quot;)
+	setPosition(Vec(child));
+      if (child.tagName() == &quot;orientation&quot;)
+	setOrientation(Quaternion(child).normalized());
+
+      child = child.nextSibling().toElement();
+    }
+}
+
+/////////////////////////////////   ALIGN   /////////////////////////////////
+
+/*! Aligns the Frame with \p frame, so that two of their axis are parallel.
+
+If one of the X, Y and Z axis of the Frame is almost parallel to any of the X, Y, or Z axis of \p
+frame, the Frame is rotated so that these two axis actually become parallel.
+
+If, after this first rotation, two other axis are also almost parallel, a second alignment is
+performed. The two frames then have identical orientations, up to 90 degrees rotations.
+
+\p threshold measures how close two axis must be to be considered parallel. It is compared with the
+absolute values of the dot product of the normalized axis.
+
+When \p move is set to \c true, the Frame position() is also affected by the alignment. The new
+Frame position() is such that the \p frame position (computed with coordinatesOf(), in the Frame
+coordinates system) does not change.
+
+\p frame may be \c NULL and then represents the world coordinate system (same convention than for
+the referenceFrame()).
+
+The rotation (and translation when \p move is \c true) applied to the Frame are filtered by the
+possible constraint(). */
+void Frame::alignWithFrame(const Frame* const frame, bool move, float threshold)
+{
+  Vec directions[2][3];
+  for (int d=0; d&lt;3; ++d)
+    {
+      Vec dir((d==0)? 1.0 : 0.0, (d==1)? 1.0 : 0.0, (d==2)? 1.0 : 0.0);
+      if (frame)
+	directions[0][d] = frame-&gt;inverseTransformOf(dir);
+      else
+	directions[0][d] = dir;
+      directions[1][d] = inverseTransformOf(dir);
+    }
+
+  float maxProj = 0.0f;
+  float proj;
+  unsigned short index[2];
+  index[0] = index[1] = 0;
+  for (int i=0; i&lt;3; ++i)
+    for (int j=0; j&lt;3; ++j)
+      if ( (proj=fabs(directions[0][i]*directions[1][j])) &gt;= maxProj )
+	{
+	  index[0] = i;
+	  index[1] = j;
+	  maxProj  = proj;
+	}
+
+  Frame old;
+  old=*this;
+
+  float coef = directions[0][index[0]] * directions[1][index[1]];
+  if (fabs(coef) &gt;= threshold)
+    {
+      const Vec axis = cross(directions[0][index[0]], directions[1][index[1]]);
+      float angle = asin(axis.norm());
+      if (coef &gt;= 0.0)
+	angle = -angle;
+      // setOrientation(Quaternion(axis, angle) * orientation());
+      rotate(rotation().inverse() * Quaternion(axis, angle) * orientation());
+
+      // Try to align an other axis direction
+      unsigned short d = (index[1]+1) % 3;
+      Vec dir((d==0)? 1.0 : 0.0, (d==1)? 1.0 : 0.0, (d==2)? 1.0 : 0.0);
+      dir = inverseTransformOf(dir);
+
+      float max = 0.0f;
+      for (int i=0; i&lt;3; ++i)
+	{
+	  float proj = fabs(directions[0][i]*dir);
+	  if (proj &gt; max)
+	    {
+	      index[0] = i;
+	      max = proj;
+	    }
+	}
+
+      if (max &gt;= threshold)
+	{
+	  const Vec axis = cross(directions[0][index[0]], dir);
+	  float angle = asin(axis.norm());
+	  if (directions[0][index[0]] * dir &gt;= 0.0)
+	    angle = -angle;
+	  // setOrientation(Quaternion(axis, angle) * orientation());
+	  rotate(rotation().inverse() * Quaternion(axis, angle) * orientation());
+	}
+    }
+
+  if (move)
+    {
+      Vec center;
+      if (frame)
+	center = frame-&gt;position();
+
+      // setPosition(center - orientation().rotate(old.coordinatesOf(center)));
+      translate(center - orientation().rotate(old.coordinatesOf(center)) - translation());
+    }
+}
+
+/*! Translates the Frame so that its position() lies on the line defined by \p origin and \p
+  direction (defined in the world coordinate system).
+
+Simply uses an orthogonal projection. \p direction does not need to be normalized. */
+void Frame::projectOnLine(const Vec&amp; origin, const Vec&amp; direction)
+{
+  // If you are trying to find a bug here, because of memory problems, you waste your time.
+  // This is a bug in the gcc 3.3 compiler. Compile the library in debug mode and test.
+  // Uncommenting this line also seems to solve the problem. Horrible.
+  // cout &lt;&lt; &quot;position = &quot; &lt;&lt; position() &lt;&lt; endl;
+  // If you found a problem or are using a different compiler, please let me know.
+  const Vec shift = origin - position();
+  Vec proj = shift;
+  proj.projectOnAxis(direction);
+  translate(shift-proj);
+}

Added: trunk/lib/QGLViewer/frame.h
===================================================================
--- trunk/lib/QGLViewer/frame.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/frame.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,425 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_FRAME_H
+#define QGLVIEWER_FRAME_H
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QObject&gt;
+# include &lt;QString&gt;
+#else
+# include &lt;qobject.h&gt;
+# include &lt;qstring.h&gt;
+#endif
+
+#include &quot;constraint.h&quot;
+// #include &quot;GL/gl.h&quot; is now included in config.h for ease of configuration
+
+namespace qglviewer {
+  /*! \brief The Frame class represents a coordinate system, defined by a position and an
+  orientation. \class Frame frame.h QGLViewer/frame.h
+
+  A Frame is a 3D coordinate system, represented by a position() and an orientation(). The order of
+  these transformations is important: the Frame is first translated \e and \e then rotated around
+  the new translated origin.
+
+  A Frame is useful to define the position and orientation of a 3D rigid object, using its matrix()
+  method, as shown below:
+  \code
+  // Builds a Frame at position (0.5,0,0) and oriented such that its Y axis is along the (1,1,1)
+  // direction. One could also have used setPosition() and setOrientation().
+  Frame fr(Vec(0.5,0,0), Quaternion(Vec(0,1,0), Vec(1,1,1)));
+  glPushMatrix();
+  glMultMatrixd(fr.matrix());
+  // Draw your object here, in the local fr coordinate system.
+  glPopMatrix();
+  \endcode
+
+  Many functions are provided to transform a 3D point from one coordinate system (Frame) to an
+  other: see coordinatesOf(), inverseCoordinatesOf(), coordinatesOfIn(), coordinatesOfFrom()...
+
+  You may also want to transform a 3D vector (such as a normal), which corresponds to applying only
+  the rotational part of the frame transformation: see transformOf() and inverseTransformOf(). See
+  the &lt;a href=&quot;../examples/frameTransform.html&quot;&gt;frameTransform example&lt;/a&gt; for an illustration.
+
+  The translation() and the rotation() that are encapsulated in a Frame can also be used to
+  represent a \e rigid \e transformation of space. Such a transformation can also be interpreted as
+  a change of coordinate system, and the coordinate system conversion functions actually allow you
+  to use a Frame as a rigid transformation. Use inverseCoordinatesOf() (resp. coordinatesOf()) to
+  apply the transformation (resp. its inverse). Note the inversion.
+
+  &lt;h3&gt;Hierarchy of Frames&lt;/h3&gt;
+
+  The position and the orientation of a Frame are actually defined with respect to a
+  referenceFrame(). The default referenceFrame() is the world coordinate system (represented by a \c
+  NULL referenceFrame()). If you setReferenceFrame() to a different Frame, you must then
+  differentiate:
+
+  \arg the \e local translation() and rotation(), defined with respect to the referenceFrame(),
+
+  \arg the \e global position() and orientation(), always defined with respect to the world
+  coordinate system.
+
+  A Frame is actually defined by its translation() with respect to its referenceFrame(), and then by
+  a rotation() of the coordinate system around the new translated origin.
+
+  This terminology for \e local (translation() and rotation()) and \e global (position() and
+  orientation()) definitions is used in all the methods' names and should be sufficient to prevent
+  ambiguities. These notions are obviously identical when the referenceFrame() is \c NULL, i.e. when
+  the Frame is defined in the world coordinate system (the one you are in at the beginning of the
+  QGLViewer::draw() method, see the &lt;a href=&quot;../introduction.html&quot;&gt;introduction page&lt;/a&gt;).
+
+  Frames can hence easily be organized in a tree hierarchy, which root is the world coordinate
+  system. A loop in the hierarchy would result in an inconsistent (multiple) Frame definition.
+  settingAsReferenceFrameWillCreateALoop() checks this and prevents setReferenceFrame() from
+  creating such a loop.
+
+  This frame hierarchy is used in methods like coordinatesOfIn(), coordinatesOfFrom()... which allow
+  coordinates (or vector) conversions from a Frame to any other one (including the world coordinate
+  system).
+
+  However, one must note that this hierarchical representation is internal to the Frame classes.
+  When the Frames represent OpenGL coordinates system, one should map this hierarchical
+  representation to the OpenGL GL_MODELVIEW matrix stack. See the matrix() documentation for
+  details.
+
+  &lt;h3&gt;Constraints&lt;/h3&gt;
+
+  An interesting feature of Frames is that their displacements can be constrained. When a Constraint
+  is attached to a Frame, it filters the input of translate() and rotate(), and only the resulting
+  filtered motion is applied to the Frame. The default constraint() is \c NULL resulting in no
+  filtering. Use setConstraint() to attach a Constraint to a frame.
+
+  Constraints are especially usefull for the ManipulatedFrame instances, in order to forbid some
+  mouse motions. See the &lt;a href=&quot;../examples/constrainedFrame.html&quot;&gt;constrainedFrame&lt;/a&gt;, &lt;a
+  href=&quot;../examples/constrainedCamera.html&quot;&gt;constrainedCamera&lt;/a&gt; and &lt;a
+  href=&quot;../examples/luxo.html&quot;&gt;luxo&lt;/a&gt; examples for an illustration.
+
+  Classical constraints are provided for convenience (see LocalConstraint, WorldConstraint and
+  CameraConstraint) and new constraints can very easily be implemented.
+
+  &lt;h3&gt;Derived classes&lt;/h3&gt;
+
+  The ManipulatedFrame class inherits Frame and implements a mouse motion convertion, so that a
+  Frame (and hence an object) can be manipulated in the scene with the mouse.
+
+  \nosubgrouping */
+  class QGLVIEWER_EXPORT Frame : public QObject
+  {
+    Q_OBJECT
+
+  public:
+    Frame();
+
+    /*! Virtual destructor. Empty. */
+    virtual ~Frame() {};
+
+    Frame(const Frame&amp; frame);
+    Frame&amp; operator=(const Frame&amp; frame);
+
+  signals:
+    /*! This signal is emitted whenever the position() or the orientation() of the Frame is modified.
+
+    Connect this signal to any object that must be notified:
+    \code
+    QObject::connect(myFrame, SIGNAL(modified()), myObject, SLOT(update()));
+    \endcode
+    Use the QGLViewer::QGLViewerPool() to connect the signal to all the viewers.
+
+    \note If your Frame is part of a Frame hierarchy (see referenceFrame()), a modification of one
+    of the parents of this Frame will \e not emit this signal. Use code like this to change this
+    behavior (you can do this recursively for all the referenceFrame() until the \c NULL world root
+    frame is encountered):
+    \code
+    // Emits the Frame modified() signal when its referenceFrame() is modified().
+    connect(myFrame-&gt;referenceFrame(), SIGNAL(modified()), myFrame, SIGNAL(modified()));
+    \endcode
+
+    \attention Connecting this signal to a QGLWidget::updateGL() slot (or a method that calls it)
+    will prevent you from modifying the Frame \e inside your QGLViewer::draw() method as it would
+    result in an infinite loop. However, QGLViewer::draw() should not modify the scene.
+
+    \note For efficiency reasons, this signal is emitted even if the Frame is not actually modified, for
+    instance with translate(Vec(0,0,0)) or setPosition(position()). */
+    void modified();
+
+    /*! This signal is emitted when the Frame is interpolated by a KeyFrameInterpolator.
+
+    See the KeyFrameInterpolator documentation for details.
+
+    If a KeyFrameInterpolator is used to successively interpolate several Frames in your scene,
+    connect the KeyFrameInterpolator::interpolated() signal instead (identical, but independent of
+    the interpolated Frame). */
+    void interpolated();
+
+  public:
+    /*! @name World coordinates position and orientation */
+    //@{
+    Frame(const Vec&amp; position, const Quaternion&amp; orientation);
+
+    void setPosition(const Vec&amp; position);
+    void setPosition(float x, float y, float z);
+    void setPositionWithConstraint(Vec&amp; position);
+
+    void setOrientation(const Quaternion&amp; orientation);
+    void setOrientation(double q0, double q1, double q2, double q3);
+    void setOrientationWithConstraint(Quaternion&amp; orientation);
+
+    void setPositionAndOrientation(const Vec&amp; position, const Quaternion&amp; orientation);
+    void setPositionAndOrientationWithConstraint(Vec&amp; position, Quaternion&amp; orientation);
+
+    /*! Returns the position of the Frame, defined in the world coordinate system. See also
+      orientation(), setPosition() and translation(). */
+    Vec position() const { return inverseCoordinatesOf(Vec(0.0,0.0,0.0)); };
+    Quaternion orientation() const;
+
+    void getPosition(float&amp; x, float&amp; y, float&amp; z) const;
+    void getOrientation(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3) const;
+  //@}
+
+
+    public:
+    /*! @name Local translation and rotation w/r reference Frame */
+    //@{
+    /*! Sets the translation() of the frame, locally defined with respect to the referenceFrame().
+      Emits the modified() signal.
+
+    Use setPosition() to define the world coordinates position(). Use
+    setTranslationWithConstraint() to take into account the potential constraint() of the Frame. */
+    void setTranslation(const Vec&amp; translation) { t_ = translation; emit modified(); };
+    void setTranslation(float x, float y, float z);
+    void setTranslationWithConstraint(Vec&amp; translation);
+
+    /*! Set the current rotation Quaternion. See rotation() and the different Quaternion
+    constructors. Emits the modified() signal. See also setTranslation() and
+    setRotationWithConstraint(). */
+
+    /*! Sets the rotation() of the Frame, locally defined with respect to the referenceFrame().
+      Emits the modified() signal.
+
+     Use setOrientation() to define the world coordinates orientation(). The potential
+     constraint() of the Frame is not taken into account, use setRotationWithConstraint()
+     instead. */
+    void setRotation(const Quaternion&amp; rotation) { q_ = rotation; emit modified(); };
+    void setRotation(double q0, double q1, double q2, double q3);
+    void setRotationWithConstraint(Quaternion&amp; rotation);
+
+    void setTranslationAndRotation(const Vec&amp; translation, const Quaternion&amp; rotation);
+    void setTranslationAndRotationWithConstraint(Vec&amp; translation, Quaternion&amp; rotation);
+
+    /*! Returns the Frame translation, defined with respect to the referenceFrame().
+
+    Use position() to get the result in the world coordinates. These two values are identical
+    when the referenceFrame() is \c NULL (default).
+
+    See also setTranslation() and setTranslationWithConstraint(). */
+    Vec translation() const { return t_; };
+    /*! Returns the Frame rotation, defined with respect to the referenceFrame().
+
+    Use orientation() to get the result in the world coordinates. These two values are identical
+    when the referenceFrame() is \c NULL (default).
+
+    See also setRotation() and setRotationWithConstraint(). */
+
+    /*! Returns the current Quaternion orientation. See setRotation(). */
+    Quaternion rotation() const { return q_; };
+
+    void getTranslation(float&amp; x, float&amp; y, float&amp; z) const;
+    void getRotation(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3) const;
+    //@}
+
+    public:
+    /*! @name Frame hierarchy */
+    //@{
+    /*! Returns the reference Frame, in which coordinates system the Frame is defined.
+
+    The translation() and rotation() of the Frame are defined with respect to the referenceFrame()
+    coordinate system. A \c NULL referenceFrame() (default value) means that the Frame is defined in
+    the world coordinate system.
+
+    Use position() and orientation() to recursively convert values along the referenceFrame() chain
+    and to get values expressed in the world coordinate system. The values match when the
+    referenceFrame() is \c NULL.
+
+    Use setReferenceFrame() to set this value and create a Frame hierarchy. Convenient functions
+    allow you to convert 3D coordinates from one Frame to an other: see coordinatesOf(),
+    localCoordinatesOf(), coordinatesOfIn() and their inverse functions.
+
+    Vectors can also be converted using transformOf(), transformOfIn, localTransformOf() and their
+    inverse functions. */
+    const Frame* referenceFrame() const { return referenceFrame_; };
+    void setReferenceFrame(const Frame* const refFrame);
+    bool settingAsReferenceFrameWillCreateALoop(const Frame* const frame);
+    //@}
+
+
+    /*! @name Frame modification */
+    //@{
+    void translate(Vec&amp; t);
+    void translate(const Vec&amp; t);
+    // Some compilers complain about &quot;overloading cannot distinguish from previous declaration&quot;
+    // Simply comment out the following method and its associated implementation
+    void translate(float x, float y, float z);
+    void translate(float&amp; x, float&amp; y, float&amp; z);
+
+    void rotate(Quaternion&amp; q);
+    void rotate(const Quaternion&amp; q);
+    // Some compilers complain about &quot;overloading cannot distinguish from previous declaration&quot;
+    // Simply comment out the following method and its associated implementation
+    void rotate(double q0, double q1, double q2, double q3);
+    void rotate(double&amp; q0, double&amp; q1, double&amp; q2, double&amp; q3);
+
+    void rotateAroundPoint(Quaternion&amp; rotation, const Vec&amp; point);
+    void rotateAroundPoint(const Quaternion&amp; rotation, const Vec&amp; point);
+
+    void alignWithFrame(const Frame* const frame, bool move=false, float threshold=0.85f);
+    void projectOnLine(const Vec&amp; origin, const Vec&amp; direction);
+    //@}
+
+
+    /*! @name Coordinate system transformation of 3D coordinates */
+    //@{
+    Vec coordinatesOf(const Vec&amp; src) const;
+    Vec inverseCoordinatesOf(const Vec&amp; src) const;
+    Vec localCoordinatesOf(const Vec&amp; src) const;
+    Vec localInverseCoordinatesOf(const Vec&amp; src) const;
+    Vec coordinatesOfIn(const Vec&amp; src, const Frame* const in) const;
+    Vec coordinatesOfFrom(const Vec&amp; src, const Frame* const from) const;
+
+    void getCoordinatesOf(const float src[3], float res[3]) const;
+    void getInverseCoordinatesOf(const float src[3], float res[3]) const;
+    void getLocalCoordinatesOf(const float src[3], float res[3]) const;
+    void getLocalInverseCoordinatesOf(const float src[3], float res[3]) const;
+    void getCoordinatesOfIn(const float src[3], float res[3], const Frame* const in) const;
+    void getCoordinatesOfFrom(const float src[3], float res[3], const Frame* const from) const;
+    //@}
+
+    /*! @name Coordinate system transformation of vectors */
+    // A frame is as a new coordinate system, defined with respect to a reference frame (the world
+    // coordinate system by default, see the &quot;Composition of frame&quot; section).
+
+    // The transformOf() (resp. inverseTransformOf()) functions transform a 3D vector from (resp.
+    // to) the world coordinates system. This section defines the 3D vector transformation
+    // functions. See the Coordinate system transformation of 3D points above for the transformation
+    // of 3D points. The difference between the two sets of functions is simple: for vectors, only
+    // the rotational part of the transformations is taken into account, while translation is also
+    // considered for 3D points.
+
+    // The length of the resulting transformed vector is identical to the one of the source vector
+    // for all the described functions.
+
+    // When local is prepended to the names of the functions, the functions simply transform from
+    // (and to) the reference frame.
+
+    // When In (resp. From) is appended to the names, the functions transform from (resp. To) the
+    // frame that is given as an argument. The frame does not need to be in the same branch or the
+    // hierarchical tree, and can be \c NULL (the world coordinates system).
+
+    // Combining any of these functions with its inverse (in any order) leads to the identity.
+    //@{
+    Vec transformOf(const Vec&amp; src) const;
+    Vec inverseTransformOf(const Vec&amp; src) const;
+    Vec localTransformOf(const Vec&amp; src) const;
+    Vec localInverseTransformOf(const Vec&amp; src) const;
+    Vec transformOfIn(const Vec&amp; src, const Frame* const in) const;
+    Vec transformOfFrom(const Vec&amp; src, const Frame* const from) const;
+
+    void getTransformOf(const float src[3], float res[3]) const;
+    void getInverseTransformOf(const float src[3], float res[3]) const;
+    void getLocalTransformOf(const float src[3], float res[3]) const;
+    void getLocalInverseTransformOf(const float src[3], float res[3]) const;
+    void getTransformOfIn(const float src[3], float res[3], const Frame* const in) const;
+    void getTransformOfFrom(const float src[3], float res[3], const Frame* const from) const;
+    //@}
+
+
+    /*! @name Constraint on the displacement */
+    //@{
+    /*! Returns the current constraint applied to the Frame.
+
+    A \c NULL value (default) means that no Constraint is used to filter Frame translation and
+    rotation. See the Constraint class documentation for details.
+
+    You may have to use a \c dynamic_cast to convert the result to a Constraint derived class. */
+    Constraint* constraint() const { return constraint_; }
+    /*! Sets the constraint() attached to the Frame.
+
+    A \c NULL value means no constraint. The previous constraint() should be deleted by the calling
+    method if needed. */
+    void setConstraint(Constraint* const constraint) { constraint_ = constraint; }
+    //@}
+
+    /*! @name Associated matrices */
+    //@{
+  public:
+    const GLdouble* matrix() const;
+    void getMatrix(GLdouble m[4][4]) const;
+    void getMatrix(GLdouble m[16]) const;
+
+    const GLdouble* worldMatrix() const;
+    void getWorldMatrix(GLdouble m[4][4]) const;
+    void getWorldMatrix(GLdouble m[16]) const;
+
+    void setFromMatrix(const GLdouble m[4][4]);
+    void setFromMatrix(const GLdouble m[16]);
+    //@}
+
+    /*! @name Inversion of the transformation */
+    //@{
+    Frame inverse() const;
+    /*! Returns the inverse() of the Frame world transformation.
+
+    The orientation() of the new Frame is the Quaternion::inverse() of the original orientation.
+    Its position() is the negated and inverse rotated image of the original position.
+
+    The result Frame has a \c NULL referenceFrame() and a \c NULL constraint().
+
+    Use inverse() for a local (i.e. with respect to referenceFrame()) transformation inverse. */
+    Frame worldInverse() const { return Frame(-(orientation().inverseRotate(position())), orientation().inverse()); }
+    //@}
+
+    /*! @name XML representation */
+    //@{
+  public:
+    virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  public slots:
+    virtual void initFromDOMElement(const QDomElement&amp; element);
+    //@}
+
+  private:
+    // P o s i t i o n   a n d   o r i e n t a t i o n
+    Vec t_;
+    Quaternion q_;
+
+    // C o n s t r a i n t s
+    Constraint* constraint_;
+
+    // F r a m e   c o m p o s i t i o n
+    const Frame* referenceFrame_;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_FRAME_H

Added: trunk/lib/QGLViewer/keyFrameInterpolator.cpp
===================================================================
--- trunk/lib/QGLViewer/keyFrameInterpolator.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/keyFrameInterpolator.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,821 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;qglviewer.h&quot; // for QGLViewer::drawAxis and Camera::drawCamera
+
+using namespace qglviewer;
+using namespace std;
+
+#if QT_VERSION &lt; 0x040000
+// Patch for QPtrList / QList syntax difference
+# define peekNext current
+#endif
+
+/*! Creates a KeyFrameInterpolator, with \p frame as associated frame().
+
+  The frame() can be set or changed using setFrame().
+
+  interpolationTime(), interpolationSpeed() and interpolationPeriod() are set to their default
+  values. */
+KeyFrameInterpolator::KeyFrameInterpolator(Frame* frame)
+  : frame_(NULL), period_(40), interpolationTime_(0.0), interpolationSpeed_(1.0), interpolationStarted_(false),
+    closedPath_(false), loopInterpolation_(false), pathIsValid_(false), valuesAreValid_(true), currentFrameValid_(false)
+  // #CONNECTION# Values cut pasted initFromDOMElement()
+{
+  setFrame(frame);
+#if QT_VERSION &lt; 0x040000
+  keyFrame_.setAutoDelete(true);
+#endif
+  for (int i=0; i&lt;4; ++i)
+#if QT_VERSION &gt;= 0x040000
+    currentFrame_[i] = new QMutableListIterator&lt;KeyFrame*&gt;(keyFrame_);
+#else
+    currentFrame_[i] = new QPtrListIterator&lt;KeyFrame&gt;(keyFrame_);
+#endif
+  connect(&amp;timer_, SIGNAL(timeout()), SLOT(update()));
+}
+
+/*! Virtual destructor. Clears the keyFrame path. */
+KeyFrameInterpolator::~KeyFrameInterpolator()
+{
+  deletePath();
+  for (int i=0; i&lt;4; ++i)
+    delete currentFrame_[i];
+}
+
+/*! Sets the frame() associated to the KeyFrameInterpolator. */
+void KeyFrameInterpolator::setFrame(Frame* const frame)
+{
+  if (this-&gt;frame())
+    disconnect(this, SIGNAL( interpolated() ), this-&gt;frame(), SIGNAL( interpolated() ));
+
+  frame_ = frame;
+
+  if (this-&gt;frame())
+    connect(this, SIGNAL( interpolated() ), this-&gt;frame(), SIGNAL( interpolated() ));
+}
+
+/*! Updates frame() state according to current interpolationTime(). Then adds
+  interpolationPeriod()*interpolationSpeed() to interpolationTime().
+
+  This internal method is called by a timer when interpolationIsStarted(). It can be used for
+  debugging purpose. stopInterpolation() is called when interpolationTime() reaches firstTime() or
+  lastTime(), unless loopInterpolation() is \c true. */
+void KeyFrameInterpolator::update()
+{
+  interpolateAtTime(interpolationTime());
+
+  interpolationTime_ += interpolationSpeed() * interpolationPeriod() / 1000.0;
+
+  if (interpolationTime() &gt; keyFrame_.last()-&gt;time())
+    {
+      if (loopInterpolation())
+	setInterpolationTime(keyFrame_.first()-&gt;time() + interpolationTime_ - keyFrame_.last()-&gt;time());
+      else
+	{
+	  // Make sure last KeyFrame is reached and displayed
+	  interpolateAtTime(keyFrame_.last()-&gt;time());
+	  stopInterpolation();
+	}
+      emit endReached();
+    }
+  else
+    if (interpolationTime() &lt; keyFrame_.first()-&gt;time())
+      {
+	if (loopInterpolation())
+	  setInterpolationTime(keyFrame_.last()-&gt;time() - keyFrame_.first()-&gt;time() + interpolationTime_);
+	else
+	  {
+	    // Make sure first KeyFrame is reached and displayed
+	    interpolateAtTime(keyFrame_.first()-&gt;time());
+	    stopInterpolation();
+	  }
+	emit endReached();
+      }
+}
+
+
+/*! Starts the interpolation process.
+
+  A timer is started with an interpolationPeriod() period that updates the frame()'s position and
+  orientation. interpolationIsStarted() will return \c true until stopInterpolation() or
+  toggleInterpolation() is called.
+
+  If \p period is positive, it is set as the new interpolationPeriod(). The previous
+  interpolationPeriod() is used otherwise (default).
+
+  If interpolationTime() is larger than lastTime(), interpolationTime() is reset to firstTime()
+  before interpolation starts (and inversely for negative interpolationSpeed()).
+
+  Use setInterpolationTime() before calling this method to change the starting interpolationTime().
+
+  See the &lt;a href=&quot;../examples/keyFrames.html&quot;&gt;keyFrames example&lt;/a&gt; for an illustration.
+
+  You may also be interested in QGLViewer::animate() and QGLViewer::startAnimation().
+
+  \attention The keyFrames must be defined (see addKeyFrame()) \e before you startInterpolation(),
+  or else the interpolation will naturally immediately stop. */
+void KeyFrameInterpolator::startInterpolation(int period)
+{
+  if (period &gt;= 0)
+    setInterpolationPeriod(period);
+
+  if (!keyFrame_.isEmpty())
+    {
+      if ((interpolationSpeed() &gt; 0.0) &amp;&amp; (interpolationTime() &gt;= keyFrame_.last()-&gt;time()))
+	setInterpolationTime(keyFrame_.first()-&gt;time());
+      if ((interpolationSpeed() &lt; 0.0) &amp;&amp; (interpolationTime() &lt;= keyFrame_.first()-&gt;time()))
+	setInterpolationTime(keyFrame_.last()-&gt;time());
+      timer_.start(interpolationPeriod());
+      interpolationStarted_ = true;
+      update();
+    }
+}
+
+
+/*! Stops an interpolation started with startInterpolation(). See interpolationIsStarted() and toggleInterpolation(). */
+void KeyFrameInterpolator::stopInterpolation()
+{
+  timer_.stop();
+  interpolationStarted_ = false;
+}
+
+
+/*! Stops the interpolation and resets interpolationTime() to the firstTime().
+
+If desired, call interpolateAtTime() after this method to actually move the frame() to
+firstTime(). */
+void KeyFrameInterpolator::resetInterpolation()
+{
+  stopInterpolation();
+  setInterpolationTime(firstTime());
+}
+
+/*! Appends a new keyFrame to the path, with its associated \p time (in seconds).
+
+  The keyFrame is given as a pointer to a Frame, which will be connected to the
+  KeyFrameInterpolator: when \p frame is modified, the KeyFrameInterpolator path is updated
+  accordingly. This allows for dynamic paths, where keyFrame can be edited, even during the
+  interpolation. See the &lt;a href=&quot;../examples/keyFrames.html&quot;&gt;keyFrames example&lt;/a&gt; for an
+  illustration.
+
+  \c NULL \p frame pointers are silently ignored. The keyFrameTime() has to be monotonously
+  increasing over keyFrames.
+
+  Use addKeyFrame(const Frame&amp;, float) to add keyFrame by values. */
+void KeyFrameInterpolator::addKeyFrame(const Frame* const frame, float time)
+{
+  if (!frame)
+    return;
+
+  if (keyFrame_.isEmpty())
+    interpolationTime_ = time;
+
+  if ( (!keyFrame_.isEmpty()) &amp;&amp; (keyFrame_.last()-&gt;time() &gt; time) )
+    qWarning(&quot;Error in KeyFrameInterpolator::addKeyFrame: time is not monotone&quot;);
+  else
+    keyFrame_.append(new KeyFrame(frame, time));
+  connect(frame, SIGNAL(modified()), SLOT(invalidateValues()));
+  valuesAreValid_ = false;
+  pathIsValid_ = false;
+  currentFrameValid_ = false;
+  resetInterpolation();
+}
+
+/*! Appends a new keyFrame to the path, with its associated \p time (in seconds).
+
+  The path will use the current \p frame state. If you want the path to change when \p frame is
+  modified, you need to pass a \e pointer to the Frame instead (see addKeyFrame(const Frame*,
+  float)).
+
+  The keyFrameTime() have to be monotonously increasing over keyFrames. */
+void KeyFrameInterpolator::addKeyFrame(const Frame&amp; frame, float time)
+{
+  if (keyFrame_.isEmpty())
+    interpolationTime_ = time;
+
+  if ( (!keyFrame_.isEmpty()) &amp;&amp; (keyFrame_.last()-&gt;time() &gt; time) )
+    qWarning(&quot;Error in KeyFrameInterpolator::addKeyFrame: time is not monotone&quot;);
+  else
+    keyFrame_.append(new KeyFrame(frame, time));
+
+  valuesAreValid_ = false;
+  pathIsValid_ = false;
+  currentFrameValid_ = false;
+  resetInterpolation();
+}
+
+
+/*! Appends a new keyFrame to the path.
+
+ Same as addKeyFrame(const Frame* frame, float), except that the keyFrameTime() is set to the
+ previous keyFrameTime() plus one second (or 0.0 if there is no previous keyFrame). */
+void KeyFrameInterpolator::addKeyFrame(const Frame* const frame)
+{
+  float time;
+  if (keyFrame_.isEmpty())
+    time = 0.0;
+  else
+    time = lastTime() + 1.0;
+
+  addKeyFrame(frame, time);
+}
+
+/*! Appends a new keyFrame to the path.
+
+ Same as addKeyFrame(const Frame&amp; frame, float), except that the keyFrameTime() is automatically set
+ to previous keyFrameTime() plus one second (or 0.0 if there is no previous keyFrame). */
+void KeyFrameInterpolator::addKeyFrame(const Frame&amp; frame)
+{
+  float time;
+  if (keyFrame_.isEmpty())
+    time = 0.0;
+  else
+    time = keyFrame_.last()-&gt;time() + 1.0;
+
+  addKeyFrame(frame, time);
+}
+
+/*! Removes all keyFrames from the path. The numberOfKeyFrames() is set to 0. */
+void KeyFrameInterpolator::deletePath()
+{
+  stopInterpolation();
+#if QT_VERSION &gt;= 0x040000
+  qDeleteAll(keyFrame_);
+#endif
+  keyFrame_.clear();
+  pathIsValid_ = false;
+  valuesAreValid_ = false;
+  currentFrameValid_ = false;
+}
+
+static void drawCamera(float scale)
+{
+  glDisable(GL_LIGHTING);
+
+  const float halfHeight = scale * 0.07;
+  const float halfWidth  = halfHeight * 1.3;
+  const float dist = halfHeight / tan(M_PI/8.0);
+
+  const float arrowHeight    = 1.5f * halfHeight;
+  const float baseHeight     = 1.2f * halfHeight;
+  const float arrowHalfWidth = 0.5f * halfWidth;
+  const float baseHalfWidth  = 0.3f * halfWidth;
+
+  // Frustum outline
+  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+  glBegin(GL_LINE_STRIP);
+  glVertex3f(-halfWidth, halfHeight,-dist);
+  glVertex3f(-halfWidth,-halfHeight,-dist);
+  glVertex3f( 0.0f, 0.0f, 0.0f);
+  glVertex3f( halfWidth,-halfHeight,-dist);
+  glVertex3f(-halfWidth,-halfHeight,-dist);
+  glEnd();
+  glBegin(GL_LINE_STRIP);
+  glVertex3f( halfWidth,-halfHeight,-dist);
+  glVertex3f( halfWidth, halfHeight,-dist);
+  glVertex3f( 0.0f, 0.0f, 0.0f);
+  glVertex3f(-halfWidth, halfHeight,-dist);
+  glVertex3f( halfWidth, halfHeight,-dist);
+  glEnd();
+
+  // Up arrow
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  // Base
+  glBegin(GL_QUADS);
+  glVertex3f(-baseHalfWidth, halfHeight,-dist);
+  glVertex3f( baseHalfWidth, halfHeight,-dist);
+  glVertex3f( baseHalfWidth, baseHeight,-dist);
+  glVertex3f(-baseHalfWidth, baseHeight,-dist);
+  glEnd();
+
+  // Arrow
+  glBegin(GL_TRIANGLES);
+  glVertex3f( 0.0f,           arrowHeight,-dist);
+  glVertex3f(-arrowHalfWidth, baseHeight, -dist);
+  glVertex3f( arrowHalfWidth, baseHeight, -dist);
+  glEnd();
+}
+
+/*! Draws the path used to interpolate the frame().
+
+  \p mask controls what is drawn: if (mask &amp; 1) (default), the position path is drawn. If (mask &amp;
+  2), a camera representation is regularly drawn and if (mask &amp; 4), an oriented axis is regularly
+  drawn. Examples:
+
+  \code
+  drawPath();  // Simply draws the interpolation path
+  drawPath(3); // Draws path and cameras
+  drawPath(5); // Draws path and axis
+  \endcode
+
+  In the case where camera or axis is drawn, \p nbFrames controls the number of objects (axis or
+  camera) drawn between two successive keyFrames. When \p nbFrames=1, only the path KeyFrames are
+  drawn. \p nbFrames=2 also draws the intermediate orientation, etc. The maximum value is 30. \p
+  nbFrames should divide 30 so that an object is drawn for each KeyFrame. Default value is 6.
+
+  \p scale (default=1.0) controls the scaling of the camera and axis drawing. A value of
+  QGLViewer::sceneRadius() should give good results.
+
+  See the &lt;a href=&quot;../examples/keyFrames.html&quot;&gt;keyFrames example&lt;/a&gt; for an illustration.
+
+  The color of the path is the current \c glColor().
+
+  \attention The OpenGL state is modified by this method: GL_LIGHTING is disabled and line width set
+  to 2. Use this code to preserve your current OpenGL state:
+  \code
+  glPushAttrib(GL_ALL_ATTRIB_BITS);
+  drawPathModifyGLState(mask, nbFrames, scale);
+  glPopAttrib();
+  \endcode */
+void KeyFrameInterpolator::drawPath(int mask, int nbFrames, float scale)
+{
+  const int nbSteps = 30;
+  if (!pathIsValid_)
+    {
+      path_.clear();
+#if QT_VERSION &lt; 0x040000
+      path_.reserve(nbSteps*keyFrame_.count());
+#endif
+
+      if (keyFrame_.isEmpty())
+	return;
+
+      if (!valuesAreValid_)
+	updateModifiedFrameValues();
+
+      if (keyFrame_.first() == keyFrame_.last())
+	path_.push_back(Frame(keyFrame_.first()-&gt;position(), keyFrame_.first()-&gt;orientation()));
+      else
+	{
+	  static Frame fr;
+	  KeyFrame* kf_[4];
+	  kf_[0] = keyFrame_.first();
+	  kf_[1] = kf_[0];
+#if QT_VERSION &gt;= 0x040000
+	  int index = 1;
+	  kf_[2] = (index &lt; keyFrame_.size()) ? keyFrame_.at(index) : NULL;
+	  index++;
+	  kf_[3] = (index &lt; keyFrame_.size()) ? keyFrame_.at(index) : NULL;
+#else
+	  kf_[2] = keyFrame_.next();
+	  kf_[3] = keyFrame_.next();
+#endif
+
+	  while (kf_[2])
+	    {
+	      Vec diff = kf_[2]-&gt;position() - kf_[1]-&gt;position();
+	      Vec v1 = 3.0 * diff - 2.0 * kf_[1]-&gt;tgP() - kf_[2]-&gt;tgP();
+	      Vec v2 = -2.0 * diff + kf_[1]-&gt;tgP() + kf_[2]-&gt;tgP();
+
+	      // cout &lt;&lt; kf_[0]-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt; kf_[1]-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt; kf_[2]-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt; kf_[3]-&gt;time() &lt;&lt; endl;
+	      for (int step=0; step&lt;nbSteps; ++step)
+		{
+		  float alpha = step / static_cast&lt;float&gt;(nbSteps);
+		  fr.setPosition(kf_[1]-&gt;position() + alpha * (kf_[1]-&gt;tgP() + alpha * (v1+alpha*v2)));
+		  fr.setOrientation(Quaternion::squad(kf_[1]-&gt;orientation(), kf_[1]-&gt;tgQ(), kf_[2]-&gt;tgQ(), kf_[2]-&gt;orientation(), alpha));
+		  path_.push_back(fr);
+		}
+
+	      // Shift
+	      kf_[0] = kf_[1];
+	      kf_[1] = kf_[2];
+	      kf_[2] = kf_[3];
+#if QT_VERSION &gt;= 0x040000
+	      index++;
+	      kf_[3] = (index &lt; keyFrame_.size()) ? keyFrame_.at(index) : NULL;
+#else
+	      kf_[3] = keyFrame_.next();
+#endif
+	    }
+	  // Add last KeyFrame
+	  path_.push_back(Frame(kf_[1]-&gt;position(), kf_[1]-&gt;orientation()));
+	}
+      pathIsValid_ = true;
+    }
+
+  if (mask)
+    {
+      glDisable(GL_LIGHTING);
+      glLineWidth(2);
+
+      if (mask &amp; 1)
+	{
+	  glBegin(GL_LINE_STRIP);
+#if QT_VERSION &gt;= 0x040000
+	  foreach (Frame fr, path_)
+	    glVertex3fv(fr.position());
+#else
+# if QT_VERSION &lt; 0x030000
+	  for (int i=0; i &lt; path_.size(); ++i)
+	    glVertex3fv((path_.at(i)).position());
+# else
+	  for (QValueVector&lt;Frame&gt;::const_iterator pnt=path_.begin(), end=path_.end(); pnt!=end; ++pnt)
+	    glVertex3fv((*pnt).position());
+# endif
+#endif
+	  glEnd();
+	}
+      if (mask &amp; 6)
+	{
+	  int count = 0;
+	  if (nbFrames &gt; nbSteps)
+	    nbFrames = nbSteps;
+	  float goal = 0.0f;
+#if QT_VERSION &gt;= 0x040000
+	  foreach (Frame fr, path_)
+#else
+# if QT_VERSION &lt; 0x030000
+	  for (int i=0; i &lt; path_.size(); ++i)
+# else
+	  for (QValueVector&lt;Frame&gt;::const_iterator pnt=path_.begin(), end=path_.end(); pnt!=end; ++pnt)
+# endif
+#endif
+	      if ((count++) &gt;= goal)
+		{
+		  goal += nbSteps / static_cast&lt;float&gt;(nbFrames);
+		  glPushMatrix();
+#if QT_VERSION &gt;= 0x040000
+		  glMultMatrixd(fr.matrix());
+#else
+# if QT_VERSION &lt; 0x030000
+		  glMultMatrixd((path_.at(i)).matrix());
+# else
+		  glMultMatrixd((*pnt).matrix());
+# endif
+#endif
+		  if (mask &amp; 2) drawCamera(scale);
+		  if (mask &amp; 4) QGLViewer::drawAxis(scale/10.0);
+		  glPopMatrix();
+		}
+	}
+    }
+}
+
+void KeyFrameInterpolator::updateModifiedFrameValues()
+{
+  Quaternion prevQ = keyFrame_.first()-&gt;orientation();
+  KeyFrame* kf;
+#if QT_VERSION &gt;= 0x040000
+  for (int i=0; i&lt;keyFrame_.size(); ++i)
+    {
+      kf = keyFrame_.at(i);
+#else
+  for (kf = keyFrame_.first(); kf; kf=keyFrame_.next())
+    {
+#endif
+      if (kf-&gt;frame())
+	kf-&gt;updateValuesFromPointer();
+      kf-&gt;flipOrientationIfNeeded(prevQ);
+      prevQ = kf-&gt;orientation();
+    }
+
+  KeyFrame* prev = keyFrame_.first();
+  kf = keyFrame_.first();
+#if QT_VERSION &gt;= 0x040000
+  int index = 1;
+#endif
+  while (kf)
+    {
+#if QT_VERSION &gt;= 0x040000
+      KeyFrame* next = (index &lt; keyFrame_.size()) ? keyFrame_.at(index) : NULL;
+      index++;
+#else
+      KeyFrame* next = keyFrame_.next();
+#endif
+      if (next)
+	kf-&gt;computeTangent(prev, next);
+      else
+	kf-&gt;computeTangent(prev, kf);
+      prev = kf;
+      kf = next;
+    }
+  valuesAreValid_ = true;
+}
+
+/*! Returns the Frame associated with the keyFrame at index \p index.
+
+ See also keyFrameTime(). \p index has to be in the range 0..numberOfKeyFrames()-1.
+
+ \note If this keyFrame was defined using a pointer to a Frame (see addKeyFrame(const Frame*
+  const)), the \e current pointed Frame state is returned. */
+Frame KeyFrameInterpolator::keyFrame(int index) const
+{
+  const KeyFrame* const kf = keyFrame_.at(index);
+  return Frame(kf-&gt;position(), kf-&gt;orientation());
+}
+
+/*! Returns the time corresponding to the \p index keyFrame.
+
+ See also keyFrame(). \p index has to be in the range 0..numberOfKeyFrames()-1. */
+float KeyFrameInterpolator::keyFrameTime(int index) const
+{
+  return keyFrame_.at(index)-&gt;time();
+}
+
+/*! Returns the duration of the KeyFrameInterpolator path, expressed in seconds.
+
+ Simply corresponds to lastTime() - firstTime(). Returns 0.0 if the path has less than 2 keyFrames.
+ See also keyFrameTime(). */
+float KeyFrameInterpolator::duration() const
+{
+  return lastTime() - firstTime();
+}
+
+/*! Returns the time corresponding to the first keyFrame, expressed in seconds.
+
+Returns 0.0 if the path is empty. See also lastTime(), duration() and keyFrameTime(). */
+float KeyFrameInterpolator::firstTime() const
+{
+  if (keyFrame_.isEmpty())
+    return 0.0;
+  else
+    return keyFrame_.first()-&gt;time();
+}
+
+/*! Returns the time corresponding to the last keyFrame, expressed in seconds.
+
+Returns 0.0 if the path is empty. See also firstTime(), duration() and keyFrameTime(). */
+float KeyFrameInterpolator::lastTime() const
+{
+  if (keyFrame_.isEmpty())
+    return 0.0;
+  else
+    return keyFrame_.last()-&gt;time();
+}
+
+void KeyFrameInterpolator::updateCurrentKeyFrameForTime(float time)
+{
+  // Assertion: times are sorted in monotone order.
+  // Assertion: keyFrame_ is not empty
+
+  // TODO: Special case for loops when closed path is implemented !!
+  if (!currentFrameValid_)
+    // Recompute everything from scrach
+#if QT_VERSION &gt;= 0x040000
+    currentFrame_[1]-&gt;toFront();
+#else
+    currentFrame_[1]-&gt;toFirst();
+#endif
+
+  while (currentFrame_[1]-&gt;peekNext()-&gt;time() &gt; time)
+    {
+      currentFrameValid_ = false;
+#if QT_VERSION &gt;= 0x040000
+      if (!currentFrame_[1]-&gt;hasPrevious())
+#else
+      if (currentFrame_[1]-&gt;atFirst())
+#endif
+	break;
+#if QT_VERSION &gt;= 0x040000
+      currentFrame_[1]-&gt;previous();
+#else
+      --(*currentFrame_[1]);
+#endif
+    }
+
+  if (!currentFrameValid_)
+    *currentFrame_[2] = *currentFrame_[1];
+
+  while (currentFrame_[2]-&gt;peekNext()-&gt;time() &lt; time)
+    {
+      currentFrameValid_ = false;
+#if QT_VERSION &gt;= 0x040000
+      if (!currentFrame_[2]-&gt;hasNext())
+#else
+      if (currentFrame_[2]-&gt;atLast())
+#endif
+	break;
+#if QT_VERSION &gt;= 0x040000
+      currentFrame_[2]-&gt;next();
+#else
+      ++(*currentFrame_[2]);
+#endif
+    }
+
+  if (!currentFrameValid_)
+    {
+      *currentFrame_[1] = *currentFrame_[2];
+#if QT_VERSION &gt;= 0x040000
+      if ((currentFrame_[1]-&gt;hasPrevious()) &amp;&amp; (time &lt; currentFrame_[2]-&gt;peekNext()-&gt;time()))
+	currentFrame_[1]-&gt;previous();
+#else
+      if ((!currentFrame_[1]-&gt;atFirst()) &amp;&amp; (time &lt; currentFrame_[2]-&gt;current()-&gt;time()))
+	--(*currentFrame_[1]);
+#endif
+
+      *currentFrame_[0] = *currentFrame_[1];
+#if QT_VERSION &gt;= 0x040000
+      if (currentFrame_[0]-&gt;hasPrevious())
+	currentFrame_[0]-&gt;previous();
+#else
+      if (!currentFrame_[0]-&gt;atFirst())
+	--(*currentFrame_[0]);
+#endif
+
+      *currentFrame_[3] = *currentFrame_[2];
+#if QT_VERSION &gt;= 0x040000
+      if (currentFrame_[3]-&gt;hasNext())
+	currentFrame_[3]-&gt;next();
+#else
+      if (!currentFrame_[3]-&gt;atLast())
+	++(*currentFrame_[3]);
+#endif
+
+      currentFrameValid_ = true;
+      splineCacheIsValid_ = false;
+    }
+
+  // cout &lt;&lt; &quot;Time = &quot; &lt;&lt; time &lt;&lt; &quot; : &quot; &lt;&lt; currentFrame_[0]-&gt;peekNext()-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt;
+  // currentFrame_[1]-&gt;peekNext()-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt; currentFrame_[2]-&gt;peekNext()-&gt;time() &lt;&lt; &quot; , &quot; &lt;&lt;  currentFrame_[3]-&gt;peekNext()-&gt;time() &lt;&lt; endl;
+}
+
+void KeyFrameInterpolator::updateSplineCache()
+{
+  Vec delta = currentFrame_[2]-&gt;peekNext()-&gt;position() - currentFrame_[1]-&gt;peekNext()-&gt;position();
+  v1 = 3.0 * delta - 2.0 * currentFrame_[1]-&gt;peekNext()-&gt;tgP() - currentFrame_[2]-&gt;peekNext()-&gt;tgP();
+  v2 = -2.0 * delta + currentFrame_[1]-&gt;peekNext()-&gt;tgP() + currentFrame_[2]-&gt;peekNext()-&gt;tgP();
+  splineCacheIsValid_ = true;
+}
+
+/*! Interpolate frame() at time \p time (expressed in seconds). interpolationTime() is set to \p
+  time and frame() is set accordingly.
+
+  If you simply want to change interpolationTime() but not the frame() state, use
+  setInterpolationTime() instead.
+
+  Emits the interpolated() signal and makes the frame() emit the Frame::interpolated() signal. */
+void KeyFrameInterpolator::interpolateAtTime(float time)
+{
+  setInterpolationTime(time);
+
+  if ((keyFrame_.isEmpty()) || (!frame()))
+    return;
+
+  if (!valuesAreValid_)
+    updateModifiedFrameValues();
+
+  updateCurrentKeyFrameForTime(time);
+
+  if (!splineCacheIsValid_)
+    updateSplineCache();
+
+  float alpha;
+  float dt = currentFrame_[2]-&gt;peekNext()-&gt;time() - currentFrame_[1]-&gt;peekNext()-&gt;time();
+  if (dt == 0.0)
+    alpha = 0.0;
+  else
+    alpha = (time - currentFrame_[1]-&gt;peekNext()-&gt;time()) / dt;
+
+  // Linear interpolation - debug
+  // Vec pos = alpha*(currentFrame_[2]-&gt;peekNext()-&gt;position()) + (1.0-alpha)*(currentFrame_[1]-&gt;peekNext()-&gt;position());
+  Vec pos = currentFrame_[1]-&gt;peekNext()-&gt;position() + alpha * (currentFrame_[1]-&gt;peekNext()-&gt;tgP() + alpha * (v1+alpha*v2));
+  Quaternion q = Quaternion::squad(currentFrame_[1]-&gt;peekNext()-&gt;orientation(), currentFrame_[1]-&gt;peekNext()-&gt;tgQ(),
+				   currentFrame_[2]-&gt;peekNext()-&gt;tgQ(), currentFrame_[2]-&gt;peekNext()-&gt;orientation(), alpha);
+  frame()-&gt;setPositionAndOrientationWithConstraint(pos, q);
+
+  emit interpolated();
+}
+
+/*! Returns an XML \c QDomElement that represents the KeyFrameInterpolator.
+
+ The resulting QDomElement holds the KeyFrameInterpolator parameters as well as the path keyFrames
+ (if the keyFrame is defined by a pointer to a Frame, use its current value).
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ Use initFromDOMElement() to restore the ManipulatedFrame state from the resulting QDomElement.
+
+ See Vec::domElement() for a complete example. See also Quaternion::domElement(),
+ Camera::domElement()...
+
+ Note that the Camera::keyFrameInterpolator() are automatically saved by QGLViewer::saveStateToFile()
+ when a QGLViewer is closed. */
+QDomElement KeyFrameInterpolator::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement de = document.createElement(name);
+  int count = 0;
+#if QT_VERSION &gt;= 0x040000
+  foreach (KeyFrame* kf, keyFrame_)
+#else
+  for (KeyFrame* kf = keyFrame_.first(); kf; kf = keyFrame_.next() )
+#endif
+    {
+      Frame fr(kf-&gt;position(), kf-&gt;orientation());
+      QDomElement kfNode = fr.domElement(&quot;KeyFrame&quot;, document);
+      kfNode.setAttribute(&quot;index&quot;, QString::number(count));
+      kfNode.setAttribute(&quot;time&quot;,  QString::number(kf-&gt;time()));
+      de.appendChild(kfNode);
+      ++count;
+    }
+  de.setAttribute(&quot;nbKF&quot;, QString::number(keyFrame_.count()));
+  de.setAttribute(&quot;time&quot;, QString::number(interpolationTime()));
+  de.setAttribute(&quot;speed&quot;, QString::number(interpolationSpeed()));
+  de.setAttribute(&quot;period&quot;, QString::number(interpolationPeriod()));
+  de.setAttribute(&quot;closedPath&quot;, (closedPath()?&quot;true&quot;:&quot;false&quot;));
+  de.setAttribute(&quot;loop&quot;, (loopInterpolation()?&quot;true&quot;:&quot;false&quot;));
+  return de;
+}
+
+/*! Restores the KeyFrameInterpolator state from a \c QDomElement created by domElement().
+
+ Note that the frame() pointer is not included in the domElement(): you need to setFrame() after
+ this method to attach a Frame to the KeyFrameInterpolator.
+
+ See Vec::initFromDOMElement() for a complete code example.
+
+ See also Camera::initFromDOMElement() and Frame::initFromDOMElement(). */
+void KeyFrameInterpolator::initFromDOMElement(const QDomElement&amp; element)
+{
+#if QT_VERSION &gt;= 0x040000
+  qDeleteAll(keyFrame_);
+#endif
+  keyFrame_.clear();
+  QDomElement child=element.firstChild().toElement();
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;KeyFrame&quot;)
+	{
+	  Frame fr;
+	  fr.initFromDOMElement(child);
+	  float time = DomUtils::floatFromDom(child, &quot;time&quot;, 0.0);
+	  addKeyFrame(fr, time);
+	}
+
+      child = child.nextSibling().toElement();
+    }
+
+  // #CONNECTION# Values cut pasted from constructor
+  setInterpolationTime(DomUtils::floatFromDom(element, &quot;time&quot;, 0.0));
+  setInterpolationSpeed(DomUtils::floatFromDom(element, &quot;speed&quot;, 1.0));
+  setInterpolationPeriod(DomUtils::intFromDom(element, &quot;period&quot;, 40));
+  setClosedPath(DomUtils::boolFromDom(element, &quot;closedPath&quot;, false));
+  setLoopInterpolation(DomUtils::boolFromDom(element, &quot;loop&quot;, false));
+
+  // setFrame(NULL);
+  pathIsValid_ = false;
+  valuesAreValid_ = false;
+  currentFrameValid_ = false;
+
+  stopInterpolation();
+}
+
+#ifndef DOXYGEN
+
+//////////// KeyFrame private class implementation /////////
+KeyFrameInterpolator::KeyFrame::KeyFrame(const Frame&amp; fr, float t)
+  : time_(t), frame_(NULL)
+{
+  p_ = fr.position();
+  q_ = fr.orientation();
+}
+
+KeyFrameInterpolator::KeyFrame::KeyFrame(const Frame* fr, float t)
+  : time_(t), frame_(fr)
+{
+  updateValuesFromPointer();
+}
+
+void KeyFrameInterpolator::KeyFrame::updateValuesFromPointer()
+{
+  p_ = frame()-&gt;position();
+  q_ = frame()-&gt;orientation();
+}
+
+void KeyFrameInterpolator::KeyFrame::computeTangent(const KeyFrame* const prev, const KeyFrame* const next)
+{
+  tgP_ = 0.5 * (next-&gt;position() - prev-&gt;position());
+  tgQ_ = Quaternion::squadTangent(prev-&gt;orientation(), q_, next-&gt;orientation());
+}
+
+void KeyFrameInterpolator::KeyFrame::flipOrientationIfNeeded(const Quaternion&amp; prev)
+{
+  if (Quaternion::dot(prev, q_) &lt; 0.0)
+    q_.negate();
+}
+
+#endif //DOXYGEN

Added: trunk/lib/QGLViewer/keyFrameInterpolator.h
===================================================================
--- trunk/lib/QGLViewer/keyFrameInterpolator.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/keyFrameInterpolator.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,377 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_KEY_FRAME_INTERPOLATOR_H
+#define QGLVIEWER_KEY_FRAME_INTERPOLATOR_H
+
+#if QT_VERSION &gt; 0x040000
+# include &lt;QObject&gt;
+# include &lt;QTimer&gt;
+#else
+# include &lt;qobject.h&gt;
+# include &lt;qtimer.h&gt;
+#endif
+
+#include &quot;quaternion.h&quot;
+// Not actually needed, but some bad compilers (Microsoft VS6) complain.
+#include &quot;frame.h&quot;
+
+// If you compiler complains about incomplete type, uncomment the next line
+// #include &quot;frame.h&quot;
+// and comment &quot;class Frame;&quot; 3 lines below
+
+namespace qglviewer {
+  class Camera;
+  class Frame;
+  /*! \brief A keyFrame Catmull-Rom Frame interpolator.
+  \class KeyFrameInterpolator keyFrameInterpolator.h QGLViewer/keyFrameInterpolator.h
+
+  A KeyFrameInterpolator holds keyFrames (that define a path) and a pointer to a Frame of your
+  application (which will be interpolated). When the user startInterpolation(), the
+  KeyFrameInterpolator regularly updates the frame() position and orientation along the path.
+
+  Here is a typical utilization example (see also the &lt;a href=&quot;../examples/keyFrames.html&quot;&gt;keyFrames
+  example&lt;/a&gt;):
+  \code
+
+
+  init()
+  {
+    // The KeyFrameInterpolator kfi is given the Frame that it will drive over time.
+    kfi = new KeyFrameInterpolator( new Frame() );
+    kfi-&gt;addKeyFrame( Frame( Vec(1,0,0), Quaternion() ) );
+    kfi-&gt;addKeyFrame( new Frame( Vec(2,1,0), Quaternion() ) );
+    // ...and so on for all the keyFrames.
+
+    // Ask for a display update after each update of the KeyFrameInterpolator
+    connect(kfi, SIGNAL(interpolated()), SLOT(updateGL()));
+
+    kfi-&gt;startInterpolation();
+  }
+
+  draw()
+  {
+    glPushMatrix();
+    glMultMatrixd( kfi-&gt;frame()-&gt;matrix() );
+    // Draw your object here. Its position and orientation are interpolated.
+    glPopMatrix();
+  }
+  \endcode
+
+  The keyFrames are defined by a Frame and a time, expressed in seconds. The Frame can be provided
+  as a const reference or as a pointer to a Frame (see the addKeyFrame() methods). In the latter
+  case, the path will automatically be updated when the Frame is modified (using the
+  Frame::modified() signal).
+
+  The time has to be monotonously increasing over keyFrames. When interpolationSpeed() equals 1.0
+  (default value), these times correspond to actual user's seconds during interpolation (provided
+  that your main loop is fast enough). The interpolation is then real-time: the keyFrames will be
+  reached at their keyFrameTime().
+
+  &lt;h3&gt;Interpolation details&lt;/h3&gt;
+
+  When the user startInterpolation(), a timer is started which will update the frame()'s position
+  and orientation every interpolationPeriod() milliseconds. This update increases the
+  interpolationTime() by interpolationPeriod() * interpolationSpeed() milliseconds.
+
+  Note that this mechanism ensures that the number of interpolation steps is constant and equal to
+  the total path duration() divided by the interpolationPeriod() * interpolationSpeed(). This is
+  especially useful for benchmarking or movie creation (constant number of snapshots).
+
+  During the interpolation, the KeyFrameInterpolator emits an interpolated() signal, which will
+  usually be connected to the QGLViewer::updateGL() slot. The interpolation is stopped when
+  interpolationTime() is greater than the lastTime() (unless loopInterpolation() is \c true) and the
+  endReached() signal is then emitted.
+
+  Note that a Camera has Camera::keyFrameInterpolator(), that can be used to drive the Camera along a
+  path, or to restore a saved position (a path made of a single keyFrame). Press Alt+Fx to define a
+  new keyFrame for path x. Pressing Fx plays/pauses path interpolation. See QGLViewer::pathKey() and
+  the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details.
+
+  \attention If a Constraint is attached to the frame() (see Frame::constraint()), it should be
+  deactivated before interpolationIsStarted(), otherwise the interpolated motion (computed as if
+  there was no constraint) will probably be erroneous.
+
+  &lt;h3&gt;Retrieving interpolated values&lt;/h3&gt;
+
+  This code defines a KeyFrameInterpolator, and displays the positions that will be followed by the
+  frame() along the path:
+  \code
+  KeyFrameInterpolator kfi( new Frame() );
+  // calls to kfi.addKeyFrame() to define the path.
+
+  const float deltaTime = 0.04; // output a position every deltaTime seconds
+  for (float time=kfi.firstTime(); time&lt;=kfi.lastTime(); time += deltaTime)
+  {
+    kfi.interpolateAtTime(time);
+    cout &lt;&lt; &quot;t=&quot; &lt;&lt; time &lt;&lt; &quot;\tpos=&quot; &lt;&lt; kfi.frame()-&gt;position() &lt;&lt; endl;
+  }
+  \endcode
+  You may want to temporally disconnect the \c kfi interpolated() signal from the
+  QGLViewer::updateGL() slot before calling this code. \nosubgrouping */
+  class QGLVIEWER_EXPORT KeyFrameInterpolator : public QObject
+  {
+    // todo closedPath, insertKeyFrames, deleteKeyFrame, replaceKeyFrame
+    Q_OBJECT
+
+  public:
+    KeyFrameInterpolator(Frame* fr=NULL);
+    virtual ~KeyFrameInterpolator();
+
+  signals:
+    /*! This signal is emitted whenever the frame() state is interpolated.
+
+    The emission of this signal triggers the synchronous emission of the frame()
+    Frame::interpolated() signal, which may also be useful.
+
+    This signal should especially be connected to your QGLViewer::updateGL() slot, so that the display
+    is updated after every update of the KeyFrameInterpolator frame():
+    \code
+    connect(myKeyFrameInterpolator, SIGNAL(interpolated()), SLOT(updateGL()));
+    \endcode
+    Use the QGLViewer::QGLViewerPool() to connect the signal to all the viewers.
+
+    Note that the QGLViewer::camera() Camera::keyFrameInterpolator() created using QGLViewer::pathKey()
+    have their interpolated() signals automatically connected to the QGLViewer::updateGL() slot. */
+    void interpolated();
+
+    /*! This signal is emitted when the interpolation reaches the first (when interpolationSpeed()
+      is negative) or the last keyFrame.
+
+    When loopInterpolation() is \c true, interpolationTime() is reset and the interpolation
+    continues. It otherwise stops. */
+    void endReached();
+
+    /*! @name Path creation */
+    //@{
+  public slots:
+    void addKeyFrame(const Frame&amp; frame);
+    void addKeyFrame(const Frame&amp; frame, float time);
+
+    void addKeyFrame(const Frame* const frame);
+    void addKeyFrame(const Frame* const frame, float time);
+
+    void deletePath();
+    //@}
+
+    /*! @name Associated Frame */
+    //@{
+  public:
+    /*! Returns the associated Frame and that is interpolated by the KeyFrameInterpolator.
+
+    When interpolationIsStarted(), this Frame's position and orientation will regularly be updated
+    by a timer, so that they follow the KeyFrameInterpolator path.
+
+    Set using setFrame() or with the KeyFrameInterpolator constructor. */
+    Frame* frame() const { return frame_; };
+
+  public slots:
+    void setFrame(Frame* const frame);
+    //@}
+
+    /*! @name Path parameters */
+    //@{
+  public:
+    Frame keyFrame(int index) const;
+    float keyFrameTime(int index) const;
+    /*! Returns the number of keyFrames used by the interpolation. Use addKeyFrame() to add new keyFrames. */
+    int numberOfKeyFrames() const { return keyFrame_.count(); };
+    float duration() const;
+    float firstTime() const;
+    float lastTime() const;
+    //@}
+
+    /*! @name Interpolation parameters */
+    //@{
+  public:
+    /*! Returns the current interpolation time (in seconds) along the KeyFrameInterpolator path.
+
+    This time is regularly updated when interpolationIsStarted(). Can be set directly with
+    setInterpolationTime() or interpolateAtTime(). */
+    float interpolationTime() const { return interpolationTime_; };
+    /*! Returns the current interpolation speed.
+
+    Default value is 1.0, which means keyFrameTime() will be matched during the interpolation
+    (provided that your main loop is fast enough).
+
+    A negative value will result in a reverse interpolation of the keyFrames. See also
+    interpolationPeriod(). */
+    float interpolationSpeed() const { return interpolationSpeed_; };
+    /*! Returns the current interpolation period, expressed in milliseconds.
+
+    The update of the frame() state will be done by a timer at this period when
+    interpolationIsStarted().
+
+    This period (multiplied by interpolationSpeed()) is added to the interpolationTime() at each
+    update, and the frame() state is modified accordingly (see interpolateAtTime()). Default value
+    is 40 milliseconds. */
+    int interpolationPeriod() const { return period_; };
+    /*! Returns \c true when the interpolation is played in an infinite loop.
+
+    When \c false (default), the interpolation stops when interpolationTime() reaches firstTime()
+    (with negative interpolationSpeed()) or lastTime().
+
+    interpolationTime() is otherwise reset to firstTime() (+ interpolationTime() - lastTime()) (and
+    inversely for negative interpolationSpeed()) and interpolation continues.
+
+    In both cases, the endReached() signal is emitted. */
+    bool loopInterpolation() const { return loopInterpolation_; };
+#ifndef DOXYGEN
+    /*! Whether or not (default) the path defined by the keyFrames is a closed loop. When \c true,
+    the last and the first KeyFrame are linked by a new spline segment.
+
+    Use setLoopInterpolation() to create a continuous animation over the entire path.
+    \attention The closed path feature is not yet implemented. */
+    bool closedPath() const { return closedPath_; };
+#endif
+  public slots:
+    /*! Sets the interpolationTime().
+
+    \attention The frame() state is not affected by this method. Use this function to define the
+    starting time of a future interpolation (see startInterpolation()). Use interpolateAtTime() to
+    actually interpolate at a given time. */
+    void setInterpolationTime(float time) { interpolationTime_ = time; };
+    /*! Sets the interpolationSpeed(). Negative or null values are allowed. */
+    void setInterpolationSpeed(float speed) { interpolationSpeed_ = speed; };
+    /*! Sets the interpolationPeriod(). */
+    void setInterpolationPeriod(int period) { period_ = period; };
+    /*! Sets the loopInterpolation() value. */
+    void setLoopInterpolation(bool loop=true) { loopInterpolation_ = loop; };
+#ifndef DOXYGEN
+    /*! Sets the closedPath() value. \attention The closed path feature is not yet implemented. */
+    void setClosedPath(bool closed=true) { closedPath_ = closed; };
+#endif
+    //@}
+
+
+    /*! @name Interpolation */
+    //@{
+  public:
+    /*! Returns \c true when the interpolation is being performed. Use startInterpolation(),
+    stopInterpolation() or toggleInterpolation() to modify this state. */
+    bool interpolationIsStarted() const { return interpolationStarted_; };
+  public slots:
+    void startInterpolation(int period = -1);
+    void stopInterpolation();
+    void resetInterpolation();
+    /*! Calls startInterpolation() or stopInterpolation(), depending on interpolationIsStarted(). */
+    void toggleInterpolation() { if (interpolationIsStarted()) stopInterpolation(); else startInterpolation(); };
+    virtual void interpolateAtTime(float time);
+    //@}
+
+    /*! @name Path drawing */
+    //@{
+  public:
+    virtual void drawPath(int mask=1, int nbFrames=6, float scale=1.0f);
+    //@}
+
+    /*! @name XML representation */
+    //@{
+  public:
+    virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+    virtual void initFromDOMElement(const QDomElement&amp; element);
+    //@}
+
+  private slots:
+    virtual void update();
+    virtual void invalidateValues() { valuesAreValid_ = false; pathIsValid_ = false; splineCacheIsValid_ = false; };
+
+  private:
+    // Copy constructor and opertor= are declared private and undefined
+    // Prevents everyone from trying to use them
+    // KeyFrameInterpolator(const KeyFrameInterpolator&amp; kfi);
+    // KeyFrameInterpolator&amp; operator=(const KeyFrameInterpolator&amp; kfi);
+
+    void updateCurrentKeyFrameForTime(float time);
+    void updateModifiedFrameValues();
+    void updateSplineCache();
+
+#ifndef DOXYGEN
+    // Internal private KeyFrame representation
+    class KeyFrame
+    {
+    public:
+      KeyFrame(const Frame&amp; fr, float t);
+      KeyFrame(const Frame* fr, float t);
+
+      Vec position() const { return p_; }
+      Quaternion orientation() const { return q_; }
+      Vec tgP() const { return tgP_; }
+      Quaternion tgQ() const { return tgQ_; }
+      float time() const { return time_; }
+      const Frame* frame() const { return frame_; }
+      void updateValuesFromPointer();
+      void flipOrientationIfNeeded(const Quaternion&amp; prev);
+      void computeTangent(const KeyFrame* const prev, const KeyFrame* const next);
+    private:
+      Vec p_, tgP_;
+      Quaternion q_, tgQ_;
+      float time_;
+      const Frame* const frame_;
+    };
+#endif
+
+    // K e y F r a m e s
+#if QT_VERSION &gt;= 0x040000
+    mutable QList&lt;KeyFrame*&gt; keyFrame_;
+    QMutableListIterator&lt;KeyFrame*&gt;* currentFrame_[4];
+    QList&lt;Frame&gt; path_;
+#else
+    mutable QPtrList&lt;KeyFrame&gt; keyFrame_;
+    // 4 succesive frames. interpolationTime_ is between index 1 and 2.
+    QPtrListIterator&lt;KeyFrame&gt;* currentFrame_[4];
+# if QT_VERSION &gt;= 0x030000
+    // Cached path computed values (for drawPath()).
+    QValueVector&lt;Frame&gt; path_;
+# else
+    QVector&lt;Frame&gt; path_;
+# endif
+#endif
+
+    // A s s o c i a t e d   f r a m e
+    Frame* frame_;
+
+    // R h y t h m
+    QTimer timer_;
+    int period_;
+    float interpolationTime_;
+    float interpolationSpeed_;
+    bool interpolationStarted_;
+
+    // M i s c
+    bool closedPath_;
+    bool loopInterpolation_;
+
+    // C a c h e d   v a l u e s   a n d   f l a g s
+    bool pathIsValid_;
+    bool valuesAreValid_;
+    bool currentFrameValid_;
+    bool splineCacheIsValid_;
+    Vec v1, v2;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_KEY_FRAME_INTERPOLATOR_H

Added: trunk/lib/QGLViewer/manipulatedCameraFrame.cpp
===================================================================
--- trunk/lib/QGLViewer/manipulatedCameraFrame.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/manipulatedCameraFrame.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,444 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;manipulatedCameraFrame.h&quot;
+#include &quot;qglviewer.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QMouseEvent&gt;
+#endif
+
+using namespace qglviewer;
+using namespace std;
+
+/*! Default constructor.
+
+ flySpeed() is set to 0.0 and flyUpVector() is (0,1,0). The revolveAroundPoint() is set to (0,0,0).
+
+  \attention Created object is removeFromMouseGrabberPool(). */
+ManipulatedCameraFrame::ManipulatedCameraFrame()
+  : driveSpeed_(0.0), flyUpVector_(0.0, 1.0, 0.0)
+{
+  setFlySpeed(0.0);
+  removeFromMouseGrabberPool();
+
+  connect(&amp;flyTimer_, SIGNAL(timeout()), SLOT(flyUpdate()));
+}
+
+/*! Equal operator. Calls ManipulatedFrame::operator=() and then copy attributes. */
+ManipulatedCameraFrame&amp; ManipulatedCameraFrame::operator=(const ManipulatedCameraFrame&amp; mcf)
+{
+  ManipulatedFrame::operator=(mcf);
+
+  setFlySpeed(mcf.flySpeed());
+  setFlyUpVector(mcf.flyUpVector());
+
+  return *this;
+}
+
+/*! Copy constructor. Performs a deep copy of all members using operator=(). */
+ManipulatedCameraFrame::ManipulatedCameraFrame(const ManipulatedCameraFrame&amp; mcf)
+  : ManipulatedFrame(mcf)
+{
+  removeFromMouseGrabberPool();
+  connect(&amp;flyTimer_, SIGNAL(timeout()), SLOT(flyUpdate()));
+  (*this)=(mcf);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Overloading of ManipulatedFrame::spin().
+
+Rotates the ManipulatedCameraFrame around its revolveAroundPoint() instead of its origin. */
+void ManipulatedCameraFrame::spin()
+{
+  rotateAroundPoint(spinningQuaternion(), revolveAroundPoint());
+}
+
+#ifndef DOXYGEN
+/*! Called for continuous frame motion in fly mode (see QGLViewer::MOVE_FORWARD). Emits
+  manipulated(). */
+void ManipulatedCameraFrame::flyUpdate()
+{
+  static Vec flyDisp(0.0, 0.0, 0.0);
+  switch (action_)
+    {
+    case QGLViewer::MOVE_FORWARD:
+      flyDisp.z = -flySpeed();
+      translate(localInverseTransformOf(flyDisp));
+      break;
+    case QGLViewer::MOVE_BACKWARD:
+      flyDisp.z = flySpeed();
+      translate(localInverseTransformOf(flyDisp));
+      break;
+    case QGLViewer::DRIVE:
+      flyDisp.z = flySpeed() * driveSpeed_;
+      translate(localInverseTransformOf(flyDisp));
+      break;
+    default:
+      break;
+    }
+
+  // Needs to be out of the switch since ZOOM/fastDraw()/wheelEvent use this callback to trigger a final draw().
+  // #CONNECTION# wheelEvent.
+  emit manipulated();
+}
+#endif
+
+/*! This method will be called by the Camera when its orientation is changed, so that the
+flyUpVector (private) is changed accordingly. You should not need to call this method. */
+void ManipulatedCameraFrame::updateFlyUpVector()
+{
+  flyUpVector_ = inverseTransformOf(Vec(0.0, 1.0, 0.0));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//          S t a t e   s a v i n g   a n d   r e s t o r i n g               //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns an XML \c QDomElement that represents the ManipulatedCameraFrame.
+
+ Adds to the ManipulatedFrame::domElement() the ManipulatedCameraFrame specific informations in a \c
+ ManipulatedCameraParameters child QDomElement.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ Use initFromDOMElement() to restore the ManipulatedCameraFrame state from the resulting
+ \c QDomElement.
+
+ See Vec::domElement() for a complete example. See also Quaternion::domElement(),
+ Frame::domElement(), Camera::domElement()... */
+QDomElement ManipulatedCameraFrame::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement e = ManipulatedFrame::domElement(name, document);
+  QDomElement mcp = document.createElement(&quot;ManipulatedCameraParameters&quot;);
+  mcp.setAttribute(&quot;flySpeed&quot;, QString::number(flySpeed()));
+  mcp.appendChild(flyUpVector().domElement(&quot;flyUpVector&quot;, document));
+  e.appendChild(mcp);
+  return e;
+}
+
+/*! Restores the ManipulatedCameraFrame state from a \c QDomElement created by domElement().
+
+First calls ManipulatedFrame::initFromDOMElement() and then initializes ManipulatedCameraFrame
+specific parameters. */
+void ManipulatedCameraFrame::initFromDOMElement(const QDomElement&amp; element)
+{
+  // No need to initialize, since default flyUpVector and flySpeed are not meaningful.
+  // It's better to keep current ones. And it would destroy constraint() and referenceFrame().
+  // *this = ManipulatedCameraFrame();
+  ManipulatedFrame::initFromDOMElement(element);
+
+  QDomElement child=element.firstChild().toElement();
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;ManipulatedCameraParameters&quot;)
+	{
+	  setFlySpeed(DomUtils::floatFromDom(child, &quot;flySpeed&quot;, flySpeed()));
+
+	  QDomElement schild=child.firstChild().toElement();
+	  while (!schild.isNull())
+	    {
+	      if (schild.tagName() == &quot;flyUpVector&quot;)
+		setFlyUpVector(Vec(schild));
+
+	      schild = schild.nextSibling().toElement();
+	    }
+	}
+      child = child.nextSibling().toElement();
+    }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//                 M o u s e    h a n d l i n g                               //
+////////////////////////////////////////////////////////////////////////////////
+
+#ifndef DOXYGEN
+/*! Protected internal method used to handle mouse events. */
+void ManipulatedCameraFrame::startAction(int ma, bool withConstraint)
+{
+  ManipulatedFrame::startAction(ma, withConstraint);
+
+  switch (action_)
+    {
+    case QGLViewer::MOVE_FORWARD:
+    case QGLViewer::MOVE_BACKWARD:
+    case QGLViewer::DRIVE:
+#if QT_VERSION &gt;= 0x040000
+      flyTimer_.setSingleShot(false);
+#endif
+      flyTimer_.start(10);
+      break;
+    default:
+      break;
+    }
+}
+#endif
+
+/*! Overloading of ManipulatedFrame::mouseMoveEvent().
+
+Motion depends on mouse binding (see &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details). The
+resulting displacements are basically inverted from those of a ManipulatedFrame. */
+void ManipulatedCameraFrame::mouseMoveEvent(QMouseEvent* const event, Camera* const camera)
+{
+  // #CONNECTION# QGLViewer::mouseMoveEvent does the updateGL.
+  switch (action_)
+    {
+    case QGLViewer::TRANSLATE:
+      {
+	const QPoint delta = prevPos_ - event-&gt;pos();
+	Vec trans(static_cast&lt;float&gt;(delta.x()), static_cast&lt;float&gt;(-delta.y()), 0.0);
+	// Scale to fit the screen mouse displacement
+	switch (camera-&gt;type())
+	  {
+	  case Camera::PERSPECTIVE :
+	    trans *= 2.0 * tan(camera-&gt;fieldOfView()/2.0) *
+	      fabs((camera-&gt;frame()-&gt;coordinatesOf(revolveAroundPoint())).z) / camera-&gt;screenHeight();
+	    break;
+	  case Camera::ORTHOGRAPHIC :
+	    {
+	      GLdouble w,h;
+	      camera-&gt;getOrthoWidthHeight(w, h);
+	      trans[0] *= 2.0 * w / camera-&gt;screenWidth();
+	      trans[1] *= 2.0 * h / camera-&gt;screenHeight();
+	      break;
+	    }
+	  }
+	translate(inverseTransformOf(translationSensitivity()*trans));
+	break;
+      }
+
+    case QGLViewer::MOVE_FORWARD:
+      {
+	Quaternion rot = pitchYawQuaternion(event-&gt;x(), event-&gt;y(), camera);
+	rotate(rot);
+	//#CONNECTION# wheelEvent MOVE_FORWARD case
+	// actual translation is made in flyUpdate().
+	//translate(inverseTransformOf(Vec(0.0, 0.0, -flySpeed())));
+	break;
+      }
+
+    case QGLViewer::MOVE_BACKWARD:
+      {
+	Quaternion rot = pitchYawQuaternion(event-&gt;x(), event-&gt;y(), camera);
+	rotate(rot);
+	// actual translation is made in flyUpdate().
+	//translate(inverseTransformOf(Vec(0.0, 0.0, flySpeed())));
+	break;
+      }
+
+    case QGLViewer::DRIVE:
+      {
+	Quaternion rot = turnQuaternion(event-&gt;x(), camera);
+	rotate(rot);
+	// actual translation is made in flyUpdate().
+	driveSpeed_ = 0.01 * (event-&gt;y() - pressPos_.y());
+	break;
+      }
+
+    case QGLViewer::ZOOM:
+      {
+	//#CONNECTION# wheelEvent() ZOOM case
+	const float coef = qMax(fabsf((camera-&gt;frame()-&gt;coordinatesOf(camera-&gt;revolveAroundPoint())).z), 0.2f*camera-&gt;sceneRadius());
+	Vec trans(0.0, 0.0, -coef * (event-&gt;y() - prevPos_.y()) / camera-&gt;screenHeight());
+	translate(inverseTransformOf(trans));
+	break;
+      }
+
+    case QGLViewer::LOOK_AROUND:
+      {
+	Quaternion rot = pitchYawQuaternion(event-&gt;x(), event-&gt;y(), camera);
+	rotate(rot);
+	break;
+      }
+
+    case QGLViewer::ROTATE:
+      {
+	Vec trans = camera-&gt;projectedCoordinatesOf(revolveAroundPoint());
+	Quaternion rot = deformedBallQuaternion(event-&gt;x(), event-&gt;y(), trans[0], trans[1], camera);
+	//#CONNECTION# These two methods should go together (spinning detection and activation)
+	computeMouseSpeed(event);
+	setSpinningQuaternion(rot);
+	spin();
+	break;
+      }
+
+    case QGLViewer::SCREEN_ROTATE:
+      {
+	Vec trans = camera-&gt;projectedCoordinatesOf(revolveAroundPoint());
+
+	const float angle = atan2(event-&gt;y() - trans[1], event-&gt;x() - trans[0]) - atan2(prevPos_.y()-trans[1], prevPos_.x()-trans[0]);
+
+	Quaternion rot(Vec(0.0, 0.0, 1.0), angle);
+	//#CONNECTION# These two methods should go together (spinning detection and activation)
+	computeMouseSpeed(event);
+	setSpinningQuaternion(rot);
+	spin();
+	updateFlyUpVector();
+	break;
+      }
+
+    case QGLViewer::ROLL:
+      {
+	const float angle = M_PI * (event-&gt;x() - prevPos_.x()) / camera-&gt;screenWidth();
+	Quaternion rot(Vec(0.0, 0.0, 1.0), angle);
+	rotate(rot);
+	setSpinningQuaternion(rot);
+	updateFlyUpVector();
+	break;
+      }
+
+    case QGLViewer::SCREEN_TRANSLATE:
+      {
+	Vec trans;
+	int dir = mouseOriginalDirection(event);
+	if (dir == 1)
+	  trans.setValue(static_cast&lt;float&gt;(prevPos_.x() - event-&gt;x()), 0.0, 0.0);
+	else if (dir == -1)
+	  trans.setValue(0.0, static_cast&lt;float&gt;(event-&gt;y() - prevPos_.y()), 0.0);
+
+	switch (camera-&gt;type())
+	  {
+	  case Camera::PERSPECTIVE :
+	    trans *= 2.0 * tan(camera-&gt;fieldOfView()/2.0) *
+	      fabs((camera-&gt;frame()-&gt;coordinatesOf(revolveAroundPoint())).z) / camera-&gt;screenHeight();
+	    break;
+	  case Camera::ORTHOGRAPHIC :
+	    {
+	      GLdouble w,h;
+	      camera-&gt;getOrthoWidthHeight(w, h);
+	      trans[0] *= 2.0 * w / camera-&gt;screenWidth();
+	      trans[1] *= 2.0 * h / camera-&gt;screenHeight();
+	      break;
+	    }
+	  }
+
+	translate(inverseTransformOf(translationSensitivity()*trans));
+	break;
+      }
+
+    case QGLViewer::ZOOM_ON_REGION:
+    case QGLViewer::NO_MOUSE_ACTION:
+      break;
+    }
+
+  if (action_ != QGLViewer::NO_MOUSE_ACTION)
+    {
+      prevPos_ = event-&gt;pos();
+      if (action_ != QGLViewer::ZOOM_ON_REGION)
+	// ZOOM_ON_REGION should not emit manipulated().
+	// prevPos_ is used to draw rectangle feedback.
+	emit manipulated();
+    }
+}
+
+
+/*! This is an overload of ManipulatedFrame::mouseReleaseEvent(). The QGLViewer::MouseAction is
+  terminated. */
+void ManipulatedCameraFrame::mouseReleaseEvent(QMouseEvent* const event, Camera* const camera)
+{
+  if ((action_ == QGLViewer::MOVE_FORWARD) || (action_ == QGLViewer::MOVE_BACKWARD) || (action_ == QGLViewer::DRIVE))
+    flyTimer_.stop();
+
+  if (action_ == QGLViewer::ZOOM_ON_REGION)
+    camera-&gt;fitScreenRegion(QRect(pressPos_, event-&gt;pos()));
+
+  ManipulatedFrame::mouseReleaseEvent(event, camera);
+}
+
+/*! This is an overload of ManipulatedFrame::wheelEvent().
+
+The wheel behavior depends on the wheel binded action. Current possible actions are QGLViewer::ZOOM,
+QGLViewer::MOVE_FORWARD, QGLViewer::MOVE_BACKWARD. QGLViewer::ZOOM speed depends on
+wheelSensitivity() while QGLViewer::MOVE_FORWARD and QGLViewer::MOVE_BACKWARD depend on flySpeed().
+See QGLViewer::setWheelBinding() to customize the binding. */
+void ManipulatedCameraFrame::wheelEvent(QWheelEvent* const event, Camera* const camera)
+{
+  //#CONNECTION# QGLViewer::setWheelBinding, ManipulatedFrame::wheelEvent.
+  switch (action_)
+    {
+    case QGLViewer::ZOOM:
+      {
+	const float wheelSensitivityCoef = 8E-4f;
+	//#CONNECTION# mouseMoveEvent() ZOOM case
+       	const float coef = qMax(fabsf((camera-&gt;frame()-&gt;coordinatesOf(camera-&gt;revolveAroundPoint())).z), 0.2f*camera-&gt;sceneRadius());
+	Vec trans(0.0, 0.0, coef * event-&gt;delta() * wheelSensitivity() * wheelSensitivityCoef);
+	translate(inverseTransformOf(trans));
+	emit manipulated();
+	break;
+      }
+    case QGLViewer::MOVE_FORWARD:
+    case QGLViewer::MOVE_BACKWARD:
+      //#CONNECTION# mouseMoveEvent() MOVE_FORWARD case
+      translate(inverseTransformOf(Vec(0.0, 0.0, 0.2*flySpeed()*event-&gt;delta())));
+      emit manipulated();
+      break;
+    default:
+      break;
+    }
+
+  // #CONNECTION# startAction should always be called before
+  if (previousConstraint_)
+    setConstraint(previousConstraint_);
+
+  // The wheel triggers a fastDraw. A final updateGL is needed after the last wheel event to
+  // polish the rendering using draw(). Since the last wheel event does not say its name, we use
+  // the flyTimer_ to trigger flyUpdate(), which emits manipulated. Two wheel events
+  // separated by more than this delay milliseconds will trigger a draw().
+  const int finalDrawAfterWheelEventDelay = 400;
+
+  // Starts (or prolungates) the timer.
+#if QT_VERSION &gt;= 0x040000
+  flyTimer_.setSingleShot(true);
+  flyTimer_.start(finalDrawAfterWheelEventDelay);
+#else
+  flyTimer_.start(finalDrawAfterWheelEventDelay, true);
+#endif
+
+  // This could also be done *before* manipulated is emitted, so that isManipulated() returns false.
+  // But then fastDraw would not be used with wheel.
+  // Detecting the last wheel event and forcing a final draw() is done using the timer_.
+  action_ = QGLViewer::NO_MOUSE_ACTION;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns a Quaternion that is a rotation around current camera Y, proportionnal to the horizontal mouse position. */
+Quaternion ManipulatedCameraFrame::turnQuaternion(int x, const Camera* const camera)
+{
+  return Quaternion(Vec(0.0, 1.0, 0.0), rotationSensitivity()*(prevPos_.x()-x)/camera-&gt;screenWidth());
+}
+
+/*! Returns a Quaternion that is the composition of two rotations, inferred from the
+  mouse pitch (X axis) and yaw (flyUpVector() axis). */
+Quaternion ManipulatedCameraFrame::pitchYawQuaternion(int x, int y, const Camera* const camera)
+{
+  const Quaternion rotX(Vec(1.0, 0.0, 0.0), rotationSensitivity()*(prevPos_.y()-y)/camera-&gt;screenHeight());
+  const Quaternion rotY(transformOf(flyUpVector()), rotationSensitivity()*(prevPos_.x()-x)/camera-&gt;screenWidth());
+  return rotY * rotX;
+}

Added: trunk/lib/QGLViewer/manipulatedCameraFrame.h
===================================================================
--- trunk/lib/QGLViewer/manipulatedCameraFrame.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/manipulatedCameraFrame.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,169 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_MANIPULATED_CAMERA_FRAME_H
+#define QGLVIEWER_MANIPULATED_CAMERA_FRAME_H
+
+#include &quot;manipulatedFrame.h&quot;
+
+namespace qglviewer {
+  /*! \brief The ManipulatedCameraFrame class represents a ManipulatedFrame with Camera specific mouse bindings.
+  \class ManipulatedCameraFrame manipulatedCameraFrame.h QGLViewer/manipulatedCameraFrame.h
+
+  A ManipulatedCameraFrame is a specialization of a ManipulatedFrame, designed to be set as the
+  Camera::frame(). Mouse motions are basically interpreted in a negated way: when the mouse goes to
+  the right, the ManipulatedFrame translation goes to the right, while the ManipulatedCameraFrame
+  has to go to the \e left, so that the \e scene seems to move to the right.
+
+  A ManipulatedCameraFrame rotates around its revolveAroundPoint(), which corresponds to the
+  associated Camera::revolveAroundPoint().
+
+  A ManipulatedCameraFrame can also &quot;fly&quot; in the scene. It basically moves forward, and turns
+  according to the mouse motion. See flySpeed(), flyUpVector() and the QGLViewer::MOVE_FORWARD and
+  QGLViewer::MOVE_BACKWARD QGLViewer::MouseAction.
+
+  See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for a description of the possible actions that can
+  be performed using the mouse and their bindings.
+  \nosubgrouping */
+  class QGLVIEWER_EXPORT ManipulatedCameraFrame : public ManipulatedFrame
+  {
+#ifndef DOXYGEN
+    friend class Camera;
+    friend class ::QGLViewer;
+#endif
+
+    Q_OBJECT
+
+  public:
+    ManipulatedCameraFrame();
+    /*! Virtual destructor. Empty. */
+    virtual ~ManipulatedCameraFrame() {};
+
+    ManipulatedCameraFrame(const ManipulatedCameraFrame&amp; mcf);
+    ManipulatedCameraFrame&amp; operator=(const ManipulatedCameraFrame&amp; mcf);
+
+    /*! @name Revolve around point */
+    //@{
+  public:
+    /*! Returns the point the ManipulatedCameraFrame revolves around when rotated.
+
+    It is defined in the world coordinate system. Default value is (0,0,0).
+
+    When the ManipulatedCameraFrame is associated to a Camera, Camera::revolveAroundPoint() also
+    returns this value. This point can interactively be changed using the mouse (see
+    QGLViewer::RAP_FROM_PIXEL and QGLViewer::RAP_IS_CENTER in the &lt;a href=&quot;../mouse.html&quot;&gt;mouse
+    page&lt;/a&gt;). */
+    Vec revolveAroundPoint() const { return revolveAroundPoint_; }
+    /*! Sets the revolveAroundPoint(), defined in the world coordinate system. */
+    void setRevolveAroundPoint(const Vec&amp; revolveAroundPoint) { revolveAroundPoint_ = revolveAroundPoint; }
+    //@}
+
+    /*! @name Fly parameters */
+    //@{
+  public slots:
+    /*! Sets the flySpeed(), defined in OpenGL units.
+
+    Default value is 0.0, but it is modified according to the QGLViewer::sceneRadius() when the
+    ManipulatedCameraFrame is set as the Camera::frame(). */
+    void setFlySpeed(float speed) { flySpeed_ = speed; };
+
+    /*! Sets the flyUpVector(), defined in the world coordinate system.
+
+    Default value is (0,1,0), but it is updated by the Camera when set as its Camera::frame(). Use
+    Camera::setUpVector() instead in that case. */
+    void setFlyUpVector(const Vec&amp; up) { flyUpVector_ = up; };
+
+  public:
+    /*! Returns the fly speed, expressed in OpenGL units.
+
+    It corresponds to the incremental displacement that is periodically applied to the
+    ManipulatedCameraFrame position when a QGLViewer::MOVE_FORWARD or QGLViewer::MOVE_BACKWARD
+    QGLViewer::MouseAction is proceeded.
+
+    \attention When the ManipulatedCameraFrame is set as the Camera::frame(), this value is set
+    according to the QGLViewer::sceneRadius() by QGLViewer::setSceneRadius(). */
+    float flySpeed() const { return flySpeed_; };
+
+    /*! Returns the up vector used in fly mode, expressed in the world coordinate system.
+
+    Fly mode corresponds to the QGLViewer::MOVE_FORWARD and QGLViewer::MOVE_BACKWARD
+    QGLViewer::MouseAction bindings. In these modes, horizontal displacements of the mouse rotate
+    the ManipulatedCameraFrame around this vector. Vertical displacements rotate always around the
+    Camera \c X axis.
+
+    Default value is (0,1,0), but it is updated by the Camera when set as its Camera::frame().
+    Camera::setOrientation() and Camera::setUpVector()) modify this value and should be used
+    instead. */
+    Vec flyUpVector() const { return flyUpVector_; };
+    //@}
+
+    /*! @name Mouse event handlers */
+    //@{
+  protected:
+    virtual void mouseReleaseEvent(QMouseEvent* const event, Camera* const camera);
+    virtual void mouseMoveEvent   (QMouseEvent* const event, Camera* const camera);
+    virtual void wheelEvent       (QWheelEvent* const event, Camera* const camera);
+    //@}
+
+    /*! @name Spinning */
+    //@{
+  protected slots:
+    virtual void spin();
+    //@}
+
+    /*! @name XML representation */
+    //@{
+  public:
+    virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  public slots:
+    virtual void initFromDOMElement(const QDomElement&amp; element);
+    //@}
+
+#ifndef DOXYGEN
+  protected:
+    virtual void startAction(int ma, bool withConstraint=true); // int is really a QGLViewer::MouseAction
+#endif
+
+  private slots:
+    virtual void flyUpdate();
+
+  private:
+    void updateFlyUpVector();
+    Quaternion turnQuaternion(int x, const Camera* const camera);
+    Quaternion pitchYawQuaternion(int x, int y, const Camera* const camera);
+
+  private:
+    // Fly mode data
+    float flySpeed_;
+    float driveSpeed_;
+    Vec flyUpVector_;
+    QTimer flyTimer_;
+
+    Vec revolveAroundPoint_;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_MANIPULATED_CAMERA_FRAME_H

Added: trunk/lib/QGLViewer/manipulatedFrame.cpp
===================================================================
--- trunk/lib/QGLViewer/manipulatedFrame.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/manipulatedFrame.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,534 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;manipulatedFrame.h&quot;
+#include &quot;qglviewer.h&quot;
+#include &quot;camera.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QMouseEvent&gt;
+#endif
+
+using namespace qglviewer;
+using namespace std;
+
+/*! Default constructor.
+
+  The translation is set to (0,0,0), with an identity rotation (0,0,0,1) (see Frame constructor
+  for details).
+
+  The different sensitivities are set to their default values (see rotationSensitivity(),
+  translationSensitivity(), spinningSensitivity() and wheelSensitivity()). */
+ManipulatedFrame::ManipulatedFrame()
+  : action_(QGLViewer::NO_MOUSE_ACTION), keepsGrabbingMouse_(false)
+{
+  // #CONNECTION# initFromDOMElement and accessor docs
+  setRotationSensitivity(1.0f);
+  setTranslationSensitivity(1.0f);
+  setSpinningSensitivity(0.3f);
+  setWheelSensitivity(1.0f);
+
+  isSpinning_ = false;
+  previousConstraint_ = false;
+
+  connect(&amp;spinningTimer_, SIGNAL(timeout()), SLOT(spinUpdate()));
+}
+
+/*! Equal operator. Calls Frame::operator=() and then copy attributes. */
+ManipulatedFrame&amp; ManipulatedFrame::operator=(const ManipulatedFrame&amp; mf)
+{
+  Frame::operator=(mf);
+
+  setRotationSensitivity(mf.rotationSensitivity());
+  setTranslationSensitivity(mf.translationSensitivity());
+  setSpinningSensitivity(mf.spinningSensitivity());
+  setWheelSensitivity(mf.wheelSensitivity());
+
+  mouseSpeed_ = 0.0;
+  dirIsFixed_ = false;
+  keepsGrabbingMouse_ = false;
+
+  return *this;
+}
+
+/*! Copy constructor. Performs a deep copy of all attributes using operator=(). */
+ManipulatedFrame::ManipulatedFrame(const ManipulatedFrame&amp; mf)
+  : Frame(mf), MouseGrabber()
+{
+  (*this)=mf;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Implementation of the MouseGrabber main method.
+
+The ManipulatedFrame grabsMouse() when the mouse is within a 10 pixels region around its
+Camera::projectedCoordinatesOf() position().
+
+See the &lt;a href=&quot;../examples/mouseGrabber.html&quot;&gt;mouseGrabber example&lt;/a&gt; for an illustration. */
+void ManipulatedFrame::checkIfGrabsMouse(int x, int y, const Camera* const camera)
+{
+  const int thresold = 10;
+  const Vec proj = camera-&gt;projectedCoordinatesOf(position());
+  setGrabsMouse(keepsGrabbingMouse_ || ((fabs(x-proj.x) &lt; thresold) &amp;&amp; (fabs(y-proj.y) &lt; thresold)));
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//          S t a t e   s a v i n g   a n d   r e s t o r i n g               //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns an XML \c QDomElement that represents the ManipulatedFrame.
+
+ Adds to the Frame::domElement() the ManipulatedFrame specific informations in a \c
+ ManipulatedParameters child QDomElement.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ Use initFromDOMElement() to restore the ManipulatedFrame state from the resulting \c QDomElement.
+
+ See Vec::domElement() for a complete example. See also Quaternion::domElement(),
+ Camera::domElement()... */
+QDomElement ManipulatedFrame::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement e = Frame::domElement(name, document);
+  QDomElement mp = document.createElement(&quot;ManipulatedParameters&quot;);
+  mp.setAttribute(&quot;rotSens&quot;, QString::number(rotationSensitivity()));
+  mp.setAttribute(&quot;transSens&quot;, QString::number(translationSensitivity()));
+  mp.setAttribute(&quot;spinSens&quot;, QString::number(spinningSensitivity()));
+  mp.setAttribute(&quot;wheelSens&quot;, QString::number(wheelSensitivity()));
+  e.appendChild(mp);
+  return e;
+}
+
+/*! Restores the ManipulatedFrame state from a \c QDomElement created by domElement().
+
+Fields that are not described in \p element are set to their default values (see
+ManipulatedFrame()).
+
+First calls Frame::initFromDOMElement() and then initializes ManipulatedFrame specific parameters.
+Note that constraint() and referenceFrame() are not restored and are left unchanged.
+
+See Vec::initFromDOMElement() for a complete code example. */
+void ManipulatedFrame::initFromDOMElement(const QDomElement&amp; element)
+{
+  // Not called since it would set constraint() and referenceFrame() to NULL.
+  // *this = ManipulatedFrame();
+  Frame::initFromDOMElement(element);
+
+  stopSpinning();
+
+  QDomElement child=element.firstChild().toElement();
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;ManipulatedParameters&quot;)
+	{
+	  // #CONNECTION# constructor default values and accessor docs
+	  setRotationSensitivity   (DomUtils::floatFromDom(child, &quot;rotSens&quot;,   1.0f));
+	  setTranslationSensitivity(DomUtils::floatFromDom(child, &quot;transSens&quot;, 1.0f));
+	  setSpinningSensitivity   (DomUtils::floatFromDom(child, &quot;spinSens&quot;,  0.3f));
+	  setWheelSensitivity      (DomUtils::floatFromDom(child, &quot;wheelSens&quot;, 1.0f));
+	}
+      child = child.nextSibling().toElement();
+    }
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+//                 M o u s e    h a n d l i n g                               //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns \c true when the ManipulatedFrame is being manipulated with the mouse.
+
+  Can be used to change the display of the manipulated object during manipulation.
+
+  When Camera::frame() of the QGLViewer::camera() isManipulated(), QGLViewer::fastDraw() is used in
+  place of QGLViewer::draw() for scene rendering. A simplified drawing will then allow for
+  interactive camera displacements.  */
+bool ManipulatedFrame::isManipulated() const
+{
+  return action_ != QGLViewer::NO_MOUSE_ACTION;
+}
+
+/*! Starts the spinning of the ManipulatedFrame.
+
+This method starts a timer that will call spin() every \p updateInterval milliseconds. The
+ManipulatedFrame isSpinning() until you call stopSpinning(). */
+void ManipulatedFrame::startSpinning(int updateInterval)
+{
+  isSpinning_ = true;
+  spinningTimer_.start(updateInterval);
+}
+
+/*! Rotates the ManipulatedFrame by its spinningQuaternion(). Called by a timer when the
+  ManipulatedFrame isSpinning(). */
+void ManipulatedFrame::spin()
+{
+  rotate(spinningQuaternion());
+}
+
+/* spin() and spinUpdate() differ since spin can be used by itself (for instance by
+   QGLViewer::SCREEN_ROTATE) without a spun emission. Much nicer to use the spinningQuaternion() and
+   hence spin() for these incremental updates. Nothing special to be done for continuous spinning
+   with this design. */
+void ManipulatedFrame::spinUpdate()
+{
+  spin();
+  emit spun();
+}
+
+#ifndef DOXYGEN
+/*! Protected internal method used to handle mouse events. */
+void ManipulatedFrame::startAction(int ma, bool withConstraint)
+{
+  action_ = (QGLViewer::MouseAction)(ma);
+
+  // #CONNECTION# manipulatedFrame::wheelEvent, manipulatedCameraFrame::wheelEvent and mouseReleaseEvent()
+  // restore previous constraint
+  if (withConstraint)
+    previousConstraint_ = NULL;
+  else
+    {
+      previousConstraint_ = constraint();
+      setConstraint(NULL);
+    }
+
+  switch (action_)
+    {
+    case QGLViewer::ROTATE:
+    case QGLViewer::SCREEN_ROTATE:
+      mouseSpeed_ = 0.0;
+      stopSpinning();
+      break;
+
+    case QGLViewer::SCREEN_TRANSLATE:
+      dirIsFixed_ = false;
+      break;
+
+    default:
+      break;
+    }
+}
+
+/*! Updates mouse speed, measured in pixels/milliseconds. Should be called by any method which wants to
+use mouse speed. Currently used to trigger spinning in mouseReleaseEvent(). */
+void ManipulatedFrame::computeMouseSpeed(const QMouseEvent* const e)
+{
+  const QPoint delta = (e-&gt;pos() - prevPos_);
+  const float dist = sqrt(static_cast&lt;float&gt;(delta.x()*delta.x() + delta.y()*delta.y()));
+  delay_ = last_move_time.restart();
+  if (delay_ == 0)
+    // Less than a millisecond: assume delay = 1ms
+    mouseSpeed_ = dist;
+  else
+    mouseSpeed_ = dist/delay_;
+}
+
+/*! Return 1 if mouse motion was started horizontally and -1 if it was more vertical. Returns 0 if
+this could not be determined yet (perfect diagonal motion, rare). */
+int ManipulatedFrame::mouseOriginalDirection(const QMouseEvent* const e)
+{
+  static bool horiz = true; // Two simultaneous manipulatedFrame require two mice !
+
+  if (!dirIsFixed_)
+    {
+      const QPoint delta = e-&gt;pos() - pressPos_;
+      dirIsFixed_ = abs(delta.x()) != abs(delta.y());
+      horiz = abs(delta.x()) &gt; abs(delta.y());
+    }
+
+  if (dirIsFixed_)
+    if (horiz)
+      return 1;
+    else
+      return -1;
+  else
+    return 0;
+}
+#endif // DOXYGEN
+
+/*! Initiates the ManipulatedFrame mouse manipulation.
+
+Overloading of MouseGrabber::mousePressEvent(). See also mouseMoveEvent() and mouseReleaseEvent().
+
+The mouse behavior depends on which button is pressed. See the &lt;a href=&quot;../mouse.html&quot;&gt;QGLViewer
+mouse page&lt;/a&gt; for details. */
+void ManipulatedFrame::mousePressEvent(QMouseEvent* const event, Camera* const camera)
+{
+  Q_UNUSED(camera);
+
+  if (grabsMouse())
+    keepsGrabbingMouse_ = true;
+
+  // #CONNECTION setMouseBinding
+  // action_ should no longer possibly be NO_MOUSE_ACTION since this value is not inserted in mouseBinding_
+  //#if QT_VERSION &gt;= 0x030000
+  //if (action_ == QGLViewer::NO_MOUSE_ACTION)
+  //event-&gt;ignore();
+  //#endif
+
+  prevPos_ = pressPos_ = event-&gt;pos();
+}
+
+/*! Modifies the ManipulatedFrame according to the mouse motion.
+
+Actual behavior depends on mouse bindings. See the QGLViewer::MouseAction enum and the &lt;a
+href=&quot;../mouse.html&quot;&gt;QGLViewer mouse page&lt;/a&gt; for details.
+
+The \p camera is used to fit the mouse motion with the display parameters (see
+Camera::screenWidth(), Camera::screenHeight(), Camera::fieldOfView()).
+
+Emits the manipulated() signal. */
+void ManipulatedFrame::mouseMoveEvent(QMouseEvent* const event, Camera* const camera)
+{
+  switch (action_)
+    {
+    case QGLViewer::TRANSLATE:
+      {
+	const QPoint delta = event-&gt;pos() - prevPos_;
+	Vec trans(static_cast&lt;float&gt;(delta.x()), static_cast&lt;float&gt;(-delta.y()), 0.0);
+	// Scale to fit the screen mouse displacement
+	switch (camera-&gt;type())
+	  {
+	  case Camera::PERSPECTIVE :
+	    trans *= 2.0 * tan(camera-&gt;fieldOfView()/2.0) * fabs((camera-&gt;frame()-&gt;coordinatesOf(position())).z) / camera-&gt;screenHeight();
+	    break;
+	  case Camera::ORTHOGRAPHIC :
+	    {
+	      GLdouble w,h;
+	      camera-&gt;getOrthoWidthHeight(w, h);
+	      trans[0] *= 2.0 * w / camera-&gt;screenWidth();
+	      trans[1] *= 2.0 * h / camera-&gt;screenHeight();
+	      break;
+	    }
+	  }
+	// Transform to world coordinate system.
+	trans = camera-&gt;frame()-&gt;orientation().rotate(translationSensitivity()*trans);
+	// And then down to frame
+	if (referenceFrame()) trans = referenceFrame()-&gt;transformOf(trans);
+	translate(trans);
+	break;
+      }
+
+    case QGLViewer::ZOOM:
+      {
+	//#CONNECTION# wheelEvent ZOOM case
+	Vec trans(0.0, 0.0, (camera-&gt;position()-position()).norm() * (event-&gt;y() - prevPos_.y()) / camera-&gt;screenHeight());
+
+	trans = camera-&gt;frame()-&gt;orientation().rotate(trans);
+	if (referenceFrame())
+	  trans = referenceFrame()-&gt;transformOf(trans);
+	translate(trans);
+	break;
+      }
+
+    case QGLViewer::SCREEN_ROTATE:
+      {
+	Vec trans = camera-&gt;projectedCoordinatesOf(position());
+
+	const double prev_angle = atan2(prevPos_.y()-trans[1], prevPos_.x()-trans[0]);
+	const double      angle = atan2(event-&gt;y()-trans[1], event-&gt;x()-trans[0]);
+
+	const Vec axis = transformOf(camera-&gt;frame()-&gt;inverseTransformOf(Vec(0.0, 0.0, -1.0)));
+	Quaternion rot(axis, angle-prev_angle);
+	//#CONNECTION# These two methods should go together (spinning detection and activation)
+	computeMouseSpeed(event);
+	setSpinningQuaternion(rot);
+	spin();
+	break;
+      }
+
+    case QGLViewer::SCREEN_TRANSLATE:
+      {
+	Vec trans;
+	int dir = mouseOriginalDirection(event);
+	if (dir == 1)
+	  trans.setValue(static_cast&lt;float&gt;(event-&gt;x() - prevPos_.x()), 0.0, 0.0);
+	else if (dir == -1)
+	  trans.setValue(0.0, static_cast&lt;float&gt;(prevPos_.y() - event-&gt;y()), 0.0);
+
+	switch (camera-&gt;type())
+	  {
+	  case Camera::PERSPECTIVE :
+	    trans *= 2.0 * tan(camera-&gt;fieldOfView()/2.0) * fabs((camera-&gt;frame()-&gt;coordinatesOf(position())).z) / camera-&gt;screenHeight();
+	    break;
+	  case Camera::ORTHOGRAPHIC :
+	    {
+	      GLdouble w,h;
+	      camera-&gt;getOrthoWidthHeight(w, h);
+	      trans[0] *= 2.0 * w / camera-&gt;screenWidth();
+	      trans[1] *= 2.0 * h / camera-&gt;screenHeight();
+	      break;
+	    }
+	  }
+	// Transform to world coordinate system.
+	trans = camera-&gt;frame()-&gt;orientation().rotate(translationSensitivity()*trans);
+	// And then down to frame
+	if (referenceFrame())
+	  trans = referenceFrame()-&gt;transformOf(trans);
+
+	translate(trans);
+	break;
+      }
+
+    case QGLViewer::ROTATE:
+      {
+	Vec trans = camera-&gt;projectedCoordinatesOf(position());
+	Quaternion rot = deformedBallQuaternion(event-&gt;x(), event-&gt;y(), trans[0], trans[1], camera);
+	trans = Vec(-rot[0], -rot[1], -rot[2]);
+	trans = camera-&gt;frame()-&gt;orientation().rotate(trans);
+	trans = transformOf(trans);
+	rot[0] = trans[0];
+	rot[1] = trans[1];
+	rot[2] = trans[2];
+	//#CONNECTION# These two methods should go together (spinning detection and activation)
+	computeMouseSpeed(event);
+	setSpinningQuaternion(rot);
+	spin();
+	break;
+      }
+
+    case QGLViewer::NO_MOUSE_ACTION:
+      // Possible when the ManipulatedFrame is a MouseGrabber. This method is then called without startAction
+      // because of mouseTracking.
+      break;
+    }
+
+  if (action_ != QGLViewer::NO_MOUSE_ACTION)
+    {
+      prevPos_ = event-&gt;pos();
+      emit manipulated();
+    }
+}
+
+/*! Stops the ManipulatedFrame mouse manipulation.
+
+Overloading of MouseGrabber::mouseReleaseEvent().
+
+If the action was a QGLViewer::ROTATE QGLViewer::MouseAction, a continuous spinning is possible if
+the speed of the mouse cursor is larger than spinningSensitivity() when the button is released.
+Press the rotate button again to stop spinning. See startSpinning() and isSpinning(). */
+void ManipulatedFrame::mouseReleaseEvent(QMouseEvent* const event, Camera* const camera)
+{
+  Q_UNUSED(event);
+  Q_UNUSED(camera);
+
+  keepsGrabbingMouse_ = false;
+
+  if (previousConstraint_)
+    setConstraint(previousConstraint_);
+
+  if (((action_ == QGLViewer::ROTATE) || (action_ == QGLViewer::SCREEN_ROTATE)) &amp;&amp; (mouseSpeed_ &gt;= spinningSensitivity()))
+    startSpinning(delay_);
+
+  action_ = QGLViewer::NO_MOUSE_ACTION;
+}
+
+/*! Overloading of MouseGrabber::mouseDoubleClickEvent().
+
+Left button double click aligns the ManipulatedFrame with the \p camera axis (see alignWithFrame()
+ and QGLViewer::ALIGN_FRAME). Right button projects the ManipulatedFrame on the \p camera view
+ direction. */
+void ManipulatedFrame::mouseDoubleClickEvent(QMouseEvent* const event, Camera* const camera)
+{
+#if QT_VERSION &gt;= 0x040000
+  if (event-&gt;modifiers() == Qt::NoModifier)
+#else
+  if (event-&gt;state() == Qt::NoButton)
+#endif
+    switch (event-&gt;button())
+      {
+      case Qt::LeftButton:  alignWithFrame(camera-&gt;frame()); break;
+      case Qt::RightButton: projectOnLine(camera-&gt;position(), camera-&gt;viewDirection()); break;
+      default: break;
+      }
+}
+
+/*! Overloading of MouseGrabber::wheelEvent().
+
+Using the wheel is equivalent to a QGLViewer::ZOOM QGLViewer::MouseAction. See
+ QGLViewer::setWheelBinding() and setWheelSensitivity(). */
+void ManipulatedFrame::wheelEvent(QWheelEvent* const event, Camera* const camera)
+{
+  //#CONNECTION# QGLViewer::setWheelBinding
+  if (action_ == QGLViewer::ZOOM)
+    {
+      const float wheelSensitivityCoef = 8E-4f;
+      Vec trans(0.0, 0.0, -event-&gt;delta()*wheelSensitivity()*wheelSensitivityCoef*(camera-&gt;position()-position()).norm());
+
+      //#CONNECTION# Cut-pasted from the mouseMoveEvent ZOOM case
+      trans = camera-&gt;frame()-&gt;orientation().rotate(trans);
+      if (referenceFrame())
+	trans = referenceFrame()-&gt;transformOf(trans);
+      translate(trans);
+      emit manipulated();
+    }
+
+  // #CONNECTION# startAction should always be called before
+  if (previousConstraint_)
+    setConstraint(previousConstraint_);
+
+  action_ = QGLViewer::NO_MOUSE_ACTION;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Returns &quot;pseudo-distance&quot; from (x,y) to ball of radius size.
+\arg for a point inside the ball, it is proportional to the euclidean distance to the ball
+\arg for a point outside the ball, it is proportional to the inverse of this distance (tends to
+zero) on the ball, the function is continuous. */
+static float projectOnBall(float x, float y)
+{
+  // If you change the size value, change angle computation in deformedBallQuaternion().
+  const float size       = 1.0f;
+  const float size2      = size*size;
+  const float size_limit = size2*0.5;
+
+  const float d = x*x + y*y;
+  return d &lt; size_limit ? sqrt(size2 - d) : size_limit/sqrt(d);
+}
+
+#ifndef DOXYGEN
+/*! Returns a quaternion computed according to the mouse motion. Mouse positions are projected on a
+deformed ball, centered on (\p cx,\p cy). */
+Quaternion ManipulatedFrame::deformedBallQuaternion(int x, int y, float cx, float cy, const Camera* const camera)
+{
+  // Points on the deformed ball
+  float px = rotationSensitivity() * (prevPos_.x()  - cx) / camera-&gt;screenWidth();
+  float py = rotationSensitivity() * (cy - prevPos_.y())  / camera-&gt;screenHeight();
+  float dx = rotationSensitivity() * (x - cx)	    / camera-&gt;screenWidth();
+  float dy = rotationSensitivity() * (cy - y)	    / camera-&gt;screenHeight();
+
+  const Vec p1(px, py, projectOnBall(px, py));
+  const Vec p2(dx, dy, projectOnBall(dx, dy));
+  // Approximation of rotation angle
+  // Should be divided by the projectOnBall size, but it is 1.0
+  const Vec axis = cross(p2,p1);
+  const float angle = 2.0 * asin(sqrt(axis.squaredNorm() / p1.squaredNorm() / p2.squaredNorm()));
+  return Quaternion(axis, angle);
+}
+#endif // DOXYGEN

Added: trunk/lib/QGLViewer/manipulatedFrame.h
===================================================================
--- trunk/lib/QGLViewer/manipulatedFrame.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/manipulatedFrame.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,311 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_MANIPULATED_FRAME_H
+#define QGLVIEWER_MANIPULATED_FRAME_H
+
+#include &quot;frame.h&quot;
+#include &quot;mouseGrabber.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QString&gt;
+# include &lt;QTimer&gt;
+# include &lt;QDateTime&gt;
+#else
+# include &lt;qstring.h&gt;
+# include &lt;qtimer.h&gt;
+# include &lt;qdatetime.h&gt;
+#endif
+
+namespace qglviewer {
+  /*! \brief A ManipulatedFrame is a Frame that can be rotated and translated using the mouse.
+  \class ManipulatedFrame manipulatedFrame.h QGLViewer/manipulatedFrame.h
+
+  It converts the mouse motion into a translation and an orientation updates. A ManipulatedFrame is
+  used to move an object in the scene. Combined with object selection, its MouseGrabber properties
+  and a dynamic update of the scene, the ManipulatedFrame introduces a great reactivity in your
+  applications.
+
+  A ManipulatedFrame is attached to a QGLViewer using QGLViewer::setManipulatedFrame():
+  \code
+  init() { setManipulatedFrame( new ManipulatedFrame() ); }
+
+  draw()
+  {
+    glPushMatrix();
+    glMultMatrixd(manipulatedFrame()-&gt;matrix());
+    // draw the manipulated object here
+    glPopMatrix();
+  }
+  \endcode
+  See the &lt;a href=&quot;../examples/manipulatedFrame.html&quot;&gt;manipulatedFrame example&lt;/a&gt; for a complete
+  application.
+
+  Mouse events are normally sent to the QGLViewer::camera(). You have to press the QGLViewer::FRAME
+  state key (default is \c Control) to move the QGLViewer::manipulatedFrame() instead. See the &lt;a
+  href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for a description of mouse button bindings.
+
+  &lt;h3&gt;Inherited functionalities&lt;/h3&gt;
+
+  A ManipulatedFrame is an overloaded instance of a Frame. The powerful coordinate system
+  transformation functions (Frame::coordinatesOf(), Frame::transformOf(), ...) can hence be applied
+  to a ManipulatedFrame.
+
+  A ManipulatedFrame is also a MouseGrabber. If the mouse cursor gets within a distance of 10 pixels
+  from the projected position of the ManipulatedFrame, the ManipulatedFrame becomes the new
+  QGLViewer::mouseGrabber(). It can then be manipulated directly, without any specific state key,
+  object selection or GUI intervention. This is very convenient to directly move some objects in the
+  scene (typically a light). See the &lt;a href=&quot;../examples/mouseGrabber.html&quot;&gt;mouseGrabber
+  example&lt;/a&gt; as an illustration. Note that QWidget::setMouseTracking() needs to be enabled in order
+  to use this feature (see the MouseGrabber documentation).
+
+  &lt;h3&gt;Advanced functionalities&lt;/h3&gt;
+
+  A QGLViewer can handle at most one ManipulatedFrame at a time. If you want to move several objects
+  in the scene, you simply have to keep a list of the different ManipulatedFrames, and to activate
+  the right one (using QGLViewer::setManipulatedFrame()) when needed. This can for instance be done
+  according to an object selection: see the &lt;a href=&quot;../examples/luxo.html&quot;&gt;luxo example&lt;/a&gt; for an
+  illustration.
+
+  When the ManipulatedFrame is being manipulated using the mouse (mouse pressed and not yet
+  released), isManipulated() returns \c true. This might be used to trigger a specific action or
+  display (as is done with QGLViewer::fastDraw()).
+
+  The ManipulatedFrame also emits a manipulated() signal each time its state is modified by the
+  mouse. This signal is automatically connected to the QGLViewer::updateGL() slot when the
+  ManipulatedFrame is attached to a viewer using QGLViewer::setManipulatedFrame().
+
+  You can make the ManipulatedFrame spin() if you release the rotation mouse button while moving the
+  mouse fast enough (see spinningSensitivity()). See also translationSensitivity() and
+  rotationSensitivity() for sensitivity tuning. \nosubgrouping */
+  class QGLVIEWER_EXPORT ManipulatedFrame : public Frame, public MouseGrabber
+  {
+#ifndef DOXYGEN
+    friend class Camera;
+    friend class ::QGLViewer;
+#endif
+
+    Q_OBJECT
+
+  public:
+    ManipulatedFrame();
+    /*! Virtual destructor. Empty. */
+    virtual ~ManipulatedFrame() {};
+
+    ManipulatedFrame(const ManipulatedFrame&amp; mf);
+    ManipulatedFrame&amp; operator=(const ManipulatedFrame&amp; mf);
+
+    signals:
+    /*! This signal is emitted when ever the ManipulatedFrame is manipulated (i.e. rotated or
+    translated) using the mouse. Connect this signal to any object that should be notified.
+
+    Note that this signal is automatically connected to the QGLViewer::updateGL() slot, when the
+    ManipulatedFrame is attached to a viewer using QGLViewer::setManipulatedFrame(), which is
+    probably all you need.
+
+    Use the QGLViewer::QGLViewerPool() if you need to connect this signal to all the viewers.
+
+    See also the spun(), modified(), interpolated() and KeyFrameInterpolator::interpolated()
+    signals' documentations. */
+    void manipulated();
+
+    /*! This signal is emitted when the ManipulatedFrame isSpinning().
+
+    Note that for the QGLViewer::manipulatedFrame(), this signal is automatically connected to the
+    QGLViewer::updateGL() slot.
+
+    Connect this signal to any object that should be notified. Use the QGLViewer::QGLViewerPool() if
+    you need to connect this signal to all the viewers.
+
+    See also the manipulated(), modified(), interpolated() and KeyFrameInterpolator::interpolated()
+    signals' documentations. */
+    void spun();
+
+    /*! @name Manipulation sensitivity */
+    //@{
+  public slots:
+    /*! Defines the rotationSensitivity(). */
+    void setRotationSensitivity(float sensitivity) { rotSensitivity_ = sensitivity; };
+    /*! Defines the translationSensitivity(). */
+    void setTranslationSensitivity(float sensitivity) { transSensitivity_ = sensitivity; };
+    /*! Defines the spinningSensitivity(), in pixels per milliseconds. */
+    void setSpinningSensitivity(float sensitivity) { spinningSensitivity_ = sensitivity; };
+    /*! Defines the wheelSensitivity(). */
+    void setWheelSensitivity(float sensitivity) { wheelSensitivity_ = sensitivity; };
+  public:
+    /*! Returns the influence of a mouse displacement on the ManipulatedFrame rotation.
+
+    Default value is 1.0. With an identical mouse displacement, a higher value will generate a
+    larger rotation (and inversely for lower values). A 0.0 value will forbid ManipulatedFrame mouse
+    rotation (see also constraint()).
+
+    See also setRotationSensitivity(), translationSensitivity(), spinningSensitivity() and
+    wheelSensitivity(). */
+    float rotationSensitivity() const { return rotSensitivity_; };
+    /*! Returns the influence of a mouse displacement on the ManipulatedFrame translation.
+
+    Default value is 1.0. You should not have to modify this value, since with 1.0 the
+    ManipulatedFrame precisely stays under the mouse cursor.
+
+    With an identical mouse displacement, a higher value will generate a larger translation (and
+    inversely for lower values). A 0.0 value will forbid ManipulatedFrame mouse translation (see
+    also constraint()).
+
+    \note When the ManipulatedFrame is used to move a \e Camera (see the ManipulatedCameraFrame
+    class documentation), after zooming on a small region of your scene, the camera may translate
+    too fast. For a camera, it is the Camera::revolveAroundPoint() that exactly matches the mouse
+    displacement. Hence, instead of changing the translationSensitivity(), solve the problem by
+    (temporarily) setting the Camera::revolveAroundPoint() to a point on the zoomed region (see the
+    QGLViewer::RAP_FROM_PIXEL mouse binding in the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;).
+
+    See also setTranslationSensitivity(), rotationSensitivity(), spinningSensitivity() and
+    wheelSensitivity(). */
+    float translationSensitivity() const { return transSensitivity_; };
+    /*! Returns the minimum mouse speed required (at button release) to make the ManipulatedFrame
+      spin().
+
+    See spin(), spinningQuaternion() and startSpinning() for details.
+
+    Mouse speed is expressed in pixels per milliseconds. Default value is 0.3 (300 pixels per
+    second). Use setSpinningSensitivity() to tune this value. A higher value will make spinning more
+    difficult (a value of 100.0 forbids spinning in practice).
+
+    See also setSpinningSensitivity(), translationSensitivity(), rotationSensitivity() and
+    wheelSensitivity(). */
+    float spinningSensitivity() const { return spinningSensitivity_; };
+    /*! Returns the mouse wheel sensitivity.
+
+    Default value is 1.0. A higher value will make the wheel action more efficient (usually meaning
+    a faster zoom). Use a negative value to invert the zoom in and out directions.
+
+    See also setWheelSensitivity(), translationSensitivity(), rotationSensitivity() and
+    spinningSensitivity(). */
+    float wheelSensitivity() const { return wheelSensitivity_; };
+    //@}
+
+
+    /*! @name Spinning */
+    //@{
+      public:
+    /*! Returns \c true when the ManipulatedFrame is spinning.
+
+    During spinning, spin() rotates the ManipulatedFrame by its spinningQuaternion() at a frequency
+    defined when the ManipulatedFrame startSpinning().
+
+    Use startSpinning() and stopSpinning() to change this state. Default value is \c false. */
+    bool isSpinning() const { return isSpinning_; };
+    /*! Returns the incremental rotation that is applied by spin() to the ManipulatedFrame
+      orientation when it isSpinning().
+
+     Default value is a null rotation (identity Quaternion). Use setSpinningQuaternion() to change
+     this value.
+
+     The spinningQuaternion() axis is defined in the ManipulatedFrame coordinate system. You can use
+     Frame::transformOfFrom() to convert this axis from an other Frame coordinate system. */
+    Quaternion spinningQuaternion() const { return spinningQuaternion_; }
+  public slots:
+  /*! Defines the spinningQuaternion(). Its axis is defined in the ManipulatedFrame coordinate
+    system. */
+    void setSpinningQuaternion(const Quaternion&amp; spinningQuaternion) { spinningQuaternion_ = spinningQuaternion; }
+    virtual void startSpinning(int updateInterval);
+    /*! Stops the spinning motion started using startSpinning(). isSpinning() will return \c false
+      after this call. */
+    virtual void stopSpinning() { spinningTimer_.stop(); isSpinning_ = false; };
+  protected slots:
+    virtual void spin();
+  private slots:
+    void spinUpdate();
+    //@}
+
+    /*! @name Mouse event handlers */
+    //@{
+  protected:
+    virtual void mousePressEvent      (QMouseEvent* const event, Camera* const camera);
+    virtual void mouseMoveEvent       (QMouseEvent* const event, Camera* const camera);
+    virtual void mouseReleaseEvent    (QMouseEvent* const event, Camera* const camera);
+    virtual void mouseDoubleClickEvent(QMouseEvent* const event, Camera* const camera);
+    virtual void wheelEvent           (QWheelEvent* const event, Camera* const camera);
+    //@}
+
+  public:
+    /*! @name Current state */
+    //@{
+    bool isManipulated() const;
+    //@}
+
+    /*! @name MouseGrabber implementation */
+    //@{
+  public:
+    virtual void checkIfGrabsMouse(int x, int y, const Camera* const camera);
+    //@}
+
+    /*! @name XML representation */
+    //@{
+  public:
+    virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  public slots:
+    virtual void initFromDOMElement(const QDomElement&amp; element);
+    //@}
+
+#ifndef DOXYGEN
+  protected:
+    Quaternion deformedBallQuaternion(int x, int y, float cx, float cy, const Camera* const camera);
+
+    int action_; // Should be a QGLViewer::MouseAction, but include loop
+    Constraint* previousConstraint_; // When manipulation is without Contraint.
+
+    virtual void startAction(int ma, bool withConstraint=true); // int is really a QGLViewer::MouseAction
+    void computeMouseSpeed(const QMouseEvent* const e);
+    int mouseOriginalDirection(const QMouseEvent* const e);
+
+    // Previous mouse position (used for incremental updates) and mouse press position.
+    QPoint prevPos_, pressPos_;
+#endif // DOXYGEN
+
+  private:
+    // Sensitivity
+    float rotSensitivity_;
+    float transSensitivity_;
+    float spinningSensitivity_;
+    float wheelSensitivity_;
+
+    // Mouse speed and spinning
+    QTime last_move_time;
+    float mouseSpeed_;
+    int delay_;
+    bool isSpinning_;
+    QTimer spinningTimer_;
+    Quaternion spinningQuaternion_;
+
+    // Whether the SCREEN_TRANS direction (horizontal or vertical) is fixed or not.
+    bool dirIsFixed_;
+
+    // MouseGrabber
+    bool keepsGrabbingMouse_;
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_MANIPULATED_FRAME_H

Added: trunk/lib/QGLViewer/mouseGrabber.cpp
===================================================================
--- trunk/lib/QGLViewer/mouseGrabber.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/mouseGrabber.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,91 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;mouseGrabber.h&quot;
+
+using namespace qglviewer;
+
+// Static private variable
+#if QT_VERSION &gt;= 0x040000
+QList&lt;MouseGrabber*&gt; MouseGrabber::MouseGrabberPool_;
+#else
+QPtrList&lt;MouseGrabber&gt; MouseGrabber::MouseGrabberPool_;
+#endif
+
+/*! Default constructor.
+
+Adds the created MouseGrabber in the MouseGrabberPool(). grabsMouse() is set to \c false. */
+MouseGrabber::MouseGrabber()
+  : grabsMouse_(false)
+{
+  addInMouseGrabberPool();
+}
+
+/*! Adds the MouseGrabber in the MouseGrabberPool().
+
+All created MouseGrabber are automatically added in the MouseGrabberPool() by the constructor.
+Trying to add a MouseGrabber that already isInMouseGrabberPool() has no effect.
+
+Use removeFromMouseGrabberPool() to remove the MouseGrabber from the list, so that it is no longer
+tested with checkIfGrabsMouse() by the QGLViewer, and hence can no longer grab mouse focus. Use
+isInMouseGrabberPool() to know the current state of the MouseGrabber. */
+void MouseGrabber::addInMouseGrabberPool()
+{
+  if (!isInMouseGrabberPool())
+    MouseGrabber::MouseGrabberPool_.append(this);
+}
+
+/*! Removes the MouseGrabber from the MouseGrabberPool().
+
+See addInMouseGrabberPool() for details. Removing a MouseGrabber that is not in MouseGrabberPool()
+has no effect. */
+void MouseGrabber::removeFromMouseGrabberPool()
+{
+  if (isInMouseGrabberPool())
+#if QT_VERSION &gt;= 0x040000
+    MouseGrabber::MouseGrabberPool_.removeAll(const_cast&lt;MouseGrabber*&gt;(this));
+#else
+    MouseGrabber::MouseGrabberPool_.removeRef(this);
+#endif
+}
+
+/*! Clears the MouseGrabberPool().
+
+ Use this method only if it is faster to clear the MouseGrabberPool() and then to add back a few
+ MouseGrabbers than to remove each one independently. Use QGLViewer::setMouseTracking(false) instead
+ if you want to disable mouse grabbing.
+
+ When \p autoDelete is \c true, the MouseGrabbers of the MouseGrabberPool() are actually deleted
+ (use this only if you're sure of what you do). */
+void MouseGrabber::clearMouseGrabberPool(bool autoDelete)
+{
+#if QT_VERSION &gt;= 0x040000
+  if (autoDelete)
+    qDeleteAll(MouseGrabber::MouseGrabberPool_);
+#else
+  MouseGrabber::MouseGrabberPool_.setAutoDelete(autoDelete);
+#endif
+  MouseGrabber::MouseGrabberPool_.clear();
+}

Added: trunk/lib/QGLViewer/mouseGrabber.h
===================================================================
--- trunk/lib/QGLViewer/mouseGrabber.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/mouseGrabber.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,291 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_MOUSE_GRABBER_H
+#define QGLVIEWER_MOUSE_GRABBER_H
+
+#include &quot;config.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QEvent&gt;
+#else
+# include &lt;qevent.h&gt;
+#endif
+
+class QGLViewer;
+
+namespace qglviewer {
+  class Camera;
+
+  /*! \brief Abstract class for objects that grab mouse focus in a QGLViewer.
+  \class MouseGrabber mouseGrabber.h QGLViewer/mouseGrabber.h
+
+  MouseGrabber are objects which react to the mouse cursor, usually when it hovers over them. This
+  abstract class only provides an interface for all these objects: their actual behavior has to be
+  defined in a derived class.
+
+  &lt;h3&gt;How does it work ?&lt;/h3&gt;
+
+  All the created MouseGrabber are grouped in a MouseGrabberPool(). The QGLViewers parse this pool,
+  calling all the MouseGrabbers' checkIfGrabsMouse() methods that setGrabsMouse() if desired.
+
+  When a MouseGrabber grabsMouse(), it becomes the QGLViewer::mouseGrabber(). All the mouse events
+  (mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), mouseDoubleClickEvent() and
+  wheelEvent()) are then transmitted to the QGLViewer::mouseGrabber() instead of being normally
+  processed. This continues while grabsMouse() (updated using checkIfGrabsMouse()) returns \c true.
+
+  If you want to (temporarily) disable a specific MouseGrabbers, you can remove it from this pool
+  using removeFromMouseGrabberPool(). You can also disable a MouseGrabber in a specific QGLViewer
+  using QGLViewer::setMouseGrabberIsEnabled().
+
+  &lt;h3&gt;Implementation details&lt;/h3&gt;
+
+  In order to make MouseGrabber react to mouse events, mouse tracking has to be activated in the
+  QGLViewer which wants to use MouseGrabbers:
+  \code
+  init() { setMouseTracking(true); }
+  \endcode
+  Call \c QGLWidget::hasMouseTracking() to get the current state of this flag.
+
+  The \p camera parameter of the different mouse event methods is a pointer to the
+  QGLViewer::camera() of the QGLViewer that uses the MouseGrabber. It can be used to compute 2D to
+  3D coordinates conversion using Camera::projectedCoordinatesOf() and
+  Camera::unprojectedCoordinatesOf().
+
+  Very complex behaviors can be implemented using this framework: auto-selected objects (no need to
+  press a key to use them), automatic drop-down menus, 3D GUI, spinners using the wheelEvent(), and
+  whatever your imagination creates. See the &lt;a href=&quot;../examples/mouseGrabber.html&quot;&gt;mouseGrabber
+  example&lt;/a&gt; for an illustration.
+
+  Note that ManipulatedFrame are MouseGrabber: see the &lt;a href=&quot;../examples/keyFrames.html&quot;&gt;keyFrame
+  example&lt;/a&gt; for an illustration. Every created ManipulatedFrame is hence present in the
+  MouseGrabberPool() (note however that ManipulatedCameraFrame are not inserted).
+
+  &lt;h3&gt;Example&lt;/h3&gt;
+
+  Here is for instance a draft version of a MovableObject class. Instances of these class can freely
+  be moved on screen using the mouse, as movable post-it-like notes:
+  \code
+  class MovableObject : public MouseGrabber
+  {
+  public:
+    MovableObject() : pos(0,0), moved(false) {};
+
+    void checkIfGrabsMouse(int x, int y, const qglviewer::Camera* const)
+    {
+      // MovableObject is active in a region of 5 pixels around its pos.
+      // May depend on the actual shape of the object. Customize as desired.
+      // Once clicked (moved = true), it keeps grabbing mouse until button is released.
+      setGrabsMouse( moved || ((pos-QPoint(x,y)).manhattanLength() &lt; 5) );
+    }
+
+    void mousePressEvent( QMouseEvent* const e, Camera* const) { prevPos = e-&gt;pos(); moved = true; }
+
+    void mouseMoveEvent(QMouseEvent* const e, const Camera* const)
+    {
+      if (moved)
+      {
+        // Add position delta to current pos
+        pos += e-&gt;pos() - prevPos;
+        prevPos = e-&gt;pos();
+      }
+    }
+
+    void mouseReleaseEvent(QMouseEvent* const, Camera* const) { moved = false; }
+
+    void draw()
+    {
+      // The object is drawn centered on its pos, with different possible aspects:
+      if (grabsMouse())
+        if (moved)
+	  // Object being moved, maybe a transparent display
+        else
+	  // Object ready to be moved, maybe a highlighted visual feedback
+      else
+        // Normal display
+    }
+
+  private:
+    QPoint pos, prevPos;
+    bool moved;
+  };
+  \endcode
+  Note that the different event callback methods are called only once the MouseGrabber grabsMouse().
+  \nosubgrouping */
+  class QGLVIEWER_EXPORT MouseGrabber
+  {
+#ifndef DOXYGEN
+    friend class ::QGLViewer;
+#endif
+
+  public:
+    MouseGrabber();
+    /*! Virtual destructor. Removes the MouseGrabber from the MouseGrabberPool(). */
+#if QT_VERSION &gt;= 0x040000
+    virtual ~MouseGrabber() { MouseGrabber::MouseGrabberPool_.removeAll(this); };
+#else
+    virtual ~MouseGrabber() { MouseGrabber::MouseGrabberPool_.removeRef(this); };
+#endif
+
+    /*! @name Mouse grabbing detection */
+    //@{
+  public:
+    /*! Pure virtual method, called by the QGLViewers before they test if the MouseGrabber
+      grabsMouse(). Should setGrabsMouse() according to the mouse position.
+
+    This is the core method of the MouseGrabber. It has to be overloaded in your derived class.
+    Its goal is to update the grabsMouse() flag according to the mouse and MouseGrabber current
+    positions, using setGrabsMouse().
+
+    grabsMouse() is usually set to \c true when the mouse cursor is close enough to the MouseGrabber
+    position. It should also be set to \c false when the mouse cursor leaves this region in order to
+    release the mouse focus.
+
+    \p x and \p y are the mouse cursor coordinates (Qt coordinate system: (0,0) corresponds to the upper
+    left corner).
+
+    A typical implementation will look like:
+    \code
+    // (posX,posY) is the position of the MouseGrabber on screen.
+    // Here, distance to mouse must be less than 10 pixels to activate the MouseGrabber.
+    setGrabsMouse( sqrt((x-posX)*(x-posX) + (y-posY)*(y-posY)) &lt; 10);
+    \endcode
+
+    If the MouseGrabber position is defined in 3D, use the \p camera parameter, corresponding to
+    the calling QGLViewer Camera. Project on screen and then compare the projected coordinates:
+    \code
+    Vec proj = camera-&gt;projectedCoordinatesOf(myMouseGrabber-&gt;frame()-&gt;position());
+    setGrabsMouse((fabs(x-proj.x) &lt; 5) &amp;&amp; (fabs(y-proj.y) &lt; 2)); // Rectangular region
+    \endcode
+
+    See examples in the &lt;a href=&quot;#_details&quot;&gt;detailed description&lt;/a&gt; section and in the &lt;a
+    href=&quot;../examples/mouseGrabber.html&quot;&gt;mouseGrabber example&lt;/a&gt;. */
+    virtual void checkIfGrabsMouse(int x, int y, const Camera* const camera) = 0;
+
+    /*! Returns \c true when the MouseGrabber grabs the QGLViewer's mouse events.
+
+    This flag is set with setGrabsMouse() by the checkIfGrabsMouse() method. */
+    bool grabsMouse() const { return grabsMouse_; };
+
+  protected:
+    /*! Sets the grabsMouse() flag. Normally used by checkIfGrabsMouse(). */
+    void setGrabsMouse(bool grabs) { grabsMouse_ = grabs; };
+    //@}
+
+
+    /*! @name MouseGrabber pool */
+    //@{
+  public:
+    /*! Returns a list containing pointers to all the active MouseGrabbers.
+
+    Used by the QGLViewer to parse all the MouseGrabbers and to check if any of them grabsMouse()
+    using checkIfGrabsMouse().
+
+    You should not have to directly use this list. Use removeFromMouseGrabberPool() and
+    addInMouseGrabberPool() to modify this list.
+
+    \attention This method returns a \c QPtrList&lt;MouseGrabber&gt; with Qt 3 and a \c QList&lt;MouseGrabber&gt; with Qt 2. */
+#if QT_VERSION &gt;= 0x040000
+    static const QList&lt;MouseGrabber*&gt;&amp; MouseGrabberPool() { return MouseGrabber::MouseGrabberPool_; };
+#else
+# if QT_VERSION &gt;= 0x030000
+    static const QPtrList&lt;MouseGrabber&gt;&amp; MouseGrabberPool() { return MouseGrabber::MouseGrabberPool_; };
+# else
+    static const QList&lt;MouseGrabber&gt;&amp; MouseGrabberPool() { return MouseGrabber::MouseGrabberPool_; };
+# endif
+#endif
+
+    /*! Returns \c true if the MouseGrabber is currently in the MouseGrabberPool() list.
+
+    Default value is \c true. When set to \c false using removeFromMouseGrabberPool(), the
+    QGLViewers no longer checkIfGrabsMouse() on this MouseGrabber. Use addInMouseGrabberPool() to
+    insert it back. */
+#if QT_VERSION &gt;= 0x040000
+    bool isInMouseGrabberPool() const { return MouseGrabber::MouseGrabberPool_.contains(const_cast&lt;MouseGrabber*&gt;(this)); };
+#else
+    bool isInMouseGrabberPool() const { return MouseGrabber::MouseGrabberPool_.findRef(this) != -1; };
+#endif
+    void addInMouseGrabberPool();
+    void removeFromMouseGrabberPool();
+    void clearMouseGrabberPool(bool autoDelete=false);
+    //@}
+
+
+    /*! @name Mouse event handlers */
+    //@{
+  protected:
+    /*! Callback method called when the MouseGrabber grabsMouse() and a mouse button is pressed.
+
+
+    The MouseGrabber will typically start an action or change its state when a mouse button is
+    pressed. mouseMoveEvent() (called at each mouse displacement) will then update the MouseGrabber
+    accordingly and mouseReleaseEvent() (called when the mouse button is released) will terminate
+    this action.
+
+    Use the \p event QMouseEvent::state() and QMouseEvent::button() to test the keyboard
+    and button state and possibly change the MouseGrabber behavior accordingly.
+
+    See the &lt;a href=&quot;#_details&quot;&gt;detailed description section&lt;/a&gt; and the &lt;a
+    href=&quot;../examples/mouseGrabber.html&quot;&gt;mouseGrabber example&lt;/a&gt; for examples.
+
+    See the \c QGLWidget::mousePressEvent() and the \c QMouseEvent documentations for details. */
+    virtual void mousePressEvent(QMouseEvent* const event, Camera* const camera) { Q_UNUSED(event) Q_UNUSED(camera) };
+    /*! Callback method called when the MouseGrabber grabsMouse() and a mouse button is double clicked.
+
+    See the \c QGLWidget::mouseDoubleClickEvent() and the \c QMouseEvent documentations for details. */
+    virtual void mouseDoubleClickEvent(QMouseEvent* const event, Camera* const camera) { Q_UNUSED(event) Q_UNUSED(camera) };
+    /*! Mouse release event callback method. See mousePressEvent(). */
+    virtual void mouseReleaseEvent(QMouseEvent* const event, Camera* const camera) { Q_UNUSED(event) Q_UNUSED(camera) };
+    /*! Callback method called when the MouseGrabber grabsMouse() and the mouse is moved while a
+      button is pressed.
+
+    This method will typically update the state of the MouseGrabber from the mouse displacement. See
+    the mousePressEvent() documentation for details. */
+    virtual void mouseMoveEvent(QMouseEvent* const event, Camera* const camera) { Q_UNUSED(event) Q_UNUSED(camera) };
+    /*! Callback method called when the MouseGrabber grabsMouse() and the mouse wheel is used.
+
+    See the \c QGLWidget::wheelEvent() and the \c QWheelEvent documentations for details. */
+    virtual void wheelEvent(QWheelEvent* const event, Camera* const camera) { Q_UNUSED(event) Q_UNUSED(camera) };
+    //@}
+
+  private:
+    // Copy constructor and opertor= are declared private and undefined
+    // Prevents everyone from trying to use them
+    MouseGrabber(const MouseGrabber&amp;);
+    MouseGrabber&amp; operator=(const MouseGrabber&amp;);
+
+    bool grabsMouse_;
+
+    // Q G L V i e w e r   p o o l
+#if QT_VERSION &gt;= 0x040000
+    static QList&lt;MouseGrabber*&gt; MouseGrabberPool_;
+#else
+    static QPtrList&lt;MouseGrabber&gt; MouseGrabberPool_;
+#endif
+  };
+
+} // namespace qglviewer
+
+#endif // QGLVIEWER_MOUSE_GRABBER_H

Added: trunk/lib/QGLViewer/qglviewer-icon.xpm
===================================================================
--- trunk/lib/QGLViewer/qglviewer-icon.xpm	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/qglviewer-icon.xpm	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,359 @@
+/* XPM */
+static const char * qglviewer_icon[] = {
+&quot;100 100 256 2&quot;,
+&quot;  	c None&quot;,
+&quot;. 	c #0A0B27&quot;,
+&quot;+ 	c #090B2C&quot;,
+&quot;@ 	c #150C12&quot;,
+&quot;# 	c #080F34&quot;,
+&quot;$ 	c #1A0E1A&quot;,
+&quot;% 	c #220D0B&quot;,
+&quot;&amp; 	c #260B0B&quot;,
+&quot;* 	c #230E1C&quot;,
+&quot;= 	c #12113E&quot;,
+&quot;- 	c #2C0D10&quot;,
+&quot;; 	c #2F0D09&quot;,
+&quot;&gt; 	c #310D14&quot;,
+&quot;, 	c #1A123A&quot;,
+&quot;' 	c #261025&quot;,
+&quot;) 	c #17134B&quot;,
+&quot;! 	c #151453&quot;,
+&quot;~ 	c #1B1733&quot;,
+&quot;{ 	c #14135E&quot;,
+&quot;] 	c #281430&quot;,
+&quot;^ 	c #0E1867&quot;,
+&quot;/ 	c #3B1215&quot;,
+&quot;( 	c #32132A&quot;,
+&quot;_ 	c #1D1849&quot;,
+&quot;: 	c #121C58&quot;,
+&quot;&lt; 	c #431014&quot;,
+&quot;[ 	c #141974&quot;,
+&quot;} 	c #3A152E&quot;,
+&quot;| 	c #201A5E&quot;,
+&quot;1 	c #1D204C&quot;,
+&quot;2 	c #401431&quot;,
+&quot;3 	c #261960&quot;,
+&quot;4 	c #48171C&quot;,
+&quot;5 	c #411B21&quot;,
+&quot;6 	c #371B45&quot;,
+&quot;7 	c #2A1C6B&quot;,
+&quot;8 	c #0E229B&quot;,
+&quot;9 	c #52171D&quot;,
+&quot;0 	c #441A35&quot;,
+&quot;a 	c #1B2582&quot;,
+&quot;b 	c #65150F&quot;,
+&quot;c 	c #2D2076&quot;,
+&quot;d 	c #4D1B3A&quot;,
+&quot;e 	c #57182F&quot;,
+&quot;f 	c #3E1F54&quot;,
+&quot;g 	c #5E1924&quot;,
+&quot;h 	c #2E2567&quot;,
+&quot;i 	c #002BD1&quot;,
+&quot;j 	c #002AD9&quot;,
+&quot;k 	c #6D1A13&quot;,
+&quot;l 	c #36237A&quot;,
+&quot;m 	c #002FCD&quot;,
+&quot;n 	c #701A0D&quot;,
+&quot;o 	c #462060&quot;,
+&quot;p 	c #651C23&quot;,
+&quot;q 	c #322581&quot;,
+&quot;r 	c #552429&quot;,
+&quot;s 	c #581E41&quot;,
+&quot;t 	c #671E1B&quot;,
+&quot;u 	c #771911&quot;,
+&quot;v 	c #6C1B2B&quot;,
+&quot;w 	c #562341&quot;,
+&quot;x 	c #342A79&quot;,
+&quot;y 	c #3C2484&quot;,
+&quot;z 	c #062FE6&quot;,
+&quot;A 	c #68212B&quot;,
+&quot;B 	c #4D236B&quot;,
+&quot;C 	c #612045&quot;,
+&quot;D 	c #42267B&quot;,
+&quot;E 	c #811B10&quot;,
+&quot;F 	c #7C1E0E&quot;,
+&quot;G 	c #0033F1&quot;,
+&quot;H 	c #0032F9&quot;,
+&quot;I 	c #3A298E&quot;,
+&quot;J 	c #472872&quot;,
+&quot;K 	c #72202A&quot;,
+&quot;L 	c #4F2774&quot;,
+&quot;M 	c #652449&quot;,
+&quot;N 	c #442890&quot;,
+&quot;O 	c #1F37A8&quot;,
+&quot;P 	c #87200E&quot;,
+&quot;Q 	c #852014&quot;,
+&quot;R 	c #402B98&quot;,
+&quot;S 	c #6C244D&quot;,
+&quot;T 	c #7D2230&quot;,
+&quot;U 	c #8F1F12&quot;,
+&quot;V 	c #70254A&quot;,
+&quot;W 	c #542A7E&quot;,
+&quot;X 	c #212FF2&quot;,
+&quot;Y 	c #6E2E28&quot;,
+&quot;Z 	c #442E9B&quot;,
+&quot;` 	c #772834&quot;,
+&quot; .	c #971E15&quot;,
+&quot;..	c #552B86&quot;,
+&quot;+.	c #693132&quot;,
+&quot;@.	c #702A46&quot;,
+&quot;#.	c #7B2645&quot;,
+&quot;$.	c #862435&quot;,
+&quot;%.	c #79264E&quot;,
+&quot;&amp;.	c #5A2B88&quot;,
+&quot;*.	c #1B3AE9&quot;,
+&quot;=.	c #9A2211&quot;,
+&quot;-.	c #4E2EA0&quot;,
+&quot;;.	c #1E3BDE&quot;,
+&quot;&gt;.	c #722F3D&quot;,
+&quot;,.	c #5E2C91&quot;,
+&quot;'.	c #592F91&quot;,
+&quot;).	c #7A322A&quot;,
+&quot;!.	c #1D42D7&quot;,
+&quot;~.	c #902539&quot;,
+&quot;{.	c #7D2A52&quot;,
+&quot;].	c #862E26&quot;,
+&quot;^.	c #822853&quot;,
+&quot;/.	c #922B20&quot;,
+&quot;(.	c #4E34AA&quot;,
+&quot;_.	c #A62411&quot;,
+&quot;:.	c #5D309A&quot;,
+&quot;&lt;.	c #59387B&quot;,
+&quot;[.	c #5631AB&quot;,
+&quot;}.	c #5533A6&quot;,
+&quot;|.	c #912840&quot;,
+&quot;1.	c #8C2B3F&quot;,
+&quot;2.	c #AE2215&quot;,
+&quot;3.	c #862C57&quot;,
+&quot;4.	c #5D32A8&quot;,
+&quot;5.	c #882C53&quot;,
+&quot;6.	c #5C34A2&quot;,
+&quot;7.	c #6231A2&quot;,
+&quot;8.	c #A32A18&quot;,
+&quot;9.	c #5C398B&quot;,
+&quot;0.	c #4D4480&quot;,
+&quot;a.	c #982A3F&quot;,
+&quot;b.	c #8D2B5A&quot;,
+&quot;c.	c #962C44&quot;,
+&quot;d.	c #902C56&quot;,
+&quot;e.	c #7A3B43&quot;,
+&quot;f.	c #3249C3&quot;,
+&quot;g.	c #B42812&quot;,
+&quot;h.	c #583E9B&quot;,
+&quot;i.	c #BA2516&quot;,
+&quot;j.	c #524297&quot;,
+&quot;k.	c #55448B&quot;,
+&quot;l.	c #5E3BA3&quot;,
+&quot;m.	c #9E2C47&quot;,
+&quot;n.	c #5A4676&quot;,
+&quot;o.	c #873847&quot;,
+&quot;p.	c #404E94&quot;,
+&quot;q.	c #932F59&quot;,
+&quot;r.	c #BE2810&quot;,
+&quot;s.	c #992D5B&quot;,
+&quot;t.	c #5941A4&quot;,
+&quot;u.	c #8A3F36&quot;,
+&quot;v.	c #9D2F58&quot;,
+&quot;w.	c #78415D&quot;,
+&quot;x.	c #A72D4D&quot;,
+&quot;y.	c #A2304B&quot;,
+&quot;z.	c #C72815&quot;,
+&quot;A.	c #C12C13&quot;,
+&quot;B.	c #654298&quot;,
+&quot;C.	c #654780&quot;,
+&quot;D.	c #8F385F&quot;,
+&quot;E.	c #98345D&quot;,
+&quot;F.	c #2F51E3&quot;,
+&quot;G.	c #A93724&quot;,
+&quot;H.	c #A0325B&quot;,
+&quot;I.	c #CA2B10&quot;,
+&quot;J.	c #A93054&quot;,
+&quot;K.	c #A6305D&quot;,
+&quot;L.	c #D42A00&quot;,
+&quot;M.	c #D22914&quot;,
+&quot;N.	c #89415D&quot;,
+&quot;O.	c #6546A5&quot;,
+&quot;P.	c #AB3255&quot;,
+&quot;Q.	c #DC2806&quot;,
+&quot;R.	c #A3355D&quot;,
+&quot;S.	c #AA325A&quot;,
+&quot;T.	c #A13F2F&quot;,
+&quot;U.	c #6A4A8E&quot;,
+&quot;V.	c #A53754&quot;,
+&quot;W.	c #DE2A00&quot;,
+&quot;X.	c #CF300A&quot;,
+&quot;Y.	c #D62C0E&quot;,
+&quot;Z.	c #A8385B&quot;,
+&quot;`.	c #4B54C3&quot;,
+&quot; +	c #964356&quot;,
+&quot;.+	c #E82903&quot;,
+&quot;++	c #8F4757&quot;,
+&quot;@+	c #DF2C14&quot;,
+&quot;#+	c #D93011&quot;,
+&quot;$+	c #A23D62&quot;,
+&quot;%+	c #8C4E44&quot;,
+&quot;&amp;+	c #E32F00&quot;,
+&quot;*+	c #6E4CA5&quot;,
+&quot;=+	c #6E4F9B&quot;,
+&quot;-+	c #A04259&quot;,
+&quot;;+	c #9D4266&quot;,
+&quot;&gt;+	c #D03716&quot;,
+&quot;,+	c #E3300D&quot;,
+&quot;'+	c #6A51A7&quot;,
+&quot;)+	c #BA3F2F&quot;,
+&quot;!+	c #EC2E07&quot;,
+&quot;~+	c #A9405F&quot;,
+&quot;{+	c #EB2E13&quot;,
+&quot;]+	c #EF3100&quot;,
+&quot;^+	c #4A5CDC&quot;,
+&quot;/+	c #984A68&quot;,
+&quot;(+	c #B54536&quot;,
+&quot;_+	c #4563C9&quot;,
+&quot;:+	c #F62E03&quot;,
+&quot;&lt;+	c #EF310B&quot;,
+&quot;[+	c #E73411&quot;,
+&quot;}+	c #AA4B3E&quot;,
+&quot;|+	c #F62E10&quot;,
+&quot;1+	c #CE401F&quot;,
+&quot;2+	c #D33D23&quot;,
+&quot;3+	c #7455A7&quot;,
+&quot;4+	c #C54426&quot;,
+&quot;5+	c #A5496A&quot;,
+&quot;6+	c #F93106&quot;,
+&quot;7+	c #A45048&quot;,
+&quot;8+	c #CD412C&quot;,
+&quot;9+	c #F2350E&quot;,
+&quot;0+	c #AA4A64&quot;,
+&quot;a+	c #5266C7&quot;,
+&quot;b+	c #DE411E&quot;,
+&quot;c+	c #EF3C18&quot;,
+&quot;d+	c #755FAD&quot;,
+&quot;e+	c #C94C34&quot;,
+&quot;f+	c #C14F3F&quot;,
+&quot;g+	c #DB452E&quot;,
+&quot;h+	c #AB526E&quot;,
+&quot;i+	c #EB421F&quot;,
+&quot;j+	c #AA566A&quot;,
+&quot;k+	c #A55B6B&quot;,
+&quot;l+	c #AA5873&quot;,
+&quot;m+	c #E94824&quot;,
+&quot;n+	c #D94D35&quot;,
+&quot;o+	c #DB4F31&quot;,
+&quot;p+	c #5B71DE&quot;,
+&quot;q+	c #A85F76&quot;,
+&quot;r+	c #EC4C31&quot;,
+&quot;s+	c #E2522E&quot;,
+&quot;t+	c #E84F30&quot;,
+&quot;u+	c #CD5D42&quot;,
+&quot;v+	c #6976CD&quot;,
+&quot;w+	c #D9583F&quot;,
+&quot;x+	c #E55537&quot;,
+&quot;y+	c #E7573E&quot;,
+&quot;z+	c #D65F4C&quot;,
+&quot;A+	c #CA6457&quot;,
+&quot;B+	c #E35C3E&quot;,
+&quot;C+	c #D1634E&quot;,
+&quot;D+	c #E26447&quot;,
+&quot;E+	c #E1674E&quot;,
+&quot;F+	c #DE6F57&quot;,
+&quot;G+	c #DE705E&quot;,
+&quot;                                                                                                                                                                                                        &quot;,
+&quot;                                                                                                                                                                                                        &quot;,
+&quot;                                                                                                                                                                                      C+                &quot;,
+&quot;                                                                                                                          ` &gt;.o.                                                    1+X.u+              &quot;,
+&quot;                                                                                                                    e.A K K T $.T ++                                              1+L.L.X.              &quot;,
+&quot;                                                                                                                  A A v ` T T T 1.~.++                                          X.L.L.L.W.1+            &quot;,
+&quot;                                                                                                                g A K K T T $.$.1.$.1.                                        &gt;+L.L.L.L.L.L.            &quot;,
+&quot;                                                                                                            r g A v v T T $.1.$.$.|.|. +                                  u+X.L.L.L.L.W.W.W.2+          &quot;,
+&quot;                                                                                  f                       r g g K K v T T T |.|.1.1.c.-+                                u+X.L.L.L.Q.L.Q.Q.W.W.          &quot;,
+&quot;                                                                              6 o B C.                  4 9 p p v T T T 1.~.$.1.~.a.~.1.                              u+X.L.L.L.Q.L.W.L.W.W.W.o+        &quot;,
+&quot;                                                                              f o B C.                4 9 9 g v v T T $.1.1.~.|.c.c.c.m.                            4+L.L.L.Q.L.Q.Q.W.&amp;+W.W.,+b+        &quot;,
+&quot;                                                                            f o J L U.                9 9 A v K T $.1.1.$.|.|.c.c.c.a.a.q+                        4+L.L.L.L.L.Q.W.W.&amp;+L.&amp;+&amp;+&amp;+W.        &quot;,
+&quot;                                                                          f o B W L &lt;.              &lt; 9 g A e.` ` $.$.|.$.1.~.a.a.c.c.a.k+                        1+L.L.Q.Q.W.L.W.L.&amp;+&amp;+&amp;+,+&amp;+&amp;+w+      &quot;,
+&quot;                                                                        6 f B L L ..              4 4 9         o.$.|.$.c.a.c.c.m.m.y.c.q+                        u+L.W.Q.L.W.&amp;+&amp;+W.&amp;+,+&amp;+&amp;+&amp;+.+s+      &quot;,
+&quot;                                    p.                                  f o L W W ..            / &lt; r             1.|.|.c.c.c.c.y.m.y.a.k+                          X.L.W.L.,+,+&amp;+,+&amp;+&amp;+&amp;+[+&amp;+&amp;+b+      &quot;,
+&quot;                                    3                                 6 B L W W &amp;.9.            /                 o.|.|.c.a.m.y.a.a.y.y.q+                          e+W.W.&amp;+W.W.,+&amp;+&amp;+&amp;+&amp;+.+&amp;+!+b+      &quot;,
+&quot;                                  a :                               f o L L ....&amp;.B.          /                   ++a.a.m.c.a.y.y.a.y.y.q+                          u+W.W.W.&amp;+.+&amp;+{+&amp;+[+&amp;+!+&amp;+]+&amp;+      &quot;,
+&quot;                                O ^ 1                               f J W ....&amp;.'.U.        / 5                   k+c.m.c.m.y.m.y.y.y.y.                              L.&amp;+&amp;+&amp;+&amp;+&amp;+&amp;+!+]+!+[+!+!+!+      &quot;,
+&quot;                              f.[ )                               $ &lt;.L W ..&amp;.'.'.          /                     k+c.m.a.m.y.a.y.y.y.y.                              b+&amp;+,+&amp;+.+&amp;+&amp;+&amp;+[+]+&amp;+!+&amp;+!+E+    &quot;,
+&quot;                            `.8 ! =                             $   &lt;.W ..&amp;.'.'.B.        -                       k+y.a.y.y.a.y.x.y.x.V.                              b+.+&amp;+!+&amp;+[+!+!+]+!+!+!+9+!+B+    &quot;,
+&quot;                          a+m { = #                             $   ....'.'.'.,.=+      -                         k+m.y.y.y.V.y.x.y.x.V.                              w+!+&amp;+!+]+&amp;+[+&amp;+!+[+&lt;+!+]+&amp;+B+    &quot;,
+&quot;                        v+m 8 ) #                             $   U...'.'.'.,.:.        -                         -+m.m.y.V.x.y.y.x.m.0+                              s+&amp;+!+[+&amp;+!+]+&lt;+!+]+]+[+&lt;+9+B+    &quot;,
+&quot;                        ;.m ) = +                             $   9.&amp;.'.l.l.,.*+      &amp;                           -+y.y.x.x.J.x.y.x.y.0+                              B+&amp;+]+!+&lt;+!+!+[+]+!+]+&lt;+]+&lt;+B+    &quot;,
+&quot;                      ;.i [ = + .                           $     &amp;.'.,.,.,.:.*+      &amp;                           0+y.y.x.y.y.y.J.V.x.l+                              s+!+!+!+[+&lt;+]+]+!+]+]+]+!+]+B+    &quot;,
+&quot;                    ;.z ^+1 # +                             $   =+l.'.l.7.:.'.      %                             y.x.y.x.x.P.y.x.P.y.                                B+.+[+]+!+[+]+]+&lt;+]+]+]+]+&lt;+B+    &quot;,
+&quot;                  ;.z ;.  + + .                           $     '.:.:.:.:.:.3+      &amp;                             V.y.x.y.x.J.P.P.V.Z.                                x+&lt;+]+]+]+:+]+]+]+9+&lt;+9+9+]+      &quot;,
+&quot;              p+*.G G p+    + .                           @   U.:.:.7.:.6.7.      %                             h+P.V.P.P.y.J.P.x.y.0+                                s+]+9+]+]+9+9+]+]+]+]+]+9+&lt;+      &quot;,
+&quot;    f.    p+F.H H G F.    . . .                         $     l.:.:.:.6.:.O.      &amp;                             0+x.J.J.V.P.x.x.P.P.h+                                x+&lt;+]+&lt;+]+]+]+9+]+]+]+9+]+&lt;+      &quot;,
+&quot;    i G X X X G H ;.      . .                           $   =+:.:.6.l.6.:.3+    %                               V.y.y.x.P.V.V.P.P.J.                                  m+!+]+]+]+9+]+|+9+|+]+9+]+c+      &quot;,
+&quot;    m z G H G H G p+      . .                         *     O.6.6.:.7.6.:.      &amp;                               V.P.P.P.x.P.P.V.V.V.                                  i+]+]+&lt;+|+:+]+]+:+]+:+:+]+m+      &quot;,
+&quot;    i z G G G G F.        . .                         *   3+7.7.6.6.6.6.3+    %                               0+x.P.x.V.x.x.x.x.P.0+                                  [+9+]+]+]+|+]+]+]+9+9+9+]+m+      &quot;,
+&quot;    i z G G H *.          . .                       *     :.6.6.7.6.7.:.      &amp;                               0+P.P.P.P.P.P.P.P.V.                                    :+:+]+]+9+]+9+9+|+:+:+:+]+B+      &quot;,
+&quot;    i z G G G p+          .                         *   *+7.}.6.4.6.6.*+    %                                 V.y.P.x.P.x.P.P.P.V.                                  F+]+|+9+:+]+:+:+]+]+:+|+|+:+B+      &quot;,
+&quot;    i z G G ^+            .                         ' n.4.6.7.4.7.4.6.      &amp;                               0+x.P.P.P.P.P.P.P.P.~+                                  s+9+]+:+]+|+6+]+]+|+9+]+]+9+        &quot;,
+&quot;    i z G F.              .                       *   O.4.6.6.6.6.4.*+    &amp;                                 ~+P.P.P.P.P.P.P.P.Z.l+                                  s+6+9+|+]+9+|+|+]+6+:+6+6+9+        &quot;,
+&quot;    j z !.                .                       ] J 4.6.4.[.4.[.l.      &amp;                                 P.P.P.P.P.P.P.P.P.V.                                    c+9+6+]+|+6+9+]+6+9+|+9+|+i+        &quot;,
+&quot;  a+i ;.                  .                     '   l.[.(.6.6.6.4.*+      &amp;                               h+P.P.S.P.S.P.P.P.P.0+                                    :+|+]+]+|+6+|+9+6+]+6+]+9+t+        &quot;,
+&quot;  a+!.                    .                     ] t.(.6.7.4.4.[.6.      &amp;                                 S.P.P.P.P.P.S.S.S.S.q+                                  D+9+9+|+6+]+9+]+6+|+6+9+6+:+E+        &quot;,
+&quot;                        .                       3+7.[.6.(.6.6.6.*+      &amp;                               h+S.S.P.S.~+P.P.P.P.~+                                    r+6+]+9+6+6+6+9+]+9+6+9+6+9+          &quot;,
+&quot;                        .                       6.(.6.4.4.4.(.6.        &amp;                               ~+P.P.P.P.P.P.P.P.P.h+                                    c+6+|+6+9+6+9+6+|+6+|+6+9+9+          &quot;,
+&quot;                        .                     l.[.[.(.6.(.4.(.3+      %                               l+S.V.~+P.P.P.~+P.P.S.                                      9+]+|+6+9+6+|+9+9+]+|+6+9+t+          &quot;,
+&quot;                        ~                   *+(.6.4.4.4.6.4.l.        %                               ~+P.S.P.S.P.S.P.S.S.0+                                    B+9+6+9+9+6+|+9+6+6+|+]+]+|+D+          &quot;,
+&quot;                        ~                 '+(.[.(.(.(.4.4.6.d+      &amp;                                 S.P.S.P.S.P.S.P.P.~+                                      i+9+6+6+9+6+6+:+9+:+6+|+6+c+            &quot;,
+&quot;                        =               '+(.[.(.(.[.4.[.(.O.        %                               ~+~+S.Z.S.Z.S.P.Z.S.~+                                      9+6+6+9+6+9+:+9+6+6+9+6+]+m+            &quot;,
+&quot;                        _             '+Z }.}.4.6.(.(.[.4.          &amp;                             q+S.S.S.~+S.~+S.S.S.S.l+                                    x+]+9+6+9+6+9+6+9+9+6+9+|+6+B+            &quot;,
+&quot;                        ) h         h.Z -.-.}.(.(.[.[.(.'+          &amp;                             R.Z.Z.S.S.S.S.~+Z.Z.R.                                      r+|+6+|+6+9+6+|+6+6+9+6+9+]+F+            &quot;,
+&quot;                        _ 3 x k.j.I Z -.Z Z }.4.(.(.4.t.          %                             l+S.S.Z.Z.Z.S.S.S.S.Z.h+                                    F+]+9+6+9+6+9+6+9+9+6+9+6+6+c+              &quot;,
+&quot;                        ) 3 7 q I I Z N }.}.}.(.}.}.(.            &amp;                             Z.Z.S.Z.Z.S.Z.Z.Z.Z.~+                                      B+6+6+9+6+|+6+9+6+6+|+6+6+9+y+              &quot;,
+&quot;                      = ! 7 c q I N Z Z Z Z -.}.}.}.'+          %                             l+S.Z.S.S.Z.S.S.S.S.Z.h+                                      c+9+6+9+6+9+6+|+9+6+9+9+6+6+                &quot;,
+&quot;                      _ ) 3 l q N N Z N -.}.Z -.(.O.            &amp;                             R.R.R.S.K.S.Z.Z.Z.V.$+                                      D+6+6+9+6+9+6+9+6+6+9+6+6+9+m+                &quot;,
+&quot;                      _ 3 3 l q I N Z Z -.-.}.}.Z               &amp;                           $+S.S.Z.Z.Z.K.K.K.K.S.h+                                      i+9+6+9+6+9+6+9+9+6+9+9+6+9+B+                &quot;,
+&quot;                      _ | 7 l y I I N N Z -.(.-.d+              %                         l+R.R.R.R.S.K.Z.S.S.S.~+                                      F+9+6+9+|+6+6+9+6+6+9+|+6+6+9+                  &quot;,
+&quot;                      _ 3 7 c q I R Z :.Z Z -.'+                &amp;                         R.K.K.K.R.Z.S.Z.Z.Z.K.l+                                      r+9+6+6+9+6+6+6+9+6+6+9+9+6+t+                  &quot;,
+&quot;                      ) | 7 l y y I N R Z -.D                   &amp;                       ;+R.Z.Z.S.K.K.R.Z.S.S.5+                                      G+6+6+9+9+6+9+9+9+6+6+9+6+6+]+E+                  &quot;,
+&quot;                        3 x c I y I Z Z Z h.'                 &amp;                       5+K.K.R.R.S.K.S.K.R.R.S.                                        t+9+6+|+9+6+6+6+6+9+6+9+|+|+i+                    &quot;,
+&quot;                        | c l q I R I Z h.  $                 &amp;                       $+R.s.K.R.R.Z.R.K.K.K.5+                                        9+6+9+6+6+6+c+6+9+6+9+|+6+6+x+                    &quot;,
+&quot;                        h 7 l q y N N j.    *                 &amp;                     H.H.R.s.K.H.H.K.Z.K.S.Z.                                        r+9+6+9+6+6+6+6+6+6+6+9+9+9+c+                      &quot;,
+&quot;                        0.l q y I y '+      '                 ;                   ;+v.v.K.R.H.K.K.v.H.Z.R.5+                                      G+9+|+6+c+6+c+6+c+6+6+9+6+|+6+B+                      &quot;,
+&quot;                          0.x D j.          '                 &amp;                 ;+s.R.s.K.H.s.s.R.K.K.K.$+                                        m+9+9+|+9+6+9+6+6+c+6+6+9+9+6+                        &quot;,
+&quot;                                            ( (               ;               ;+v.$+s.R.v.H.R.K.K.R.s.R.                                        E+9+|+9+6+6+c+6+c+6+6+9+9+6+6+t+                        &quot;,
+&quot;                                            ( }             &amp; ;             /+5.v.v.v.s.H.R.H.H.s.K.R.5+                                        i+9+|+9+9+6+6+6+c+6+6+6+9+6+9+                          &quot;,
+&quot;                                            ( }             - ;           /+q.s.s.s.E.H.v.K.v.R.K.R.$+                                        y+|+|+9+9+|+9+c+6+6+c+9+9+|+9+x+                          &quot;,
+&quot;                                            ( 2 0           - ;         D.d.q.q.E.v.v.s.s.H.s.R.v.$+                                          9+9+|+|+9+6+6+9+c+6+6+6+c+6+9+                            &quot;,
+&quot;                                            } 0 0           ; ;       3.q.b.q.q.s.E.s.H.H.v.K.v.H.5+                                        r+9+|+9+9+6+c+9+6+6+c+9+9+|+|+x+                            &quot;,
+&quot;                                            } 0 d d         ; &lt;   N.5.3.q.q.q.q.s.E.E.E.s.v.s.H.5+                                        D+9+9+|+9+9+6+c+9+6+|+6+9+9+9+9+                              &quot;,
+&quot;                                            } 2 s s s M w.w.e @.{.^.3.3.b.d.q.q.q.s.v.v.s.H.s.$+                                          i+9+|+9+|+c+6+|+6+9+9+9+9+6+|+y+                              &quot;,
+&quot;                                            0 0 d s C M V V V ^.^.5.5.5.3.d.q.q.q.q.s.v.E.R.E.                                          r+9+c+|+9+|+9+c+c+|+|+9+6+9+6+i+                                &quot;,
+&quot;                                            2 2 s w C C V V %.{.{.5.b.5.q.3.d.q.q.s.E.E.v.s.q+                                        w+9+9+9+9+9+9+|+|+|+9+9+|+9+|+9+E+                                &quot;,
+&quot;                                            0 0 d w C C S V V {.%.#.3.5.d.d.d.q.q.s.s.E.E.q+                                        E+c+9+9+c+9+c+9+|+9+|+9+9+9+9+|+i+                                  &quot;,
+&quot;                                            } d s s C M V S %.%.^.3.3.3.3.3.d.d.q.d.q.s./+                                          i+!+c+9+9+9+|+9+9+|+9+|+9+|+|+9+G+                                  &quot;,
+&quot;                                            0 d d e M M V S {.{.^.3.3.d.d.D.d.d.q.q.v./+                                          r+[+|+{+9+c+9+9+9+9+9+9+|+9+9+9+B+                                    &quot;,
+&quot;                                              d s s s V S V S %.{.{.5.3.3.d.d.q.q.q./+                                          o+[+!+c+9+|+9+c+9+c+9+c+9+9+|+9+m+                                      &quot;,
+&quot;                                              0 s C s V V %.V {.^.{.5.5.3.3.D.d.q./+                                          n+{+[+{+[+c+c+|+9+9+9+|+9+c+9+|+|+G+                                      &quot;,
+&quot;                                              d w s M M M V %.%.{.3.{.3.d.d.d.q./+                                          w+[+[+{+&amp;+{+{+{+9+c+9+c+9+c+|+9+c+B+                                        &quot;,
+&quot;                                                w s @.S S S %.%.{.5.5.^.3.b.D.                                            <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">G+ at +</A>[+[+[+c+[+&lt;+[+9+c+|+c+9+9+c+|+m+                                          &quot;,
+&quot;                                                w s C M V V S %.^.{.{.3.5.N.                                            <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">C+ at +</A>[+{+&amp;+{+&amp;+&lt;+[+{+{+{+9+9+9+c+9+c+G+                                          &quot;,
+&quot;                                                  w M M S V {.V ^.5.5.{.                                              <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">w+,+,+ at +</A>[+[+{+[+{+c+9+&lt;+[+9+9+9+9+{+D+                                            &quot;,
+&quot;                                                      M @.V V {.{.#.++                                              <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">w+ at +</A>@<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>[+{+[+[+{+[+&amp;+[+[+{+c+{+{+{+x+                                              &quot;,
+&quot;                                                          w.&gt;.p t b ).                                            <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">8+ at +</A>,+[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+ at +</A>{+[+[+&amp;+{+{+{+[+!+[+9+9+b+                                                &quot;,
+&quot;                                                            +.b b n u %+                                        2+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+ at +Q.</A>@+[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>,+[+[+[+[+[+&lt;+[+&lt;+{+i+                                                  &quot;,
+&quot;                                                              b b k u u                                     u+M.M.#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A><A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">,+ at +</A>[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>[+{+[+[+{+[+[+[+[+{+z+                                                  &quot;,
+&quot;                                                              b b n u u /.                              A+2+M.#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+ at +</A>@+,+,+[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>,+[+{+[+{+{+[+&lt;+w+                                                    &quot;,
+&quot;                                                              t k k F u P /.7+                      A+e+z.#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +M.</A>#+#+,+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +Q.</A>[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>@+,+{+&amp;+[+{+[+B+                                                      &quot;,
+&quot;                                                              Y n u u E Q U U T.7+              f+4+I.M.&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+M.M.Y. at +M.</A>@+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A><A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">,+ at +</A>@+[+[+[+[+[+[+[+n+                                                        &quot;,
+&quot;                                                                k n F Q Q U  .=._.8.G.(+(+)+g.i.z.r.I.M.I.&gt;+I.#+#+#+#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+,+Q.,+ at +</A><A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">,+ at +</A>{+{+o+                                                          &quot;,
+&quot;                                                                k u u E U U U =.=._.2.g.i.i.i.A.r.z.z.I.M.Y.#+&gt;+#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+Q. at +</A>@<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>@+,+[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>[+,+s+                                                            &quot;,
+&quot;                                                                ).n E E P U =.=.=.8._._.g.g.i.i.A.A.z.I.z.M.Y.M.M.M.#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+ at +</A>@<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>[<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+ at +g+</A>                                                              &quot;,
+&quot;                                                                  u u Q U U U =._._.2.g.g.g.A.A.A.z.A.z.M.I.I.Y.#+#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+,+,+,+,+ at +o+</A>                                                                &quot;,
+&quot;                                                                  ).F Q U U =.=.=.8._.2.2.g.r.r.r.I.I.I.z.M.I.M.#+M.#+#+#+#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>@<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>,+w+                                                                  &quot;,
+&quot;                                                                    Q Q P U U =._._.2._.g.g.g.i.A.A.A.A.I.I.M.X.M.#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>#<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>@<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>,+#+z+                                                                    &quot;,
+&quot;                                                                    u.U /.U U 8._.8._.2.2.g.g.i.A.A.I.z.I.I.M.I.Y.&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">+ at +</A>#+#+#+#+#+A+                                                                      &quot;,
+&quot;                                                                      ].U U =.=.=.2.2._.g.i.i.A.i.A.A.I.z.I.&gt;+Y.&gt;+Y.Y.#+#+#+n+                                                                          &quot;,
+&quot;                                                                        /.U  .=.=._._.2.2.g.i.A.A.z.A.I.I.M.I.M.M.M.M.Y.M.z+                                                                            &quot;,
+&quot;                                                                          /.=.8._._.2._.g.g.g.g.i.A.z.A.z.I.I.Y.I.X.#+8+                                                                                &quot;,
+&quot;                                                                            /.8.8._._.2.2.i.i.A.i.A.z.z.I.I.I.M.M.8+A+                                                                                  &quot;,
+&quot;                                                                              }+8._.2.2.g.2.A.i.A.A.A.&gt;+z.z.z.4+A+                                                                                      &quot;,
+&quot;                                                                                  T.)+_.g.2.A.r.A.A.r.A.4+z+                                                                                            &quot;,
+&quot;                                                                                        }+}+(+(+f+f+A+                                                                                                  &quot;,
+&quot;                                                                                                                                                                                                        &quot;,
+&quot;                                                                                                                                                                                                        &quot;};

Added: trunk/lib/QGLViewer/qglviewer.cpp
===================================================================
--- trunk/lib/QGLViewer/qglviewer.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/qglviewer.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,4055 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;qglviewer.h&quot;
+#include &quot;camera.h&quot;
+#include &quot;keyFrameInterpolator.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QtAlgorithms&gt;
+# include &lt;QTextEdit&gt;
+# include &lt;QApplication&gt;
+# include &lt;QFileInfo&gt;
+# include &lt;QDateTime&gt;
+# include &lt;QMessageBox&gt;
+# include &lt;QPushButton&gt;
+# include &lt;QTabWidget&gt;
+# include &lt;QTextStream&gt;
+# include &lt;QMouseEvent&gt;
+# include &lt;QTimer&gt;
+# include &lt;QImage&gt;
+# include &lt;QDir&gt;
+#else
+# include &lt;qapplication.h&gt;
+# include &lt;qfileinfo.h&gt;
+# include &lt;qdatetime.h&gt;
+# include &lt;qmessagebox.h&gt;
+# include &lt;qpushbutton.h&gt;
+# include &lt;qtabwidget.h&gt;
+# include &lt;qtextstream.h&gt;
+# include &lt;qtimer.h&gt;
+# include &lt;qimage.h&gt;
+# include &lt;qdir.h&gt;
+// Patch for enums names change
+# define KeyboardModifierMask KeyButtonMask
+// Patch for QMap API change
+# define value data
+# if QT_VERSION &gt;= 0x030000
+#  include &lt;qtextedit.h&gt;
+#  include &lt;qkeysequence.h&gt;
+# else
+#  include &lt;qtextview.h&gt;
+   typedef QTextView QTextEdit;
+#  include &lt;qtextstream.h&gt;
+#  include &lt;algorithm&gt;
+#  include &quot;keySequence.h&quot;
+# endif
+#endif
+
+using namespace std;
+using namespace qglviewer;
+
+// Static private variable
+#if QT_VERSION &gt;= 0x040000
+  QList&lt;QGLViewer*&gt; QGLViewer::QGLViewerPool_;
+#else
+  QPtrList&lt;QGLViewer&gt; QGLViewer::QGLViewerPool_;
+#endif
+
+/*! \mainpage
+
+libQGLViewer is a free C++ library based on Qt that enables the quick creation of OpenGL 3D viewers.
+It features a powerful camera trackball and simple applications simply require an implementation of
+the &lt;code&gt;draw()&lt;/code&gt; method. This makes it a tool of choice for OpenGL beginners and
+assignments. It provides screenshot saving, mouse manipulated frames, stereo display, interpolated
+keyFrames, object selection, and much
+&lt;a href=&quot;<A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/features.html">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/features.html</A>&quot;&gt;more&lt;/a&gt;. It is fully
+customizable and easy to extend to create complex applications, with a possible Qt GUI.
+
+libQGLViewer is &lt;i&gt;not&lt;/i&gt; a 3D viewer that can be used directly to view 3D scenes in various
+formats. It is more likely to be the starting point for the coding of such a viewer.
+
+libQGLViewer is based on the Qt toolkit and hence compiles on any architecture (Unix-Linux, Mac,
+Windows, ...). Full &lt;a
+href=&quot;<A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/refManual/hierarchy.html">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/refManual/hierarchy.html</A>&quot;&gt;reference
+documentation&lt;/a&gt; and many &lt;a
+href=&quot;<A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/examples/index.html">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer/examples/index.html</A>&quot;&gt;examples&lt;/a&gt; are
+provided.
+
+See the &lt;a href=&quot;<A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>&quot;&gt;project main page&lt;/a&gt; for
+details on the project and installation steps. */
+
+void QGLViewer::defaultConstructor()
+{
+  //      - - -  W A R N I N G  - - -
+  // This method should not call initializeGL(). Otherwise, as we are in the
+  // base class constructor, the user-defined init() would never be called.
+  // The different QGLViewer::setXXX are hence protected, so that updateGL is not called.
+  // The different constructor code should then be EMPTY.
+  updateGLOK_ = false;
+
+  // Test OpenGL context
+  // if (glGetString(GL_VERSION) == 0)
+    // qWarning(&quot;Unable to get OpenGL version, context may not be available - Check your configuration&quot;);
+
+  QGLViewer::QGLViewerPool_.append(this);
+
+  camera_ = new Camera();
+  setCamera(camera());
+
+#if QT_VERSION &gt;= 0x040000
+  setFocusPolicy(Qt::StrongFocus);
+#else
+  setFocusPolicy(QWidget::StrongFocus);
+#endif
+
+  setDefaultShortcuts();
+  setDefaultMouseBindings();
+
+  setSnapshotFileName(&quot;snapshot&quot;);
+  initializeSnapshotFormats();
+  setSnapshotCounter(0);
+  setSnapshotQuality(95);
+
+  fpsTime_.start();
+  fpsCounter_		= 0;
+  f_p_s_		= 0.0;
+  fpsString_		= &quot;?Hz&quot;;
+  visualHint_		= 0;
+  previousPathId_	= 0;
+  // prevPos_ is not initialized since pos() is not meaningful here. It will be set by setFullScreen().
+
+  // #CONNECTION# default values in initFromDOMElement()
+  manipulatedFrame_ = NULL;
+  manipulatedFrameIsACamera_ = false;
+  mouseGrabberIsAManipulatedFrame_ = false;
+  mouseGrabberIsAManipulatedCameraFrame_ = false;
+  displayMessage_ = false;
+  connect(&amp;messageTimer_, SIGNAL(timeout()), SLOT(hideMessage()));
+#if QT_VERSION &gt;= 0x040000
+  messageTimer_.setSingleShot(true);
+#endif
+  helpWidget_ = NULL;
+  setMouseGrabber(NULL);
+
+  setSceneRadius(1.0);
+  showEntireScene();
+  setStateFileName(&quot;.qglviewer.xml&quot;);
+
+  // #CONNECTION# default values in initFromDOMElement()
+  setAxisIsDrawn(false);
+  setGridIsDrawn(false);
+  setFPSIsDisplayed(false);
+  setCameraIsEdited(false);
+  setTextIsEnabled(true);
+  setStereoDisplay(false);
+  setFullScreen(false);
+
+  animationTimerId_ = 0;
+  stopAnimation();
+  setAnimationPeriod(40); // 25Hz
+
+  selectBuffer_ = NULL;
+  setSelectBufferSize(4*1000);
+  setSelectRegionWidth(3);
+  setSelectRegionHeight(3);
+  setSelectedName(-1);
+
+  bufferTextureId_ = 0;
+  bufferTextureMaxU_ = 0.0;
+  bufferTextureMaxV_ = 0.0;
+  bufferTextureWidth_ = 0;
+  bufferTextureHeight_ = 0;
+  previousBufferTextureFormat_ = 0;
+  previousBufferTextureInternalFormat_ = 0;
+
+#if QT_VERSION &gt;= 0x040000
+  setAttribute(Qt::WA_NoSystemBackground);
+#endif
+}
+
+#if QT_VERSION &gt;= 0x040000
+/*! Constructor. See \c QGLWidget documentation for details.
+
+ All viewer parameters (display flags, scene parameters, associated objects...) are set to their default values. See
+ the associated documentation.
+
+ If the \p shareWidget parameter points to a valid \c QGLWidget, the QGLViewer will share the OpenGL
+ context with \p shareWidget (see isSharing()). */
+QGLViewer::QGLViewer(QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
+  : QGLWidget(parent, shareWidget, flags)
+{ defaultConstructor(); }
+
+/*! Same as QGLViewer(), but a \c QGLContext can be provided so that viewers share GL contexts, even
+ with \c QGLContext sub-classes (use \p shareWidget otherwise).
+
+ \note This constructor is correctly working only with Qt versions greater or equal than 3.2. The
+ provided \p context is simply ignored otherwise. */
+QGLViewer::QGLViewer(QGLContext *context, QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
+  : QGLWidget(context, parent, shareWidget, flags)
+{ defaultConstructor(); }
+
+/*! Same as QGLViewer(), but a specific \c QGLFormat can be provided.
+
+This is for instance needed to ask for a stencil buffer or for stereo display (as is illustrated in
+the &lt;a href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt;). */
+QGLViewer::QGLViewer(const QGLFormat&amp; format, QWidget* parent, const QGLWidget* shareWidget, Qt::WFlags flags)
+  : QGLWidget(format, parent, shareWidget, flags)
+{ defaultConstructor(); }
+#endif
+
+/*! Virtual destructor.
+
+Removes viewer from QGLViewerPool() and releases allocated memory. The camera() is deleted and
+should be copied before if it is shared. */
+QGLViewer::~QGLViewer()
+{
+  // See closeEvent comment. Destructor is called (and not closeEvent) only when the widget is embedded.
+  // Hence we saveToFile here. It is however a bad idea if virtual domElement() has been overloaded !
+  // if (parent())
+    // saveStateToFileForAllViewers();
+#if QT_VERSION &gt;= 0x040000
+  QGLViewer::QGLViewerPool_.removeAll(this);
+#else
+  QGLViewer::QGLViewerPool_.removeRef(this);
+#endif
+
+  delete camera();
+  delete[] selectBuffer_;
+  if (helpWidget())
+    {
+      // Needed for Qt 4 which has no main widget.
+      helpWidget()-&gt;close();
+      delete helpWidget_;
+    }
+}
+
+
+static QString QGLViewerVersionString()
+{
+  return QString::number((QGLVIEWER_VERSION &amp; 0xff0000) &gt;&gt; 16) + &quot;.&quot; +
+    QString::number((QGLVIEWER_VERSION &amp; 0x00ff00) &gt;&gt; 8) + &quot;.&quot; +
+    QString::number(QGLVIEWER_VERSION &amp; 0x0000ff);
+}
+
+static int convertToKeyboardModifiers(int state)
+{
+#if QT_VERSION &lt; 0x040000
+  // Qt 2 &amp; 3 have different values for ButtonState and Modifiers.
+  // Converts CTRL,SHIFT... to ControlButton, ShiftButton...
+  if (state &amp; Qt::MODIFIER_MASK)
+    {
+      if (state &amp; Qt::CTRL)  { state &amp;= ~Qt::CTRL;	state |= Qt::ControlButton; }
+      if (state &amp; Qt::SHIFT) { state &amp;= ~Qt::SHIFT;	state |= Qt::ShiftButton; }
+      if (state &amp; Qt::ALT)   { state &amp;= ~Qt::ALT; 	state |= Qt::AltButton; }
+# if QT_VERSION &gt;= 0x030100
+      if (state &amp; Qt::META)  { state &amp;= ~Qt::META; 	state |= Qt::MetaButton; }
+# endif
+    }
+#endif
+  return state;
+}
+
+static QtKeyboardModifiers convertKeyboardModifiers(QtKeyboardModifiers modifiers)
+{
+#if QT_VERSION &lt; 0x040000
+  return QtKeyboardModifiers(convertToKeyboardModifiers(modifiers));
+#else
+  return modifiers;
+#endif
+}
+
+static int convertToShortModifier(int state)
+{
+  // Converts ControlButton, ShiftButton... to CTRL,SHIFT...
+  // convertToKeyboardModifiers does the opposite
+#if QT_VERSION &lt; 0x040000
+  if (state &amp; Qt::KeyButtonMask)
+    {
+      if (state &amp; Qt::ControlButton) { state &amp;= ~Qt::ControlButton;	state |= Qt::CTRL; }
+      if (state &amp; Qt::ShiftButton)   { state &amp;= ~Qt::ShiftButton;	state |= Qt::SHIFT; }
+      if (state &amp; Qt::AltButton)     { state &amp;= ~Qt::AltButton;		state |= Qt::ALT; }
+# if QT_VERSION &gt;= 0x030100
+      if (state &amp; Qt::MetaButton)    { state &amp;= ~Qt::MetaButton; 	state |= Qt::META; }
+# endif
+    }
+#endif
+  return state;
+}
+
+/*! Opens an about dialog.
+
+Default implementation displays libQGLViewer version, copyright notice and web site. */
+void QGLViewer::aboutQGLViewer()
+{
+  QMessageBox mb(&quot;About libQGLViewer&quot;,
+		 QString(&quot;libQGLViewer, version &quot;)+QGLViewerVersionString()+QString(&quot;.&lt;br&gt;&quot;
+		 &quot;A versatile 3D viewer based on OpenGL and Qt.&lt;br&gt;&quot;
+		 &quot;Copyright 2002-2007 Gilles Debunne.&lt;br&gt;&quot;
+		 &quot;&lt;code&gt;<A HREF="http://artis.imag.fr/Software/QGLViewer&lt;/code">http://artis.imag.fr/Software/QGLViewer&lt;/code</A>&gt;&quot;),
+		 QMessageBox::Information,
+		 QMessageBox::Ok,
+		 QMessageBox::NoButton,
+		 QMessageBox::NoButton,
+		 this);
+
+#include &quot;qglviewer-icon.xpm&quot;
+  QPixmap pixmap(qglviewer_icon);
+  mb.setIconPixmap(pixmap);
+  mb.setTextFormat(Qt::RichText);
+  mb.exec();
+}
+
+/*! Initializes the QGLViewer OpenGL context and then calls user-defined init().
+
+ This method is automatically called once, before the first call to paintGL().
+
+ Overload init() instead of this method to modify viewer specific OpenGL state or to create display
+ lists.
+
+ To make beginners' life easier and to simplify the examples, this method slightly modifies the
+ standard OpenGL state:
+ \code
+ glEnable(GL_LIGHT0);
+ glEnable(GL_LIGHTING);
+ glEnable(GL_DEPTH_TEST);
+ glEnable(GL_COLOR_MATERIAL);
+ \endcode
+
+ If you port an existing application to QGLViewer and your display changes, you probably want to
+ disable these flags in init() to get back to a standard OpenGL state. */
+void QGLViewer::initializeGL()
+{
+  if (updateGLOK_)
+    qWarning(&quot;Internal debug: initializeGL() is called in QGLViewer constructor.&quot;);
+
+  glEnable(GL_LIGHT0);
+  glEnable(GL_LIGHTING);
+  glEnable(GL_DEPTH_TEST);
+  glEnable(GL_COLOR_MATERIAL);
+
+  // Default colors
+  setForegroundColor(QColor(180, 180, 180));
+  setBackgroundColor(QColor(51, 51, 51));
+
+  // Clear the buffer where we're going to draw
+  if (format().stereo())
+    {
+      glDrawBuffer(GL_BACK_RIGHT);
+      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+      glDrawBuffer(GL_BACK_LEFT);
+      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+    }
+  else
+    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  // Calls user defined method. Default emits a signal.
+  init();
+
+  // Give time to glInit to finish and then call setFullScreen().
+  if (isFullScreen())
+    QTimer::singleShot( 100, this, SLOT(delayedFullScreen()) );
+
+  updateGLOK_ = true;
+}
+
+/*! Main paint method, inherited from \c QGLWidget.
+
+ Calls the following methods, in that order:
+ \arg preDraw() (or preDrawStereo() if viewer displaysInStereo()) : places the camera in the world coordinate system.
+ \arg draw() (or fastDraw() when the camera is manipulated) : main drawing method. Should be overloaded.
+ \arg postDraw() : display of visual hints (world axis, FPS...) */
+void QGLViewer::paintGL()
+{
+  updateGLOK_ = false;
+  if (displaysInStereo())
+    {
+      for (int view=1; view&gt;=0; --view)
+	{
+	  // Clears screen, set model view matrix with shifted matrix for ith buffer
+	  preDrawStereo(view);
+	  // Used defined method. Default is empty
+	  if (camera()-&gt;frame()-&gt;isManipulated())
+	    fastDraw();
+	  else
+	    draw();
+	  postDraw();
+	}
+    }
+  else
+    {
+      // Clears screen, set model view matrix...
+      preDraw();
+      // Used defined method. Default calls draw()
+      if (camera()-&gt;frame()-&gt;isManipulated())
+	fastDraw();
+      else
+	draw();
+      // Add visual hints: axis, camera, grid...
+      postDraw();
+    }
+  updateGLOK_ = true;
+  emit drawFinished(true);
+}
+
+/*! Sets OpenGL state before draw().
+
+ Default behavior clears screen and sets the projection and modelView matrices:
+ \code
+ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+ camera()-&gt;loadProjectionMatrix();
+ camera()-&gt;loadModelViewMatrix();
+ \endcode
+
+ Emits the drawNeeded() signal once this is done (see the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt;). */
+void QGLViewer::preDraw()
+{
+  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  // GL_PROJECTION matrix
+  camera()-&gt;loadProjectionMatrix();
+  // GL_MODELVIEW matrix
+  camera()-&gt;loadModelViewMatrix();
+
+  emit drawNeeded();
+}
+
+/*! Called after draw() to draw viewer visual hints.
+
+ Default implementation displays axis, grid, FPS... when the respective flags are sets.
+
+ See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
+ href=&quot;../examples/contribs.html#thumbnail&quot;&gt;thumbnail&lt;/a&gt; examples for an overloading illustration.
+
+ The GLContext (color, LIGHTING, BLEND...) should \e not be modified by this method, so that in
+ draw(), the user can rely on the OpenGL context. Respect this convention (by pushing/popping the
+ different attributes) if you overload this method. */
+void QGLViewer::postDraw()
+{
+  // Reset model view matrix to world coordinates origin
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix();
+  camera()-&gt;loadModelViewMatrix();
+  // TODO restore model loadProjectionMatrixStereo
+
+  // Save OpenGL state
+  glPushAttrib(GL_ALL_ATTRIB_BITS);
+
+  // Set neutral GL state
+  glDisable(GL_TEXTURE_1D);
+  glDisable(GL_TEXTURE_2D);
+#ifdef GL_TEXTURE_3D  // OpenGL 1.2 Only...
+  glDisable(GL_TEXTURE_3D);
+#endif
+
+  glDisable(GL_TEXTURE_GEN_Q);
+  glDisable(GL_TEXTURE_GEN_R);
+  glDisable(GL_TEXTURE_GEN_S);
+  glDisable(GL_TEXTURE_GEN_T);
+
+#ifdef GL_RESCALE_NORMAL  // OpenGL 1.2 Only...
+  glEnable(GL_RESCALE_NORMAL);
+#endif
+
+  glDisable(GL_COLOR_MATERIAL);
+  qglColor(foregroundColor());
+
+  if (cameraIsEdited())
+    camera()-&gt;drawAllPaths();
+
+  // Revolve Around Point, line when camera rolls, zoom region
+  drawVisualHints();
+
+  if (gridIsDrawn()) { glLineWidth(1.0); drawGrid(camera()-&gt;sceneRadius()); }
+  if (axisIsDrawn()) { glLineWidth(2.0); drawAxis(camera()-&gt;sceneRadius()); }
+
+  // FPS computation
+  const unsigned int maxCounter = 20;
+  if (++fpsCounter_ == maxCounter)
+    {
+      f_p_s_ = 1000.0 * maxCounter / fpsTime_.restart();
+      fpsString_ = QString(&quot;%1Hz&quot;).arg(f_p_s_, 0, 'f', ((f_p_s_ &lt; 10.0)?1:0));
+      fpsCounter_ = 0;
+    }
+
+  // Restore foregroundColor
+  float color[4];
+  color[0] = foregroundColor().red()   / 255.0;
+  color[1] = foregroundColor().green() / 255.0;
+  color[2] = foregroundColor().blue()  / 255.0;
+  color[3] = 1.0;
+  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+  glDisable(GL_LIGHTING);
+
+  if (FPSIsDisplayed()) displayFPS();
+  if (displayMessage_) drawText(10, height()-10,  message_);
+
+  // Restore GL state
+  glPopAttrib();
+  glPopMatrix();
+}
+
+/*! Called before draw() (instead of preDraw()) when viewer displaysInStereo().
+
+ Same as preDraw() except that the glDrawBuffer() is set to \c GL_BACK_LEFT or \c GL_BACK_RIGHT
+ depending on \p leftBuffer, and it uses qglviewer::Camera::loadProjectionMatrixStereo() and
+ qglviewer::Camera::loadModelViewMatrixStereo() instead. */
+void QGLViewer::preDrawStereo(bool leftBuffer)
+{
+  // Set buffer to draw in
+  // Seems that SGI and Crystal Eyes are not synchronized correctly !
+  // That's why we don't draw in the appropriate buffer...
+  if (!leftBuffer)
+    glDrawBuffer(GL_BACK_LEFT);
+  else
+    glDrawBuffer(GL_BACK_RIGHT);
+
+  // Clear the buffer where we're going to draw
+  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+  // GL_PROJECTION matrix
+  camera()-&gt;loadProjectionMatrixStereo(leftBuffer);
+  // GL_MODELVIEW matrix
+  camera()-&gt;loadModelViewMatrixStereo(leftBuffer);
+
+  emit drawNeeded();
+}
+
+/*! Draws a simplified version of the scene to guarantee interactive camera displacements.
+
+ This method is called instead of draw() when the qglviewer::Camera::frame() is
+ qglviewer::ManipulatedCameraFrame::isManipulated(). Default implementation simply calls draw().
+
+ Overload this method if your scene is too complex to allow for interactive camera manipulation. See
+ the &lt;a href=&quot;../examples/fastDraw.html&quot;&gt;fastDraw example&lt;/a&gt; for an illustration. */
+void QGLViewer::fastDraw()
+{
+  draw();
+}
+
+/*! Starts (\p edit = \c true, default) or stops (\p edit=\c false) the edition of the camera().
+
+ Current implementation is limited to paths display. Get current state using cameraIsEdited().
+
+ \attention This method sets the qglviewer::Camera::zClippingCoefficient() to 5.0 when \p edit is \c
+ true, so that the Camera paths (see qglviewer::Camera::keyFrameInterpolator()) are not clipped. It
+ restores the previous value when \p edit is \c false. */
+void QGLViewer::setCameraIsEdited(bool edit)
+{
+  cameraIsEdited_ = edit;
+  if (edit)
+    {
+      previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
+      // #CONNECTION# 5.0 also used in domElement() and in initFromDOMElement().
+      camera()-&gt;setZClippingCoefficient(5.0);
+    }
+  else
+    camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
+
+  emit cameraIsEditedChanged(edit);
+
+  if (updateGLOK_)
+    updateGL();
+}
+
+// Key bindings. 0 means not defined
+void QGLViewer::setDefaultShortcuts()
+{
+  // D e f a u l t   a c c e l e r a t o r s
+  setShortcut(DRAW_AXIS,	Qt::Key_A);
+  setShortcut(DRAW_GRID,	Qt::Key_G);
+  setShortcut(DISPLAY_FPS,	Qt::Key_F);
+  setShortcut(ENABLE_TEXT,	Qt::SHIFT+Qt::Key_Question);
+  setShortcut(EXIT_VIEWER,	Qt::Key_Escape);
+  setShortcut(SAVE_SCREENSHOT,	Qt::CTRL+Qt::Key_S);
+  setShortcut(CAMERA_MODE,	Qt::Key_Space);
+  setShortcut(FULL_SCREEN,	Qt::ALT+Qt::Key_Return);
+  setShortcut(STEREO,		Qt::Key_S);
+  setShortcut(ANIMATION,	Qt::Key_Return);
+  setShortcut(HELP,		Qt::Key_H);
+  setShortcut(EDIT_CAMERA,	Qt::Key_C);
+  setShortcut(MOVE_CAMERA_LEFT,	Qt::Key_Left);
+  setShortcut(MOVE_CAMERA_RIGHT,Qt::Key_Right);
+  setShortcut(MOVE_CAMERA_UP,	Qt::Key_Up);
+  setShortcut(MOVE_CAMERA_DOWN,	Qt::Key_Down);
+  setShortcut(INCREASE_FLYSPEED,Qt::Key_Plus);
+  setShortcut(DECREASE_FLYSPEED,Qt::Key_Minus);
+
+  keyboardActionDescription_[DISPLAY_FPS] = 		&quot;Toggles the display of the FPS&quot;;
+  keyboardActionDescription_[SAVE_SCREENSHOT] = 	&quot;Saves a screenshot&quot;;
+  keyboardActionDescription_[FULL_SCREEN] = 		&quot;Toggles full screen display&quot;;
+  keyboardActionDescription_[DRAW_AXIS] = 		&quot;Toggles the display of the world axis&quot;;
+  keyboardActionDescription_[DRAW_GRID] = 		&quot;Toggles the display of the XY grid&quot;;
+  keyboardActionDescription_[CAMERA_MODE] = 		&quot;Changes camera mode (revolve or fly)&quot;;
+  keyboardActionDescription_[STEREO] = 			&quot;Toggles stereo display&quot;;
+  keyboardActionDescription_[HELP] = 			&quot;Opens this help window&quot;;
+  keyboardActionDescription_[ANIMATION] = 		&quot;Starts/stops the animation&quot;;
+  keyboardActionDescription_[EDIT_CAMERA] = 		&quot;Toggles camera paths display&quot;; // TODO change
+  keyboardActionDescription_[ENABLE_TEXT] = 		&quot;Toggles the display of the text&quot;;
+  keyboardActionDescription_[EXIT_VIEWER] =		&quot;Exits program&quot;;
+  keyboardActionDescription_[MOVE_CAMERA_LEFT] = 	&quot;Moves camera left&quot;;
+  keyboardActionDescription_[MOVE_CAMERA_RIGHT] = 	&quot;Moves camera right&quot;;
+  keyboardActionDescription_[MOVE_CAMERA_UP] = 		&quot;Moves camera up&quot;;
+  keyboardActionDescription_[MOVE_CAMERA_DOWN] = 	&quot;Moves camera down&quot;;
+  keyboardActionDescription_[INCREASE_FLYSPEED] = 	&quot;Increases fly speed&quot;;
+  keyboardActionDescription_[DECREASE_FLYSPEED] = 	&quot;Decreases fly speed&quot;;
+
+  // K e y f r a m e s   s h o r t c u t   k e y s
+  setPathKey(Qt::Key_F1,   1);
+  setPathKey(Qt::Key_F2,   2);
+  setPathKey(Qt::Key_F3,   3);
+  setPathKey(Qt::Key_F4,   4);
+  setPathKey(Qt::Key_F5,   5);
+  setPathKey(Qt::Key_F6,   6);
+  setPathKey(Qt::Key_F7,   7);
+  setPathKey(Qt::Key_F8,   8);
+  setPathKey(Qt::Key_F9,   9);
+  setPathKey(Qt::Key_F10, 10);
+  setPathKey(Qt::Key_F11, 11);
+  setPathKey(Qt::Key_F12, 12);
+
+#if QT_VERSION &gt;= 0x040000
+  setAddKeyFrameKeyboardModifiers(Qt::AltModifier);
+  setPlayPathKeyboardModifiers(Qt::NoModifier);
+#else
+  setAddKeyFrameKeyboardModifiers(Qt::AltButton);
+  setPlayPathKeyboardModifiers(Qt::NoButton);
+#endif
+}
+
+// M o u s e   b e h a v i o r
+void QGLViewer::setDefaultMouseBindings()
+{
+#if QT_VERSION &gt;= 0x040000
+  const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlModifier;
+#else
+  const QtKeyboardModifiers frameKeyboardModifiers = Qt::ControlButton;
+#endif
+  //#CONNECTION# toggleCameraMode()
+  for (int handler=0; handler&lt;2; ++handler)
+    {
+      MouseHandler mh = (MouseHandler)(handler);
+#if QT_VERSION &gt;= 0x040000
+      QtKeyboardModifiers modifiers = Qt::NoModifier;
+#else
+      QtKeyboardModifiers modifiers = Qt::NoButton;
+#endif
+      if (mh == FRAME)
+	modifiers = frameKeyboardModifiers;
+
+      setMouseBinding(modifiers | Qt::LeftButton,  mh, ROTATE);
+      setMouseBinding(modifiers | Qt::MidButton,   mh, ZOOM);
+      setMouseBinding(modifiers | Qt::RightButton, mh, TRANSLATE);
+
+      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  mh, SCREEN_ROTATE);
+      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  mh, SCREEN_TRANSLATE);
+
+      setWheelBinding(modifiers, mh, ZOOM);
+    }
+
+#if QT_VERSION &gt;= 0x040000
+  // Z o o m   o n   r e g i o n
+  setMouseBinding(Qt::ShiftModifier | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
+  // S e l e c t
+  setMouseBinding(Qt::ShiftModifier | Qt::LeftButton, SELECT);
+#else
+  setMouseBinding(Qt::ShiftButton | Qt::MidButton, CAMERA, ZOOM_ON_REGION);
+  setMouseBinding(Qt::ShiftButton | Qt::LeftButton, SELECT);
+#endif
+
+
+  // D o u b l e   c l i c k
+  setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
+  setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
+  setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
+
+  setMouseBinding(frameKeyboardModifiers | Qt::LeftButton,  ALIGN_FRAME,  true);
+  setMouseBinding(frameKeyboardModifiers | Qt::RightButton, CENTER_FRAME, true);
+
+  // S p e c i f i c   d o u b l e   c l i c k s
+  setMouseBinding(Qt::LeftButton,  RAP_FROM_PIXEL, true, Qt::RightButton);
+  setMouseBinding(Qt::RightButton, RAP_IS_CENTER,  true, Qt::LeftButton);
+  setMouseBinding(Qt::LeftButton,  ZOOM_ON_PIXEL,  true, Qt::MidButton);
+  setMouseBinding(Qt::RightButton, ZOOM_TO_FIT,    true, Qt::MidButton);
+}
+
+/*! Associates a new qglviewer::Camera to the viewer.
+
+You should only use this method when you derive a new class from qglviewer::Camera and want to use
+one of its instances instead of the original class.
+
+It you simply want to save and restore Camera positions, use qglviewer::Camera::addKeyFrameToPath()
+and qglviewer::Camera::playPath() instead.
+
+This method silently ignores NULL \p camera pointers. The calling method is responsible for deleting
+the previous camera pointer in order to prevent memory leaks if needed.
+
+The sceneRadius() and sceneCenter() of \p camera are set to the \e current QGLViewer values.
+
+All the \p camera qglviewer::Camera::keyFrameInterpolator()
+qglviewer::KeyFrameInterpolator::interpolated() signals are connected to the viewer updateGL() slot.
+The connections with the previous viewer's camera are removed. */
+void QGLViewer::setCamera(Camera* const camera)
+{
+  if (!camera)
+    return;
+
+  camera-&gt;setSceneRadius(sceneRadius());
+  camera-&gt;setSceneCenter(sceneCenter());
+  camera-&gt;setScreenWidthAndHeight(width(),height());
+
+  // Disconnect current camera to this viewer.
+  disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
+  disconnect(this-&gt;camera()-&gt;frame(), SIGNAL(spun()), this, SLOT(updateGL()));
+
+  // Connect camera frame to this viewer.
+  connect(camera-&gt;frame(), SIGNAL(manipulated()), SLOT(updateGL()));
+  connect(camera-&gt;frame(), SIGNAL(spun()), SLOT(updateGL()));
+
+  connectAllCameraKFIInterpolatedSignals(false);
+  camera_ = camera;
+  connectAllCameraKFIInterpolatedSignals();
+
+  previousCameraZClippingCoefficient_ = this-&gt;camera()-&gt;zClippingCoefficient();
+}
+
+void QGLViewer::connectAllCameraKFIInterpolatedSignals(bool connection)
+{
+  for (QMap&lt;int, KeyFrameInterpolator*&gt;::ConstIterator it = camera()-&gt;kfi_.begin(), end=camera()-&gt;kfi_.end(); it != end; ++it)
+    {
+      if (connection)
+	connect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), SLOT(updateGL()));
+      else
+	disconnect(camera()-&gt;keyFrameInterpolator(it.key()), SIGNAL(interpolated()), this, SLOT(updateGL()));
+    }
+
+  if (connection)
+    connect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), SLOT(updateGL()));
+  else
+    disconnect(camera()-&gt;interpolationKfi_, SIGNAL(interpolated()), this, SLOT(updateGL()));
+}
+
+/*! Draws a representation of \p light.
+
+ Called in draw(), this method is useful to debug or display your light setup. Light drawing depends
+ on the type of light (point, spot, directional).
+
+ The method retrieves the light setup using \c glGetLightfv. Position and define your lights before
+ calling this method.
+
+ Light is drawn using its diffuse color. Disabled lights are not displayed.
+
+ Drawing size is proportional to sceneRadius(). Use \p scale to rescale it.
+
+ See the &lt;a href=&quot;../examples/drawLight.html&quot;&gt;drawLight example&lt;/a&gt; for an illustration.
+
+ \attention You need to enable \c GL_COLOR_MATERIAL before calling this method. \c glColor is set to
+ the light diffuse color. */
+void QGLViewer::drawLight(GLenum light, float scale) const
+{
+  static GLUquadric* quadric = gluNewQuadric();
+
+  const float length = sceneRadius() / 5.0 * scale;
+
+  GLboolean lightIsOn;
+  glGetBooleanv(light, &amp;lightIsOn);
+
+  if (lightIsOn)
+    {
+      // All light values are given in eye coordinates
+      glPushMatrix();
+      glLoadIdentity();
+
+      float color[4];
+      glGetLightfv(light, GL_DIFFUSE, color);
+      glColor4fv(color);
+
+      float pos[4];
+      glGetLightfv(light, GL_POSITION, pos);
+
+      if (pos[3] != 0.0)
+	{
+	  glTranslatef(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
+
+	  GLfloat cutOff;
+	  glGetLightfv(light, GL_SPOT_CUTOFF, &amp;cutOff);
+	  if (cutOff != 180.0)
+	    {
+	      GLfloat dir[4];
+	      glGetLightfv(light, GL_SPOT_DIRECTION, dir);
+	      glMultMatrixd(Quaternion(Vec(0,0,1), Vec(dir)).matrix());
+	      QGLViewer::drawArrow(length);
+	      gluCylinder(quadric, 0.0, 0.7 * length * sin(cutOff * M_PI / 180.0), 0.7 * length * cos(cutOff * M_PI / 180.0), 12, 1);
+	    }
+	  else
+	    gluSphere(quadric, 0.2*length, 10, 10);
+	}
+      else
+	{
+	  // Directional light.
+	  Vec dir(pos[0], pos[1], pos[2]);
+	  dir.normalize();
+	  Frame fr=Frame(camera()-&gt;cameraCoordinatesOf(4.0 * length * camera()-&gt;frame()-&gt;inverseTransformOf(dir)),
+			 Quaternion(Vec(0,0,-1), dir));
+	  glMultMatrixd(fr.matrix());
+	  drawArrow(length);
+	}
+
+      glPopMatrix();
+    }
+}
+
+
+/*! Draws \p text at position \p x, \p y (expressed in screen coordinates pixels, origin in the
+  upper left corner of the widget).
+
+  The default QApplication::font() is used to render the text when no \p fnt is specified. Use
+  QApplication::setFont() to define this default font.
+
+  You should disable \c GL_LIGHTING before this method so that colors are properly rendered.
+
+  This method can be used in conjunction with the qglviewer::Camera::projectedCoordinatesOf()
+  method to display a text attached to an object. In your draw() method use:
+  \code
+  qglviewer::Vec screenPos = camera()-&gt;projectedCoordinatesOf(myFrame.position());
+  drawText((int)screenPos[0], (int)screenPos[1], &quot;My Object&quot;);
+  \endcode
+  See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem example&lt;/a&gt; for an illustration.
+
+  Text is displayed only when textIsEnabled() (default). This mechanism allows the user to
+  conveniently remove all the displayed text with a single keyboard shortcut.
+
+  Use displayMessage() to drawText() for only a short amount of time.
+
+  Use the QGLWidget::renderText(x,y,z, text) method (Qt version &gt;= 3.1) to draw a text (fixed size,
+  facing the camera) located at a specific 3D position instead of 2D screen coordinates.
+
+  The \c GL_MODELVIEW and \c GL_PROJECTION matrices are not modified by this method.
+
+  \attention This method uses display lists to render the characters, with an index that starts at
+  2000 by default (see the QGLWidget::renderText() documentation). If you use more than 2000 Display
+  Lists, they may overlap with these. Directly use QGLWidget::renderText() in that case, with a
+  higher \c listBase parameter (or overload &lt;code&gt;fontDisplayListBase&lt;/code&gt; with Qt4).
+
+  \attention There is a problem with anti-aliased font with nVidia cards and Qt versions lower than
+  3.3. Until this version, the \p fnt parameter is not taken into account to prevent a crash. It is
+  replaced by a fixed font that should be compatible with the \c qtconfig anti-aliased font
+  configuration (disable this option otherwise).
+
+  \note This method uses QGLWidget::renderText() if your Qt version is greater or equal to 3.1,
+  otherwise it uses (and requires) GLUT. When GLUT is used, only the \p fnt size attribute (set with
+  QFont::setPixelSize() or QFont::setPointSize()) is taken into account. Also note that in that case
+  each call to drawText() changes the camera projection matrix and restores it back (using
+  startScreenCoordinatesSystem() and stopScreenCoordinatesSystem()). If you call this method several
+  times and it slows down your frame rate, consider factorizing the context changes. */
+void QGLViewer::drawText(int x, int y, const QString&amp; text, const QFont&amp; fnt)
+{
+  if (!textIsEnabled())
+    return;
+
+#if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
+  const GLfloat font_scale = 119.05f - 33.33f; // see glutStrokeCharacter man page
+
+  startScreenCoordinatesSystem();
+
+  // Anti-aliased characters
+  glPushAttrib(GL_ALL_ATTRIB_BITS);
+  glDisable(GL_LIGHTING);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  glEnable(GL_BLEND);
+  glDisable(GL_DEPTH_TEST);
+  glEnable(GL_LINE_SMOOTH);
+  glLineWidth(1.0);
+
+  glTranslatef((GLfloat)x, (GLfloat)y, 0.0);
+  const GLfloat scale = ((fnt.pixelSize()&gt;0)?fnt.pixelSize():fnt.pointSize()) / font_scale;
+  glScalef(scale, -scale, scale);
+
+  for (uint i=0; i&lt;text.length(); ++i)
+    glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
+
+  glPopAttrib();
+
+  stopScreenCoordinatesSystem();
+
+#else
+
+# if QT_VERSION &lt; 0x030300 &amp;&amp; defined Q_OS_UNIX
+  // Fix bug with anti-aliased fonts on nVidia driver
+  QFont newFont(fnt);
+  newFont.setFamily(&quot;fixed&quot;);
+  newFont.setRawMode(true);
+  newFont.setPixelSize(10);
+  newFont.setFixedPitch(true);
+#  if QT_VERSION &gt;= 0x030200
+  newFont.setStyleStrategy(QFont::OpenGLCompatible);
+#  endif
+  newFont.setStyleHint(QFont::AnyStyle, QFont::PreferBitmap);
+  renderText(x, y, text, newFont);
+# else
+  renderText(x, y, text, fnt);
+# endif
+
+#endif
+}
+
+/* Similar to drawText(), but the text is handled as a classical 3D object of the scene.
+
+Although useful, this method is deprecated with recent Qt versions. Indeed, Qt renders text as
+pixmaps that cannot be orientated. However, when GLUT is used instead of Qt (when your Qt version is
+lower than 3.1, see drawText() documentation) orientated characters are possible and this method will work.
+
+\p pos and \p normal respectively represent the 3D coordinate of the text and the normal to the text
+plane. They are expressed with respect to the \e current \c GL_MODELVIEW matrix.
+
+If you want your text to always face the camera (normal parallel to camera()-&gt;viewDirection), use
+QGLWidget::renderText(x,y,z).
+
+See the &lt;a href=&quot;../examples/draw3DText.html&quot;&gt;draw3DText example&lt;/a&gt; for an illustration. */
+/*
+ void QGLViewer::draw3DText(const Vec&amp; pos, const Vec&amp; normal, const QString&amp; text, GLfloat height)
+ {
+ #if QT_VERSION &lt; QGLVIEWER_QT_VERSION_WITHOUT_GLUT
+ if (!textIsEnabled())
+ return;
+
+ glMatrixMode(GL_MODELVIEW) ;
+ glPushMatrix() ;
+
+ const GLfloat font_scale = (119.05f - 33.33f) / 8; // see glutStrokeCharacter man page
+ // const GLfloat font_scale = (119.05f - 33.33f) * 15.0f; // see glutStrokeCharacter man page
+
+ static GLfloat lineWidth;
+ glGetFloatv(GL_LINE_WIDTH, &amp;lineWidth);
+
+ glTranslatef(pos.x, pos.y, pos.z);
+ glMultMatrixd(Quaternion(Vec(0.0, 0.0, 1.0), normal).matrix());
+
+ glLineWidth(2.0);
+
+ glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+ glEnable(GL_BLEND);
+ glEnable(GL_LINE_SMOOTH);
+
+ const GLfloat scale = height / font_scale;
+ glScalef(scale, scale, scale);
+
+ for (uint i=0; i&lt;text.length(); ++i)
+ glutStrokeCharacter(GLUT_STROKE_ROMAN, text.at(i));
+
+ glLineWidth(lineWidth);
+
+ glMatrixMode(GL_MODELVIEW);
+ glPopMatrix() ;
+ #else
+ static bool displayed = false;
+
+ if (!displayed)
+ {
+   qWarning(&quot;draw3DText is not supported with Qt &gt;= 3.1.&quot;);
+   qWarning(&quot;Use QGLWidget::renderText() instead,&quot;);
+   qWarning(&quot;or use the glut glutStrokeCharacter() method.&quot;);
+   displayed = true;
+ }
+
+  Q_UNUSED(pos)
+    Q_UNUSED(normal)
+    Q_UNUSED(text)
+    Q_UNUSED(height)
+ #endif
+ }
+*/
+
+/*! Briefly displays a message in the lower left corner of the widget. Convenient to provide
+ feedback to the user.
+
+ \p message is displayed during \p delay milliseconds (default is 2 seconds) using drawText().
+
+ This method should not be called in draw(). If you want to display a text in each draw(), use
+ drawText() instead.
+
+ If this method is called when a message is already displayed, the new message replaces the old one.
+ Use setTextIsEnabled() (default shortcut is '?') to enable or disable text (and hence messages)
+ display. */
+void QGLViewer::displayMessage(const QString&amp; message, int delay)
+{
+  message_ = message;
+  displayMessage_ = true;
+#if QT_VERSION &gt;= 0x040000
+  // Was set to single shot in defaultConstructor.
+  messageTimer_.start(delay);
+#else
+  if (messageTimer_.isActive())
+    messageTimer_.changeInterval(delay);
+  else
+    messageTimer_.start(delay, true);
+#endif
+  if (textIsEnabled() &amp;&amp; updateGLOK_)
+    updateGL();
+}
+
+void QGLViewer::hideMessage()
+{
+  displayMessage_ = false;
+  if (textIsEnabled())
+    updateGL();
+}
+
+
+/*! Displays the averaged currentFPS() frame rate in the upper left corner of the widget.
+
+ updateGL() should be called in a loop in order to have a meaningful value (this is the case when
+ you continuously move the camera using the mouse or when animationIsStarted()).
+ setAnimationPeriod(0) to make this loop as fast as possible in order to reach and measure the
+ maximum available frame rate.
+
+ When FPSIsDisplayed() is \c true (default is \c false), this method is called by postDraw() to
+ display the currentFPS(). Use QApplication::setFont() to define the font (see drawText()). */
+void QGLViewer::displayFPS()
+{
+  drawText(10, int(1.5*((QApplication::font().pixelSize()&gt;0)?QApplication::font().pixelSize():QApplication::font().pointSize())), fpsString_);
+}
+
+/*! Modify the projection matrix so that drawing can be done directly with 2D screen coordinates.
+
+ Once called, the \p x and \p y coordinates passed to \c glVertex are expressed in pixels screen
+ coordinates. The origin (0,0) is in the upper left corner of the widget by default. This follows
+ the Qt standards, so that you can directly use the \c pos() provided by for instance \c
+ QMouseEvent. Set \p upward to \c true to place the origin in the \e lower left corner, thus
+ following the OpenGL and mathematical standards. It is always possible to switch between the two
+ representations using \c newY = height() - \c y.
+
+ You need to call stopScreenCoordinatesSystem() at the end of the drawing block to restore the
+ previous camera matrix.
+
+ In practice, this method should be used in draw(). It sets an appropriate orthographic projection
+ matrix and then sets \c glMatrixMode to \c GL_MODELVIEW.
+
+ See the &lt;a href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt;, &lt;a
+ href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect&lt;/a&gt; and &lt;a
+ href=&quot;../examples/contribs.html#backgroundImage&quot;&gt;backgroundImage&lt;/a&gt; examples for an illustration.
+
+ You may want to disable \c GL_LIGHTING, to enable \c GL_LINE_SMOOTH or \c GL_BLEND to draw when
+ this method is used.
+
+ If you want to link 2D drawings to 3D objects, use qglviewer::Camera::projectedCoordinatesOf() to
+ compute the 2D projection on screen of a 3D point (see the &lt;a
+ href=&quot;../examples/screenCoordSystem.html&quot;&gt;screenCoordSystem&lt;/a&gt; example). See also drawText().
+
+ In this mode, you should use z values that are in the [0.0, 1.0[ range (0.0 corresponding to the
+ near clipping plane and 1.0 being just beyond the far clipping plane). This interval matches the
+ values that can be read from the z-buffer. Note that if you use the convenient \c glVertex2i() to
+ provide coordinates, the implicit 0.0 z coordinate will make your drawings appear \e on \e top of
+ the rest of the scene. */
+void QGLViewer::startScreenCoordinatesSystem(bool upward) const
+{
+  glMatrixMode(GL_PROJECTION);
+  glPushMatrix();
+  glLoadIdentity();
+  if (upward)
+    glOrtho(0, width(), 0, height(), 0.0, -1.0);
+  else
+    glOrtho(0, width(), height(), 0, 0.0, -1.0);
+
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix();
+  glLoadIdentity();
+}
+
+/*! Stops the pixel coordinate drawing block started by startScreenCoordinatesSystem().
+
+ The \c GL_MODELVIEW and \c GL_PROJECTION matrices modified in
+ startScreenCoordinatesSystem() are restored. \c glMatrixMode is set to \c GL_MODELVIEW. */
+void QGLViewer::stopScreenCoordinatesSystem() const
+{
+  glMatrixMode(GL_PROJECTION);
+  glPopMatrix();
+
+  glMatrixMode(GL_MODELVIEW);
+  glPopMatrix();
+}
+
+/*! Overloading of the \c QObject method.
+
+ If animationIsStarted(), calls animate() and draw(). */
+void QGLViewer::timerEvent(QTimerEvent *)
+{
+  if (animationIsStarted())
+    {
+      animate();
+      updateGL();
+    }
+}
+
+/*! Starts the animation loop. See animationIsStarted(). */
+void QGLViewer::startAnimation()
+{
+  animationTimerId_ = startTimer(animationPeriod());
+  animationStarted_ = true;
+}
+
+/*! Stops animation. See animationIsStarted(). */
+void QGLViewer::stopAnimation()
+{
+  animationStarted_ = false;
+  if (animationTimerId_ != 0)
+    killTimer(animationTimerId_);
+}
+
+/*! Overloading of the \c QWidget method.
+
+Saves the viewer state using saveStateToFile() and then calls QGLWidget::closeEvent(). */
+void QGLViewer::closeEvent(QCloseEvent *e)
+{
+  // When the user clicks on the window close (x) button:
+  // - If the viewer is a top level window, closeEvent is called and then saves to file.
+  // - Otherwise, nothing happen s:(
+  // When the user press the EXIT_VIEWER keyboard shortcut:
+  // - If the viewer is a top level window, saveStateToFile() is also called
+  // - Otherwise, closeEvent is NOT called and keyPressEvent does the job.
+
+  /* After tests:
+     E : Embedded widget
+     N : Widget created with new
+     C : closeEvent called
+     D : destructor called
+
+     E	N	C	D
+     y	y
+     y	n		y
+     n	y	y
+     n	n	y	y
+
+     closeEvent is called iif the widget is NOT embedded.
+
+     Destructor is called iif the widget is created on the stack
+     or if widget (resp. parent if embedded) is created with WDestructiveClose flag.
+
+     closeEvent always before destructor.
+
+     Close using qApp-&gt;closeAllWindows or (x) is identical.
+  */
+
+  // #CONNECTION# Also done for EXIT_VIEWER in keyPressEvent().
+  saveStateToFile();
+  QGLWidget::closeEvent(e);
+}
+
+/*! Simple wrapper method: calls \c select(event-&gt;pos()).
+
+  Emits \c pointSelected(e) which is useful only if you rely on the Qt signal-slot mechanism and you
+  did not overload QGLViewer. If you choose to derive your own viewer class, simply overload
+  select() (or probably simply drawWithNames(), see the &lt;a href=&quot;../examples/select.html&quot;&gt;select
+  example&lt;/a&gt;) to implement your selection mechanism.
+
+  This method is called when you use the QGLViewer::SELECT mouse binding(s) (default is Shift + left
+  button). Use setMouseBinding() to change this. */
+void QGLViewer::select(const QMouseEvent* event)
+{
+  // For those who don't derive but rather rely on the signal-slot mechanism.
+  emit pointSelected(event);
+  select(event-&gt;pos());
+}
+
+/*! This method performs a selection in the scene from pixel coordinates.
+
+ It is called when the user clicks on the QGLViewer::SELECT QGLViewer::ClickAction binded button(s)
+ (default is Shift + LeftButton).
+
+ This method successively calls four other methods:
+ \code
+ beginSelection(point);
+ drawWithNames();
+ endSelection(point);
+ postSelection(point);
+ \endcode
+
+ The default implementation of these methods is as follows (see the methods' documentation for
+ more details):
+
+ \arg beginSelection() sets the \c GL_SELECT mode with the appropriate picking matrices. A
+ rectangular frustum (of size defined by selectRegionWidth() and selectRegionHeight()) centered on
+ \p point is created.
+
+ \arg drawWithNames() is empty and should be overloaded. It draws each selectable object of the
+ scene, enclosed by calls to \c glPushName() / \c glPopName() to tag the object with an integer id.
+
+ \arg endSelection() then restores \c GL_RENDER mode and analyzes the selectBuffer() to set in
+ selectedName() the id of the object that was drawn in the region. If several object are in the
+ region, the closest one in the depth buffer is chosen. If no object has been drawn under cursor,
+ selectedName() is set to -1.
+
+ \arg postSelection() is empty and can be overloaded for possible signal/display/interface update.
+
+ See the \c glSelectBuffer() man page for details on this \c GL_SELECT mechanism.
+
+ This default implementation is quite limited: only the closer object is selected, and only one
+ level of names can be pushed. However, this reveals sufficient in many cases and you usually only
+ have to overload drawWithNames() to implement a simple object selection process. See the &lt;a
+ href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration.
+
+ If you need a more complex selection process (such as a point, edge or triangle selection, which
+ is easier with a 2 or 3 levels selectBuffer() heap, and which requires a finer depth sorting to
+ privilege point over edge and edges over triangles), overload the endSelection() method. Use
+ setSelectRegionWidth(), setSelectRegionHeight() and setSelectBufferSize() to tune the select
+ buffer configuration. See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
+ an illustration.
+
+ \p point is the center pixel (origin in the upper left corner) of the selection region. Use
+ qglviewer::Camera::convertClickToLine() to transform these coordinates in a 3D ray if you want to
+ perform an analytical intersection.
+
+ \attention \c GL_SELECT mode seems to report wrong results when used in conjunction with backface
+ culling. If you encounter problems try to \c glDisable(GL_CULL_FACE). */
+void QGLViewer::select(const QPoint&amp; point)
+{
+  beginSelection(point);
+  drawWithNames();
+  endSelection(point);
+  postSelection(point);
+}
+
+/*! This method should prepare the selection. It is called by select() before drawWithNames().
+
+ The default implementation uses the \c GL_SELECT mode to perform a selection. It uses
+ selectBuffer() and selectBufferSize() to define a \c glSelectBuffer(). The \c GL_PROJECTION is then
+ set using \c gluPickMatrix(), with a window selection size defined by selectRegionWidth() and
+ selectRegionHeight(). Finally, the \c GL_MODELVIEW matrix is set to the world coordinate system
+ using qglviewer::Camera::loadModelViewMatrix(). See the gluPickMatrix() documentation for details.
+
+ You should not need to redefine this method (if you use the \c GL_SELECT mode to perform your
+ selection), since this code is fairly classical and can be tuned. You are more likely to overload
+ endSelection() if you want to use a more complex select buffer structure. */
+void QGLViewer::beginSelection(const QPoint&amp; point)
+{
+  // Make OpenGL context current (may be needed with several viewers ?)
+  makeCurrent();
+
+  // Prepare the selection mode
+  glSelectBuffer(selectBufferSize(), selectBuffer());
+  glRenderMode(GL_SELECT);
+  glInitNames();
+
+  // Loads the matrices
+  glMatrixMode(GL_PROJECTION);
+  glLoadIdentity();
+  static GLint viewport[4];
+  camera()-&gt;getViewport(viewport);
+  gluPickMatrix(point.x(), point.y(), selectRegionWidth(), selectRegionHeight(), viewport);
+
+  // loadProjectionMatrix() first resets the GL_PROJECTION matrix with a glLoadIdentity().
+  // The false parameter prevents this and hence multiplies the matrices.
+  camera()-&gt;loadProjectionMatrix(false);
+  // Reset the original (world coordinates) modelview matrix
+  camera()-&gt;loadModelViewMatrix();
+}
+
+/*! This method is called by select() after scene elements were drawn by drawWithNames(). It should
+ analyze the selection result to determine which object is actually selected.
+
+ The default implementation relies on \c GL_SELECT mode (see beginSelection()). It assumes that
+ names were pushed and popped in drawWithNames(), and analyzes the selectBuffer() to find the name
+ that corresponds to the closer (z min) object. It then setSelectedName() to this value, or to -1 if
+ the selectBuffer() is empty (no object drawn in selection region). Use selectedName() (probably in
+ the postSelection() method) to retrieve this value and update your data structure accordingly.
+
+ This default implementation, although sufficient for many cases is however limited and you may have
+ to overload this method. This will be the case if drawWithNames() uses several push levels in the
+ name heap. A more precise depth selection, for instance privileging points over edges and
+ triangles to avoid z precision problems, will also require an overloading. A typical implementation
+ will look like:
+ \code
+ glFlush();
+
+ // Get the number of objects that were seen through the pick matrix frustum.
+ // Resets GL_RENDER mode.
+ GLint nbHits = glRenderMode(GL_RENDER);
+
+ if (nbHits &lt;= 0)
+   setSelectedName(-1);
+ else
+ {
+   // Interpret results: each object created values in the selectBuffer().
+   // See the glSelectBuffer() man page for details on the buffer structure.
+   // The following code depends on your selectBuffer() structure.
+   for (int i=0; i&lt;nbHits; ++i)
+    if ((selectBuffer())[i*4+1] &lt; zMin)
+      setSelectedName((selectBuffer())[i*4+3])
+ }
+ \endcode
+
+ See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for
+ a multi-object selection implementation of this method. */
+void QGLViewer::endSelection(const QPoint&amp; point)
+{
+  Q_UNUSED(point);
+
+  // Flush GL buffers
+  glFlush();
+
+  // Get the number of objects that were seen through the pick matrix frustum. Reset GL_RENDER mode.
+  GLint nbHits = glRenderMode(GL_RENDER);
+
+  if (nbHits &lt;= 0)
+    setSelectedName(-1);
+  else
+    {
+      // Interpret results: each object created 4 values in the selectBuffer().
+      // selectBuffer[4*i+1] is the object minimum depth value, while selectBuffer[4*i+3] is the id pushed on the stack.
+      // Of all the objects that were projected in the pick region, we select the closest one (zMin comparison).
+      // This code needs to be modified if you use several stack levels. See glSelectBuffer() man page.
+      GLuint zMin = (selectBuffer())[1];
+      setSelectedName((selectBuffer())[3]);
+      for (int i=1; i&lt;nbHits; ++i)
+	if ((selectBuffer())[4*i+1] &lt; zMin)
+	  {
+	    zMin = (selectBuffer())[4*i+1];
+	    setSelectedName((selectBuffer())[4*i+3]);
+	  }
+    }
+}
+
+/*! Sets the selectBufferSize().
+
+The previous selectBuffer() is deleted and a new one is created. */
+void QGLViewer::setSelectBufferSize(int size)
+{
+  if (selectBuffer_)
+    delete[] selectBuffer_;
+  selectBufferSize_ = size;
+  selectBuffer_ = new GLuint[selectBufferSize()];
+}
+
+void QGLViewer::performClickAction(ClickAction ca, const QMouseEvent* const e)
+{
+  // Note: action that need it should updateGL().
+  switch (ca)
+    {
+      // # CONNECTION setMouseBinding prevents adding NO_CLICK_ACTION in clickBinding_
+      // This case should hence not be possible. Prevents unused case warning.
+    case NO_CLICK_ACTION :
+      break;
+    case ZOOM_ON_PIXEL :
+      camera()-&gt;interpolateToZoomOnPixel(e-&gt;pos());
+      break;
+    case ZOOM_TO_FIT :
+      camera()-&gt;interpolateToFitScene();
+      break;
+    case SELECT :
+      select(e);
+      updateGL();
+      break;
+    case RAP_FROM_PIXEL :
+      if (camera()-&gt;setRevolveAroundPointFromPixel(e-&gt;pos()))
+	{
+	  setVisualHintsMask(1);
+	  updateGL();
+	}
+      break;
+    case RAP_IS_CENTER :
+      camera()-&gt;setRevolveAroundPoint(sceneCenter());
+      setVisualHintsMask(1);
+      updateGL();
+      break;
+    case CENTER_FRAME :
+      if (manipulatedFrame())
+	manipulatedFrame()-&gt;projectOnLine(camera()-&gt;position(), camera()-&gt;viewDirection());
+      break;
+    case CENTER_SCENE :
+      camera()-&gt;centerScene();
+      break;
+    case SHOW_ENTIRE_SCENE :
+      camera()-&gt;showEntireScene();
+      break;
+    case ALIGN_FRAME :
+      if (manipulatedFrame())
+	manipulatedFrame()-&gt;alignWithFrame(camera()-&gt;frame());
+      break;
+    case ALIGN_CAMERA :
+      camera()-&gt;frame()-&gt;alignWithFrame(NULL, true);
+      break;
+    }
+}
+
+/*! Overloading of the \c QWidget method.
+
+ When the user clicks on the mouse:
+ \arg if a mouseGrabber() is defined, qglviewer::MouseGrabber::mousePressEvent() is called,
+ \arg otherwise, the camera() or the manipulatedFrame() interprets the mouse displacements,
+ depending on mouse bindings.
+
+ Mouse bindings customization can be achieved using setMouseBinding() and setWheelBinding(). See the
+ &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for a complete description of mouse bindings.
+
+ See the mouseMoveEvent() documentation for an example of more complex mouse behavior customization
+ using overloading.
+
+ \note When the mouseGrabber() is a manipulatedFrame(), the modifier keys are not taken into
+ account. This allows for a direct manipulation of the manipulatedFrame() when the mouse hovers,
+ which is probably what is expected. */
+void QGLViewer::mousePressEvent(QMouseEvent* e)
+{
+  //#CONNECTION# mouseDoubleClickEvent has the same structure
+  //#CONNECTION# mouseString() concatenates bindings description in inverse order.
+  ClickActionPrivate cap;
+  cap.doubleClick = false;
+#if QT_VERSION &gt;= 0x040000
+  cap.modifiers = e-&gt;modifiers();
+  cap.button = e-&gt;button();
+  cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
+#else
+  cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+  cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
+  cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
+#endif
+
+  if (clickBinding_.contains(cap))
+    performClickAction(clickBinding_[cap], e);
+  else
+      if (mouseGrabber())
+	{
+	  if (mouseGrabberIsAManipulatedFrame_)
+	    {
+	      for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it!=end; ++it)
+#if QT_VERSION &gt;= 0x040000
+		if ((it.value().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == e-&gt;buttons()))
+#else
+		  if ((it.data().handler == FRAME) &amp;&amp; ((it.key() &amp; Qt::MouseButtonMask) == (e-&gt;stateAfter() &amp; Qt::MouseButtonMask)))
+#endif
+		    {
+		      ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
+		      if (mouseGrabberIsAManipulatedCameraFrame_)
+			{
+			  mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
+			  mf-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+			}
+		      else
+			{
+			  mf-&gt;startAction(it.value().action, it.value().withConstraint);
+			  mf-&gt;mousePressEvent(e, camera());
+			}
+		      break;
+		    }
+	    }
+	  else
+	    mouseGrabber()-&gt;mousePressEvent(e, camera());
+	  updateGL();
+	}
+      else
+	{
+	  //#CONNECTION# wheelEvent has the same structure
+#if QT_VERSION &gt;= 0x040000
+	  const int state = e-&gt;modifiers() | e-&gt;buttons();
+#else
+	  const int state = e-&gt;stateAfter();
+#endif
+
+	  if (mouseBinding_.contains(state))
+	    {
+	      MouseActionPrivate map = mouseBinding_[state];
+	      switch (map.handler)
+		{
+		case CAMERA :
+		  camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
+		  camera()-&gt;frame()-&gt;mousePressEvent(e, camera());
+		  break;
+		case FRAME :
+		  if (manipulatedFrame())
+		    {
+		      if (manipulatedFrameIsACamera_)
+			{
+			  manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
+			  manipulatedFrame()-&gt;ManipulatedFrame::mousePressEvent(e, camera());
+			}
+		      else
+			{
+			  manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
+			  manipulatedFrame()-&gt;mousePressEvent(e, camera());
+			}
+		    }
+		  break;
+		}
+	      if (map.action == SCREEN_ROTATE)
+		// Display visual hint line
+		updateGL();
+	    }
+#if QT_VERSION &gt;= 0x030000
+	  else
+	    e-&gt;ignore();
+#endif
+	}
+}
+
+/*! Overloading of the \c QWidget method.
+
+ Mouse move event is sent to the mouseGrabber() (if any) or to the camera() or the
+ manipulatedFrame(), depending on mouse bindings (see setMouseBinding()).
+
+ If you want to define your own mouse behavior, do something like this:
+ \code
+ void Viewer::mousePressEvent(QMouseEvent* e)
+ {
+
+   // Qt version 2 or 3 : use Qt::KeyButtonMask and Qt::MouseButtonMask to separate the modifiers
+   // (Qt::ControlButton/Qt::AltButton/Qt::ShiftButton/Qt::MetaButton) from the mouse buttons
+   // (Qt::LeftButton/Qt::MidButton/Qt::RightButton) in state().
+   if ( ((e-&gt;state() &amp; Qt::KeyButtonMask) == myModifiers) &amp;&amp;
+        ((e-&gt;state() &amp; Qt::MouseButtonMask) == myButton) )
+
+   // With Qt 4, use instead :
+   if ((e-&gt;button() == myButton) &amp;&amp; (e-&gt;modifiers() == myModifiers))
+     myMouseBehavior = true;
+   else
+     QGLViewer::mousePressEvent(e);
+ }
+
+ void Viewer::mouseMoveEvent(QMouseEvent *e)
+ {
+   if (myMouseBehavior)
+     // Use e-&gt;x() and e-&gt;y() as you want...
+   else
+     QGLViewer::mouseMoveEvent(e);
+ }
+
+ void Viewer::mouseReleaseEvent(QMouseEvent* e)
+ {
+   if (myMouseBehavior)
+     myMouseBehavior = false;
+   else
+     QGLViewer::mouseReleaseEvent(e);
+ }
+ \endcode */
+void QGLViewer::mouseMoveEvent(QMouseEvent* e)
+{
+  if (mouseGrabber())
+    {
+      mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+      if (mouseGrabber()-&gt;grabsMouse())
+	if (mouseGrabberIsAManipulatedCameraFrame_)
+	  (dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
+	else
+	  mouseGrabber()-&gt;mouseMoveEvent(e, camera());
+      else
+	setMouseGrabber(NULL);
+      updateGL();
+    }
+
+  if (!mouseGrabber())
+    {
+      //#CONNECTION# mouseReleaseEvent has the same structure
+      if (camera()-&gt;frame()-&gt;isManipulated())
+	{
+	  camera()-&gt;frame()-&gt;mouseMoveEvent(e, camera());
+	  // #CONNECTION# manipulatedCameraFrame::mouseMoveEvent specific if at the beginning
+	  if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
+	    updateGL();
+	}
+      else // !
+	if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
+	  if (manipulatedFrameIsACamera_)
+	    manipulatedFrame()-&gt;ManipulatedFrame::mouseMoveEvent(e, camera());
+	  else
+	    manipulatedFrame()-&gt;mouseMoveEvent(e, camera());
+	else
+	  if (hasMouseTracking())
+	    {
+#if QT_VERSION &gt;= 0x040000
+	      foreach (MouseGrabber* mg, MouseGrabber::MouseGrabberPool())
+		{
+#else
+	      QPtrListIterator&lt;MouseGrabber&gt; it(MouseGrabber::MouseGrabberPool());
+	      for (MouseGrabber* mg; (mg = it.current()); ++it)
+		{
+#endif
+		  mg-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+		  if (mg-&gt;grabsMouse())
+		    {
+		      setMouseGrabber(mg);
+		      // Check that MouseGrabber is not disabled
+		      if (mouseGrabber() == mg)
+			{
+			  updateGL();
+			  break;
+			}
+		    }
+		}
+	    }
+    }
+}
+
+/*! Overloading of the \c QWidget method.
+
+ Calls the mouseGrabber(), camera() or manipulatedFrame \c mouseReleaseEvent method.
+
+ See the mouseMoveEvent() documentation for an example of mouse behavior customization. */
+void QGLViewer::mouseReleaseEvent(QMouseEvent* e)
+{
+  if (mouseGrabber())
+    {
+      if (mouseGrabberIsAManipulatedCameraFrame_)
+	(dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber()))-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
+      else
+	mouseGrabber()-&gt;mouseReleaseEvent(e, camera());
+      mouseGrabber()-&gt;checkIfGrabsMouse(e-&gt;x(), e-&gt;y(), camera());
+      if (!(mouseGrabber()-&gt;grabsMouse()))
+	setMouseGrabber(NULL);
+      // updateGL();
+    }
+  else
+    //#CONNECTION# mouseMoveEvent has the same structure
+    if (camera()-&gt;frame()-&gt;isManipulated())
+      {
+	// bool updateGLNeeded = ((camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION) ||
+			       // (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE));
+	camera()-&gt;frame()-&gt;mouseReleaseEvent(e, camera());
+	// if (updateGLNeeded)
+	// Needed in all cases because of fastDraw().
+	// updateGL();
+      }
+    else
+      if ((manipulatedFrame()) &amp;&amp; (manipulatedFrame()-&gt;isManipulated()))
+	{
+	  // bool updateGLNeeded = (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE);
+	  if (manipulatedFrameIsACamera_)
+	    manipulatedFrame()-&gt;ManipulatedFrame::mouseReleaseEvent(e, camera());
+	  else
+	    manipulatedFrame()-&gt;mouseReleaseEvent(e, camera());
+	  // if (updateGLNeeded)
+	    // updateGL();
+	}
+#if QT_VERSION &gt;= 0x030000
+      else
+	e-&gt;ignore();
+#endif
+
+  // Not absolutely needed (see above commented code for the optimal version), but may reveal
+  // useful for specific applications.
+  updateGL();
+}
+
+/*! Overloading of the \c QWidget method.
+
+ If defined, the wheel event is sent to the mouseGrabber(). It is otherwise sent according to wheel
+ bindings (see setWheelBinding()). */
+void QGLViewer::wheelEvent(QWheelEvent* e)
+{
+  if (mouseGrabber())
+    {
+      if (mouseGrabberIsAManipulatedFrame_)
+	{
+	  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
+	    if (it.value().handler == FRAME)
+	      {
+		ManipulatedFrame* mf = dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber());
+		if (mouseGrabberIsAManipulatedCameraFrame_)
+		  {
+		    mf-&gt;ManipulatedFrame::startAction(it.value().action, it.value().withConstraint);
+		    mf-&gt;ManipulatedFrame::wheelEvent(e, camera());
+		  }
+		else
+		  {
+		    mf-&gt;startAction(it.value().action, it.value().withConstraint);
+		    mf-&gt;wheelEvent(e, camera());
+		  }
+		break;
+	      }
+	}
+      else
+	mouseGrabber()-&gt;wheelEvent(e, camera());
+      updateGL();
+    }
+  else
+    {
+      //#CONNECTION# mousePressEvent has the same structure
+#if QT_VERSION &gt;= 0x040000
+      const QtKeyboardModifiers modifiers = e-&gt;modifiers();
+#else
+      const QtKeyboardModifiers modifiers = e-&gt;state();
+#endif
+      if (wheelBinding_.contains(modifiers))
+	{
+	  MouseActionPrivate map = wheelBinding_[modifiers];
+	  switch (map.handler)
+	    {
+	    case CAMERA :
+	      camera()-&gt;frame()-&gt;startAction(map.action, map.withConstraint);
+	      camera()-&gt;frame()-&gt;wheelEvent(e, camera());
+	      break;
+	    case FRAME :
+	      if (manipulatedFrame())
+		if (manipulatedFrameIsACamera_)
+		  {
+		    manipulatedFrame()-&gt;ManipulatedFrame::startAction(map.action, map.withConstraint);
+		    manipulatedFrame()-&gt;ManipulatedFrame::wheelEvent(e, camera());
+		  }
+		else
+		  {
+		    manipulatedFrame()-&gt;startAction(map.action, map.withConstraint);
+		    manipulatedFrame()-&gt;wheelEvent(e, camera());
+		  }
+	      break;
+	    }
+	}
+#if QT_VERSION &gt;= 0x030000
+      else
+	e-&gt;ignore();
+#endif
+    }
+}
+
+/*! Overloading of the \c QWidget method.
+
+ The behavior of the mouse double click depends on the mouse binding. See setMouseBinding() and the
+ &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. */
+void QGLViewer::mouseDoubleClickEvent(QMouseEvent* e)
+{
+  //#CONNECTION# mousePressEvent has the same structure
+  ClickActionPrivate cap;
+  cap.doubleClick = true;
+#if QT_VERSION &gt;= 0x040000
+  cap.modifiers = e-&gt;modifiers();
+  cap.button = e-&gt;button();
+  cap.buttonsBefore = (QtMouseButtons)(e-&gt;buttons() &amp; ~(e-&gt;button()));
+#else
+  cap.modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+  cap.button = (QtMouseButtons)((e-&gt;stateAfter() &amp; Qt::MouseButtonMask) &amp; (~(e-&gt;state() &amp; Qt::MouseButtonMask)));
+  cap.buttonsBefore = (QtMouseButtons)(e-&gt;state() &amp; Qt::MouseButtonMask);
+#endif
+  if (clickBinding_.contains(cap))
+    performClickAction(clickBinding_[cap], e);
+  else
+    if (mouseGrabber())
+      mouseGrabber()-&gt;mouseDoubleClickEvent(e, camera());
+#if QT_VERSION &gt;= 0x030000
+    else
+      e-&gt;ignore();
+#endif
+}
+
+/*! Sets the state of displaysInStereo(). See also toggleStereoDisplay().
+
+First checks that the display is able to handle stereovision using QGLWidget::format(). Opens a
+warning message box in case of failure. Emits the stereoChanged() signal otherwise. */
+void QGLViewer::setStereoDisplay(bool stereo)
+{
+  if (format().stereo())
+    {
+      stereo_ = stereo;
+      if (!displaysInStereo())
+	{
+	  glDrawBuffer(GL_BACK_LEFT);
+	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	  glDrawBuffer(GL_BACK_RIGHT);
+	  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	}
+
+      emit stereoChanged(stereo_);
+
+      if (updateGLOK_)
+	updateGL();
+    }
+  else
+    if (stereo)
+      QMessageBox::warning(this, &quot;Stereo not supported&quot;, &quot;Stereo is not supported on this display&quot;);
+    else
+      stereo_ = false;
+}
+
+/*! Sets the isFullScreen() state.
+
+ If the QGLViewer is embedded in an other QWidget (see QWidget::topLevelWidget()), this widget is
+ displayed in full screen instead. */
+void QGLViewer::setFullScreen(bool fullScreen)
+{
+  fullScreen_ = fullScreen;
+
+  // Tricky. A timer does it later if !updateGLOK_.
+  if (!updateGLOK_)
+    return;
+
+  QWidget* tlw = topLevelWidget();
+
+  if (isFullScreen())
+    {
+      prevPos_ = topLevelWidget()-&gt;pos();
+      tlw-&gt;showFullScreen();
+      tlw-&gt;move(0,0);
+    }
+  else
+    {
+      tlw-&gt;showNormal();
+      tlw-&gt;move(prevPos_);
+    }
+}
+
+/*! Directly defines the mouseGrabber().
+
+You should not call this method directly as it bypasses the
+qglviewer::MouseGrabber::checkIfGrabsMouse() test performed by mouseMoveEvent().
+
+If the MouseGrabber is disabled (see mouseGrabberIsEnabled()), this method silently does nothing. */
+void QGLViewer::setMouseGrabber(MouseGrabber* mouseGrabber)
+{
+  if (!mouseGrabberIsEnabled(mouseGrabber))
+    return;
+
+  mouseGrabber_ = mouseGrabber;
+
+  mouseGrabberIsAManipulatedFrame_       = (dynamic_cast&lt;ManipulatedFrame*&gt;(mouseGrabber) != NULL);
+  mouseGrabberIsAManipulatedCameraFrame_ = ((dynamic_cast&lt;ManipulatedCameraFrame*&gt;(mouseGrabber) != NULL) &amp;&amp;
+					    (mouseGrabber != camera()-&gt;frame()));
+  emit mouseGrabberChanged(mouseGrabber);
+}
+
+/*! Sets the mouseGrabberIsEnabled() state. */
+void QGLViewer::setMouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber, bool enabled)
+{
+  if (enabled)
+    disabledMouseGrabbers_.remove(reinterpret_cast&lt;size_t&gt;(mouseGrabber));
+  else
+    disabledMouseGrabbers_[reinterpret_cast&lt;size_t&gt;(mouseGrabber)];
+}
+
+static QString keyboardModifiersString(QtKeyboardModifiers m, bool noButton=false)
+{
+  QString result(&quot;&quot;);
+#if QT_VERSION &gt;= 0x040000
+  if (m &amp; Qt::ControlModifier) 	result += &quot;Ctrl+&quot;;
+  if (m &amp; Qt::AltModifier) 	result += &quot;Alt+&quot;;
+  if (m &amp; Qt::ShiftModifier) 	result += &quot;Shift+&quot;;
+  if (m &amp; Qt::MetaModifier) 	result += &quot;Meta+&quot;;
+  if (noButton &amp;&amp; (m==Qt::NoModifier)) result += &quot;(no button)&quot;;
+#else
+  if (m &amp; Qt::ControlButton) 	result += &quot;Ctrl+&quot;;
+  if (m &amp; Qt::AltButton) 	result += &quot;Alt+&quot;;
+  if (m &amp; Qt::ShiftButton) 	result += &quot;Shift+&quot;;
+# if QT_VERSION &gt;= 0x030000
+  if (m &amp; Qt::MetaButton) 	result += &quot;Meta+&quot;;
+# endif
+  if (noButton &amp;&amp; (m==Qt::NoButton)) result += &quot;(no button)&quot;;
+#endif
+  return result;
+}
+
+static QString mouseButtonsString(QtMouseButtons b)
+{
+  QString result(&quot;&quot;);
+  bool addAmpersand = false;
+  if (b &amp; Qt::LeftButton)    { result += &quot;Left&quot;; addAmpersand=true; }
+  if (b &amp; Qt::MidButton)     { if (addAmpersand) result += &quot; &amp; &quot;; result += &quot;Middle&quot;; addAmpersand=true; }
+  if (b &amp; Qt::RightButton)   { if (addAmpersand) result += &quot; &amp; &quot;; result += &quot;Right&quot;; }
+  return result;
+}
+
+QString QGLViewer::mouseActionString(QGLViewer::MouseAction ma)
+{
+  switch (ma)
+    {
+    case QGLViewer::NO_MOUSE_ACTION : 	return QString::null;
+    case QGLViewer::ROTATE : 		return QString(&quot;Rotates&quot;);
+    case QGLViewer::ZOOM : 		return QString(&quot;Zooms&quot;);
+    case QGLViewer::TRANSLATE : 	return QString(&quot;Translates&quot;);
+    case QGLViewer::MOVE_FORWARD : 	return QString(&quot;Moves forward&quot;);
+    case QGLViewer::LOOK_AROUND : 	return QString(&quot;Looks around&quot;);
+    case QGLViewer::MOVE_BACKWARD : 	return QString(&quot;Moves backward&quot;);
+    case QGLViewer::SCREEN_ROTATE : 	return QString(&quot;Rotates on screen&quot;);
+    case QGLViewer::ROLL :		return QString(&quot;Rolls&quot;);
+    case QGLViewer::DRIVE :		return QString(&quot;Drives&quot;);
+    case QGLViewer::SCREEN_TRANSLATE : 	return QString(&quot;Horizontally/Vertically translates&quot;);
+    case QGLViewer::ZOOM_ON_REGION : 	return QString(&quot;Zooms on region for&quot;);
+    }
+  return QString::null;
+}
+
+QString QGLViewer::clickActionString(QGLViewer::ClickAction ca)
+{
+  switch (ca)
+    {
+    case QGLViewer::NO_CLICK_ACTION : 	return QString::null;
+    case QGLViewer::ZOOM_ON_PIXEL : 	return QString(&quot;Zooms on pixel&quot;);
+    case QGLViewer::ZOOM_TO_FIT : 	return QString(&quot;Zooms to fit scene&quot;);
+    case QGLViewer::SELECT : 		return QString(&quot;Selects&quot;);
+    case QGLViewer::RAP_FROM_PIXEL : 	return QString(&quot;Sets revolve around point&quot;);
+    case QGLViewer::RAP_IS_CENTER : 	return QString(&quot;Resets revolve around point&quot;);
+    case QGLViewer::CENTER_FRAME : 	return QString(&quot;Centers frame&quot;);
+    case QGLViewer::CENTER_SCENE : 	return QString(&quot;Centers scene&quot;);
+    case QGLViewer::SHOW_ENTIRE_SCENE : return QString(&quot;Shows entire scene&quot;);
+    case QGLViewer::ALIGN_FRAME : 	return QString(&quot;Aligns frame&quot;);
+    case QGLViewer::ALIGN_CAMERA : 	return QString(&quot;Aligns camera&quot;);
+    }
+  return QString::null;
+}
+
+/*! Provides a custom mouse binding description, displayed in the help() window Mouse tab.
+
+ \p state is a combination of QtKeyboardModifiers (\c Qt::ControlModifier, \c Qt::AltModifier, \c
+ Qt::ShiftModifier, \c Qt::MetaModifier) and QtMouseButtons (\c Qt::LeftButton, \c Qt::MidButton and
+ \c Qt::RightButton), combined using the \c &quot;|&quot; bitwise operator or simply &quot;+&quot;. One can also use the
+ shorter \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
+
+ \p doubleClick indicates whether or not the user has to double click this button to perform the
+ described action.
+
+ Set an empty \p description to \e remove a mouse binding description.
+
+ \code
+ // Left and Right button together simulate a middle button
+ setMouseBindingDescription(Qt::LeftButton + Qt::RightButton, &quot;Emulates a middle button&quot;);
+
+ // A left button double click toggles full screen
+ setMouseBindingDescription(Qt::LeftButton, &quot;Toggles full screen mode&quot;, true);
+
+ // Removes the description of Ctrl+Right button
+ setMouseBindingDescription(Qt::ControlModifier + Qt::RightButton, &quot;&quot;);
+ \endcode
+
+ Overload mouseMoveEvent() and friends to implement your custom mouse behavior (see the
+ mouseMoveEvent() documentation for an example). See the &lt;a
+ href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an illustration.
+
+ Use setMouseBinding() and setWheelBinding() to change the standard mouse action bindings.
+
+ \note If you use Qt version 2 or 3, the \c Modifier postfix should be replaced by \c Button in the
+ examples above (\c Qt::ControlButton, \c Qt::AltButton, ...).
+
+ \note If you use Qt version 2 or 3, the \p buttonsBefore parameter type is actually a
+ Qt::ButtonState. */
+void QGLViewer::setMouseBindingDescription(int state, QString description, bool doubleClick, QtMouseButtons buttonsBefore)
+{
+  ClickActionPrivate cap;
+  cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
+  cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+  cap.doubleClick = doubleClick;
+  cap.buttonsBefore = buttonsBefore;
+
+  if (description.isEmpty())
+    mouseDescription_.remove(cap);
+  else
+    mouseDescription_[cap] = description;
+}
+
+static QString tableLine(const QString&amp; left, const QString&amp; right)
+{
+  static bool even = false;
+  const QString tdtd(&quot;&lt;/b&gt;&lt;/td&gt;&lt;td&gt;&quot;);
+  const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
+
+  QString res(&quot;&lt;tr bgcolor=\&quot;&quot;);
+
+  if (even)
+    res += &quot;#eeeeff\&quot;&gt;&quot;;
+  else
+    res += &quot;#ffffff\&quot;&gt;&quot;;
+  res += &quot;&lt;td&gt;&lt;b&gt;&quot; + left + tdtd + right + tdtr;
+  even = !even;
+
+  return res;
+}
+
+/*! Returns a QString that describes the application mouse bindings, displayed in the help() window
+  \c Mouse tab.
+
+  Result is a table that describes custom application mouse binding descriptions defined using
+  setMouseBindingDescription() as well as standard mouse bindings (defined using setMouseBinding()
+  and setWheelBinding()). See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details on mouse
+  bindings.
+
+  See also helpString() and keyboardString(). */
+QString QGLViewer::mouseString() const
+{
+  QString text(&quot;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot;&gt;\n&quot;);
+  const QString trtd(&quot;&lt;tr&gt;&lt;td&gt;&quot;);
+  const QString tdtr(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);
+  const QString tdtd(&quot;&lt;/td&gt;&lt;td&gt;&quot;);
+
+  text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;Button(s)&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;\n&quot;;
+
+  QMap&lt;ClickActionPrivate, QString&gt; mouseBinding;
+
+  // User-defined mouse bondings come first.
+  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator itm=mouseDescription_.begin(), endm=mouseDescription_.end(); itm!=endm; ++itm)
+    mouseBinding[itm.key()] = itm.value();
+
+  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it=mouseBinding.begin(), end=mouseBinding.end(); it != end; ++it)
+    {
+      // Should not be needed (see setMouseBindingDescription())
+      if (it.value().isNull())
+	continue;
+
+      QString button = keyboardModifiersString(it.key().modifiers) + mouseButtonsString(it.key().button);
+      if (it.key().doubleClick)
+	button += &quot; double click&quot;;
+      if (it.key().button == Qt::NoButton)
+	button += &quot;Wheel&quot;;
+      if (it.key().buttonsBefore != Qt::NoButton)
+	button += &quot; with &quot; + mouseButtonsString(it.key().buttonsBefore) + &quot; pressed&quot;;
+
+      text += tableLine(button, it.value());
+    }
+
+  // Optionnal separator line
+  if (!mouseBinding.isEmpty())
+    {
+      mouseBinding.clear();
+      text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;Standard mouse bindings&lt;/td&gt;&lt;/tr&gt;\n&quot;;
+    }
+
+  // Concatenates the descriptions of wheelBinding_, mouseBinding_, clickBinding_ and mouseDescription_.
+  // The order is significant and corresponds to the priorities set in mousePressEvent()
+  // #CONNECTION# mousePressEvent() order
+  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator itw=wheelBinding_.begin(), endw=wheelBinding_.end(); itw != endw; ++itw)
+    {
+      ClickActionPrivate cap;
+      cap.doubleClick = false;
+      cap.modifiers = itw.key();
+      cap.button = Qt::NoButton;
+      cap.buttonsBefore = Qt::NoButton;
+
+      QString text = mouseActionString(itw.value().action);
+
+      if (!text.isNull())
+	{
+	  switch (itw.value().handler)
+	    {
+	    case CAMERA: text += &quot; camera&quot;; break;
+	    case FRAME:  text += &quot; manipulated frame&quot;; break;
+	    }
+	  if (!(itw.value().withConstraint))
+	    text += &quot;*&quot;;
+	}
+
+      mouseBinding[cap] = text;
+    }
+
+  for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator itmb=mouseBinding_.begin(), endmb=mouseBinding_.end();
+       itmb != endmb; ++itmb)
+    {
+      ClickActionPrivate cap;
+      cap.doubleClick = false;
+      cap.modifiers = QtKeyboardModifiers(itmb.key() &amp; Qt::KeyboardModifierMask);
+      cap.button = QtMouseButtons(itmb.key() &amp; Qt::MouseButtonMask);
+      cap.buttonsBefore = Qt::NoButton;
+
+      QString text = mouseActionString(itmb.value().action);
+
+      if (!text.isNull())
+	{
+	  switch (itmb.value().handler)
+	    {
+	    case CAMERA: text += &quot; camera&quot;; break;
+	    case FRAME:  text += &quot; manipulated frame&quot;; break;
+	    }
+	  if (!(itmb.value().withConstraint))
+	    text += &quot;*&quot;;
+	}
+      mouseBinding[cap] = text;
+    }
+
+  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator itcb=clickBinding_.begin(), endcb=clickBinding_.end(); itcb!=endcb; ++itcb)
+    mouseBinding[itcb.key()] = clickActionString(itcb.value());
+
+  for (QMap&lt;ClickActionPrivate, QString&gt;::ConstIterator it2=mouseBinding.begin(), end2=mouseBinding.end(); it2 != end2; ++it2)
+    {
+      if (it2.value().isNull())
+	continue;
+
+      QString button = keyboardModifiersString(it2.key().modifiers) + mouseButtonsString(it2.key().button);
+      if (it2.key().doubleClick)
+	button += &quot; double click&quot;;
+      if (it2.key().button == Qt::NoButton)
+	button += &quot;Wheel&quot;;
+      if (it2.key().buttonsBefore != Qt::NoButton)
+	button += &quot; with &quot; + mouseButtonsString(it2.key().buttonsBefore) + &quot; pressed&quot;;
+
+      text += tableLine(button, it2.value());
+    }
+
+  text += &quot;&lt;/table&gt;&quot;;
+
+  return text;
+}
+
+/*! Defines a custom keyboard shortcut description, that will be displayed in the help() window \c
+ Keyboard tab.
+
+ The \p key definition is given as an \c int using Qt enumerated values. Set an empty \p description
+ to remove a shortcut description:
+ \code
+ setKeyDescription(Qt::Key_W, &quot;Toggles wireframe display&quot;);
+ setKeyDescription(Qt::CTRL+Qt::Key_L, &quot;Loads a new scene&quot;);
+ // Removes a description
+ setKeyDescription(Qt::CTRL+Qt::Key_C, &quot;&quot;);
+ \endcode
+
+ See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for illustration
+ and the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
+void QGLViewer::setKeyDescription(int key, QString description)
+{
+#if QT_VERSION &gt;= 0x030000
+  // #CONNECTION# keyString. In Qt 2.3, longs modifier overlap with key codes.
+  key = convertToKeyboardModifiers(key);
+#endif
+  if (description.isEmpty())
+    keyDescription_.remove(key);
+  else
+    keyDescription_[key] = description;
+}
+
+static QString keyString(int key)
+{
+#if QT_VERSION &gt;= 0x030000
+  return QString(QKeySequence(convertToShortModifier(key)));
+#else
+  // #CONNECTION# setKeyDescription. In Qt 2.3, longs modifier overlap with key codes.
+  return QString(QKeySequence(key));
+#endif
+}
+
+QString QGLViewer::cameraPathKeysString() const
+{
+  if (pathIndex_.isEmpty())
+    return QString::null;
+
+#if QT_VERSION &gt;= 0x040000 || QT_VERSION &lt; 0x030000
+  QVector&lt;int&gt; keys;
+#else
+  QValueVector&lt;int&gt; keys;
+#endif
+  keys.reserve(pathIndex_.count());
+  for (QMap&lt;Qt::Key, int&gt;::ConstIterator i = pathIndex_.begin(), endi=pathIndex_.end(); i != endi; ++i)
+    keys.push_back(i.key());
+#if QT_VERSION &gt;= 0x040000
+  qSort(keys);
+#else
+# if QT_VERSION &gt;= 0x030000
+  qHeapSort(keys);
+# else
+  sort(keys.begin(), keys.end());
+# endif
+#endif
+
+#if QT_VERSION &gt;= 0x040000 || QT_VERSION &lt; 0x030000
+  QVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
+#else
+  QValueVector&lt;int&gt;::const_iterator it = keys.begin(), end = keys.end();
+#endif
+  QString res = keyString(*it);
+
+  const int maxDisplayedKeys = 6;
+  int nbDisplayedKeys = 0;
+  int previousKey = (*it);
+  int state = 0;
+  ++it;
+  while ((it != end) &amp;&amp; (nbDisplayedKeys &lt; maxDisplayedKeys-1))
+    {
+      switch (state)
+	{
+	case 0 :
+	  if ((*it) == previousKey + 1)
+	    state++;
+	  else
+	    {
+	      res += &quot;, &quot; + keyString(*it);
+	      nbDisplayedKeys++;
+	    }
+	  break;
+	case 1 :
+	  if ((*it) == previousKey + 1)
+	    state++;
+	  else
+	    {
+	      res += &quot;, &quot; + keyString(previousKey);
+	      res += &quot;, &quot; + keyString(*it);
+	      nbDisplayedKeys += 2;
+	      state = 0;
+	    }
+	  break;
+	default :
+	  if ((*it) != previousKey + 1)
+	    {
+	      res += &quot;..&quot; + keyString(previousKey);
+	      res += &quot;, &quot; + keyString(*it);
+	      nbDisplayedKeys += 2;
+	      state = 0;
+	    }
+	  break;
+	}
+      previousKey = *it;
+      ++it;
+    }
+
+  if (state == 1)
+    res += &quot;, &quot; + keyString(previousKey);
+  if (state == 2)
+    res += &quot;..&quot; + keyString(previousKey);
+  if (it != end)
+    res += &quot;...&quot;;
+
+  return res;
+}
+
+/*! Returns a QString that describes the application keyboard shortcut bindings, and that will be
+ displayed in the help() window \c Keyboard tab.
+
+ Default value is a table that describes the custom shortcuts defined using setKeyDescription() as
+ well as the \e standard QGLViewer::KeyboardAction shortcuts (defined using setShortcut()). See the
+ &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details on key customization.
+
+ See also helpString() and mouseString(). */
+QString QGLViewer::keyboardString() const
+{
+  QString text(&quot;&lt;table border=\&quot;1\&quot; cellspacing=\&quot;0\&quot;&gt;\n&quot;);
+  text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;th align=\&quot;center\&quot;&gt;Key(s)&lt;/th&gt;&lt;th align=\&quot;center\&quot;&gt;Description&lt;/th&gt;&lt;/tr&gt;\n&quot;;
+
+  QMap&lt;int, QString&gt; keyDescription;
+
+  // 1 - User defined key descriptions
+  for (QMap&lt;int, QString&gt;::ConstIterator kd=keyDescription_.begin(), kdend=keyDescription_.end(); kd!=kdend; ++kd)
+    keyDescription[kd.key()] = kd.value();
+
+  // Add to text in sorted order
+  for (QMap&lt;int, QString&gt;::ConstIterator kb=keyDescription.begin(), endb=keyDescription.end(); kb!=endb; ++kb)
+    text += tableLine(keyString(kb.key()), kb.value());
+
+
+  // 2 - Optional separator line
+  if (!keyDescription.isEmpty())
+    {
+      keyDescription.clear();
+      text += &quot;&lt;tr bgcolor=\&quot;#aaaacc\&quot;&gt;&lt;td colspan=2&gt;Standard viewer keys&lt;/td&gt;&lt;/tr&gt;\n&quot;;
+    }
+
+
+  // 3 - KeyboardAction bindings description
+  for (QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end(); it != end; ++it)
+    if ((it.value() != 0) &amp;&amp; ((!cameraIsInRevolveMode()) || ((it.key() != INCREASE_FLYSPEED) &amp;&amp; (it.key() != DECREASE_FLYSPEED))))
+      keyDescription[it.value()] = keyboardActionDescription_[it.key()];
+
+  // Add to text in sorted order
+  for (QMap&lt;int, QString&gt;::ConstIterator kb2=keyDescription.begin(), endb2=keyDescription.end(); kb2!=endb2; ++kb2)
+    text += tableLine(keyString(kb2.key()), kb2.value());
+
+
+  // 4 - Camera paths keys description
+  const QString cpks = cameraPathKeysString();
+  if (!cpks.isNull())
+    {
+      text += &quot;&lt;tr bgcolor=\&quot;#ccccff\&quot;&gt;&gt;&lt;td colspan=2&gt;\nCamera paths are controlled using &quot; + cpks + &quot; (noted &lt;i&gt;Fx&lt;/i&gt; below):&lt;/td&gt;&lt;/tr&gt;\n&quot;;
+      text += tableLine(keyboardModifiersString(playPathKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;&quot;,
+			&quot;Plays path (or resets saved position)&quot;);
+      text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;&quot;,
+			&quot;Adds a key frame (or defines a position)&quot;);
+      text += tableLine(keyboardModifiersString(addKeyFrameKeyboardModifiers()) + &quot;&lt;i&gt;Fx&lt;/i&gt;+&lt;i&gt;Fx&lt;/i&gt;&quot;,
+			&quot;Deletes path (or saved position)&quot;);
+    }
+  text += &quot;&lt;/table&gt;&quot;;
+
+  return text;
+}
+
+/*! Opens a modal help window that includes three tabs, respectively filled with helpString(),
+  keyboardString() and mouseString().
+
+ Rich html-like text can be used (see the QStyleSheet documentation). This method is called when the
+ user presses the QGLViewer::HELP (default is 'H').
+
+ Use helpWidget() to access to the help widget (to add/remove tabs, change layout...). The &quot;About&quot;
+ button (helpWidget()-&gt;cornerWidget()) is connected to the aboutQGLViewer() slot.
+
+ The helpRequired() signal is emitted. */
+void QGLViewer::help()
+{
+  emit helpRequired();
+
+  bool resize = false;
+  int width=600;
+  int height=400;
+
+  static QString label[] = {&quot; &amp;Help &quot;, &quot; &amp;Keyboard &quot;, &quot; &amp;Mouse &quot;};
+
+  if (!helpWidget())
+    {
+      // Qt4 requires a NULL parent...
+      helpWidget_ = new QTabWidget(NULL);
+#if QT_VERSION &gt;= 0x040000
+      helpWidget()-&gt;setWindowTitle(&quot;Help&quot;);
+#else
+      helpWidget()-&gt;setCaption(&quot;Help&quot;);
+#endif
+
+#if QT_VERSION &gt;= 0x030200
+      QPushButton* aboutButton = new QPushButton(&quot;About&quot;, helpWidget());
+      connect(aboutButton, SIGNAL(released()), SLOT(aboutQGLViewer()));
+      helpWidget()-&gt;setCornerWidget(aboutButton);
+#endif
+
+      resize = true;
+      for (int i=0; i&lt;3; ++i)
+	{
+	  QTextEdit* tab = new QTextEdit(NULL);
+#if QT_VERSION &gt;= 0x030000
+	  tab-&gt;setReadOnly(true);
+#endif
+
+#if QT_VERSION &gt;= 0x040000
+	  helpWidget()-&gt;insertTab(i, tab, label[i]);
+#else
+	  tab-&gt;setTextFormat(Qt::RichText);
+	  helpWidget()-&gt;insertTab(tab, label[i]);
+#endif
+	}
+    }
+
+#if QT_VERSION &lt; 0x030000
+  const int currentPageIndex = helpWidget()-&gt;currentPageIndex();
+#endif
+
+  for (int i=0; i&lt;3; ++i)
+    {
+      QString text;
+      switch (i)
+	{
+	case 0 : text = helpString();	  break;
+	case 1 : text = keyboardString(); break;
+	case 2 : text = mouseString();	  break;
+	default : break;
+	}
+
+#if QT_VERSION &gt;= 0x040000
+    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;widget(i));
+    textEdit-&gt;setHtml(text);
+#else
+# if QT_VERSION &lt; 0x030000
+    helpWidget()-&gt;setCurrentPage(i);
+    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;currentPage());
+# else
+    QTextEdit* textEdit = (QTextEdit*)(helpWidget()-&gt;page(i));
+# endif
+    textEdit-&gt;setText(text);
+#endif
+
+#if QT_VERSION &lt; 0x040000
+    if (resize &amp;&amp; (textEdit-&gt;heightForWidth(width) &gt; height))
+      height = textEdit-&gt;heightForWidth(width);
+#else
+    if (resize &amp;&amp; (textEdit-&gt;height() &gt; height))
+      height = textEdit-&gt;height();
+#endif
+    }
+
+#if QT_VERSION &lt; 0x030000
+  helpWidget()-&gt;setCurrentPage(currentPageIndex);
+#endif
+
+  if (resize)
+    helpWidget()-&gt;resize(width, height+40); // 40 pixels is ~ tabs' height
+  helpWidget()-&gt;show();
+  helpWidget()-&gt;raise();
+}
+
+/*! Overloading of the \c QWidget method.
+
+ Default keyboard shortcuts are defined using setShortcut(). Overload this method to implement a
+ specific keyboard binding. Call the original method if you do not catch the event to preserve the
+ viewer default key bindings:
+ \code
+ void Viewer::keyPressEvent(QKeyEvent *e)
+ {
+   // With Qt 2 or 3, you would retrieve modifiers keys using :
+   // const Qt::ButtonState modifiers = (Qt::ButtonState)(e-&gt;state() &amp; Qt::KeyButtonMask);
+
+   // Defines the Alt+R shortcut. Call updateGL to refresh display.
+   if ((e-&gt;key() == Qt::Key_R) &amp;&amp; (e-&gt;modifiers() == Qt::AltModifier))
+     {
+       myResetFunction();
+       updateGL();
+     }
+   else
+     QGLViewer::keyPressEvent(e);
+ }
+ \endcode
+ When you define a new keyboard shortcut, use setKeyDescription() to provide a short description
+ which is displayed in the help() window Keyboard tab. See the &lt;a
+ href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
+
+ See also QGLWidget::keyReleaseEvent(). */
+void QGLViewer::keyPressEvent(QKeyEvent *e)
+{
+  if (e-&gt;key() == 0)
+    {
+      e-&gt;ignore();
+      return;
+    }
+
+  const Qt::Key key = Qt::Key(e-&gt;key());
+#if QT_VERSION &gt;= 0x040000
+  const QtKeyboardModifiers modifiers = e-&gt;modifiers();
+#else
+  const QtKeyboardModifiers modifiers = (QtKeyboardModifiers)(e-&gt;state() &amp; Qt::KeyboardModifierMask);
+#endif
+
+  QMap&lt;KeyboardAction, int&gt;::ConstIterator it=keyboardBinding_.begin(), end=keyboardBinding_.end();
+  while ((it != end) &amp;&amp; (it.value() != (key | modifiers)))
+    ++it;
+
+  if (it != end)
+    handleKeyboardAction(it.key());
+  else
+    if (pathIndex_.contains(Qt::Key(key)))
+      {
+	// Camera paths
+	int index = pathIndex_[Qt::Key(key)];
+
+	static QTime doublePress; // try to double press on two viewers at the same time !
+
+	if (modifiers == playPathKeyboardModifiers())
+	  {
+	    int elapsed = doublePress.restart();
+	    if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
+	      camera()-&gt;resetPath(index);
+	    else
+	      {
+		// Stop previous interpolation before starting a new one.
+		if (index != previousPathId_)
+		  {
+		    KeyFrameInterpolator* previous = camera()-&gt;keyFrameInterpolator(previousPathId_);
+		    if ((previous) &amp;&amp; (previous-&gt;interpolationIsStarted()))
+		      previous-&gt;resetInterpolation();
+		  }
+		camera()-&gt;playPath(index);
+	      }
+	    previousPathId_ = index;
+	  }
+	else if (modifiers == addKeyFrameKeyboardModifiers())
+	  {
+	    int elapsed = doublePress.restart();
+	    if ((elapsed &lt; 250) &amp;&amp; (index==previousPathId_))
+	      {
+		if (camera()-&gt;keyFrameInterpolator(index))
+		  {
+		    disconnect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), this, SLOT(updateGL()));
+		    if (camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames() &gt; 1)
+		      displayMessage(&quot;Path &quot;+QString::number(index)+&quot; deleted&quot;);
+		    else
+		      displayMessage(&quot;Position &quot;+QString::number(index)+&quot; deleted&quot;);
+		    camera()-&gt;deletePath(index);
+		  }
+	      }
+	    else
+	      {
+		bool nullBefore = (camera()-&gt;keyFrameInterpolator(index) == NULL);
+		camera()-&gt;addKeyFrameToPath(index);
+		if (nullBefore)
+		  connect(camera()-&gt;keyFrameInterpolator(index), SIGNAL(interpolated()), SLOT(updateGL()));
+		int nbKF = camera()-&gt;keyFrameInterpolator(index)-&gt;numberOfKeyFrames();
+		if (nbKF == 1)
+		  displayMessage(&quot;Position &quot;+QString::number(index)+&quot; saved&quot;);
+		else
+		  displayMessage(&quot;Path &quot;+QString::number(index)+&quot;, position &quot;+QString::number(nbKF)+&quot; saved&quot;);
+	      }
+	    previousPathId_ = index;
+	  }
+	updateGL();
+      }
+    else
+      e-&gt;ignore();
+}
+
+void QGLViewer::handleKeyboardAction(KeyboardAction id)
+{
+  switch (id)
+    {
+    case DRAW_AXIS :		toggleAxisIsDrawn(); break;
+    case DRAW_GRID :		toggleGridIsDrawn(); break;
+    case DISPLAY_FPS :		toggleFPSIsDisplayed(); break;
+    case ENABLE_TEXT :		toggleTextIsEnabled(); break;
+    case EXIT_VIEWER :		saveStateToFileForAllViewers(); qApp-&gt;closeAllWindows(); break;
+    case SAVE_SCREENSHOT :	saveSnapshot(false, false); break;
+    case FULL_SCREEN :		toggleFullScreen(); break;
+    case STEREO :		toggleStereoDisplay(); break;
+    case ANIMATION :		toggleAnimation(); break;
+    case HELP :			help(); break;
+    case EDIT_CAMERA :		toggleCameraIsEdited(); break;
+    case CAMERA_MODE :
+      toggleCameraMode();
+      displayMessage(cameraIsInRevolveMode()?&quot;Camera in revolve around mode&quot;:&quot;Camera in fly mode&quot;);
+      break;
+
+    case MOVE_CAMERA_LEFT :
+      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(-10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
+      updateGL();
+      break;
+    case MOVE_CAMERA_RIGHT :
+      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec( 10.0*camera()-&gt;flySpeed(), 0.0, 0.0)));
+      updateGL();
+      break;
+    case MOVE_CAMERA_UP :
+      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0,  10.0*camera()-&gt;flySpeed(), 0.0)));
+      updateGL();
+      break;
+    case MOVE_CAMERA_DOWN :
+      camera()-&gt;frame()-&gt;translate(camera()-&gt;frame()-&gt;inverseTransformOf(Vec(0.0, -10.0*camera()-&gt;flySpeed(), 0.0)));
+      updateGL();
+      break;
+
+    case INCREASE_FLYSPEED : 	camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() * 1.5); break;
+    case DECREASE_FLYSPEED : 	camera()-&gt;setFlySpeed(camera()-&gt;flySpeed() / 1.5); break;
+    }
+}
+
+/*! Callback method used when the widget size is modified.
+
+ If you overload this method, first call the inherited method. Also called when the widget is
+ created, before its first display. */
+void QGLViewer::resizeGL(int width, int height)
+{
+  QGLWidget::resizeGL(width, height);
+  glViewport( 0, 0, GLint(width), GLint(height) );
+  camera()-&gt;setScreenWidthAndHeight(this-&gt;width(), this-&gt;height());
+}
+
+//////////////////////////////////////////////////////////////////////////
+//              K e y b o a r d   s h o r t c u t s                     //
+//////////////////////////////////////////////////////////////////////////
+
+/*! Defines the shortcut() that triggers a given QGLViewer::KeyboardAction.
+
+ Here are some examples:
+ \code
+ // Press 'Q' to exit application
+ setShortcut(EXIT_VIEWER, Qt::Key_Q);
+
+ // Alt+M toggles camera mode
+ setShortcut(CAMERA_MODE, Qt::ALT+Qt::Key_M);
+
+ // The DISPLAY_FPS action is disabled
+ setShortcut(DISPLAY_FPS, 0);
+ \endcode
+
+ Only one shortcut can be assigned to a given QGLViewer::KeyboardAction (new bindings replace
+ previous ones). If several KeyboardAction are binded to the same shortcut, only one of them is
+ active. */
+void QGLViewer::setShortcut(KeyboardAction action, int key)
+{
+  keyboardBinding_[action] = convertToKeyboardModifiers(key);
+}
+
+/*! Returns the keyboard shortcut associated to a given QGLViewer::KeyboardAction.
+
+ Result is an \c int defined using Qt enumerated values, as in \c Qt::Key_Q or \c
+ Qt::CTRL+Qt::Key_X. Use Qt::MODIFIER_MASK to separate the key from the state keys. Returns \c 0 if
+ the KeyboardAction is disabled (not binded). Set using setShortcut().
+
+ If you want to define keyboard shortcuts for custom actions (say, open a scene file), overload
+ keyPressEvent() and then setKeyDescription().
+
+ These shortcuts and their descriptions are automatically included in the help() window \c Keyboard
+ tab.
+
+ See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details and default values and the &lt;a
+ href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for a practical
+ illustration. */
+int QGLViewer::shortcut(KeyboardAction action) const
+{
+  if (keyboardBinding_.contains(action))
+    return convertToShortModifier(keyboardBinding_[action]);
+  else
+    return 0;
+}
+
+#ifndef DOXYGEN
+void QGLViewer::setKeyboardAccelerator(KeyboardAction action, int key)
+{
+  qWarning(&quot;setKeyboardAccelerator is deprecated. Use setShortcut instead.&quot;);
+  setShortcut(action, key);
+}
+
+int QGLViewer::keyboardAccelerator(KeyboardAction action) const
+{
+  qWarning(&quot;keyboardAccelerator is deprecated. Use shortcut instead.&quot;);
+  return shortcut(action);
+}
+#endif
+
+///////     Key Frames associated keys       ///////
+
+/*! Returns the keyboard key associated to camera Key Frame path \p index.
+
+ Default values are F1..F12 for indexes 1..12.
+
+ addKeyFrameKeyboardModifiers() (resp. playPathKeyboardModifiers()) define the state key(s) that
+ must be pressed with this key to add a KeyFrame to (resp. to play) the associated Key Frame path.
+ If you quickly press twice the pathKey(), the path is reset (resp. deleted).
+
+ Use camera()-&gt;keyFrameInterpolator( \p index ) to retrieve the KeyFrameInterpolator that defines
+ the path.
+
+ If several keys are binded to a given \p index (see setPathKey()), one of them is returned.
+ Returns \c 0 if no key is associated with this index.
+
+ See also the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt;. */
+Qt::Key QGLViewer::pathKey(int index) const
+{
+  for (QMap&lt;Qt::Key, int&gt;::ConstIterator it = pathIndex_.begin(), end=pathIndex_.end(); it != end; ++it)
+    if (it.value() == index)
+      return it.key();
+  return Qt::Key(0);
+}
+
+/*! Sets the pathKey() associated with the camera Key Frame path \p index.
+
+ Several keys can be binded to the same \p index. Use a negated \p key value to delete the binding
+ (the \p index value is then ignored):
+ \code
+ // Press 'space' to play/pause/add/delete camera path of index 0.
+ setPathKey(Qt::Key_Space, 0);
+
+ // Remove this binding
+ setPathKey(-Qt::Key_Space);
+ \endcode */
+void QGLViewer::setPathKey(int key, int index)
+{
+  if (key &lt; 0)
+    pathIndex_.remove(Qt::Key(-key));
+  else
+    pathIndex_[Qt::Key(key)] = index;
+}
+
+/*! Sets the playPathKeyboardModifiers() value. */
+void QGLViewer::setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers)
+{
+  playPathKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
+}
+
+/*! Sets the addKeyFrameKeyboardModifiers() value. */
+void QGLViewer::setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers)
+{
+  addKeyFrameKeyboardModifiers_ = convertKeyboardModifiers(modifiers);
+}
+
+/*! Returns the keyboard modifiers that must be pressed with a pathKey() to add the current camera
+  position to a KeyFrame path.
+
+ It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
+ Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
+
+ Default value is Qt::AltModifier. Defined using setAddKeyFrameKeyboardModifiers().
+
+ See also playPathKeyboardModifiers().
+
+ \note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
+ The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
+ Qt::AltButton, ...). */
+QtKeyboardModifiers QGLViewer::addKeyFrameKeyboardModifiers() const
+{
+  return addKeyFrameKeyboardModifiers_;
+}
+
+/*! Returns the keyboard modifiers that must be pressed with a pathKey() to play a camera KeyFrame path.
+
+ It can be \c Qt::NoModifier, \c Qt::ControlModifier, \c Qt::ShiftModifier, \c Qt::AltModifier, \c
+ Qt::MetaModifier or a combination of these (using the bitwise '|' operator).
+
+ Default value is Qt::NoModifier. Defined using setPlayPathKeyboardModifiers().
+
+ See also addKeyFrameKeyboardModifiers().
+
+ \note If you use Qt version 2 or 3, the \c Qt::KeyboardModifiers is actually a \c Qt::ButtonState.
+ The \c Modifier postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c
+ Qt::AltButton, ...). */
+QtKeyboardModifiers QGLViewer::playPathKeyboardModifiers() const
+{
+  return playPathKeyboardModifiers_;
+}
+
+#ifndef DOXYGEN
+// Deprecated methods
+QtKeyboardModifiers QGLViewer::addKeyFrameStateKey() const
+{
+  qWarning(&quot;addKeyFrameStateKey has been renamed addKeyFrameKeyboardModifiers&quot;);
+  return addKeyFrameKeyboardModifiers(); }
+
+QtKeyboardModifiers QGLViewer::playPathStateKey() const
+{
+  qWarning(&quot;playPathStateKey has been renamed playPathKeyboardModifiers&quot;);
+  return playPathKeyboardModifiers();
+}
+
+void QGLViewer::setAddKeyFrameStateKey(int buttonState)
+{
+  qWarning(&quot;setAddKeyFrameStateKey has been renamed setAddKeyFrameKeyboardModifiers&quot;);
+  setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+}
+
+void QGLViewer::setPlayPathStateKey(int buttonState)
+{
+  qWarning(&quot;setPlayPathStateKey has been renamed setPlayPathKeyboardModifiers&quot;);
+  setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+}
+
+Qt::Key QGLViewer::keyFrameKey(int index) const
+{
+  qWarning(&quot;keyFrameKey has been renamed pathKey.&quot;);
+  return pathKey(index);
+}
+
+QtKeyboardModifiers QGLViewer::playKeyFramePathStateKey() const
+{
+  qWarning(&quot;playKeyFramePathStateKey has been renamed playPathKeyboardModifiers.&quot;);
+  return playPathKeyboardModifiers();
+}
+
+void QGLViewer::setKeyFrameKey(int index, int key)
+{
+  qWarning(&quot;setKeyFrameKey is deprecated, use setPathKey instead, with swapped parameters.&quot;);
+  setPathKey(key, index);
+}
+
+void QGLViewer::setPlayKeyFramePathStateKey(int buttonState)
+{
+  qWarning(&quot;setPlayKeyFramePathStateKey has been renamed setPlayPathKeyboardModifiers.&quot;);
+  setPlayPathKeyboardModifiers(QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+//              M o u s e   b e h a v i o r   s t a t e   k e y s             //
+////////////////////////////////////////////////////////////////////////////////
+/*! Associates keyboard modifiers to MouseHandler \p handler.
+
+ The \p modifiers parameter is \c Qt::AltModifier, \c Qt::ShiftModifier, \c Qt::ControlModifier, \c
+ Qt::MetaModifier or a combination of these using the '|' bitwise operator. Some shorter names are
+ also available: \c Qt::ALT, \c Qt::CTRL, \c Qt::SHIFT or \c QT::META.
+
+ \e All the \p handler's associated bindings will then need the specified \p modifiers key(s) to be
+ activated.
+
+ With this code,
+ \code
+ setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::AltModifier);
+ setHandlerKeyboardModifiers(QGLViewer::FRAME,  Qt::NoModifier);
+ \endcode
+ you will have to press the \c Alt key while pressing mouse buttons in order to move the camera(),
+ while no key will be needed to move the manipulatedFrame().
+
+ This method has a very basic implementation: every action binded to \p handler has its keyboard
+ modifier replaced by \p modifiers. If \p handler had some actions binded to different modifiers,
+ these settings will be lost. You should hence consider using setMouseBinding() for finer tuning.
+
+ The default binding associates \c Qt::ControlModifier to all the QGLViewer::FRAME actions and \c
+ Qt::NoModifier to all QGLViewer::CAMERA actions. See &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for
+ details.
+
+ \attention This method calls setMouseBinding(), which ensures that only one action is binded to a
+ given modifiers. If you want to \e swap the QGLViewer::CAMERA and QGLViewer::FRAME keyboard
+ modifiers, you have to use a temporary dummy modifier (as if you were swapping two variables) or
+ else the first call will overwrite the previous settings:
+ \code
+ // Associate FRAME with Alt (temporary value)
+ setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::AltModifier);
+ // Control is associated with CAMERA
+ setHandlerKeyboardModifiers(QGLViewer::CAMERA, Qt::ControlModifier);
+ // And finally, FRAME can be associated with NoModifier
+ setHandlerKeyboardModifiers(QGLViewer::FRAME, Qt::NoModifier);
+ \endcode
+
+ \note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
+ sufix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
+ \c Qt::ShiftButton and \c Qt::MetaButton). */
+void QGLViewer::setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers)
+{
+  QMap&lt;int, MouseActionPrivate&gt; newMouseBinding;
+  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; newWheelBinding;
+  QMap&lt;ClickActionPrivate, ClickAction&gt; newClickBinding_;
+
+  QMap&lt;int, MouseActionPrivate&gt;::Iterator mit;
+  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::Iterator wit;
+
+  // First copy unchanged bindings.
+  for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
+    if ((mit.value().handler != handler) || (mit.value().action == ZOOM_ON_REGION))
+      newMouseBinding[mit.key()] = mit.value();
+
+  for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
+    if (wit.value().handler != handler)
+      newWheelBinding[wit.key()] = wit.value();
+
+  // Then, add modified bindings, that can overwrite the previous ones.
+  modifiers = convertKeyboardModifiers(modifiers);
+  for (mit = mouseBinding_.begin(); mit != mouseBinding_.end(); ++mit)
+    if ((mit.value().handler == handler) &amp;&amp; (mit.value().action != ZOOM_ON_REGION))
+      {
+	int newState = modifiers | (mit.key() &amp; Qt::MouseButtonMask);
+	newMouseBinding[newState] = mit.value();
+      }
+
+  for (wit = wheelBinding_.begin(); wit != wheelBinding_.end(); ++wit)
+    if (wit.value().handler == handler)
+      {
+	QtKeyboardModifiers newState = modifiers;
+	newWheelBinding[newState] = wit.value();
+      }
+
+  // Same for button bindings
+  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator cb=clickBinding_.begin(), end=clickBinding_.end(); cb != end; ++cb)
+    if (((handler==CAMERA) &amp;&amp; ((cb.value() == CENTER_SCENE) || (cb.value() == ALIGN_CAMERA))) ||
+	((handler==FRAME)  &amp;&amp; ((cb.value() == CENTER_FRAME) || (cb.value() == ALIGN_FRAME))))
+      {
+	ClickActionPrivate cap;
+	cap.modifiers = modifiers;
+	cap.button = cb.key().button;
+	cap.doubleClick = cb.key().doubleClick;
+	cap.buttonsBefore = cb.key().buttonsBefore;
+	newClickBinding_[cap] = cb.value();
+      }
+    else
+      newClickBinding_[cb.key()] = cb.value();
+  
+  mouseBinding_ = newMouseBinding;
+  wheelBinding_ = newWheelBinding;
+  clickBinding_ = newClickBinding_;
+}
+
+
+#ifndef DOXYGEN
+void QGLViewer::setHandlerStateKey(MouseHandler handler, int buttonState)
+{
+  qWarning(&quot;setHandlerStateKey has been renamed setHandlerKeyboardModifiers&quot;);
+  setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+}
+
+void QGLViewer::setMouseStateKey(MouseHandler handler, int buttonState)
+{
+  qWarning(&quot;setMouseStateKey has been renamed setHandlerKeyboardModifiers.&quot;);
+  setHandlerKeyboardModifiers(handler, QtKeyboardModifiers(buttonState &amp; Qt::KeyboardModifierMask));
+}
+#endif
+
+/*! Associates a MouseAction to any mouse button and keyboard modifiers \p state combination. The
+ receiver of the mouse events is a MouseHandler (QGLViewer::CAMERA or QGLViewer::FRAME).
+
+ The parameters should read: when the \p state mouse button and keyboard modifiers are pressed,
+ activate \p action on \p handler. If \p withConstraint is \c true (default), the
+ qglviewer::Frame::constraint() associated with the Frame will be enforced during motion.
+
+ Use the '|' bitwise operator or '+' to combine keys and buttons:
+ \code
+ // Left and right buttons together make a camera zoom: emulates a mouse third button if needed.
+ setMouseBinding(Qt::LeftButton + Qt::RightButton, CAMERA, ZOOM);
+
+ // Alt + Shift + Left button rotates the manipulatedFrame().
+ setMouseBinding(Qt::ALT + Qt::SHIFT + Qt::LeftButton, FRAME, ROTATE);
+ \endcode
+
+ The list of all possible MouseAction, some binding examples and default bindings are provided in
+ the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;.
+
+ See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse&lt;/a&gt; example for an illustration.
+
+ If no mouse button is specified in \p state, the binding is ignored. If an action was previously
+ associated with this \p state, it is silently overwritten (use mouseAction() before to know if the
+ \p state is already binded).
+
+ To remove a specific mouse binding, use code like:
+ \code
+ setMouseBinding(myButtonAndModifiersCombo, myHandler, NO_MOUSE_ACTION);
+ \endcode
+
+ See also setMouseBinding(int, ClickAction, bool, int) and setWheelBinding(). */
+void QGLViewer::setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint)
+{
+  if ((handler == FRAME) &amp;&amp; ((action == MOVE_FORWARD) || (action == MOVE_BACKWARD) ||
+			     (action == ROLL) || (action == LOOK_AROUND) ||
+			     (action == ZOOM_ON_REGION)))
+    {
+#if QT_VERSION &gt;= 0x040000
+      qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;).toLatin1().constData());
+#else
+      qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME&quot;);
+#endif
+    }
+  else
+    if ((state &amp; Qt::MouseButtonMask) == 0)
+      qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
+    else
+      {
+	MouseActionPrivate map;
+	map.handler = handler;
+	map.action = action;
+	map.withConstraint = withConstraint;
+	state = convertToKeyboardModifiers(state);
+
+	mouseBinding_.remove(state);
+
+	if (action != NO_MOUSE_ACTION)
+	  mouseBinding_.insert(state, map);
+
+	ClickActionPrivate cap;
+	cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
+	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+	cap.doubleClick = false;
+	cap.buttonsBefore = Qt::NoButton;
+	clickBinding_.remove(cap);
+      }
+}
+
+/*! Associates a ClickAction to any mouse buttons and keyboard modifiers combination.
+
+ The parameters should read: when the \p state mouse button(s) is (are) pressed (possibly with Alt,
+ Control or Shift modifiers or any combination of these), and possibly with a \p doubleClick,
+ perform \p action.
+
+ If \p buttonsBefore is specified (valid only when \p doubleClick is \c true), then this mouse
+ button(s) has to be pressed \e before the double click occurs in order to perform \p action.
+
+ The list of all possible ClickAction, some binding examples and default bindings are listed in the
+ &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt;. See also the setMouseBinding() documentation.
+
+ See the &lt;a href=&quot;../examples/keyboardAndMouse.html&quot;&gt;keyboardAndMouse example&lt;/a&gt; for an
+ illustration.
+
+ The binding is ignored if no mouse button is specified in \p state.
+
+ \note If you use Qt version 2 or 3, the \p buttonsBefore is actually a Qt::ButtonState. */
+void QGLViewer::setMouseBinding(int state, ClickAction action, bool doubleClick, QtMouseButtons buttonsBefore)
+{
+  if ((buttonsBefore != Qt::NoButton) &amp;&amp; !doubleClick)
+    qWarning(&quot;Buttons before is only meaningful when doubleClick is true in setMouseBinding().&quot;);
+  else
+    if ((state &amp; Qt::MouseButtonMask) == 0)
+      qWarning(&quot;No mouse button specified in setMouseBinding&quot;);
+    else
+      {
+	ClickActionPrivate cap;
+	state = convertToKeyboardModifiers(state);
+	cap.modifiers = QtKeyboardModifiers(state &amp; Qt::KeyboardModifierMask);
+	cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+	cap.doubleClick = doubleClick;
+	cap.buttonsBefore = buttonsBefore;
+	clickBinding_.remove(cap);
+
+	// #CONNECTION performClickAction comment on NO_CLICK_ACTION
+	if (action != NO_CLICK_ACTION)
+	  clickBinding_.insert(cap, action);
+
+	if ((!doubleClick) &amp;&amp; (buttonsBefore == Qt::NoButton))
+	  mouseBinding_.remove(state);
+      }
+}
+
+/*! Associates a MouseAction and a MouseHandler to a mouse wheel event.
+
+ This method is very similar to setMouseBinding(), but specific to the wheel.
+
+ In the current implementation only QGLViewer::ZOOM can be associated with QGLViewer::FRAME, while
+ QGLViewer::CAMERA can receive QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD.
+
+ The difference between QGLViewer::ZOOM and QGLViewer::MOVE_FORWARD is that QGLViewer::ZOOM speed
+ depends on the distance to the object, while QGLViewer::MOVE_FORWARD moves at a constant speed
+ defined by qglviewer::Camera::flySpeed(). */
+void QGLViewer::setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint)
+{
+  //#CONNECTION# ManipulatedFrame::wheelEvent and ManipulatedCameraFrame::wheelEvent switches
+  if ((action != ZOOM) &amp;&amp; (action != MOVE_FORWARD) &amp;&amp; (action != MOVE_BACKWARD) &amp;&amp; (action != NO_MOUSE_ACTION))
+#if QT_VERSION &gt;= 0x040000
+    qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;).toLatin1().constData());
+#else
+    qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to wheel&quot;);
+#endif
+  else
+    if ((handler == FRAME) &amp;&amp; (action != ZOOM) &amp;&amp; (action != NO_MOUSE_ACTION))
+#if QT_VERSION &gt;= 0x040000
+      qWarning(QString(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;).toLatin1().constData());
+#else
+      qWarning(&quot;Cannot bind &quot; + mouseActionString(action) + &quot; to FRAME wheel&quot;);
+#endif
+    else
+      {
+	MouseActionPrivate map;
+	map.handler = handler;
+	map.action  = action;
+	map.withConstraint = withConstraint;
+	modifiers = convertKeyboardModifiers(modifiers);
+	wheelBinding_.remove(modifiers);
+
+	if (action != NO_MOUSE_ACTION)
+	  wheelBinding_.insert(modifiers, map);
+      }
+}
+
+/*! Returns the MouseAction associated with the \p state mouse button(s) and keyboard modifiers.
+ Returns QGLViewer::NO_MOUSE_ACTION if no action is associated.
+
+ For instance, to know which motion corresponds to Alt+LeftButton, do:
+ \code
+ QGLViewer::MouseAction ma = mouseAction(Qt::ALT + Qt::LeftButton);
+ if (ma != QGLViewer::NO_MOUSE_ACTION) ...
+ \endcode
+
+ Use mouseHandler() to know which object (QGLViewer::CAMERA or QGLViewer::FRAME) will perform this
+ action. */
+QGLViewer::MouseAction QGLViewer::mouseAction(int state) const
+{
+  state = convertToKeyboardModifiers(state);
+  if (mouseBinding_.contains(state))
+    return mouseBinding_[state].action;
+  else
+    return NO_MOUSE_ACTION;
+}
+
+/*! Returns the MouseHandler associated with the \p state. If no action is
+ associated, returns \c -1.
+
+ For instance, to know which handler receives the Alt+LeftButton, do:
+ \code
+ int mh = mouseHandler(Qt::ALT + Qt::LeftButton);
+ if (mh == QGLViewer::CAMERA) ...
+ \endcode
+
+ Use mouseAction() to know which action (see the MouseAction enum) will be perform on this handler. */
+int QGLViewer::mouseHandler(int state) const
+{
+  state = convertToKeyboardModifiers(state);
+  if (mouseBinding_.contains(state))
+    return mouseBinding_[state].handler;
+  else
+    return -1;
+}
+
+/*! Returns the mouse buttons and keyboard modifiers (if any) that have to be used to activate \p
+ action on \p handler (with constraint or not).
+
+ If no state triggers the action, returns Qt::NoButton which is an impossible case since at least
+ one mouse button has to be specified in setMouseBinding().
+
+ To know which keys and mouse buttons have to be pressed to translate the camera, use tests like:
+ \code
+ int bs = mouseButtonState(QGLViewer::CAMERA, QGLViewer::TRANSLATE);
+ if (bs &amp; Qt::RightButton) ... // Right button needed to translate the camera
+ if (bs &amp; Qt::AltModifier)   ... // Alt key needed (use AltModifier with Qt version 2 or 3)
+ if (bs &amp; Qt::KeyboardModifierMask == Qt::NoButton) ... // No keyboard modifier needed
+ \endcode
+
+ Note that mouse bindings are displayed in the 'Mouse' help window tab.
+
+ See also mouseAction() and mouseHandler(). */
+int QGLViewer::mouseButtonState(MouseHandler handler, MouseAction action, bool withConstraint) const
+{
+  for (QMap&lt;int, MouseActionPrivate&gt;::ConstIterator it=mouseBinding_.begin(), end=mouseBinding_.end(); it != end; ++it)
+    if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
+      return it.key();
+
+  return Qt::NoButton;
+}
+
+/*! Same as mouseAction(), but for the wheel action.
+
+ \note If you use Qt version 2 or 3, \p modifiers is actually a \c Qt::ButtonState. The \c Modifier
+ postfix is replaced by \c Button in the enums' names (\c Qt::ControlButton, \c Qt::AltButton,
+ Qt::ShiftButton, Qt::MetaButton). */
+QGLViewer::MouseAction QGLViewer::wheelAction(QtKeyboardModifiers modifiers) const
+{
+  modifiers = convertKeyboardModifiers(modifiers);
+  if (wheelBinding_.contains(modifiers))
+    return wheelBinding_[modifiers].action;
+  else
+    return NO_MOUSE_ACTION;
+}
+
+/*! Same as mouseHandler() but for the wheel action. See also wheelAction(). */
+int QGLViewer::wheelHandler(QtKeyboardModifiers modifiers) const
+{
+  modifiers = convertKeyboardModifiers(modifiers);
+  if (wheelBinding_.contains(modifiers))
+    return wheelBinding_[modifiers].handler;
+  else
+    return -1;
+}
+
+/*! Same as mouseButtonState(), but for the wheel.
+
+\attention Returns -1 when no Qt::ButtonState was associated with this \p handler/ \p action/ \p
+withConstraint combination (mouseButtonState() would return Qt::NoButton instead). */
+int QGLViewer::wheelButtonState(MouseHandler handler, MouseAction action, bool withConstraint) const
+{
+  for (QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt;::ConstIterator it=wheelBinding_.begin(), end=wheelBinding_.end(); it!=end; ++it)
+    if ( (it.value().handler == handler) &amp;&amp; (it.value().action == action) &amp;&amp; (it.value().withConstraint == withConstraint) )
+      return it.key();
+
+  return -1;
+}
+
+/*! Same as mouseAction(), but for the ClickAction set using setMouseBinding(). */
+QGLViewer::ClickAction QGLViewer::clickAction(int state, bool doubleClick, QtMouseButtons buttonsBefore) const
+{
+  ClickActionPrivate cap;
+  cap.modifiers = QtKeyboardModifiers(convertToKeyboardModifiers(state) &amp; Qt::KeyboardModifierMask);
+  cap.button = QtMouseButtons(state &amp; Qt::MouseButtonMask);
+  cap.doubleClick = doubleClick;
+  cap.buttonsBefore = buttonsBefore;
+  if (clickBinding_.contains(cap))
+    return clickBinding_[cap];
+  else
+    return NO_CLICK_ACTION;
+}
+
+/*! Similar to mouseButtonState(), but for ClickAction.
+
+ The results of the query are returned in the \p state, \p doubleClick and \p buttonsBefore
+ parameters. If the ClickAction is not associated to any mouse button, \c Qt::NoButton is returned
+ in \p state. If several mouse buttons trigger in the ClickAction, one of them is returned. */
+void QGLViewer::getClickButtonState(ClickAction ca, int&amp; state, bool&amp; doubleClick, QtMouseButtons&amp; buttonsBefore) const
+{
+  for (QMap&lt;ClickActionPrivate, ClickAction&gt;::ConstIterator it=clickBinding_.begin(), end=clickBinding_.end(); it != end; ++it)
+    if (it.value() == ca)
+      {
+	state = it.key().modifiers | it.key().button;
+	doubleClick = it.key().doubleClick;
+	buttonsBefore = it.key().buttonsBefore;
+	return;
+      }
+
+  state = Qt::NoButton;
+}
+
+/*! This function should be used in conjunction with toggleCameraMode(). It returns \c true when at
+  least one mouse button is binded to the \c REVOLVE mouseAction. This is crude way of determining
+  which &quot;mode&quot; the camera is in. */
+bool QGLViewer::cameraIsInRevolveMode() const
+{
+  //#CONNECTION# used in toggleCameraMode() and keyboardString()
+  return mouseButtonState(CAMERA, ROTATE) != Qt::NoButton;
+}
+
+/*! Swaps between two predefined camera mouse bindings.
+
+  The first mode makes the camera observe the scene while revolving around the
+  qglviewer::Camera::revolveAroundPoint(). The second mode is designed for walkthrough applications
+  and simulates a flying camera.
+
+  Practically, the three mouse buttons are respectively binded to:
+  \arg In revolve mode: QGLViewer::ROTATE, QGLViewer::ZOOM, QGLViewer::TRANSLATE.
+  \arg In fly mode: QGLViewer::MOVE_FORWARD, QGLViewer::LOOK_AROUND, QGLViewer::MOVE_BACKWARD.
+
+  The current mode is determined by checking if a mouse button is binded to QGLViewer::ROTATE for
+  the QGLViewer::CAMERA (using mouseButtonState()). The state key that was previously used to move
+  the camera is preserved. */
+void QGLViewer::toggleCameraMode()
+{
+  bool revolveMode = cameraIsInRevolveMode();
+  int bs;
+  if (revolveMode)
+    bs = mouseButtonState(CAMERA, ROTATE);
+  else
+    bs = mouseButtonState(CAMERA, MOVE_FORWARD);
+  QtKeyboardModifiers modifiers = QtKeyboardModifiers(bs &amp; Qt::KeyboardModifierMask);
+
+  //#CONNECTION# setDefaultMouseBindings()
+  if (revolveMode)
+    {
+      camera()-&gt;frame()-&gt;updateFlyUpVector();
+      camera()-&gt;frame()-&gt;stopSpinning();
+
+      setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, MOVE_FORWARD);
+      setMouseBinding(modifiers | Qt::MidButton,   CAMERA, LOOK_AROUND);
+      setMouseBinding(modifiers | Qt::RightButton, CAMERA, MOVE_BACKWARD);
+
+      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, ROLL);
+      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
+
+      setMouseBinding(Qt::LeftButton,  NO_CLICK_ACTION, true);
+      setMouseBinding(Qt::MidButton,   NO_CLICK_ACTION, true);
+      setMouseBinding(Qt::RightButton, NO_CLICK_ACTION, true);
+
+      setWheelBinding(modifiers, CAMERA, MOVE_FORWARD);
+    }
+  else
+    {
+      // Should stop flyTimer. But unlikely and not easy.
+      setMouseBinding(modifiers | Qt::LeftButton,  CAMERA, ROTATE);
+      setMouseBinding(modifiers | Qt::MidButton,   CAMERA, ZOOM);
+      setMouseBinding(modifiers | Qt::RightButton, CAMERA, TRANSLATE);
+
+      setMouseBinding(modifiers | Qt::LeftButton  | Qt::MidButton,  CAMERA, SCREEN_ROTATE);
+      // 2.2.4 setMouseBinding(modifiers | Qt::RightButton | Qt::MidButton,  CAMERA, SCREEN_TRANSLATE);
+
+      setMouseBinding(Qt::LeftButton,  ALIGN_CAMERA,      true);
+      setMouseBinding(Qt::MidButton,   SHOW_ENTIRE_SCENE, true);
+      setMouseBinding(Qt::RightButton, CENTER_SCENE,      true);
+
+      setWheelBinding(modifiers, CAMERA, ZOOM);
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//              M a n i p u l a t e d   f r a m e s                           //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Sets the viewer's manipulatedFrame().
+
+Several objects can be manipulated simultaneously, as is done the &lt;a
+href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt;.
+
+Defining the \e own viewer's camera()-&gt;frame() as the manipulatedFrame() is possible and will result
+in a classical camera manipulation. See the &lt;a href=&quot;../examples/luxo.html&quot;&gt;luxo example&lt;/a&gt; for an
+illustration.
+
+Note that a qglviewer::ManipulatedCameraFrame can be set as the manipulatedFrame(): it is possible
+to manipulate the camera of a first viewer in a second viewer. */
+void QGLViewer::setManipulatedFrame(ManipulatedFrame* frame)
+{
+  if (manipulatedFrame())
+    {
+      manipulatedFrame()-&gt;stopSpinning();
+
+      if (manipulatedFrame() != camera()-&gt;frame())
+	{
+	  disconnect(manipulatedFrame(), SIGNAL(manipulated()), this, SLOT(updateGL()));
+	  disconnect(manipulatedFrame(), SIGNAL(spun()), this, SLOT(updateGL()));
+	}
+    }
+
+  manipulatedFrame_ = frame;
+
+  manipulatedFrameIsACamera_ = ((manipulatedFrame() != camera()-&gt;frame()) &amp;&amp;
+				(dynamic_cast&lt;ManipulatedCameraFrame*&gt;(manipulatedFrame()) != NULL));
+
+  if (manipulatedFrame())
+    {
+      // Prevent multiple connections, that would result in useless display updates
+      if (manipulatedFrame() != camera()-&gt;frame())
+	{
+	  connect(manipulatedFrame(), SIGNAL(manipulated()), SLOT(updateGL()));
+	  connect(manipulatedFrame(), SIGNAL(spun()), SLOT(updateGL()));
+	}
+    }
+}
+
+#ifndef DOXYGEN
+////////////////////////////////////////////////////////////////////////////////
+//                          V i s u a l   H i n t s                           //
+////////////////////////////////////////////////////////////////////////////////
+/*! Draws viewer related visual hints.
+
+ Displays the new qglviewer::Camera::revolveAroundPoint() when it is changed. See the &lt;a
+ href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. Also draws a line between
+ qglviewer::Camera::revolveAroundPoint() and mouse cursor when the camera is rotated around the
+ camera Z axis.
+
+ See also setVisualHintsMask() and resetVisualHints(). The hint color is foregroundColor().
+
+ \note These methods may become more interesting one day. The current design is too limited and
+ should be improved when other visual hints must be drawn.
+
+ Limitation : One needs to have access to visualHint_ to overload this method.
+
+ Removed from the documentation for this reason. */
+void QGLViewer::drawVisualHints()
+{
+  // Revolve Around point cross
+  if (visualHint_ &amp; 1)
+    {
+      const float size = 15.0;
+      Vec proj = camera()-&gt;projectedCoordinatesOf(camera()-&gt;revolveAroundPoint());
+      startScreenCoordinatesSystem();
+      glDisable(GL_LIGHTING);
+      glDisable(GL_DEPTH_TEST);
+      glLineWidth(3.0);
+      glBegin(GL_LINES);
+      glVertex2f(proj.x - size, proj.y);
+      glVertex2f(proj.x + size, proj.y);
+      glVertex2f(proj.x, proj.y - size);
+      glVertex2f(proj.x, proj.y + size);
+      glEnd();
+      glEnable(GL_DEPTH_TEST);
+      stopScreenCoordinatesSystem();
+    }
+
+  // if (visualHint_ &amp; 2)
+    // drawText(80, 10, &quot;Play&quot;);
+
+  // Screen rotate line
+  ManipulatedFrame* mf = NULL;
+  Vec pnt;
+  if (camera()-&gt;frame()-&gt;action_ == SCREEN_ROTATE)
+    {
+      mf = camera()-&gt;frame();
+      pnt = camera()-&gt;revolveAroundPoint();
+    }
+  if (manipulatedFrame() &amp;&amp; (manipulatedFrame()-&gt;action_ == SCREEN_ROTATE))
+    {
+      mf = manipulatedFrame();
+      // Maybe useful if the mf is a manipCameraFrame...
+      // pnt = manipulatedFrame()-&gt;revolveAroundPoint();
+      pnt = manipulatedFrame()-&gt;position();
+    }
+
+  if (mf)
+    {
+      pnt = camera()-&gt;projectedCoordinatesOf(pnt);
+      startScreenCoordinatesSystem();
+      glDisable(GL_LIGHTING);
+      glDisable(GL_DEPTH_TEST);
+      glLineWidth(3.0);
+      glBegin(GL_LINES);
+      glVertex2f(pnt.x, pnt.y);
+      glVertex2f(mf-&gt;prevPos_.x(), mf-&gt;prevPos_.y());
+      glEnd();
+      glEnable(GL_DEPTH_TEST);
+      stopScreenCoordinatesSystem();
+    }
+
+  // Zoom on region: draw a rectangle
+  if (camera()-&gt;frame()-&gt;action_ == ZOOM_ON_REGION)
+    {
+      startScreenCoordinatesSystem();
+      glDisable(GL_LIGHTING);
+      glDisable(GL_DEPTH_TEST);
+      glLineWidth(2.0);
+      glBegin(GL_LINE_LOOP);
+      glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;pressPos_.y());
+      glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;pressPos_.y());
+      glVertex2i(camera()-&gt;frame()-&gt;prevPos_.x(),  camera()-&gt;frame()-&gt;prevPos_.y());
+      glVertex2i(camera()-&gt;frame()-&gt;pressPos_.x(), camera()-&gt;frame()-&gt;prevPos_.y());
+      glEnd();
+      glEnable(GL_DEPTH_TEST);
+      stopScreenCoordinatesSystem();
+    }
+}
+
+/*! Defines the mask that will be used to drawVisualHints(). The only available mask is currently 1,
+corresponding to the display of the qglviewer::Camera::revolveAroundPoint(). resetVisualHints() is
+automatically called after \p delay milliseconds (default is 2 seconds). */
+void QGLViewer::setVisualHintsMask(int mask, int delay)
+{
+  visualHint_ = visualHint_ | mask;
+  QTimer::singleShot(delay, this, SLOT(resetVisualHints()));
+}
+
+/*! Reset the mask used by drawVisualHints(). Called by setVisualHintsMask() after 2 seconds to reset the display. */
+void QGLViewer::resetVisualHints()
+{
+  visualHint_ = 0;
+}
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+//       A x i s   a n d   G r i d   d i s p l a y   l i s t s                //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! Draws a 3D arrow along the positive Z axis.
+
+ \p length, \p radius and \p nbSubdivisions define its geometry. If \p radius is negative
+ (default), it is set to 0.05 * \p length.
+
+ Use drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions) or change the \c
+ ModelView matrix to place the arrow in 3D.
+ 
+ Uses current color and does not modify the OpenGL state. */
+void QGLViewer::drawArrow(float length, float radius, int nbSubdivisions)
+{
+  static GLUquadric* quadric = gluNewQuadric();
+
+  if (radius &lt; 0.0)
+    radius = 0.05 * length;
+
+  const float head = 2.5*(radius / length) + 0.1;
+  const float coneRadiusCoef = 4.0 - 5.0 * head;
+
+  gluCylinder(quadric, radius, radius, length * (1.0 - head/coneRadiusCoef), nbSubdivisions, 1);
+  glTranslatef(0.0, 0.0, length * (1.0 - head));
+  gluCylinder(quadric, coneRadiusCoef * radius, 0.0, head * length, nbSubdivisions, 1);
+  glTranslatef(0.0, 0.0, -length * (1.0 - head));
+}
+
+/*! Draws a 3D arrow between the 3D point \p from and the 3D point \p to, both defined in the
+ current ModelView coordinates system.
+
+ See drawArrow(float length, float radius, int nbSubdivisions) for details. */
+void QGLViewer::drawArrow(const Vec&amp; from, const Vec&amp; to, float radius, int nbSubdivisions)
+{
+  glPushMatrix();
+  glTranslatef(from[0],from[1],from[2]);
+  glMultMatrixd(Quaternion(Vec(0,0,1), to-from).matrix());
+  QGLViewer::drawArrow((to-from).norm(), radius, nbSubdivisions);
+  glPopMatrix();
+}
+
+/*! Draws an XYZ axis, with a given size (default is 1.0).
+
+  The axis position and orientation matches the current modelView matrix state: three arrows (red,
+  green and blue) of length \p length are drawn along the positive X, Y and Z directions.
+
+  Use the following code to display the current position and orientation of a qglviewer::Frame:
+  \code
+  glPushMatrix();
+  glMultMatrixd(frame.matrix());
+  QGLViewer::drawAxis(sceneRadius() / 5.0); // Or any scale
+  glPopMatrix();
+  \endcode
+
+  The current color and line width are used to draw the X, Y and Z characters at the extremities of
+  the three arrows. The OpenGL state is not modified by this method.
+
+  axisIsDrawn() uses this method to draw a representation of the world coordinate system. See also
+  QGLViewer::drawArrow() and QGLViewer::drawGrid(). */
+void QGLViewer::drawAxis(float length)
+{
+  const float charWidth = length / 40.0;
+  const float charHeight = length / 30.0;
+  const float charShift = 1.04 * length;
+
+  GLboolean lighting, colorMaterial;
+  glGetBooleanv(GL_LIGHTING, &amp;lighting);
+  glGetBooleanv(GL_COLOR_MATERIAL, &amp;colorMaterial);
+
+  glDisable(GL_LIGHTING);
+
+  glBegin(GL_LINES);
+  // The X
+  glVertex3f(charShift,  charWidth, -charHeight);
+  glVertex3f(charShift, -charWidth,  charHeight);
+  glVertex3f(charShift, -charWidth, -charHeight);
+  glVertex3f(charShift,  charWidth,  charHeight);
+  // The Y
+  glVertex3f( charWidth, charShift, charHeight);
+  glVertex3f(0.0,        charShift, 0.0);
+  glVertex3f(-charWidth, charShift, charHeight);
+  glVertex3f(0.0,        charShift, 0.0);
+  glVertex3f(0.0,        charShift, 0.0);
+  glVertex3f(0.0,        charShift, -charHeight);
+  // The Z
+  glVertex3f(-charWidth,  charHeight, charShift);
+  glVertex3f( charWidth,  charHeight, charShift);
+  glVertex3f( charWidth,  charHeight, charShift);
+  glVertex3f(-charWidth, -charHeight, charShift);
+  glVertex3f(-charWidth, -charHeight, charShift);
+  glVertex3f( charWidth, -charHeight, charShift);
+  glEnd();
+
+  glEnable(GL_LIGHTING);
+  glDisable(GL_COLOR_MATERIAL);
+
+  float color[4];
+  color[0] = 0.7f;  color[1] = 0.7f;  color[2] = 1.0f;  color[3] = 1.0f;
+  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+  QGLViewer::drawArrow(length, 0.01*length);
+
+  color[0] = 1.0f;  color[1] = 0.7f;  color[2] = 0.7f;  color[3] = 1.0f;
+  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+  glPushMatrix();
+  glRotatef(90.0, 0.0, 1.0, 0.0);
+  QGLViewer::drawArrow(length, 0.01*length);
+  glPopMatrix();
+
+  color[0] = 0.7f;  color[1] = 1.0f;  color[2] = 0.7f;  color[3] = 1.0f;
+  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, color);
+  glPushMatrix();
+  glRotatef(-90.0, 1.0, 0.0, 0.0);
+  QGLViewer::drawArrow(length, 0.01*length);
+  glPopMatrix();
+
+  if (colorMaterial)
+    glEnable(GL_COLOR_MATERIAL);
+  if (!lighting)
+    glDisable(GL_LIGHTING);
+}
+
+/*! Draws a grid in the XY plane, centered on (0,0,0) (defined in the current coordinate system).
+
+ \p size (OpenGL units) and \p nbSubdivisions define its geometry. Set the \c GL_MODELVIEW matrix to
+ place and orientate the grid in 3D space (see the drawAxis() documentation).
+
+ The OpenGL state is not modified by this method. */
+void QGLViewer::drawGrid(float size, int nbSubdivisions)
+{
+  GLboolean lighting;
+  glGetBooleanv(GL_LIGHTING, &amp;lighting);
+  
+  glDisable(GL_LIGHTING);
+
+  glBegin(GL_LINES);
+  for (int i=0; i&lt;=nbSubdivisions; ++i)
+    {
+      const float pos = size*(2.0*i/nbSubdivisions-1.0);
+      glVertex2f(pos, -size);
+      glVertex2f(pos, +size);
+      glVertex2f(-size, pos);
+      glVertex2f( size, pos);
+    }
+  glEnd();
+
+  if (lighting)
+    glEnable(GL_LIGHTING);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+//       S t a t i c    m e t h o d s   :  Q G L V i e w e r   P o o l        //
+////////////////////////////////////////////////////////////////////////////////
+
+/*! saveStateToFile() is called on all the QGLViewers using the QGLViewerPool(). */
+void QGLViewer::saveStateToFileForAllViewers()
+{
+#if QT_VERSION &gt;= 0x040000
+  foreach (QGLViewer* viewer, QGLViewer::QGLViewerPool())
+    {
+#else
+  QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
+  for (QGLViewer* viewer; (viewer = it.current()) != 0; ++it)
+    {
+#endif
+    viewer-&gt;saveStateToFile();
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////
+//       S a v e   s t a t e   b e t w e e n    s e s s i o n s         //
+//////////////////////////////////////////////////////////////////////////
+
+/*! Returns the state file name. Default value is \c .qglviewer.xml.
+
+ This is the name of the XML file where saveStateToFile() saves the viewer state (camera state,
+ widget geometry, display flags... see domElement()) on exit. Use restoreStateFromFile() to restore
+ this state later (usually in your init() method).
+
+ Setting this value to \c QString::null will disable the automatic state file saving that normally
+ occurs on exit.
+
+ If more than one viewer are created by the application, this function will return a numbered file
+ name (as in &quot;.qglviewer1.xml&quot;, &quot;.qglviewer2.xml&quot;... using QGLViewer::QGLViewerIndex()) for extra
+ viewers. Each viewer will then read back its own information in restoreStateFromFile(), provided
+ that the viewers are created in the same order, which is usually the case. */
+QString QGLViewer::stateFileName() const
+{
+  QString name = stateFileName_;
+
+  if (!name.isEmpty() &amp;&amp; QGLViewer::QGLViewerIndex(this) &gt; 0)
+    {
+      QFileInfo fi(name);
+#if QT_VERSION &gt;= 0x040000
+      if (fi.suffix().isEmpty())
+#else
+      if (fi.extension(false).isEmpty())
+#endif
+	name += QString::number(QGLViewer::QGLViewerIndex(this));
+      else
+#if QT_VERSION &gt;= 0x040000
+	name = fi.absolutePath() + '/' + fi.completeBaseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.suffix();
+#else
+# if QT_VERSION &gt;= 0x030000
+	name = fi.dirPath() + '/' + fi.baseName(true) + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension(false);
+# else
+	name = fi.dirPath() + '/' + fi.baseName() + QString::number(QGLViewer::QGLViewerIndex(this)) + &quot;.&quot; + fi.extension();
+# endif
+#endif
+    }
+
+  return name;
+}
+
+/*! Saves in stateFileName() an XML representation of the QGLViewer state, obtained from
+ domElement().
+
+ Use restoreStateFromFile() to restore this viewer state.
+
+ This method is automatically called when a viewer is closed (using Escape or using the window's
+ upper right \c x close button). setStateFileName() to \c QString::null to prevent this. */
+void QGLViewer::saveStateToFile()
+{
+  QString name = stateFileName();
+
+  if (name.isEmpty())
+    return;
+
+  QFileInfo fileInfo(name);
+
+  if (fileInfo.isDir())
+    {
+      QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;State file name is a directory (&quot;+name+&quot;) and not a file.&quot;);
+      return;
+    }
+
+#if QT_VERSION &gt;= 0x040000
+  const QString dirName = fileInfo.absolutePath();
+#else
+  const QString dirName = fileInfo.dirPath();
+#endif
+  if (!QFileInfo(dirName).exists())
+    {
+      QDir dir;
+#if QT_VERSION &gt;= 0x040000
+      if (!(dir.mkdir(dirName)))
+#else
+      if (!(dir.mkdir(dirName, true)))
+#endif
+	{
+	  QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to create directory &quot;+dirName);
+	  return;
+	}
+    }
+
+  // Write the DOM tree to file
+  QFile f(name);
+#if QT_VERSION &gt;= 0x040000
+  if (f.open(QIODevice::WriteOnly))
+#else
+  if (f.open(IO_WriteOnly))
+#endif
+    {
+      QTextStream out(&amp;f);
+      QDomDocument doc(&quot;QGLVIEWER&quot;);
+      doc.appendChild(domElement(&quot;QGLViewer&quot;, doc));
+      doc.save(out, 2);
+      f.flush();
+      f.close();
+    }
+  else
+#if QT_VERSION &lt; 0x030200
+    QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to save to file &quot;+name);
+#else
+    QMessageBox::warning(this, &quot;Save to file error&quot;, &quot;Unable to save to file &quot;+name+&quot;:\n&quot;+f.errorString());
+#endif
+}
+
+/*! Restores the QGLViewer state from the stateFileName() file using initFromDOMElement().
+
+ States are saved using saveStateToFile(), which is automatically called on viewer exit.
+
+ Returns \c true when the restoration is successful. Possible problems are an non existing or
+ unreadable stateFileName() file, an empty stateFileName() or an XML syntax error.
+
+ A manipulatedFrame() should be defined \e before calling this method, so that its state can be
+ restored. Initialization code put \e after this function will override saved values:
+ \code
+ void Viewer::init()
+ {
+   // Default initialization goes here (including the declaration of a possible manipulatedFrame).
+
+   if (!restoreStateFromFile())
+     showEntireScene(); // Previous state cannot be restored: fit camera to scene.
+
+   // Specific initialization that overrides file savings goes here.
+ }
+ \endcode */
+bool QGLViewer::restoreStateFromFile()
+{
+  QString name = stateFileName();
+
+  if (name.isEmpty())
+    return false;
+
+  QFileInfo fileInfo(name);
+
+  if (!fileInfo.isFile())
+    // No warning since it would be displayed at first start.
+    return false;
+
+  if (!fileInfo.isReadable())
+    {
+      QMessageBox::warning(this, &quot;restoreStateFromFile problem&quot;, &quot;File &quot;+name+&quot; is not readable.&quot;);
+      return false;
+    }
+
+  // Read the DOM tree form file
+  QFile f(name);
+#if QT_VERSION &gt;= 0x040000
+  if (f.open(QIODevice::ReadOnly) == true)
+#else
+  if (f.open(IO_ReadOnly) == true)
+#endif
+    {
+      QDomDocument doc;
+      doc.setContent(&amp;f);
+      f.close();
+      QDomElement main = doc.documentElement();
+      initFromDOMElement(main);
+    }
+  else
+    {
+#if QT_VERSION &lt; 0x030200
+      QMessageBox::warning(this, &quot;Open file error&quot;, &quot;Unable to open file &quot;+name);
+#else
+      QMessageBox::warning(this, &quot;Open file error&quot;, &quot;Unable to open file &quot;+name+&quot;:\n&quot;+f.errorString());
+#endif
+      return false;
+    }
+
+  return true;
+}
+
+/*! Returns an XML \c QDomElement that represents the QGLViewer.
+
+ Used by saveStateToFile(). restoreStateFromFile() uses initFromDOMElement() to restore the
+ QGLViewer state from the resulting \c QDomElement.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ The created QDomElement contains state values (axisIsDrawn(), FPSIsDisplayed(), isFullScreen()...),
+ viewer geometry, as well as camera() (see qglviewer::Camera::domElement()) and manipulatedFrame()
+ (if defined, see qglviewer::ManipulatedFrame::domElement()) states.
+
+ Overload this method to add your own attributes to the state file:
+ \code
+ QDomElement Viewer::domElement(const QString&amp; name, QDomDocument&amp; document) const
+ {
+   // Creates a custom node for a light
+   QDomElement de = document.createElement(&quot;Light&quot;);
+   de.setAttribute(&quot;state&quot;, (lightIsOn()?&quot;on&quot;:&quot;off&quot;));
+   // Note the include of the ManipulatedFrame domElement method.
+   de.appendChild(lightManipulatedFrame()-&gt;domElement(&quot;LightFrame&quot;, document));
+
+   // Get default state domElement and append custom node
+   QDomElement res = QGLViewer::domElement(name, document);
+   res.appendChild(de);
+   return res;
+ }
+ \endcode
+ See initFromDOMElement() for the associated restoration code.
+
+ \attention For the manipulatedFrame(), qglviewer::Frame::constraint() and
+ qglviewer::Frame::referenceFrame() are not saved. See qglviewer::Frame::domElement(). */
+QDomElement QGLViewer::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement de = document.createElement(name);
+  de.setAttribute(&quot;version&quot;, QGLViewerVersionString());
+
+  QDomElement stateNode = document.createElement(&quot;State&quot;);
+  // stateNode.setAttribute(&quot;mouseTracking&quot;, (hasMouseTracking()?&quot;true&quot;:&quot;false&quot;));
+  stateNode.appendChild(DomUtils::QColorDomElement(foregroundColor(), &quot;foregroundColor&quot;, document));
+  stateNode.appendChild(DomUtils::QColorDomElement(backgroundColor(), &quot;backgroundColor&quot;, document));
+  stateNode.setAttribute(&quot;stereo&quot;, (displaysInStereo()?&quot;true&quot;:&quot;false&quot;));
+  stateNode.setAttribute(&quot;cameraMode&quot;, (cameraIsInRevolveMode()?&quot;revolve&quot;:&quot;fly&quot;));
+  de.appendChild(stateNode);
+
+  QDomElement displayNode = document.createElement(&quot;Display&quot;);
+  displayNode.setAttribute(&quot;axisIsDrawn&quot;,       (axisIsDrawn()?&quot;true&quot;:&quot;false&quot;));
+  displayNode.setAttribute(&quot;gridIsDrawn&quot;,       (gridIsDrawn()?&quot;true&quot;:&quot;false&quot;));
+  displayNode.setAttribute(&quot;FPSIsDisplayed&quot;,    (FPSIsDisplayed()?&quot;true&quot;:&quot;false&quot;));
+  displayNode.setAttribute(&quot;cameraIsEdited&quot;,    (cameraIsEdited()?&quot;true&quot;:&quot;false&quot;));
+  // displayNode.setAttribute(&quot;textIsEnabled&quot;,  (textIsEnabled()?&quot;true&quot;:&quot;false&quot;));
+  de.appendChild(displayNode);
+
+  QDomElement geometryNode = document.createElement(&quot;Geometry&quot;);
+  geometryNode.setAttribute(&quot;fullScreen&quot;, (isFullScreen()?&quot;true&quot;:&quot;false&quot;));
+  if (isFullScreen())
+    {
+      geometryNode.setAttribute(&quot;prevPosX&quot;, QString::number(prevPos_.x()));
+      geometryNode.setAttribute(&quot;prevPosY&quot;, QString::number(prevPos_.y()));
+    }
+  else
+    {
+      QWidget* tlw = topLevelWidget();
+      geometryNode.setAttribute(&quot;width&quot;,  QString::number(tlw-&gt;width()));
+      geometryNode.setAttribute(&quot;height&quot;, QString::number(tlw-&gt;height()));
+      geometryNode.setAttribute(&quot;posX&quot;,   QString::number(tlw-&gt;pos().x()));
+      geometryNode.setAttribute(&quot;posY&quot;,   QString::number(tlw-&gt;pos().y()));
+    }
+  de.appendChild(geometryNode);
+
+  // Restore original Camera zClippingCoefficient before saving.
+  if (cameraIsEdited())
+    camera()-&gt;setZClippingCoefficient(previousCameraZClippingCoefficient_);
+  de.appendChild(camera()-&gt;domElement(&quot;Camera&quot;, document));
+  if (cameraIsEdited())
+    // #CONNECTION# 5.0 from setCameraIsEdited()
+    camera()-&gt;setZClippingCoefficient(5.0);
+
+  if (manipulatedFrame())
+    de.appendChild(manipulatedFrame()-&gt;domElement(&quot;ManipulatedFrame&quot;, document));
+
+  return de;
+}
+
+/*! Restores the QGLViewer state from a \c QDomElement created by domElement().
+
+ Used by restoreStateFromFile() to restore the QGLViewer state from a file.
+
+ Overload this method to retrieve custom attributes from the QGLViewer state file. This code
+ corresponds to the one given in the domElement() documentation:
+ \code
+ void Viewer::initFromDOMElement(const QDomElement&amp; element)
+ {
+   // Restore standard state
+   QGLViewer::initFromDOMElement(element);
+
+   QDomElement child=element.firstChild().toElement();
+   while (!child.isNull())
+   {
+     if (child.tagName() == &quot;Light&quot;)
+     {
+       if (child.hasAttribute(&quot;state&quot;))
+	 setLightOn(child.attribute(&quot;state&quot;).lower() == &quot;on&quot;);
+
+       // Assumes there is only one child. Otherwise you need to parse child's children recursively.
+       QDomElement lf = child.firstChild().toElement();
+       if (!lf.isNull() &amp;&amp; lf.tagName() == &quot;LightFrame&quot;)
+         lightManipulatedFrame()-&gt;initFromDomElement(lf);
+     }
+     child = child.nextSibling().toElement();
+   }
+ }
+ \endcode
+
+ See also qglviewer::Camera::initFromDOMElement(), qglviewer::ManipulatedFrame::initFromDOMElement().
+
+ \note The manipulatedFrame() \e pointer is not modified by this method. If defined, its state is
+ simply set from the \p element values. */
+void QGLViewer::initFromDOMElement(const QDomElement&amp; element)
+{
+  const QString version = element.attribute(&quot;version&quot;);
+  // if (version != QGLViewerVersionString())
+  if (version[0] != '2')
+    // Patches for previous versions should go here when the state file syntax is modified.
+#if QT_VERSION &gt;= 0x040000
+    qWarning(QString(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;+QGLViewerVersionString()).toLatin1().constData());
+#else
+  qWarning(&quot;State file created using QGLViewer version &quot;+version+&quot; may not be correctly read.&quot;);
+#endif
+
+  QDomElement child=element.firstChild().toElement();
+  bool tmpCameraIsEdited = cameraIsEdited();
+  while (!child.isNull())
+    {
+      if (child.tagName() == &quot;State&quot;)
+	{
+	  // #CONNECTION# default values from defaultConstructor()
+	  // setMouseTracking(DomUtils::boolFromDom(child, &quot;mouseTracking&quot;, false));
+	  setStereoDisplay(DomUtils::boolFromDom(child, &quot;stereo&quot;, false));
+	  if ((child.attribute(&quot;cameraMode&quot;, &quot;revolve&quot;) == &quot;fly&quot;) &amp;&amp; (cameraIsInRevolveMode()))
+	    toggleCameraMode();
+
+	  QDomElement ch=child.firstChild().toElement();
+	  while (!ch.isNull())
+	    {
+	      if (ch.tagName() == &quot;foregroundColor&quot;)
+		setForegroundColor(DomUtils::QColorFromDom(ch));
+	      if (ch.tagName() == &quot;backgroundColor&quot;)
+		setBackgroundColor(DomUtils::QColorFromDom(ch));
+	      ch = ch.nextSibling().toElement();
+	    }
+	}
+
+      if (child.tagName() == &quot;Display&quot;)
+	{
+	  // #CONNECTION# default values from defaultConstructor()
+	  setAxisIsDrawn(DomUtils::boolFromDom(child, &quot;axisIsDrawn&quot;, false));
+	  setGridIsDrawn(DomUtils::boolFromDom(child, &quot;gridIsDrawn&quot;, false));
+	  setFPSIsDisplayed(DomUtils::boolFromDom(child, &quot;FPSIsDisplayed&quot;, false));
+	  // See comment below.
+	  tmpCameraIsEdited = DomUtils::boolFromDom(child, &quot;cameraIsEdited&quot;, false);
+	  // setTextIsEnabled(DomUtils::boolFromDom(child, &quot;textIsEnabled&quot;, true));
+	}
+
+      if (child.tagName() == &quot;Geometry&quot;)
+	{
+	  setFullScreen(DomUtils::boolFromDom(child, &quot;fullScreen&quot;, false));
+
+	  if (isFullScreen())
+	    {
+	      prevPos_.setX(DomUtils::intFromDom(child, &quot;prevPosX&quot;, 0));
+	      prevPos_.setY(DomUtils::intFromDom(child, &quot;prevPosY&quot;, 0));
+	    }
+	  else
+	    {
+	      int width  = DomUtils::intFromDom(child, &quot;width&quot;,  600);
+	      int height = DomUtils::intFromDom(child, &quot;height&quot;, 400);
+	      topLevelWidget()-&gt;resize(width, height);
+
+	      QPoint pos;
+	      pos.setX(DomUtils::intFromDom(child, &quot;posX&quot;, 0));
+	      pos.setY(DomUtils::intFromDom(child, &quot;posY&quot;, 0));
+	      topLevelWidget()-&gt;move(pos);
+	    }
+	}
+
+      if (child.tagName() == &quot;Camera&quot;)
+	{
+	  connectAllCameraKFIInterpolatedSignals(false);
+	  camera()-&gt;initFromDOMElement(child);
+	  connectAllCameraKFIInterpolatedSignals();
+	}
+
+      if ((child.tagName() == &quot;ManipulatedFrame&quot;) &amp;&amp; (manipulatedFrame()))
+	manipulatedFrame()-&gt;initFromDOMElement(child);
+
+      child = child.nextSibling().toElement();
+    }
+
+  // The Camera always stores its &quot;real&quot; zClippingCoef in domElement(). If it is edited,
+  // its &quot;real&quot; coef must be saved and the coef set to 5.0, as is done in setCameraIsEdited().
+  // BUT : Camera and Display are read in an arbitrary order. We must initialize Camera's
+  // &quot;real&quot; coef BEFORE calling setCameraIsEdited. Hence this temp cameraIsEdited and delayed call
+  cameraIsEdited_ = tmpCameraIsEdited;
+  if (cameraIsEdited_)
+    {
+      previousCameraZClippingCoefficient_ = camera()-&gt;zClippingCoefficient();
+      // #CONNECTION# 5.0 from setCameraIsEdited.
+      camera()-&gt;setZClippingCoefficient(5.0);
+    }
+}
+
+#ifndef DOXYGEN
+/*! This method is deprecated since version 1.3.9-5. Use saveStateToFile() and setStateFileName()
+  instead. */
+void QGLViewer::saveToFile(const QString&amp; fileName)
+{
+  if (!fileName.isEmpty())
+    setStateFileName(fileName);
+
+  qWarning(&quot;saveToFile() is deprecated, use saveStateToFile() instead.&quot;);
+  saveStateToFile();
+}
+
+/*! This function is deprecated since version 1.3.9-5. Use restoreStateFromFile() and
+  setStateFileName() instead. */
+bool QGLViewer::restoreFromFile(const QString&amp; fileName)
+{
+  if (!fileName.isEmpty())
+    setStateFileName(fileName);
+
+  qWarning(&quot;restoreFromFile() is deprecated, use restoreStateFromFile() instead.&quot;);
+  return restoreStateFromFile();
+}
+#endif
+
+/*! Makes a copy of the current buffer into a texture.
+
+ Creates a texture (when needed) and uses glCopyTexSubImage2D() to directly copy the buffer in it.
+
+ Use \p internalFormat and \p format to define the texture format and hence which and how components
+ of the buffer are copied into the texture. See the glTexImage2D() documentation for details.
+
+ When \p format is c GL_NONE (default), its value is set to \p internalFormat, which fits most
+ cases. Typical \p internalFormat (and \p format) values are \c GL_DEPTH_COMPONENT and \c GL_RGBA.
+ Use \c GL_LUMINANCE as the \p internalFormat and \c GL_RED, \c GL_GREEN or \c GL_BLUE as \p format
+ to capture a single color component as a luminance (grey scaled) value. Note that \c GL_STENCIL is
+ not supported as a format.
+
+ The texture has dimensions which are powers of two. It is as small as possible while always being
+ larger or equal to the current size of the widget. The buffer image hence does not entirely fill
+ the texture: it is stuck to the lower left corner (corresponding to the (0,0) texture coordinates).
+ Use bufferTextureMaxU() and bufferTextureMaxV() to get the upper right corner maximum u and v
+ texture coordinates. Use bufferTextureId() to retrieve the id of the created texture.
+
+ Here is how to display a grey-level image of the z-buffer:
+ \code
+ copyBufferToTexture(GL_DEPTH_COMPONENT);
+
+ glMatrixMode(GL_TEXTURE);
+ glLoadIdentity();
+
+ glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+ glEnable(GL_TEXTURE_2D);
+
+ startScreenCoordinatesSystem(true);
+
+ glBegin(GL_QUADS);
+ glTexCoord2f(0.0, 0.0);                                 glVertex2i(0, 0);
+ glTexCoord2f(bufferTextureMaxU(), 0.0);                 glVertex2i(width(), 0);
+ glTexCoord2f(bufferTextureMaxU(), bufferTextureMaxV()); glVertex2i(width(), height());
+ glTexCoord2f(0.0, bufferTextureMaxV());                 glVertex2i(0, height());
+ glEnd();
+
+ stopScreenCoordinatesSystem();
+ 
+ glDisable(GL_TEXTURE_2D);
+ \endcode
+ 
+ Use glReadBuffer() to select which buffer is copied into the texture. See also \c
+ glPixelTransfer(), \c glPixelZoom() and \c glCopyPixel() for pixel color transformations during
+ copy.
+
+ Call makeCurrent() before this method to make the OpenGL context active if needed.
+
+ \note The \c GL_DEPTH_COMPONENT format may not be supported by all hardware. It may sometimes be
+ emulated in software, resulting in poor performances.
+
+ \note The bufferTextureId() texture is binded at the end of this method. */
+void QGLViewer::copyBufferToTexture(GLint internalFormat, GLenum format)
+{
+  int h = 16;
+  int w = 16;
+  // Todo compare performance with qt code.
+  while (w &lt; width())
+    w &lt;&lt;= 1;
+  while (h &lt; height())
+    h &lt;&lt;= 1;
+
+  bool init = false;
+
+  if ((w != bufferTextureWidth_) || (h != bufferTextureHeight_))
+    {
+      bufferTextureWidth_ = w;
+      bufferTextureHeight_ = h;
+      bufferTextureMaxU_ = width()  / float(bufferTextureWidth_);
+      bufferTextureMaxV_ = height() / float(bufferTextureHeight_);
+      init = true;
+    }
+
+  if (bufferTextureId() == 0)
+    {
+      glGenTextures(1, &amp;bufferTextureId_);
+      glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      init = true;
+    }
+  else
+    glBindTexture(GL_TEXTURE_2D, bufferTextureId_);
+
+  if ((format != previousBufferTextureFormat_) ||
+      (internalFormat != previousBufferTextureInternalFormat_))
+    {
+      previousBufferTextureFormat_ = format;
+      previousBufferTextureInternalFormat_ = internalFormat;
+      init = true;
+    }
+
+  if (init)
+    {
+      if (format == GL_NONE)
+	format = internalFormat;
+
+      glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, bufferTextureWidth_, bufferTextureHeight_, 0, format, GL_UNSIGNED_BYTE, NULL);
+    }
+
+  glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, width(), height());
+}
+
+/*! Returns the texture id of the texture created by copyBufferToTexture().
+
+Use glBindTexture() to use this texture. Note that this is already done by copyBufferToTexture().
+
+Returns \c 0 is copyBufferToTexture() was never called or if the texure was deleted using
+glDeleteTextures() since then. */
+GLuint QGLViewer::bufferTextureId() const
+{
+  if (glIsTexture(bufferTextureId_))
+    return bufferTextureId_;
+  else
+    return 0;
+}

Added: trunk/lib/QGLViewer/qglviewer.cw
===================================================================
--- trunk/lib/QGLViewer/qglviewer.cw	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/qglviewer.cw	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,95 @@
+&lt;!DOCTYPE CW&gt;&lt;CW&gt;
+&lt;customwidgets&gt;
+  &lt;customwidget&gt;
+   &lt;class&gt;QGLViewer&lt;/class&gt;
+    &lt;header location=&quot;local&quot;&gt;QGLViewer/qglviewer.h&lt;/header&gt;
+    &lt;sizehint&gt;
+        &lt;width&gt;400&lt;/width&gt;
+        &lt;height&gt;300&lt;/height&gt;
+    &lt;/sizehint&gt;
+    &lt;container&gt;0&lt;/container&gt;
+    &lt;sizepolicy&gt;
+        &lt;hordata&gt;7&lt;/hordata&gt;
+        &lt;verdata&gt;7&lt;/verdata&gt;
+    &lt;/sizepolicy&gt;
+    &lt;pixmap&gt;
+        &lt;data format=&quot;XPM.GZ&quot; length=&quot;3320&quot;&gt;789c5d56db521d3b0e7dcf5750d15b6a4aa7dbee76db35350f845b200142eec9a979902f1d20dcd9248153f3efe3ad65381ce82a6aaf962ccbd2d272fff162e5cbdbdd95177f3cbb5ec8e228ada443b95a79916f4e4f6ffffcef7ffe7af6bc1f577ab7d24ffd8a79feaf67cfa9baacec9d9f9525e0b547e060f108d075053497e5a39e4e71ae4f529c9ed873c3d543f1e513fb4ec3f54fe37f573c3fd8371bbeb70f0feb351ef19378570ff920dfdb8613f2a3aef9a739aa3ff693fa2896fb7ce22c8a4f1e30fcbfb478b19db7fb27a623c5d51bf9c9eb86fd3ca93fecd3ec1a7eafd8d4c7aaff4fc5beda9dda4f5b7e23b05cb6fd86e67fd8b0993bc5dfdb7a330fba7e577198ed3c2afefc705eaff9aeb5f399a2f56552dc9554709e77cdde15d4fb25f22f65eed5fff609de58e252ff66d00ae7b7f551cc1fdafe01f524ece74a2cda2fd1f3965c42db7fa7adefb15e2e14f7c537fb6fc5e37d3de8f001eb79e993c64b458af6934e9add36ff6fedbc5d417d6f14a75cb2d687355ee973869db75bbc5082fa47d43f878cf36a3fb3c95d413d0e1a0ee01369fdcb54e3c17ed3e2a70c7ebf512c7505f8c82d1f9bc0bff516cf16d453e731f749b2e6c3ca9f2cb96bf9607e724a0978bfe198b0ffa4fe293bf49767d4e7!
 de4ebfd43ed5f3207ed0fc4ccd1ffd3b57ec92cb8877a6eb876423f8857e8ec924cce7b8c4359b82f3b2ce738c696af3b507bed60142bf71de2edaa8fce682798941307f3de62b26d178b20ffe45dfb0f2b30cd10af8bbd0fd72ac29a81dfc7771143d1f7dd4fc6ccc09fdd7fea62c11f9f01df6171f747e45f52ef6b5bda807f42e4a68f66df04b0660563ec612fbac98a057494cd0f351403fa58be0efd61207176cc35abf1acd04d4f35871aa58eda2fc4931580ffdd1f948bd4f1eebf7c09f1004fa68916f08cd1e9bddb57ab816df0af8a07c0d93cf09f97f407e7e065fe40af3eb2bc5353fd50f1f8389e897209e371e7cda6af15352bd22ad57f03e259d17be403f6bb9c1871fd037ef279d5f567d49a3b701eba10fd17b87793a6ef98e19fc79a5b8da23f800fe8877cd5fe387eca5f92b5f829966f08db4ff699ae680f93f83ff3478f41ff32355e0d10fc5719c6a0715eb3c85e2b2c3fa3bccdf641ce647edd1b83c819fb82fcc6446e887de3fd1bb2a80eaaffa95baa9f3e0d757b5d7ebc343afa0d79d0b03d6ebbc8b75cea37ee8ff746f67d54799c6ecd03f9d87d04f9270bfe8bc87610c13eaf316faeccc00fe1ee0fcae1fc007e55b2a63a5acdad7d19f2ac0c85ff91aede85b3cbfc4cbea45f46355ed53dd0ffaa07c9630dcd757fb53e6b1b3d037d53f378d!
 5d443f946f7118eb878e62ad8fc421363ee9fd18dd602cea013deb86be87fe!
 0af46170
06fdc37d350e83c17eba5e64b00efecaafec6c825db4fec5d6f1017f36509fa1eb510fe58f94a177e89ff26faa84b3d08f0df0cf84b61ef5169b7accab07bfede0d01fad570ed6c02ed7b86f2ac6f9353f6b8d057f44f5ca75a61f70ffa9befacec808bc89fcccd4eb7cc916f4d14c1df47b15fa6e5287fe35fdb5a643fec7e05ffd3c01bf0cf8626d87fb017a3ed9bed3fd08765f31ecf8dea9e7013e583c7e98583872aabf32179e1f7bf0773ee4233ee61f7cc2a7159ff1395fc0832ff9aafebfe605dff04ffec5bff9b6e23b5ee5979ae51aaff3066ff216bfe26ddee1d7fc8677abc71eeff35bdcebfc8edff307fec89ff8337fe1affc8dbbead1b3613069e0911d4fec3910139150a49a29652ad4be75e9908ee8987ed0497d7f4a6774becc8d2ee892aed4e39a1674433fe917fda65bbaa3557a593dd7689d36681367a12d7a45dbb443afe90dedd2deb21ab44f6fe980de358ff7f4813ed227fa4c5fe82b7dab6f3aeac990e5745f311a68244713790a7c79b01096ca6a89078bbf6b2af523a37e46cdf2bdfe3e942339961f72f20f8f53399373b9a8bf2ee54aae652137cbf78ffb223fe597fc965bb9935579296b74fdd4a3faaccb866cca96bc926dd9c1bb271eafe58decca9eec2f33681efffbf7b3ff03e2d71717&lt;/data&gt;
+    &lt;/pixmap&gt;
+     &lt;signal&gt; animateNeeded() &lt;/signal&gt;
+     &lt;signal&gt; axisIsDrawnChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; cameraIsEditedChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; drawFinished(bool) &lt;/signal&gt;
+     &lt;signal&gt; drawNeeded() &lt;/signal&gt;
+     &lt;signal&gt; FPSIsDisplayedChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; gridIsDrawnChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; helpRequired() &lt;/signal&gt;
+     &lt;signal&gt; mouseGrabberChanged(qglviewer::MouseGrabber *mouseGrabber) &lt;/signal&gt;
+     &lt;signal&gt; pointSelected(QMouseEvent *e) &lt;/signal&gt;
+     &lt;signal&gt; stereoChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; textIsEnabledChanged(bool) &lt;/signal&gt;
+     &lt;signal&gt; viewerInitialized() &lt;/signal&gt;
+     &lt;slot access=&quot;public&quot;&gt; aboutQGLViewer() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; animate() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; copyBufferToTexture(GLint, GLenum format) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; help() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; initFromDOMElement(QDomElement &amp;element) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; openSnapshotFormatDialog() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; resize(int, int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; restoreStateFromFile() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(bool, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; saveSnapshot(QString, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; saveStateToFile() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; select(QMouseEvent *event) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; select(QPoint) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setAnimationPeriod(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setAxisIsDrawn(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setBackgroundColor(QColor &amp;color) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setCameraIsEdited(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setCamera(qglviewer::Camera *camera) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setForegroundColor(QColor &amp;color) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setFPSIsDisplayed(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setFullScreen(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setGridIsDrawn(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setKeyDescription(int, QString) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setManipulatedFrame(qglviewer::ManipulatedFrame *frame) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBindingDescription(int, QString, bool, QtMouseButtons buttonsBefore) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int, ClickAction action, bool, QtMouseButtons buttonsBefore) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseBinding(int, MouseHandler handler, MouseAction action, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseGrabber(qglviewer::MouseGrabber *mouseGrabber) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setMouseTracking(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setPathKey(int, int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSceneBoundingBox(qglviewer::Vec &amp;min, qglviewer::Vec &amp;max) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSceneCenter(qglviewer::Vec &amp;center) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSceneRadius(float) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectBufferSize(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectedName(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectRegionHeight(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSelectRegionWidth(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setShortcut(KeyboardAction action, int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotCounter(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotFileName(QString) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotFormat(QString) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setSnapshotQuality(int) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setStateFileName(QString) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setStereoDisplay(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setTextIsEnabled(bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool) &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; showEntireScene() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; startAnimation() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; stopAnimation() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleAnimation() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleAxisIsDrawn() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleCameraIsEdited() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleCameraMode() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleFPSIsDisplayed() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleFullScreen() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleGridIsDrawn() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleStereoDisplay() &lt;/slot&gt;
+     &lt;slot access=&quot;public&quot;&gt; toggleTextIsEnabled() &lt;/slot&gt;
+     &lt;slot access=&quot;protected&quot;&gt; setAutoBufferSwap(bool on) &lt;/slot&gt;
+  &lt;/customwidget&gt;
+&lt;/customwidgets&gt;
+&lt;/CW&gt;

Added: trunk/lib/QGLViewer/qglviewer.h
===================================================================
--- trunk/lib/QGLViewer/qglviewer.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/qglviewer.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,1231 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_QGLVIEWER_H
+#define QGLVIEWER_QGLVIEWER_H
+
+#include &quot;camera.h&quot;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QMap&gt;
+#else
+# include &lt;qmap.h&gt;
+#endif
+
+class QTabWidget;
+
+namespace qglviewer {
+  class MouseGrabber;
+}
+
+#if QT_VERSION &gt;= 0x040000
+  // Qt::ButtonState was split into Qt::KeyboardModifiers and Qt::MouseButtons in Qt 4.
+# define QtKeyboardModifiers Qt::KeyboardModifiers
+# define QtMouseButtons Qt::MouseButtons
+#else
+# define QtKeyboardModifiers Qt::ButtonState
+# define QtMouseButtons Qt::ButtonState
+#endif
+
+/*! \brief A versatile 3D OpenGL viewer based on QGLWidget.
+ \class QGLViewer qglviewer.h QGLViewer/qglviewer.h
+
+ It features many classical viewer functionalities, such as a camera trackball, manipulated objects,
+ snapshot saving and much &lt;a href=&quot;../features.html&quot;&gt;more&lt;/a&gt;. Its main goal is to ease the development
+of new 3D applications.
+
+ New users should read the &lt;a href=&quot;../introduction.html&quot;&gt;introduction page&lt;/a&gt; to get familiar with
+ important notions such as sceneRadius(), sceneCenter() and the world coordinate system. Try the
+ numerous simple &lt;a href=&quot;../examples/index.html&quot;&gt;examples&lt;/a&gt; to discover the possibilities and
+ understand how it works.
+
+ &lt;h3&gt;Usage&lt;/h3&gt;
+
+ To use a QGLViewer, derive you viewer class from the QGLViewer and overload its draw() virtual
+ method. See the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
+
+ An other option is to connect your drawing methods to the signals emitted by the QGLViewer (Qt's
+ callback mechanism). See the &lt;a href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for a
+ complete implementation.
+
+ \nosubgrouping */
+class QGLVIEWER_EXPORT QGLViewer : public QGLWidget
+{
+  Q_OBJECT
+
+public:
+  // Complete implementation is provided so that the constructor is defined with QT3_SUPPORT when .h is included.
+  // (Would not be available otherwise since lib is compiled without QT3_SUPPORT).
+#if QT_VERSION &lt; 0x040000 || defined QT3_SUPPORT
+  explicit QGLViewer(QWidget* parent=NULL, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
+  : QGLWidget(parent, name, shareWidget, flags)
+  { defaultConstructor(); }
+
+  explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const char* name=0, const QGLWidget* shareWidget=0,Qt::WFlags flags=0)
+  : QGLWidget(format, parent, name, shareWidget, flags)
+  { defaultConstructor(); }
+
+  QGLViewer(QGLContext* context, QWidget* parent, const char* name=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0)
+# if QT_VERSION &gt;= 0x030200
+  : QGLWidget(context, parent, name, shareWidget, flags) {
+# else
+// MOC_SKIP_BEGIN
+  : QGLWidget(parent, name, shareWidget, flags) {
+    Q_UNUSED(context);
+// MOC_SKIP_END
+# endif
+  defaultConstructor(); }
+#endif
+
+#if QT_VERSION &gt;= 0x040000
+  explicit QGLViewer(QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+  explicit QGLViewer(QGLContext *context, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+  explicit QGLViewer(const QGLFormat&amp; format, QWidget* parent=0, const QGLWidget* shareWidget=0, Qt::WFlags flags=0);
+#endif
+
+  virtual ~QGLViewer();
+
+  /*! @name Display of visual hints */
+  //@{
+public:
+  /*! Returns \c true if the world axis is drawn by the viewer.
+
+  Set by setAxisIsDrawn() or toggleAxisIsDrawn(). Default value is \c false. */
+  bool axisIsDrawn() const { return axisIsDrawn_; };
+  /*! Returns \c true if a XY grid is drawn by the viewer.
+
+  Set by setGridIsDrawn() or toggleGridIsDrawn(). Default value is \c false. */
+  bool gridIsDrawn() const { return gridIsDrawn_; };
+  /*! Returns \c true if the viewer displays the current frame rate (Frames Per Second).
+
+  Use QApplication::setFont() to define the display font (see drawText()).
+
+  Set by setFPSIsDisplayed() or toggleFPSIsDisplayed(). Use currentFPS() to get the current FPS.
+  Default value is \c false. */
+  bool FPSIsDisplayed() const { return FPSIsDisplayed_; };
+  /*! Returns \c true if text display (see drawText()) is enabled.
+
+  Set by setTextIsEnabled() or toggleTextIsEnabled(). This feature conveniently removes all the
+  possibly displayed text, cleaning display. Default value is \c true. */
+  bool textIsEnabled() const { return textIsEnabled_; };
+
+  /*! Returns \c true if the camera() is being edited in the viewer.
+
+  Set by setCameraIsEdited() or toggleCameraIsEdited(). Default value is \p false.
+
+  The current implementation is limited: the defined camera() paths (see
+  qglviewer::Camera::keyFrameInterpolator()) are simply displayed using
+  qglviewer::Camera::drawAllPaths(). Actual camera and path edition will be implemented in the
+  future. */
+  bool cameraIsEdited() const { return cameraIsEdited_; }
+
+
+public slots:
+  /*! Sets the state of axisIsDrawn(). Emits the axisIsDrawnChanged() signal. See also toggleAxisIsDrawn(). */
+  void setAxisIsDrawn(bool draw=true) { axisIsDrawn_ = draw; emit axisIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
+  /*! Sets the state of gridIsDrawn(). Emits the gridIsDrawnChanged() signal. See also toggleGridIsDrawn(). */
+  void setGridIsDrawn(bool draw=true) { gridIsDrawn_ = draw; emit gridIsDrawnChanged(draw); if (updateGLOK_) updateGL(); };
+  /*! Sets the state of FPSIsDisplayed(). Emits the FPSIsDisplayedChanged() signal. See also toggleFPSIsDisplayed(). */
+  void setFPSIsDisplayed(bool display=true) { FPSIsDisplayed_ = display; emit FPSIsDisplayedChanged(display); if (updateGLOK_) updateGL(); };
+  /*! Sets the state of textIsEnabled(). Emits the textIsEnabledChanged() signal. See also toggleTextIsEnabled(). */
+  void setTextIsEnabled(bool enable=true) { textIsEnabled_ = enable; emit textIsEnabledChanged(enable); if (updateGLOK_) updateGL(); };
+  void setCameraIsEdited(bool edit=true);
+
+  /*! Toggles the state of axisIsDrawn(). See also setAxisIsDrawn(). */
+  void toggleAxisIsDrawn() { setAxisIsDrawn(!axisIsDrawn()); };
+  /*! Toggles the state of gridIsDrawn(). See also setGridIsDrawn(). */
+  void toggleGridIsDrawn() { setGridIsDrawn(!gridIsDrawn()); };
+  /*! Toggles the state of FPSIsDisplayed(). See also setFPSIsDisplayed(). */
+  void toggleFPSIsDisplayed() { setFPSIsDisplayed(!FPSIsDisplayed()); };
+  /*! Toggles the state of textIsEnabled(). See also setTextIsEnabled(). */
+  void toggleTextIsEnabled() { setTextIsEnabled(!textIsEnabled()); };
+  /*! Toggles the state of cameraIsEdited(). See also setCameraIsEdited(). */
+  void toggleCameraIsEdited() { setCameraIsEdited(!cameraIsEdited()); };
+  //@}
+
+
+  /*! @name Viewer's colors */
+  //@{
+public:
+  /*! Returns the background color of the viewer.
+
+  This method is provided for convenience since the background color is an OpenGL state variable
+  set with \c glClearColor(). However, this internal representation has the advantage that it is
+  saved (resp. restored) with saveStateToFile() (resp. restoreStateFromFile()).
+
+  Use setBackgroundColor() to define and activate a background color.
+
+  \attention Each QColor component is an integer ranging from 0 to 255. This differs from the float
+  values used by \c glClearColor() which are in the 0.0-1.0 range. Default value is (51, 51, 51)
+  (dark gray). You may have to change foregroundColor() accordingly.
+
+  \attention This method does not return the current OpenGL clear color as \c glGet() does. Instead,
+  it returns the QGLViewer internal variable. If you directly use \c glClearColor() or \c
+  qglClearColor() instead of setBackgroundColor(), the two results will differ. */
+  QColor backgroundColor() const { return backgroundColor_; };
+
+  /*! Returns the foreground color used by the viewer.
+
+  This color is used when FPSIsDisplayed(), gridIsDrawn(), to display the camera paths when the
+  cameraIsEdited().
+
+  \attention Each QColor component is an integer in the range 0-255. This differs from the float
+  values used by \c glColor3f() which are in the range 0-1. Default value is (180, 180, 180) (light
+  gray).
+
+  Use \c qglColor(foregroundColor()) to set the current OpenGL color to the foregroundColor().
+
+  See also backgroundColor(). */
+  QColor foregroundColor() const { return foregroundColor_; };
+public slots:
+/*! Sets the backgroundColor() of the viewer and calls \c qglClearColor(). See also
+  setForegroundColor(). */
+  void setBackgroundColor(const QColor&amp; color) { backgroundColor_=color; qglClearColor(color); };
+  /*! Sets the foregroundColor() of the viewer, used to draw visual hints. See also setBackgroundColor(). */
+  void setForegroundColor(const QColor&amp; color) { foregroundColor_ = color; };
+  //@}
+
+
+  /*! @name Scene dimensions */
+  //@{
+public:
+  /*! Returns the scene radius.
+
+  The entire displayed scene should be included in a sphere of radius sceneRadius(), centered on
+  sceneCenter().
+
+  This approximate value is used by the camera() to set qglviewer::Camera::zNear() and
+  qglviewer::Camera::zFar(). It is also used to showEntireScene() or to scale the world axis
+  display..
+
+  Default value is 1.0. This method is equivalent to camera()-&gt;sceneRadius(). See
+  setSceneRadius(). */
+  float sceneRadius() const { return camera()-&gt;sceneRadius(); }
+  /*! Returns the scene center, defined in world coordinates.
+
+  See sceneRadius() for details.
+
+  Default value is (0,0,0). Simply a wrapper for camera()-&gt;sceneCenter(). Set using
+  setSceneCenter().
+
+  Do not mismatch this value (that only depends on the scene) with the qglviewer::Camera::revolveAroundPoint(). */
+  qglviewer::Vec sceneCenter() const { return camera()-&gt;sceneCenter(); }
+
+public slots:
+  /*! Sets the sceneRadius().
+
+  The camera() qglviewer::Camera::flySpeed() is set to 1% of this value by this method. Simple
+  wrapper around camera()-&gt;setSceneRadius(). */
+  virtual void setSceneRadius(float radius) { camera()-&gt;setSceneRadius(radius); }
+
+  /*! Sets the sceneCenter(), defined in world coordinates.
+
+  \attention The qglviewer::Camera::revolveAroundPoint() is set to the sceneCenter() value by this
+  method. */
+  virtual void setSceneCenter(const qglviewer::Vec&amp; center) { camera()-&gt;setSceneCenter(center); }
+
+  /*! Convenient way to call setSceneCenter() and setSceneRadius() from a (world axis aligned) bounding box of the scene.
+
+  This is equivalent to:
+  \code
+  setSceneCenter((m+M)/2.0);
+  setSceneRadius(0.5*(M-m).norm());
+  \endcode */
+  void setSceneBoundingBox(const qglviewer::Vec&amp; min, const qglviewer::Vec&amp; max) { camera()-&gt;setSceneBoundingBox(min,max); }
+
+  /*! Moves the camera so that the entire scene is visible.
+
+  Simple wrapper around qglviewer::Camera::showEntireScene(). */
+  void showEntireScene() { camera()-&gt;showEntireScene(); if (updateGLOK_) updateGL(); }
+  //@}
+
+
+  /*! @name Associated objects */
+  //@{
+public:
+  /*! Returns the associated qglviewer::Camera, never \c NULL. */
+  qglviewer::Camera* camera() const { return camera_; };
+
+  /*! Returns the viewer's qglviewer::ManipulatedFrame.
+
+  This qglviewer::ManipulatedFrame can be moved with the mouse when the associated mouse bindings
+  are used (default is when pressing the \c Control key with any mouse button). Use
+  setMouseBinding() to define new bindings.
+
+  See the &lt;a href=&quot;../examples/manipulatedFrame.html&quot;&gt;manipulatedFrame example&lt;/a&gt; for a complete
+  implementation.
+
+  Default value is \c NULL, meaning that no qglviewer::ManipulatedFrame is set. */
+  qglviewer::ManipulatedFrame* manipulatedFrame() const { return manipulatedFrame_; };
+
+public slots:
+  void setCamera(qglviewer::Camera* const camera);
+  void setManipulatedFrame(qglviewer::ManipulatedFrame* frame);
+  //@}
+
+
+  /*! @name Mouse grabbers */
+  //@{
+public:
+  /*! Returns the current qglviewer::MouseGrabber, or \c NULL if no qglviewer::MouseGrabber
+  currently grabs mouse events.
+
+  When qglviewer::MouseGrabber::grabsMouse(), the different mouse events are sent to the
+  mouseGrabber() instead of their usual targets (camera() or manipulatedFrame()).
+
+  See the qglviewer::MouseGrabber documentation for details on MouseGrabber's mode of operation.
+
+  In order to use MouseGrabbers, you need to enable mouse tracking (so that mouseMoveEvent() is
+  called even when no mouse button is pressed). Add this line in init() or in your viewer
+  constructor:
+  \code
+  setMouseTracking(true);
+  \endcode
+  Note that mouse tracking is disabled by default. Use QWidget::hasMouseTracking() to
+  retrieve current state. */
+  qglviewer::MouseGrabber* mouseGrabber() const { return mouseGrabber_; };
+
+  void setMouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber, bool enabled=true);
+  /*! Returns \c true if \p mouseGrabber is enabled.
+
+  Default value is \c true for all MouseGrabbers. When set to \c false using
+  setMouseGrabberIsEnabled(), the specified \p mouseGrabber will never become the mouseGrabber() of
+  this QGLViewer. This is useful when you use several viewers: some MouseGrabbers may only have a
+  meaning for some specific viewers and should not be selectable in others.
+
+  You can also use qglviewer::MouseGrabber::removeFromMouseGrabberPool() to completely disable a
+  MouseGrabber in all the QGLViewers. */
+  bool mouseGrabberIsEnabled(const qglviewer::MouseGrabber* const mouseGrabber) { return !disabledMouseGrabbers_.contains(reinterpret_cast&lt;size_t&gt;(mouseGrabber)); };
+public slots:
+  void setMouseGrabber(qglviewer::MouseGrabber* mouseGrabber);
+  //@}
+
+
+  /*! @name State of the viewer */
+  //@{
+public:
+  /*! Returns the aspect ratio of the viewer's widget (width() / height()). */
+  float aspectRatio() const { return static_cast&lt;float&gt;(width())/static_cast&lt;float&gt;(height()); };
+  /*! Returns the current averaged viewer frame rate.
+
+  This value is computed and averaged over 20 successive frames. It only changes every 20 draw()
+  (previously computed value is otherwise returned).
+
+  This method is useful for true real-time applications that may adapt their computational load
+  accordingly in order to maintain a given frequency.
+
+  This value is meaningful only when draw() is regularly called, either using a \c QTimer, when
+  animationIsStarted() or when the camera is manipulated with the mouse.  */
+  float currentFPS() { return f_p_s_; };
+  /*! Returns \c true if the viewer is in fullScreen mode.
+
+  Default value is \c false. Set by setFullScreen() or toggleFullScreen().
+
+  Note that if the QGLViewer is embedded in an other QWidget, it returns \c true when the top level
+  widget is in full screen mode. */
+  bool isFullScreen() const { return fullScreen_; };
+  /*! Returns \c true if the viewer displays in stereo.
+
+  The QGLViewer object must be created with a stereo format to handle stereovision:
+  \code
+  QGLFormat format;
+  format.setStereoDisplay( TRUE );
+  QGLViewer viewer(format);
+  \endcode
+  The hardware needs to support stereo display. Try the &lt;a
+  href=&quot;../examples/stereoViewer.html&quot;&gt;stereoViewer example&lt;/a&gt; to check.
+
+  Set by setStereoDisplay() or toggleStereoDisplay(). Default value is \c false.
+
+  Stereo is performed using the Parallel axis asymmetric frustum perspective projection method.
+  See Camera::loadProjectionMatrixStereo() and Camera::loadModelViewMatrixStereo().
+
+  The stereo parameters are defined by the camera(). See qglviewer::Camera::setIODistance(),
+  qglviewer::Camera::setPhysicalDistanceToScreen(),
+  qglviewer::Camera::setPhysicalScreenWidth() and
+  qglviewer::Camera::setFocusDistance(). */
+  bool displaysInStereo() const { return stereo_; }
+  /*! Returns the recommended size for the QGLViewer. Default value is 600x400 pixels. */
+  virtual QSize sizeHint() const { return QSize(600, 400); }
+
+public slots:
+  void setFullScreen(bool fullScreen=true);
+  void setStereoDisplay(bool stereo=true);
+  /*! Toggles the state of isFullScreen(). See also setFullScreen(). */
+  void toggleFullScreen() { setFullScreen(!isFullScreen()); };
+  /*! Toggles the state of displaysInStereo(). See setStereoDisplay(). */
+  void toggleStereoDisplay() { setStereoDisplay(!stereo_); };
+  void toggleCameraMode();
+
+private:
+  bool cameraIsInRevolveMode() const;
+  //@}
+
+
+  /*! @name Display methods */
+  //@{
+public:
+  static void drawArrow(float length=1.0f, float radius=-1.0f, int nbSubdivisions=12);
+  static void drawArrow(const qglviewer::Vec&amp; from, const qglviewer::Vec&amp; to, float radius=-1.0f, int nbSubdivisions=12);
+  static void drawAxis(float length=1.0f);
+  static void drawGrid(float size=1.0f, int nbSubdivisions=10);
+
+  virtual void startScreenCoordinatesSystem(bool upward=false) const;
+  virtual void stopScreenCoordinatesSystem() const;
+
+  void drawText(int x, int y, const QString&amp; text, const QFont&amp; fnt=QFont());
+  void displayMessage(const QString&amp; message, int delay=2000);
+  // void draw3DText(const qglviewer::Vec&amp; pos, const qglviewer::Vec&amp; normal, const QString&amp; string, GLfloat height=0.1f);
+
+protected:
+  virtual void drawLight(GLenum light, float scale = 1.0f) const;
+
+private:
+  void displayFPS();
+  /*! Vectorial rendering callback method. */
+  void drawVectorial() { paintGL(); };
+
+#ifndef DOXYGEN
+  friend void drawVectorial(void* param);
+#endif
+  //@}
+
+
+#ifdef DOXYGEN
+  /*! @name Useful inherited methods */
+  //@{
+public:
+  /*! Returns viewer's widget width (in pixels). See QGLWidget documentation. */
+  int width() const;
+  /*! Returns viewer's widget height (in pixels). See QGLWidget documentation. */
+  int height() const;
+  /*! Updates the display. Do not call draw() directly, use this method instead. See QGLWidget documentation. */
+  virtual void updateGL();
+  /*! Converts \p image into the unnamed format expected by OpenGL methods such as glTexImage2D().
+    See QGLWidget documentation. */
+  static QImage convertToGLFormat(const QImage &amp; image);
+  /*! Calls \c glColor3. See QGLWidget::qglColor(). */
+  void qglColor(const QColor&amp; color) const;
+  /*! Calls \c glClearColor. See QGLWidget documentation. */
+  void qglClearColor(const QColor&amp; color) const;
+  /*! Returns \c true if the widget has a valid GL rendering context. See QGLWidget
+    documentation. */
+  bool isValid() const;
+  /*! Returns \c true if display list sharing with another QGLWidget was requested in the
+    constructor. See QGLWidget documentation. */
+  bool isSharing() const;
+  /*! Makes this widget's rendering context the current OpenGL rendering context. Useful with
+    several viewers. See QGLWidget documentation. */
+  virtual void makeCurrent();
+  /*! Returns \c true if mouseMoveEvent() is called even when no mouse button is pressed.
+
+  You need to setMouseTracking() to \c true in order to use MouseGrabber (see mouseGrabber()). See
+  details in the QWidget documentation. */
+  bool hasMouseTracking () const;
+public slots:
+  /*! Resizes the widget to size \p width by \p height pixels. See also width() and height(). */
+  virtual void resize(int width, int height);
+  /*! Sets the hasMouseTracking() value. */
+  virtual void setMouseTracking(bool enable);
+protected:
+  /*! Returns \c true when buffers are automatically swapped (default). See details in the QGLWidget
+  documentation. */
+  bool autoBufferSwap() const;
+protected slots:
+  /*! Sets the autoBufferSwap() value. */
+  void setAutoBufferSwap(bool on);
+  //@}
+#endif
+
+
+  /*! @name Snapshots */
+  //@{
+public:
+#if QT_VERSION &lt; 0x030000
+  virtual QImage grabFrameBuffer(bool withAlpha=false);
+#endif
+  /*! Returns the snapshot file name used by saveSnapshot().
+
+  This value is used in \p automatic mode (see saveSnapshot()). A dialog is otherwise popped-up to
+  set it.
+
+  You can also directly provide a file name using saveSnapshot(const QString&amp;, bool).
+
+  If the file name is relative, the current working directory at the moment of the method call is
+  used. Set using setSnapshotFileName(). */
+  const QString&amp; snapshotFileName() const { return snapshotFileName_; };
+#ifndef DOXYGEN
+  const QString&amp; snapshotFilename() const;
+#endif
+  /*! Returns the snapshot file format used by saveSnapshot().
+
+  This value is used when saveSnapshot() is passed the \p automatic flag. It is defined using a
+  saveAs pop-up dialog otherwise.
+
+  The available formats are those handled by Qt. Classical values are \c &quot;JPEG&quot;, \c &quot;PNG&quot;,
+  \c &quot;PPM, \c &quot;BMP&quot;. Use the following code to get the actual list:
+  \code
+  QList&lt;QByteArray&gt; formatList = QImageReader::supportedImageFormats();
+  // or with Qt version 2 or 3:
+  QStringList formatList = QImage::outputFormatList();
+  \endcode
+
+  If the library was compiled with the vectorial rendering option (default), three additional
+  vectorial formats are available: \c &quot;EPS&quot;, \c &quot;PS&quot; and \c &quot;XFIG&quot;. \c &quot;SVG&quot; and \c &quot;PDF&quot; formats
+  should soon be available. The &lt;a href=&quot;<A HREF="http://artis.imag.fr/Software/VRender">http://artis.imag.fr/Software/VRender</A>&quot;&gt;VRender library&lt;/a&gt;
+  was created by Cyril Soler.
+
+  Note that the VRender library has some limitations: vertex shader effects are not reproduced and
+  \c PASS_THROUGH tokens are not handled so one can not change point and line size in the middle of
+  a drawing.
+
+  Default value is the first supported among &quot;JPEG, PNG, EPS, PS, PPM, BMP&quot;, in that order.
+
+  This value is set using setSnapshotFormat() or with openSnapshotFormatDialog().
+
+  \attention No verification is performed on the provided format validity. The next call to
+  saveSnapshot() may fail if the format string is not supported. */
+  const QString&amp; snapshotFormat() const { return snapshotFormat_; };
+  /*! Returns the value of the counter used to name snapshots in saveSnapshot() when \p automatic is
+    \c true.
+
+  Set using setSnapshotCounter(). Default value is 0, and it is incremented after each \p automatic
+  snapshot. See saveSnapshot() for details. */
+  int snapshotCounter() const { return snapshotCounter_; };
+  /*! Defines the image quality of the snapshots produced with saveSnapshot().
+
+  Values must be in the range -1..100. Use 0 for lowest quality and 100 for highest quality (and
+  larger files). -1 means use Qt default quality. Default value is 95.
+
+  Set using setSnapshotQuality(). See also the QImage::save() documentation.
+
+  \note This value has no impact on the images produced in vectorial format. */
+  int snapshotQuality() { return snapshotQuality_; };
+
+  // Qt 2.3 does not support double default value parameters in slots.
+  // Remove &quot;slots&quot; from the following line to compile with Qt 2.3
+public slots:
+  void saveSnapshot(bool automatic=true, bool overwrite=false);
+
+public slots:
+  void saveSnapshot(const QString&amp; fileName, bool overwrite=false);
+  void setSnapshotFileName(const QString&amp; name);
+
+  /*! Sets the snapshotFormat(). */
+  void setSnapshotFormat(const QString&amp; format) { snapshotFormat_ = format; };
+  /*! Sets the snapshotCounter(). */
+  void setSnapshotCounter(int counter) { snapshotCounter_ = counter; };
+  /*! Sets the snapshotQuality(). */
+  void setSnapshotQuality(int quality) { snapshotQuality_ = quality; };
+  bool openSnapshotFormatDialog();
+
+private:
+  bool saveImageSnapshot(const QString&amp; fileName);
+  //@}
+
+
+  /*! @name Buffer to texture */
+  //@{
+public:
+  GLuint bufferTextureId() const;
+  /*! Returns the texture coordinate corresponding to the u extremum of the bufferTexture.
+
+  The bufferTexture is created by copyBufferToTexture(). The texture size has powers of two
+  dimensions and the buffer image hence only fills a part of it. This value corresponds to the u
+  coordinate of the extremum right side of the buffer image.
+
+  Use (0,0) to (bufferTextureMaxU(), bufferTextureMaxV()) texture coordinates to map the entire
+  texture on a quad. */
+  float bufferTextureMaxU() const { return bufferTextureMaxU_; };
+  /*! Same as bufferTextureMaxU(), but for the v texture coordinate. */
+  float bufferTextureMaxV() const { return bufferTextureMaxV_; };
+public slots:
+  void copyBufferToTexture(GLint internalFormat, GLenum format=GL_NONE);
+  //@}
+
+  /*! @name Animation */
+  //@{
+public:
+  /*! Return \c true when the animation loop is started.
+
+  During animation, an infinite loop calls animate() and draw() and then waits for animationPeriod()
+  milliseconds before calling animate() and draw() again. And again.
+
+  Use startAnimation(), stopAnimation() or toggleAnimation() to change this value.
+
+  See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for illustration. */
+  bool animationIsStarted() const { return animationStarted_; };
+  /*! The animation loop period, in milliseconds.
+
+  When animationIsStarted(), this is delay waited after draw() to call animate() and draw() again.
+  Default value is 40 milliseconds (25 Hz).
+
+  This value will define the currentFPS() when animationIsStarted() (provided that your animate()
+  and draw() methods are fast enough).
+
+  If you want to know the maximum possible frame rate of your machine on a given scene,
+  setAnimationPeriod() to \c 0, and startAnimation() (keyboard shortcut is \c Enter). The display
+  will then be updated as often as possible, and the frame rate will be meaningful.
+
+  \note This value is taken into account only the next time you call startAnimation(). If
+  animationIsStarted(), you should stopAnimation() first. */
+  int animationPeriod() const { return animationPeriod_; };
+
+public slots:
+  /*! Sets the animationPeriod(), in milliseconds. */
+  void setAnimationPeriod(int period) { animationPeriod_ = period; };
+  virtual void startAnimation();
+  virtual void stopAnimation();
+  /*! Scene animation method.
+
+  When animationIsStarted(), this method is in charge of the scene update before each draw().
+  Overload it to define how your scene evolves over time. The time should either be regularly
+  incremented in this method (frame-rate independent animation) or computed from actual time (for
+  instance using QTime::elapsed()) for real-time animations.
+
+  Note that KeyFrameInterpolator (which regularly updates a Frame) do not use this method but rather
+  rely on a QTimer signal-slot mechanism.
+
+  See the &lt;a href=&quot;../examples/animation.html&quot;&gt;animation example&lt;/a&gt; for an illustration. */
+  virtual void animate() { emit animateNeeded(); };
+  /*! Calls startAnimation() or stopAnimation(), depending on animationIsStarted(). */
+  void toggleAnimation() { if (animationIsStarted()) stopAnimation(); else startAnimation(); };
+  //@}
+
+public:
+  signals:
+  /*! Signal emitted by the default init() method.
+
+  Connect this signal to the methods that need to be called to initialize your viewer or overload init(). */
+  void viewerInitialized();
+
+  /*! Signal emitted by the default draw() method.
+
+  Connect this signal to your main drawing method or overload draw(). See the &lt;a
+  href=&quot;../examples/callback.html&quot;&gt;callback example&lt;/a&gt; for an illustration. */
+  void drawNeeded();
+
+  /*! Signal emitted at the end of the QGLViewer::paintGL() method, when frame is drawn.
+
+  Can be used to notify an image grabbing process that the image is ready. A typical example is to
+  connect this signal to the saveSnapshot() method, so that a (numbered) snapshot is generated after
+  each new display, in order to create a movie:
+  \code
+  connect(viewer, SIGNAL(drawFinished(bool)), SLOT(saveSnapshot(bool)));
+  \endcode
+
+  The \p automatic bool variable is always \c true and has been added so that the signal can be
+  connected to saveSnapshot() with an \c automatic value set to \c true. */
+  void drawFinished(bool automatic);
+
+  /*! Signal emitted by the default animate() method.
+
+  Connect this signal to your scene animation method or overload animate(). */
+  void animateNeeded();
+
+  /*! Signal emitted by the default QGLViewer::help() method.
+
+  Connect this signal to your own help method or overload help(). */
+  void helpRequired();
+
+  /*! This signal is emitted whenever axisIsDrawn() changes value. */
+  void axisIsDrawnChanged(bool drawn);
+  /*! This signal is emitted whenever gridIsDrawn() changes value. */
+  void gridIsDrawnChanged(bool drawn);
+  /*! This signal is emitted whenever FPSIsDisplayed() changes value. */
+  void FPSIsDisplayedChanged(bool displayed);
+  /*! This signal is emitted whenever textIsEnabled() changes value. */
+  void textIsEnabledChanged(bool enabled);
+  /*! This signal is emitted whenever cameraIsEdited() changes value.. */
+  void cameraIsEditedChanged(bool edited);
+  /*! This signal is emitted whenever displaysInStereo() changes value. */
+  void stereoChanged(bool on);
+  /*! Signal emitted by select().
+
+  Connect this signal to your selection method or overload select(), or more probably simply
+  drawWithNames(). */
+  void pointSelected(const QMouseEvent* e);
+
+  /*! Signal emitted by setMouseGrabber() when the mouseGrabber() is changed.
+
+  \p mouseGrabber is a pointer to the new MouseGrabber. Note that this signal is emitted with a \c
+  NULL parameter each time a MouseGrabber stops grabbing mouse. */
+  void mouseGrabberChanged(qglviewer::MouseGrabber* mouseGrabber);
+
+  /*! @name Help window */
+  //@{
+public:
+  /*! Returns the QString displayed in the help() window main tab.
+
+  Overload this method to define your own help string, which should shortly describe your
+  application and explain how it works. Rich-text (HTML) tags can be used (see QStyleSheet()
+  documentation for available tags):
+  \code
+  QString myViewer::helpString() const
+  {
+  QString text(&quot;&lt;h2&gt;M y V i e w e r&lt;/h2&gt;&quot;);
+  text += &quot;Displays a &lt;b&gt;Scene&lt;/b&gt; using OpenGL. Move the camera using the mouse.&quot;;
+  return text;
+  }
+  \endcode
+
+  See also mouseString() and keyboardString(). */
+  virtual QString helpString() const { return QString(&quot;No help available.&quot;); };
+
+  virtual QString mouseString() const;
+  virtual QString keyboardString() const;
+
+#ifndef DOXYGEN
+  /*! This method is deprecated, use mouseString() instead. */
+  virtual QString mouseBindingsString () const { return mouseString(); }
+  /*! This method is deprecated, use keyboardString() instead. */
+  virtual QString shortcutBindingsString () const { return keyboardString(); }
+#endif
+
+public slots:
+  virtual void help();
+  virtual void aboutQGLViewer();
+
+protected:
+  /*! Returns a pointer to the help widget.
+
+  Use this only if you want to directly modify the help widget. Otherwise use helpString(),
+  setKeyDescription() and setMouseBindingDescription() to customize the text displayed in the help
+  window tabs. */
+  QTabWidget* helpWidget() { return helpWidget_; }
+  //@}
+
+
+  /*! @name Drawing methods */
+  //@{
+protected:
+  virtual void resizeGL(int width, int height);
+  virtual void initializeGL();
+
+  /*! Initializes the viewer OpenGL context.
+
+  This method is called before the first drawing and should be overloaded to initialize some of the
+  OpenGL flags. The default implementation is empty. See initializeGL().
+
+  Typical usage include camera() initialization (showEntireScene()), previous viewer state
+  restoration (restoreStateFromFile()), OpenGL state modification and display list creation.
+
+  Note that initializeGL() modifies the standard OpenGL context. These values can be restored back
+  in this method.
+
+  \attention You should not call updateGL() (or any method that calls it) in this method, as it will
+  result in an infinite loop. The different QGLViewer set methods (setAxisIsDrawn(),
+  setFPSIsDisplayed()...) are protected against this problem and can safely be called.
+
+  \note All the OpenGL specific initializations must be done in this method: the OpenGL context is
+  not yet available in your viewer constructor. */
+  virtual void init() { emit viewerInitialized(); };
+
+  virtual void paintGL();
+  virtual void preDraw();
+  virtual void preDrawStereo(bool leftBuffer=true);
+
+  /*! The core method of the viewer, that draws the scene.
+
+  If you build a class that inherits from QGLViewer, this is the method you want to overload. See
+  the &lt;a href=&quot;../examples/simpleViewer.html&quot;&gt;simpleViewer example&lt;/a&gt; for an illustration.
+
+  The camera modelView matrix set in preDraw() converts from the world to the camera coordinate
+  systems. Vertices given in draw() can then be considered as being given in the world coordinate
+  system. The camera is moved in this world using the mouse. This representation is much more
+  intuitive than the default camera-centric OpenGL standard.
+
+  \attention The \c GL_PROJECTION matrix should not be modified by this method, to correctly display
+  visual hints (axis, grid, FPS...) in postDraw(). Use push/pop or call
+  camera()-&gt;loadProjectionMatrix() at the end of draw() if you need to change the projection matrix
+  (unlikely). On the other hand, the \c GL_MODELVIEW matrix can be modified and left in a arbitrary
+  state. */
+  virtual void draw() {};
+  virtual void fastDraw();
+  virtual void postDraw();
+  //@}
+
+  /*! @name Mouse, keyboard and event handlers */
+  //@{
+protected:
+  virtual void mousePressEvent(QMouseEvent *);
+  virtual void mouseMoveEvent(QMouseEvent *);
+  virtual void mouseReleaseEvent(QMouseEvent *);
+  virtual void mouseDoubleClickEvent(QMouseEvent *);
+  virtual void wheelEvent(QWheelEvent *);
+  virtual void keyPressEvent(QKeyEvent *);
+  virtual void timerEvent(QTimerEvent *);
+  virtual void closeEvent(QCloseEvent *);
+  //@}
+
+  /*! @name Object selection */
+  //@{
+public:
+  /*! Returns the name (an integer value) of the entity that was last selected by select(). This
+    value is set by endSelection(). See the select() documentation for details.
+
+    As a convention, this method returns -1 if the selectBuffer() was empty, meaning that no object
+    was selected.
+
+    Return value is -1 before the first call to select(). This value is modified using setSelectedName(). */
+  int selectedName() const { return selectedObjectId_; };
+  /*! Returns the selectBuffer() size.
+
+  See the select() documentation for details. Use setSelectBufferSize() to change this value.
+
+  Default value is 4000 (i.e. 1000 objects in selection region, since each object pushes 4 values).
+  This size should be over estimated to prevent a buffer overflow when many objects are drawn under
+  the mouse cursor. */
+  int selectBufferSize() const { return selectBufferSize_; };
+
+  /*! Returns the width (in pixels) of a selection frustum, centered on the mouse cursor, that is
+    used to select objects.
+
+    The height of the selection frustum is defined by selectRegionHeight().
+
+    The objects that will be drawn in this region by drawWithNames() will be recorded in the
+    selectBuffer(). endSelection() then analyzes this buffer and setSelectedName() to the name of the
+    closest object. See the gluPickMatrix() documentation for details.
+
+    The default value is 3, which is adapted to standard applications. A smaller value results in a
+    more precise selection but the user has to be careful for small feature selection.
+
+    See the &lt;a href=&quot;../examples/multiSelect.html&quot;&gt;multiSelect example&lt;/a&gt; for an illustration. */
+  int selectRegionWidth() const { return selectRegionWidth_; };
+  /*! See the selectRegionWidth() documentation. Default value is 3 pixels. */
+  int selectRegionHeight() const { return selectRegionHeight_; };
+
+  /*! Returns a pointer to an array of \c GLuint.
+
+  This buffer is used by the \c GL_SELECT mode in select() to perform object selection. The buffer
+  size can be modified using setSelectBufferSize(). If you overload endSelection(), you will analyze
+  the content of this buffer. See the \c glSelectBuffer() man page for details. */
+  GLuint* selectBuffer() { return selectBuffer_; };
+
+public slots:
+  virtual void select(const QMouseEvent* event);
+  virtual void select(const QPoint&amp; point);
+
+  void setSelectBufferSize(int size);
+  /*! Sets the selectRegionWidth(). */
+  void setSelectRegionWidth(int width) { selectRegionWidth_ = width; };
+  /*! Sets the selectRegionHeight(). */
+  void setSelectRegionHeight(int height) { selectRegionHeight_ = height; };
+  /*! Set the selectedName() value.
+
+  Used in endSelection() during a selection. You should only call this method if you overload the
+  endSelection() method. */
+  void setSelectedName(int id) { selectedObjectId_=id; };
+
+protected:
+  virtual void beginSelection(const QPoint&amp; point);
+  /*! This method is called by select() and should draw selectable entities.
+
+  Default implementation is empty. Overload and draw the different elements of your scene you want
+  to be able to select. The default select() implementation relies on the \c GL_SELECT, and requires
+  that each selectable element is drawn within a \c glPushName() - \c glPopName() block. A typical
+  usage would be (see the &lt;a href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt;):
+  \code
+  void Viewer::drawWithNames()
+  {
+    for (int i=0; i&lt;nbObjects; ++i)
+    {
+      glPushName(i);
+      object(i)-&gt;draw();
+      glPopName();
+    }
+  }
+  \endcode
+
+  The resulting selected name is computed by endSelection(), which setSelectedName() to the integer
+  id pushed by this method (a value of -1 means no selection). Use selectedName() to update your
+  selection, probably in the postSelection() method.
+
+  \attention If your selected objects are points, do not use \c glBegin(GL_POINTS); and \c glVertex3fv()
+  in the above \c draw() method (not compatible with raster mode): use \c glRasterPos3fv() instead. */
+  virtual void drawWithNames() {};
+  virtual void endSelection(const QPoint&amp; point);
+  /*! This method is called at the end of the select() procedure. It should finalize the selection
+    process and update the data structure/interface/computation/display... according to the newly
+    selected entity.
+
+    The default implementation is empty. Overload this method if needed, and use selectedName() to
+    retrieve the selected entity name (returns -1 if no object was selected). See the &lt;a
+    href=&quot;../examples/select.html&quot;&gt;select example&lt;/a&gt; for an illustration. */
+  virtual void postSelection(const QPoint&amp; point) { Q_UNUSED(point); };
+  //@}
+
+
+  /*! @name Keyboard customization */
+  //@{
+protected:
+  /*! Defines the different actions that can be associated with a keyboard shortcut using
+    setShortcut().
+
+    See the &lt;a href=&quot;../keyboard.html&quot;&gt;keyboard page&lt;/a&gt; for details. */
+  enum KeyboardAction { DRAW_AXIS, DRAW_GRID, DISPLAY_FPS, ENABLE_TEXT, EXIT_VIEWER,
+			SAVE_SCREENSHOT, CAMERA_MODE, FULL_SCREEN, STEREO, ANIMATION, HELP, EDIT_CAMERA,
+			MOVE_CAMERA_LEFT, MOVE_CAMERA_RIGHT, MOVE_CAMERA_UP, MOVE_CAMERA_DOWN,
+			INCREASE_FLYSPEED, DECREASE_FLYSPEED };
+public:
+  int shortcut(KeyboardAction action) const;
+#ifndef DOXYGEN
+  // QGLViewer 1.x
+  int keyboardAccelerator(KeyboardAction action) const;
+  Qt::Key keyFrameKey(int index) const;
+  QtKeyboardModifiers playKeyFramePathStateKey() const;
+  // QGLViewer 2.0 without Qt4 support
+  QtKeyboardModifiers addKeyFrameStateKey() const;
+  QtKeyboardModifiers playPathStateKey() const;
+#endif
+  Qt::Key pathKey(int index) const;
+  QtKeyboardModifiers addKeyFrameKeyboardModifiers() const;
+  QtKeyboardModifiers playPathKeyboardModifiers() const;
+
+public slots:
+  void setShortcut(KeyboardAction action, int key);
+#ifndef DOXYGEN
+  void setKeyboardAccelerator(KeyboardAction action, int key);
+#endif
+  void setKeyDescription(int key, QString description);
+
+  // Key Frames shortcut keys
+#ifndef DOXYGEN
+  // QGLViewer 1.x compatibility methods
+  virtual void setKeyFrameKey(int index, int key);
+  virtual void setPlayKeyFramePathStateKey(int buttonState);
+  // QGLViewer 2.0 without Qt4 support
+  virtual void setPlayPathStateKey(int buttonState);
+  virtual void setAddKeyFrameStateKey(int buttonState);
+#endif
+  virtual void setPathKey(int key, int index = 0);
+  virtual void setPlayPathKeyboardModifiers(QtKeyboardModifiers modifiers);
+  virtual void setAddKeyFrameKeyboardModifiers(QtKeyboardModifiers modifiers);
+  //@}
+
+
+  /*! @name Mouse customization */
+  //@{
+protected:
+  /*! Defines the different mouse handlers: camera() or manipulatedFrame().
+
+  Used by setMouseBinding(), setMouseBinding(int, ClickAction, bool, int) and setWheelBinding() to
+  define which handler receives the mouse events. */
+  enum MouseHandler { CAMERA, FRAME };
+
+  /*! Defines the possible actions that can be binded to a mouse click using
+  setMouseBinding(int,ClickAction,bool,int).
+
+  See the &lt;a href=&quot;../mouse.html&quot;&gt;mouse page&lt;/a&gt; for details. */
+  enum ClickAction { NO_CLICK_ACTION, ZOOM_ON_PIXEL, ZOOM_TO_FIT, SELECT, RAP_FROM_PIXEL, RAP_IS_CENTER,
+		     CENTER_FRAME, CENTER_SCENE, SHOW_ENTIRE_SCENE, ALIGN_FRAME, ALIGN_CAMERA };
+
+#ifndef DOXYGEN
+  // So that it can be used in ManipulatedFrame and ManipulatedCameraFrame.
+public:
+#endif
+
+  /*! Defines the possible actions that can be binded to a mouse motion (a click, followed by a
+  mouse displacement).
+
+  These actions may be binded to the camera() or to the manipulatedFrame() (see QGLViewer::MouseHandler) using
+  setMouseBinding(). */
+  enum MouseAction { NO_MOUSE_ACTION,
+		     ROTATE, ZOOM, TRANSLATE,
+		     MOVE_FORWARD, LOOK_AROUND, MOVE_BACKWARD,
+		     SCREEN_ROTATE, ROLL, DRIVE,
+		     SCREEN_TRANSLATE, ZOOM_ON_REGION };
+
+#ifdef DOXYGEN
+public:
+#endif
+
+  MouseAction mouseAction(int state) const;
+  int mouseHandler(int state) const;
+  int mouseButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
+  ClickAction clickAction(int state, bool doubleClick, QtMouseButtons buttonsBefore) const;
+  void getClickButtonState(ClickAction action, int&amp; state, bool&amp; doubleClick, QtMouseButtons&amp; buttonsBefore) const;
+
+  MouseAction wheelAction(QtKeyboardModifiers modifiers) const;
+  int wheelHandler(QtKeyboardModifiers modifiers) const;
+  int wheelButtonState(MouseHandler handler, MouseAction action, bool withConstraint=true) const;
+
+public slots:
+  void setMouseBinding(int state, MouseHandler handler, MouseAction action, bool withConstraint=true);
+#if QT_VERSION &lt; 0x030000
+  // Two slots cannot have the same name or two default parameters with Qt 2.3.
+public:
+#endif
+  void setMouseBinding(int state, ClickAction action, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
+  void setMouseBindingDescription(int state, QString description, bool doubleClick=false, QtMouseButtons buttonsBefore=Qt::NoButton);
+#if QT_VERSION &lt; 0x030000
+public slots:
+#endif
+  void setWheelBinding(QtKeyboardModifiers modifiers, MouseHandler handler, MouseAction action, bool withConstraint=true);
+  void setHandlerKeyboardModifiers(MouseHandler handler, QtKeyboardModifiers modifiers);
+#ifndef DOXYGEN
+  void setHandlerStateKey(MouseHandler handler, int buttonState);
+  void setMouseStateKey(MouseHandler handler, int buttonState);
+#endif
+
+private:
+  static QString mouseActionString(QGLViewer::MouseAction ma);
+  static QString clickActionString(QGLViewer::ClickAction ca);
+  //@}
+
+
+  /*! @name State persistence */
+  //@{
+public:
+  QString stateFileName() const;
+  virtual QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+
+public slots:
+  virtual void initFromDOMElement(const QDomElement&amp; element);
+  virtual void saveStateToFile(); // cannot be const because of QMessageBox
+  virtual bool restoreStateFromFile();
+
+  /*! Defines the stateFileName() used by saveStateToFile() and restoreStateFromFile().
+
+  The file name can have an optional prefix directory (no prefix meaning current directory). If the
+  directory does not exist, it will be created by saveStateToFile().
+
+  \code
+  // Name depends on the displayed 3D model. Saved in current directory.
+  setStateFileName(3DModelName() + &quot;.xml&quot;);
+
+  // Files are stored in a dedicated directory under user's home directory.
+  setStateFileName(QDir::homeDirPath + &quot;/.config/myApp.xml&quot;);
+  \endcode */
+  void setStateFileName(const QString&amp; name) { stateFileName_ = name; };
+
+#ifndef DOXYGEN
+  void saveToFile(const QString&amp; fileName=QString::null);
+  bool restoreFromFile(const QString&amp; fileName=QString::null);
+#endif
+
+private:
+  static void saveStateToFileForAllViewers();
+  //@}
+
+
+  /*! @name QGLViewer pool */
+  //@{
+public:
+  /*! Returns a \c QList (see Qt documentation) that contains pointers to all the created
+  QGLViewers.
+
+  Can be useful to apply a method or to connect a signal to all the viewers.
+
+  \attention With Qt version 3, this method returns a \c QPtrList instead. Use a \c QPtrListIterator
+  to iterate on the list:
+  \code
+  QPtrListIterator&lt;QGLViewer&gt; it(QGLViewer::QGLViewerPool());
+  for (QGLViewer* viewer; (viewer = it.current()) != NULL; ++it)
+  connect(myObject, SIGNAL(mySignal), viewer, SLOT(updateGL()));
+  \endcode */
+#if QT_VERSION &gt;= 0x040000
+  static const QList&lt;QGLViewer*&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
+#else
+  static const QPtrList&lt;QGLViewer&gt;&amp; QGLViewerPool() { return QGLViewer::QGLViewerPool_; };
+#endif
+
+
+  /*! Returns the index of the QGLViewer \p viewer in the QGLViewerPool(). This index in unique and
+  can be used to identify the different created QGLViewers (see stateFileName() for an application
+  example).
+
+  When a QGLViewer is deleted, the following QGLViewers' indexes are shifted down. Returns -1 if the
+  QGLViewer could not be found (which should not be possible). */
+#if QT_VERSION &gt;= 0x040000
+  static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.indexOf(const_cast&lt;QGLViewer*&gt;(viewer)); };
+#else
+  static int QGLViewerIndex(const QGLViewer* const viewer) { return QGLViewer::QGLViewerPool_.find(viewer); };
+#endif
+  //@}
+
+#ifndef DOXYGEN
+  /*! @name Visual hints */
+  //@{
+public:
+  virtual void setVisualHintsMask(int mask, int delay = 2000);
+  virtual void drawVisualHints();
+
+public slots:
+  virtual void resetVisualHints();
+  //@}
+#endif
+
+private slots:
+  // Patch for a Qt bug with fullScreen on startup
+  void delayedFullScreen() { move(prevPos_); setFullScreen(); };
+  void hideMessage();
+
+private:
+  // Copy constructor and operator= are declared private and undefined
+  // Prevents everyone from trying to use them
+  QGLViewer(const QGLViewer&amp; v);
+  QGLViewer&amp; operator=(const QGLViewer&amp; v);
+
+  // Set parameters to their default values. Called by the constructors.
+  void defaultConstructor();
+
+  void handleKeyboardAction(KeyboardAction id);
+
+  // C a m e r a
+  qglviewer::Camera* camera_;
+  bool cameraIsEdited_;
+  float previousCameraZClippingCoefficient_;
+  int previousPathId_; // Double key press recognition
+  void connectAllCameraKFIInterpolatedSignals(bool connection=true);
+
+  // C o l o r s
+  QColor backgroundColor_, foregroundColor_;
+
+  // D i s p l a y    f l a g s
+  bool axisIsDrawn_;	// world axis
+  bool gridIsDrawn_;	// world XY grid
+  bool FPSIsDisplayed_;	// Frame Per Seconds
+  bool textIsEnabled_;	// drawText() actually draws text or not
+  bool stereo_;		// stereo display
+  bool fullScreen_;	// full screen mode
+  QPoint prevPos_;	// Previous window position, used for full screen mode
+
+  // A n i m a t i o n
+  bool animationStarted_; // animation mode started
+  int animationPeriod_;   // period in msecs
+  int animationTimerId_;
+
+  // F P S    d i s p l a y
+  QTime fpsTime_;
+  unsigned int fpsCounter_;
+  QString fpsString_;
+  float f_p_s_;
+
+  // M e s s a g e s
+  QString message_;
+  bool displayMessage_;
+  QTimer messageTimer_;
+
+  // M a n i p u l a t e d    f r a m e
+  qglviewer::ManipulatedFrame* manipulatedFrame_;
+  bool manipulatedFrameIsACamera_;
+
+  // M o u s e   G r a b b e r
+  qglviewer::MouseGrabber* mouseGrabber_;
+  bool mouseGrabberIsAManipulatedFrame_;
+  bool mouseGrabberIsAManipulatedCameraFrame_;
+  QMap&lt;size_t, bool&gt; disabledMouseGrabbers_;
+
+  // S e l e c t i o n
+  int selectRegionWidth_, selectRegionHeight_;
+  int selectBufferSize_;
+  GLuint* selectBuffer_;
+  int selectedObjectId_;
+
+  // V i s u a l   h i n t s
+  int visualHint_;
+
+  // S h o r t c u t   k e y s
+  void setDefaultShortcuts();
+  QString cameraPathKeysString() const;
+  QMap&lt;KeyboardAction, QString&gt; keyboardActionDescription_;
+  QMap&lt;KeyboardAction, int&gt; keyboardBinding_;
+  QMap&lt;int, QString&gt; keyDescription_;
+
+  // K e y   F r a m e s   s h o r t c u t s
+  QMap&lt;Qt::Key, int&gt; pathIndex_;
+  QtKeyboardModifiers addKeyFrameKeyboardModifiers_, playPathKeyboardModifiers_;
+
+  // B u f f e r   T e x t u r e
+  GLuint bufferTextureId_;
+  float bufferTextureMaxU_, bufferTextureMaxV_;
+  int bufferTextureWidth_, bufferTextureHeight_;
+  unsigned int previousBufferTextureFormat_;
+  int previousBufferTextureInternalFormat_;
+
+#ifndef DOXYGEN
+  // M o u s e   a c t i o n s
+  struct MouseActionPrivate {
+    MouseHandler handler;
+    MouseAction action;
+    bool withConstraint;
+  };
+
+  // C l i c k   a c t i o n s
+  struct ClickActionPrivate {
+    QtKeyboardModifiers modifiers;
+    QtMouseButtons button;
+    bool doubleClick;
+    QtMouseButtons buttonsBefore; // only defined when doubleClick is true
+
+    // This sort order in used in mouseString() to displays sorted mouse bindings
+    bool operator&lt;(const ClickActionPrivate&amp; cap) const
+    {
+      if (buttonsBefore != cap.buttonsBefore)
+	return buttonsBefore &lt; cap.buttonsBefore;
+      else
+	if (modifiers != cap.modifiers)
+	  return modifiers &lt; cap.modifiers;
+	else
+	  if (button != cap.button)
+	    return button &lt; cap.button;
+	  else
+	    return !doubleClick &amp;&amp; cap.doubleClick;
+    }
+  };
+#endif
+
+  QMap&lt;ClickActionPrivate, QString&gt; mouseDescription_;
+
+  void setDefaultMouseBindings();
+  void performClickAction(ClickAction ca, const QMouseEvent* const e);
+  QMap&lt;int, MouseActionPrivate&gt; mouseBinding_;
+  QMap&lt;QtKeyboardModifiers, MouseActionPrivate&gt; wheelBinding_;
+  QMap&lt;ClickActionPrivate, ClickAction&gt; clickBinding_;
+
+  // S n a p s h o t s
+  void initializeSnapshotFormats();
+  QString snapshotFileName_, snapshotFormat_;
+  int snapshotCounter_, snapshotQuality_;
+
+  // Q G L V i e w e r   p o o l
+#if QT_VERSION &gt;= 0x040000
+  static QList&lt;QGLViewer*&gt; QGLViewerPool_;
+#else
+  static QPtrList&lt;QGLViewer&gt; QGLViewerPool_;
+#endif
+
+  // S t a t e   F i l e
+  QString stateFileName_;
+
+  // H e l p   w i n d o w
+  QTabWidget* helpWidget_;
+
+  // I n t e r n a l   d e b u g
+  bool updateGLOK_;
+};
+
+#endif // QGLVIEWER_QGLVIEWER_H

Added: trunk/lib/QGLViewer/quaternion.cpp
===================================================================
--- trunk/lib/QGLViewer/quaternion.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/quaternion.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,559 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;quaternion.h&quot;
+#include &lt;stdlib.h&gt; // RAND_MAX
+
+// All the methods are declared inline in Quaternion.h
+using namespace qglviewer;
+using namespace std;
+
+/*! Constructs a Quaternion that will rotate from the \p from direction to the \p to direction.
+
+Note that this rotation is not uniquely defined. The selected axis is usually orthogonal to \p from
+and \p to. However, this method is robust and can handle small or almost identical vectors. */
+Quaternion::Quaternion(const Vec&amp; from, const Vec&amp; to)
+{
+  const float epsilon = 1E-10f;
+
+  const float fromSqNorm = from.squaredNorm();
+  const float toSqNorm   = to.squaredNorm();
+  // Identity Quaternion when one vector is null
+  if ((fromSqNorm &lt; epsilon) || (toSqNorm &lt; epsilon))
+    {
+      q[0]=q[1]=q[2]=0.0;
+      q[3]=1.0;
+    }
+  else
+    {
+      Vec axis = cross(from, to);
+      const float axisSqNorm = axis.squaredNorm();
+
+      // Aligned vectors, pick any axis, not aligned with from or to
+      if (axisSqNorm &lt; epsilon)
+	axis = from.orthogonalVec();
+
+      double angle = asin(sqrt(axisSqNorm / (fromSqNorm * toSqNorm)));
+
+      if (from*to &lt; 0.0)
+	angle = M_PI-angle;
+
+      setAxisAngle(axis, angle);
+    }
+}
+
+/*! Returns the image of \p v by the Quaternion inverse() rotation.
+
+rotate() performs an inverse transformation. Same as inverse().rotate(v). */
+Vec Quaternion::inverseRotate(const Vec&amp; v) const
+{
+  return inverse().rotate(v);
+}
+
+/*! Returns the image of \p v by the Quaternion rotation.
+
+See also inverseRotate() and operator*(const Quaternion&amp;, const Vec&amp;). */
+Vec Quaternion::rotate(const Vec&amp; v) const
+{
+  const double q00 = 2.0l * q[0] * q[0];
+  const double q11 = 2.0l * q[1] * q[1];
+  const double q22 = 2.0l * q[2] * q[2];
+
+  const double q01 = 2.0l * q[0] * q[1];
+  const double q02 = 2.0l * q[0] * q[2];
+  const double q03 = 2.0l * q[0] * q[3];
+
+  const double q12 = 2.0l * q[1] * q[2];
+  const double q13 = 2.0l * q[1] * q[3];
+
+  const double q23 = 2.0l * q[2] * q[3];
+
+  return Vec((1.0 - q11 - q22)*v[0] + (      q01 - q23)*v[1] + (      q02 + q13)*v[2],
+	     (      q01 + q23)*v[0] + (1.0 - q22 - q00)*v[1] + (      q12 - q03)*v[2],
+	     (      q02 - q13)*v[0] + (      q12 + q03)*v[1] + (1.0 - q11 - q00)*v[2] );
+}
+
+/*! Set the Quaternion from a (supposedly correct) 3x3 rotation matrix.
+
+  The matrix is expressed in European format: its three \e columns are the images by the rotation of
+  the three vectors of an orthogonal basis. Note that OpenGL uses a symmetric representation for its
+  matrices.
+
+  setFromRotatedBasis() sets a Quaternion from the three axis of a rotated frame. It actually fills
+  the three columns of a matrix with these rotated basis vectors and calls this method. */
+void Quaternion::setFromRotationMatrix(const double m[3][3])
+{
+  // Compute one plus the trace of the matrix
+  const double onePlusTrace = 1.0 + m[0][0] + m[1][1] + m[2][2];
+
+  if (onePlusTrace &gt; 1E-5)
+    {
+      // Direct computation
+      const double s = sqrt(onePlusTrace) * 2.0;
+      q[0] = (m[2][1] - m[1][2]) / s;
+      q[1] = (m[0][2] - m[2][0]) / s;
+      q[2] = (m[1][0] - m[0][1]) / s;
+      q[3] = 0.25 * s;
+    }
+  else
+    {
+      // Computation depends on major diagonal term
+      if ((m[0][0] &gt; m[1][1])&amp;(m[0][0] &gt; m[2][2]))
+	{ 
+	  const double s = sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]) * 2.0; 
+	  q[0] = 0.25 * s;
+	  q[1] = (m[0][1] + m[1][0]) / s; 
+	  q[2] = (m[0][2] + m[2][0]) / s; 
+	  q[3] = (m[1][2] - m[2][1]) / s;
+	}
+      else
+	if (m[1][1] &gt; m[2][2])
+	  { 
+	    const double s = sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]) * 2.0; 
+	    q[0] = (m[0][1] + m[1][0]) / s; 
+	    q[1] = 0.25 * s;
+	    q[2] = (m[1][2] + m[2][1]) / s; 
+	    q[3] = (m[0][2] - m[2][0]) / s;
+	  }
+	else
+	  { 
+	    const double s = sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]) * 2.0; 
+	    q[0] = (m[0][2] + m[2][0]) / s; 
+	    q[1] = (m[1][2] + m[2][1]) / s; 
+	    q[2] = 0.25 * s;
+	    q[3] = (m[0][1] - m[1][0]) / s;
+	  }
+    }
+  normalize();
+}
+
+#ifndef DOXYGEN
+void Quaternion::setFromRotationMatrix(const float m[3][3])
+{
+  qWarning(&quot;setFromRotationMatrix now waits for a double[3][3] parameter&quot;);
+
+  double mat[3][3];
+  for (int i=0; i&lt;3; ++i)
+    for (int j=0; j&lt;3; ++j)
+      mat[i][j] = double(m[i][j]);
+
+  setFromRotationMatrix(mat);
+}
+
+void Quaternion::setFromRotatedBase(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z)
+{
+  qWarning(&quot;setFromRotatedBase is deprecated, use setFromRotatedBasis instead&quot;);
+  setFromRotatedBasis(X,Y,Z);
+}
+#endif
+
+/*! Sets the Quaternion from the three rotated vectors of an orthogonal basis.
+
+  The three vectors do not have to be normalized but must be orthogonal and direct (X^Y=k*Z, with k&gt;0).
+
+  \code
+  Quaternion q;
+  q.setFromRotatedBasis(X, Y, Z);
+  // Now q.rotate(Vec(1,0,0)) == X and q.inverseRotate(X) == Vec(1,0,0)
+  // Same goes for Y and Z with Vec(0,1,0) and Vec(0,0,1).
+  \endcode
+
+  See also setFromRotationMatrix() and Quaternion(const Vec&amp;, const Vec&amp;). */
+void Quaternion::setFromRotatedBasis(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z)
+{
+  double m[3][3];
+  double normX = X.norm();
+  double normY = Y.norm();
+  double normZ = Z.norm();
+
+  for (int i=0; i&lt;3; ++i)
+    {
+      m[i][0] = X[i] / normX;
+      m[i][1] = Y[i] / normY;
+      m[i][2] = Z[i] / normZ;
+    }
+  
+  setFromRotationMatrix(m);
+}
+
+/*! Returns the axis vector and the angle (in radians) of the rotation represented by the Quaternion.
+ See the axis() and angle() documentations. */
+void Quaternion::getAxisAngle(Vec&amp; axis, float&amp; angle) const
+{
+  angle = 2.0*acos(q[3]);
+  axis = Vec(q[0], q[1], q[2]);
+  const float sinus = axis.norm();
+  if (sinus &gt; 1E-8)
+    axis /= sinus;
+
+  if (angle &gt; M_PI)
+    {
+      angle = 2.0*M_PI - angle;
+      axis = -axis;
+    }
+}
+
+/*! Returns the normalized axis direction of the rotation represented by the Quaternion.
+
+It is null for an identity Quaternion. See also angle() and getAxisAngle(). */
+Vec Quaternion::axis() const
+{
+  Vec res = Vec(q[0], q[1], q[2]);
+  const float sinus = res.norm();
+  if (sinus &gt; 1E-8)
+    res /= sinus;
+  return (acos(q[3]) &lt;= M_PI/2.0) ? res : -res;
+}
+
+/*! Returns the angle (in radians) of the rotation represented by the Quaternion.
+
+ This value is always in the range [0-pi]. Larger rotational angles are obtained by inverting the
+ axis() direction.
+
+ See also axis() and getAxisAngle(). */
+float Quaternion::angle() const
+{
+  const float angle = 2.0 * acos(q[3]);
+  return (angle &lt;= M_PI) ? angle : 2.0*M_PI - angle;
+}
+
+/*! Returns an XML \c QDomElement that represents the Quaternion.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ When output to a file, the resulting QDomElement will look like:
+ \code
+ &lt;name q0=&quot;..&quot; q1=&quot;..&quot; q2=&quot;..&quot; q3=&quot;..&quot; /&gt;
+ \endcode
+
+ Use initFromDOMElement() to restore the Quaternion state from the resulting \c QDomElement. See
+ also the Quaternion(const QDomElement&amp;) constructor.
+
+ See the Vec::domElement() documentation for a complete QDomDocument creation and saving example.
+
+ See also Frame::domElement(), Camera::domElement(), KeyFrameInterpolator::domElement()... */
+QDomElement Quaternion::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement de = document.createElement(name);
+  de.setAttribute(&quot;q0&quot;, QString::number(q[0]));
+  de.setAttribute(&quot;q1&quot;, QString::number(q[1]));
+  de.setAttribute(&quot;q2&quot;, QString::number(q[2]));
+  de.setAttribute(&quot;q3&quot;, QString::number(q[3]));
+  return de;
+}
+
+/*! Restores the Quaternion state from a \c QDomElement created by domElement().
+
+ The \c QDomElement should contain the \c q0, \c q1 , \c q2 and \c q3 attributes. If one of these
+ attributes is missing or is not a number, a warning is displayed and these fields are respectively
+ set to 0.0, 0.0, 0.0 and 1.0 (identity Quaternion).
+
+ See also the Quaternion(const QDomElement&amp;) constructor. */
+void Quaternion::initFromDOMElement(const QDomElement&amp; element)
+{
+  Quaternion q(element);
+  *this = q;
+}
+
+/*! Constructs a Quaternion from a \c QDomElement representing an XML code of the form \c
+  &lt;anyTagName q0=&quot;..&quot; q1=&quot;..&quot; q2=&quot;..&quot; q3=&quot;..&quot; /&gt;.
+
+  If one of these attributes is missing or is not a number, a warning is displayed and the associated
+  value is respectively set to 0, 0, 0 and 1 (identity Quaternion).
+
+  See also domElement() and initFromDOMElement(). */
+Quaternion::Quaternion(const QDomElement&amp; element)
+{
+  QStringList attribute;
+  attribute &lt;&lt; &quot;q0&quot; &lt;&lt; &quot;q1&quot; &lt;&lt; &quot;q2&quot; &lt;&lt; &quot;q3&quot;;
+#if QT_VERSION &gt;= 0x040000
+  for (int i=0; i&lt;attribute.size(); ++i)
+#else
+  for (unsigned int i=0; i&lt;attribute.count(); ++i)
+#endif
+    q[i] = DomUtils::floatFromDom(element, attribute[i], ((i&lt;3)?0.0f:1.0f));
+}
+
+/*! Returns the Quaternion associated 4x4 OpenGL rotation matrix.
+
+ Use \c glMultMatrixd(q.matrix()) to apply the rotation represented by Quaternion \c q to the
+ current OpenGL matrix.
+
+ See also getMatrix(), getRotationMatrix() and inverseMatrix().
+
+ \attention The result is only valid until the next call to matrix(). Use it immediately (as shown
+ above) or consider using getMatrix() instead.
+
+ \attention The matrix is given in OpenGL format (row-major order) and is the transpose of the
+ actual mathematical European representation. Consider using getRotationMatrix() instead. */
+const GLdouble* Quaternion::matrix() const
+{
+  static GLdouble m[4][4];
+  getMatrix(m);
+  return (const GLdouble*)(m);
+}
+
+/*! Fills \p m with the OpenGL representation of the Quaternion rotation.
+
+Use matrix() if you do not need to store this matrix and simply want to alter the current OpenGL
+matrix. See also getInverseMatrix() and Frame::getMatrix(). */
+void Quaternion::getMatrix(GLdouble m[4][4]) const
+{
+  const double q00 = 2.0l * q[0] * q[0];
+  const double q11 = 2.0l * q[1] * q[1];
+  const double q22 = 2.0l * q[2] * q[2];
+
+  const double q01 = 2.0l * q[0] * q[1];
+  const double q02 = 2.0l * q[0] * q[2];
+  const double q03 = 2.0l * q[0] * q[3];
+
+  const double q12 = 2.0l * q[1] * q[2];
+  const double q13 = 2.0l * q[1] * q[3];
+
+  const double q23 = 2.0l * q[2] * q[3];
+
+  m[0][0] = 1.0l - q11 - q22;
+  m[1][0] =        q01 - q23;
+  m[2][0] =        q02 + q13;
+
+  m[0][1] =        q01 + q23;
+  m[1][1] = 1.0l - q22 - q00;
+  m[2][1] =        q12 - q03;
+
+  m[0][2] =        q02 - q13;
+  m[1][2] =        q12 + q03;
+  m[2][2] = 1.0l - q11 - q00;
+
+  m[0][3] = 0.0l;
+  m[1][3] = 0.0l;
+  m[2][3] = 0.0l;
+
+  m[3][0] = 0.0l;
+  m[3][1] = 0.0l;
+  m[3][2] = 0.0l;
+  m[3][3] = 1.0l;
+}
+
+/*! Same as getMatrix(), but with a \c GLdouble[16] parameter. See also getInverseMatrix() and Frame::getMatrix(). */
+void Quaternion::getMatrix(GLdouble m[16]) const
+{
+  static GLdouble mat[4][4];
+  getMatrix(mat);
+  int count = 0;
+  for (int i=0; i&lt;4; ++i)
+    for (int j=0; j&lt;4; ++j)
+      m[count++] = mat[i][j];
+}
+
+/*! Fills \p m with the 3x3 rotation matrix associated with the Quaternion.
+
+  See also getInverseRotationMatrix().
+
+  \attention \p m uses the European mathematical representation of the rotation matrix. Use matrix()
+  and getMatrix() to retrieve the OpenGL transposed version. */
+void Quaternion::getRotationMatrix(float m[3][3]) const
+{
+  static GLdouble mat[4][4];
+  getMatrix(mat);
+  for (int i=0; i&lt;3; ++i)
+    for (int j=0; j&lt;3; ++j)
+      // Beware of transposition
+      m[i][j] = mat[j][i];
+}
+
+/*! Returns the associated 4x4 OpenGL \e inverse rotation matrix. This is simply the matrix() of the
+  inverse().
+
+  \attention The result is only valid until the next call to inverseMatrix(). Use it immediately (as
+  in \c glMultMatrixd(q.inverseMatrix())) or use getInverseMatrix() instead.
+
+  \attention The matrix is given in OpenGL format (row-major order) and is the transpose of the
+  actual mathematical European representation. Consider using getInverseRotationMatrix() instead. */
+const GLdouble* Quaternion::inverseMatrix() const
+{
+  static GLdouble m[4][4];
+  getInverseMatrix(m);
+  return (const GLdouble*)(m);
+}
+
+/*! Fills \p m with the OpenGL matrix corresponding to the inverse() rotation.
+
+Use inverseMatrix() if you do not need to store this matrix and simply want to alter the current
+OpenGL matrix. See also getMatrix(). */
+void Quaternion::getInverseMatrix(GLdouble m[4][4]) const
+{
+  inverse().getMatrix(m);
+}
+
+/*! Same as getInverseMatrix(), but with a \c GLdouble[16] parameter. See also getMatrix(). */
+void Quaternion::getInverseMatrix(GLdouble m[16]) const
+{
+  inverse().getMatrix(m);
+}
+
+/*! \p m is set to the 3x3 \e inverse rotation matrix associated with the Quaternion.
+
+ \attention This is the classical mathematical rotation matrix. The OpenGL format uses its
+ transposed version. See inverseMatrix() and getInverseMatrix(). */
+void Quaternion::getInverseRotationMatrix(float m[3][3]) const
+{
+  static GLdouble mat[4][4];
+  getInverseMatrix(mat);
+  for (int i=0; i&lt;3; ++i)
+    for (int j=0; j&lt;3; ++j)
+      // Beware of transposition
+      m[i][j] = mat[j][i];
+}
+
+
+/*! Returns the slerp interpolation of Quaternions \p a and \p b, at time \p t.
+
+ \p t should range in [0,1]. Result is \p a when \p t=0 and \p b when \p t=1.
+
+ When \p allowFlip is \c true (default) the slerp interpolation will always use the &quot;shortest path&quot;
+ between the Quaternions' orientations, by &quot;flipping&quot; the source Quaternion if needed (see
+ negate()). */
+Quaternion Quaternion::slerp(const Quaternion&amp; a, const Quaternion&amp; b, float t, bool allowFlip)
+{
+  float cosAngle = Quaternion::dot(a, b);
+
+  float c1, c2;
+  // Linear interpolation for close orientations
+  if ((1.0 - fabs(cosAngle)) &lt; 0.01)
+    {
+      c1 = 1.0 - t;
+      c2 = t;
+    }
+  else
+    {
+      // Spherical interpolation
+      float angle    = acos(fabs(cosAngle));
+      float sinAngle = sin(angle);
+      c1 = sin(angle * (1.0 - t)) / sinAngle;
+      c2 = sin(angle * t) / sinAngle;
+    }
+
+  // Use the shortest path
+  if (allowFlip &amp;&amp; (cosAngle &lt; 0.0))
+    c1 = -c1;
+
+  return Quaternion(c1*a[0] + c2*b[0], c1*a[1] + c2*b[1], c1*a[2] + c2*b[2], c1*a[3] + c2*b[3]);
+}
+
+/*! Returns the slerp interpolation of the two Quaternions \p a and \p b, at time \p t, using
+  tangents \p tgA and \p tgB.
+
+  The resulting Quaternion is &quot;between&quot; \p a and \p b (result is \p a when \p t=0 and \p b for \p
+  t=1).
+
+  Use squadTangent() to define the Quaternion tangents \p tgA and \p tgB. */
+Quaternion Quaternion::squad(const Quaternion&amp; a, const Quaternion&amp; tgA, const Quaternion&amp; tgB, const Quaternion&amp; b, float t)
+{
+  Quaternion ab = Quaternion::slerp(a, b, t);
+  Quaternion tg = Quaternion::slerp(tgA, tgB, t, false);
+  return Quaternion::slerp(ab, tg, 2.0*t*(1.0-t), false);
+}
+
+/*! Returns the logarithm of the Quaternion. See also exp(). */
+Quaternion Quaternion::log()
+{
+  float len = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
+
+  if (len &lt; 1E-6)
+    return Quaternion(q[0], q[1], q[2], 0.0);
+  else
+    {
+      float coef = acos(q[3]) / len;
+      return Quaternion(q[0]*coef, q[1]*coef, q[2]*coef, 0.0);
+    }
+}
+
+/*! Returns the exponential of the Quaternion. See also log(). */
+Quaternion Quaternion::exp()
+{
+  float theta = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2]);
+
+  if (theta &lt; 1E-6)
+    return Quaternion(q[0], q[1], q[2], cos(theta));
+  else
+    {
+      float coef = sin(theta) / theta;
+      return Quaternion(q[0]*coef, q[1]*coef, q[2]*coef, cos(theta));
+    }
+}
+
+/*! Returns log(a. inverse() * b). Useful for squadTangent(). */
+Quaternion Quaternion::lnDif(const Quaternion&amp; a, const Quaternion&amp; b)
+{
+  Quaternion dif = a.inverse()*b;
+  dif.normalize();
+  return dif.log();
+}
+
+/*! Returns a tangent Quaternion for \p center, defined by \p before and \p after Quaternions.
+
+ Useful for smooth spline interpolation of Quaternion with squad() and slerp(). */
+Quaternion Quaternion::squadTangent(const Quaternion&amp; before, const Quaternion&amp; center, const Quaternion&amp; after)
+{
+  Quaternion l1 = Quaternion::lnDif(center,before);
+  Quaternion l2 = Quaternion::lnDif(center,after);
+  Quaternion e;
+  for (int i=0; i&lt;4; ++i)
+    e.q[i] = -0.25 * (l1.q[i] + l2.q[i]);
+  e = center*(e.exp());
+
+  // if (Quaternion::dot(e,b) &lt; 0.0)
+    // e.negate();
+
+  return e;
+}
+
+ostream&amp; operator&lt;&lt;(ostream&amp; o, const Quaternion&amp; Q)
+{
+  return o &lt;&lt; Q[0] &lt;&lt; '\t' &lt;&lt; Q[1] &lt;&lt; '\t' &lt;&lt; Q[2] &lt;&lt; '\t' &lt;&lt; Q[3];
+}
+
+/*! Returns a random unit Quaternion.
+
+You can create a randomly directed unit vector using:
+\code
+Vec randomDir = Quaternion::randomQuaternion() * Vec(1.0, 0.0, 0.0); // or any other Vec
+\endcode
+
+\note This function uses rand() to create pseudo-random numbers and the random number generator can
+be initialized using srand().*/
+Quaternion Quaternion::randomQuaternion()
+{
+  // The rand() function is not very portable and may not be available on your system.
+  // Add the appropriate include or replace by an other random function in case of problem.
+  double seed = rand()/(float)RAND_MAX;
+  double r1 = sqrt(1.0 - seed);
+  double r2 = sqrt(seed);
+  double t1 = 2.0 * M_PI * (rand()/(float)RAND_MAX);
+  double t2 = 2.0 * M_PI * (rand()/(float)RAND_MAX);
+  return Quaternion(sin(t1)*r1, cos(t1)*r1, sin(t2)*r2, cos(t2)*r2);
+}

Added: trunk/lib/QGLViewer/quaternion.h
===================================================================
--- trunk/lib/QGLViewer/quaternion.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/quaternion.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,314 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_QUATERNION_H
+#define QGLVIEWER_QUATERNION_H
+
+#include &quot;vec.h&quot;
+#include &lt;math.h&gt;
+#include &lt;iostream&gt;
+
+namespace qglviewer {
+  /*! \brief The Quaternion class represents 3D rotations and orientations.
+  \class Quaternion quaternion.h QGLViewer/quaternion.h
+
+  The Quaternion is an appropriate (although not very intuitive) representation for 3D rotations and
+  orientations. Many tools are provided to ease the definition of a Quaternion: see constructors,
+  setAxisAngle(), setFromRotationMatrix(), setFromRotatedBasis().
+
+  You can apply the rotation represented by the Quaternion to 3D points using rotate() and
+  inverseRotate(). See also the Frame class that represents a coordinate system and provides other
+  conversion functions like Frame::coordinatesOf() and Frame::transformOf().
+
+  You can apply the Quaternion \c q rotation to the OpenGL matrices using:
+  \code
+  glMultMatrixd(q.matrix());
+  // equvalent to glRotate(q.angle()*180.0/M_PI, q.axis().x, q.axis().y, q.axis().z);
+  \endcode
+
+  Quaternion is part of the \c qglviewer namespace, specify \c qglviewer::Quaternion or use the qglviewer
+  namespace: \code using namespace qglviewer; \endcode
+
+  &lt;h3&gt;Internal representation&lt;/h3&gt;
+
+  The internal representation of a Quaternion corresponding to a rotation around axis \c axis, with an angle
+  \c alpha is made of four doubles q[i]:
+  \code
+  {q[0],q[1],q[2]} = sin(alpha/2) * {axis[0],axis[1],axis[2]}
+  q[3] = cos(alpha/2)
+  \endcode
+
+  Note that certain implementations place the cosine term in first position (instead of last here).
+
+  The Quaternion is always normalized, so that its inverse() is actually its conjugate.
+
+  See also the Vec and Frame classes' documentations.
+  \nosubgrouping */
+class QGLVIEWER_EXPORT Quaternion
+{
+public:
+  /*! @name Defining a Quaternion */
+  //@{
+  /*! Default constructor, builds an identity rotation. */
+  Quaternion()
+  { q[0]=q[1]=q[2]=0.0;  q[3]=1.0; }
+
+  /*! Constructor from rotation axis (non null) and angle (in radians). See also setAxisAngle(). */
+  Quaternion(const Vec&amp; axis, double angle)
+  {
+    setAxisAngle(axis, angle);
+  }
+
+  Quaternion(const Vec&amp; from, const Vec&amp; to);
+
+  /*! Constructor from the four values of a Quaternion. First three values are axis*sin(angle/2) and
+    last one is cos(angle/2).
+
+  \attention The identity Quaternion is Quaternion(0,0,0,1) and \e not Quaternion(0,0,0,0) (which is
+  not unitary). The default Quaternion() creates such identity Quaternion. */
+  Quaternion(double q0, double q1, double q2, double q3)
+  { q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
+
+  /*! Copy constructor. */
+  Quaternion(const Quaternion&amp; Q)
+  { for (int i=0; i&lt;4; ++i) q[i] = Q.q[i]; }
+
+  /*! Equal operator. */
+  Quaternion&amp; operator=(const Quaternion&amp; Q)
+  {
+    for (int i=0; i&lt;4; ++i)
+      q[i] = Q.q[i];
+    return (*this);
+  }
+
+  /*! Sets the Quaternion as a rotation of axis \p axis and angle \p angle (in radians).
+
+  \p axis does not need to be normalized. A null \p axis will result in an identity Quaternion. */
+  void setAxisAngle(const Vec&amp; axis, double angle)
+  {
+    const double norm = axis.norm();
+    if (norm &lt; 1E-8)
+      {
+	// Null rotation
+	q[0] = 0.0;      q[1] = 0.0;      q[2] = 0.0;      q[3] = 1.0;
+      }
+    else
+      {
+	const double sin_half_angle = sin(angle / 2.0);
+	q[0] = sin_half_angle*axis[0]/norm;
+	q[1] = sin_half_angle*axis[1]/norm;
+	q[2] = sin_half_angle*axis[2]/norm;
+	q[3] = cos(angle / 2.0);
+      }
+  }
+
+  /*! Sets the Quaternion value. See the Quaternion(double, double, double, double) constructor documentation. */
+  void setValue(double q0, double q1, double q2, double q3)
+  { q[0]=q0;    q[1]=q1;    q[2]=q2;    q[3]=q3; }
+
+#ifndef DOXYGEN
+  void setFromRotationMatrix(const float m[3][3]);
+  void setFromRotatedBase(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
+#endif
+  void setFromRotationMatrix(const double m[3][3]);
+  void setFromRotatedBasis(const Vec&amp; X, const Vec&amp; Y, const Vec&amp; Z);
+  //@}
+
+
+  /*! @name Accessing values */
+  //@{
+  Vec axis() const;
+  float angle() const;
+  void getAxisAngle(Vec&amp; axis, float&amp; angle) const;
+
+  /*! Bracket operator, with a constant return value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
+  double operator[](int i) const { return q[i]; }
+
+  /*! Bracket operator returning an l-value. \p i must range in [0..3]. See the Quaternion(double, double, double, double) documentation. */
+  double&amp; operator[](int i) { return q[i]; }
+  //@}
+
+
+  /*! @name Rotation computations */
+  //@{
+  /*! Returns the composition of the \p a and \p b rotations.
+
+  The order is important. When applied to a Vec \c v (see operator*(const Quaternion&amp;, const Vec&amp;)
+  and rotate()) the resulting Quaternion acts as if \p b was applied first and then \p a was
+  applied. This is obvious since the image \c v' of \p v by the composited rotation satisfies: \code
+  v'= (a*b) * v = a * (b*v) \endcode
+
+  Note that a*b usually differs from b*a.
+
+  \attention For efficiency reasons, the resulting Quaternion is not normalized. Use normalize() in
+  case of numerical drift with small rotation composition. */
+  friend Quaternion operator*(const Quaternion&amp; a, const Quaternion&amp; b)
+  {
+    return Quaternion(a.q[3]*b.q[0] + b.q[3]*a.q[0] + a.q[1]*b.q[2] - a.q[2]*b.q[1],
+		      a.q[3]*b.q[1] + b.q[3]*a.q[1] + a.q[2]*b.q[0] - a.q[0]*b.q[2],
+		      a.q[3]*b.q[2] + b.q[3]*a.q[2] + a.q[0]*b.q[1] - a.q[1]*b.q[0],
+		      a.q[3]*b.q[3] - b.q[0]*a.q[0] - a.q[1]*b.q[1] - a.q[2]*b.q[2]);
+  }
+
+  /*! Quaternion rotation is composed with \p q.
+
+  See operator*(), since this is equivalent to \c this = \c this * \p q.
+
+  \note For efficiency reasons, the resulting Quaternion is not normalized.
+  You may normalize() it after each application in case of numerical drift. */
+  Quaternion&amp; operator*=(const Quaternion &amp;q)
+  {
+    *this = (*this)*q;
+    return *this;
+  }
+
+  /*! Returns the image of \p v by the rotation \p q.
+
+  Same as q.rotate(v). See rotate() and inverseRotate(). */
+  friend Vec operator*(const Quaternion&amp; q, const Vec&amp; v)
+  {
+    return q.rotate(v);
+  }
+
+  Vec rotate(const Vec&amp; v) const;
+  Vec inverseRotate(const Vec&amp; v) const;
+  //@}
+
+
+  /*! @name Inversion */
+  //@{
+  /*! Returns the inverse Quaternion (inverse rotation).
+
+  Result has a negated axis() direction and the same angle(). A composition (see operator*()) of a
+  Quaternion and its inverse() results in an identity function.
+
+  Use invert() to actually modify the Quaternion. */
+  Quaternion inverse() const { return Quaternion(-q[0], -q[1], -q[2], q[3]); }
+
+  /*! Inverses the Quaternion (same rotation angle(), but negated axis()).
+
+  See also inverse(). */
+  void invert() { q[0] = -q[0]; q[1] = -q[1]; q[2] = -q[2]; }
+
+  /*! Negates all the coefficients of the Quaternion.
+
+  This results in an other representation of the \e same rotation (opposite rotation angle, but with
+  a negated axis direction: the two cancel out). However, note that the results of axis() and
+  angle() are unchanged after a call to this method since angle() always returns a value in [0,pi].
+
+  This method is mainly useful for Quaternion interpolation, so that the spherical
+  interpolation takes the shortest path on the unit sphere. See slerp() for details. */
+  void negate() { invert(); q[3] = -q[3]; }
+
+  /*! Normalizes the Quaternion coefficients.
+
+  This method should not need to be called since we only deal with unit Quaternions. This is however
+  useful to prevent numerical drifts, especially with small rotational increments. See also
+  normalized(). */
+  double normalize()
+  {
+    const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
+    for (int i=0; i&lt;4; ++i)
+      q[i] /= norm;
+    return norm;
+  }
+
+  /*! Returns a normalized version of the Quaternion.
+
+  See also normalize(). */
+  Quaternion normalized() const
+  {
+    double Q[4];
+    const double norm = sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
+    for (int i=0; i&lt;4; ++i)
+      Q[i] = q[i] / norm;
+    return Quaternion(Q[0], Q[1], Q[2], Q[3]);
+  }
+//@}
+
+
+  /*! @name Associated matrix */
+  //@{
+  const GLdouble* matrix() const;
+  void getMatrix(GLdouble m[4][4]) const;
+  void getMatrix(GLdouble m[16]) const;
+
+  void getRotationMatrix(float m[3][3]) const;
+
+  const GLdouble* inverseMatrix() const;
+  void getInverseMatrix(GLdouble m[4][4]) const;
+  void getInverseMatrix(GLdouble m[16]) const;
+
+  void getInverseRotationMatrix(float m[3][3]) const;
+  //@}
+
+
+  /*! @name Slerp interpolation */
+  //@{
+  static Quaternion slerp(const Quaternion&amp; a, const Quaternion&amp; b, float t, bool allowFlip=true);
+  static Quaternion squad(const Quaternion&amp; a, const Quaternion&amp; tgA, const Quaternion&amp; tgB, const Quaternion&amp; b, float t);
+  /*! Returns the &quot;dot&quot; product of \p a and \p b: a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]. */
+  static double dot(const Quaternion&amp; a, const Quaternion&amp; b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]; }
+
+  Quaternion log();
+  Quaternion exp();
+  static Quaternion lnDif(const Quaternion&amp; a, const Quaternion&amp; b);
+  static Quaternion squadTangent(const Quaternion&amp; before, const Quaternion&amp; center, const Quaternion&amp; after);
+  //@}
+
+  /*! @name Random Quaternion */
+  //@{
+  static Quaternion randomQuaternion();
+  //@}
+
+  /*! @name XML representation */
+  //@{
+  explicit Quaternion(const QDomElement&amp; element);
+  QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  void initFromDOMElement(const QDomElement&amp; element);
+  //@}
+
+#ifdef DOXYGEN
+  /*! @name Output stream */
+  //@{
+  /*! Output stream operator. Enables debugging code like:
+  \code
+  Quaternion rot(...);
+  cout &lt;&lt; &quot;Rotation=&quot; &lt;&lt; rot &lt;&lt; endl;
+  \endcode */
+  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Vec&amp;);
+  //@}
+#endif
+
+private:
+  /*! The internal data representation is private, use operator[] to access values. */
+  double q[4];
+};
+
+} // namespace
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Quaternion&amp;);
+
+#endif // QGLVIEWER_QUATERNION_H

Added: trunk/lib/QGLViewer/saveSnapshot.cpp
===================================================================
--- trunk/lib/QGLViewer/saveSnapshot.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/saveSnapshot.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,801 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;qglviewer.h&quot;
+
+#ifndef NO_VECTORIAL_RENDER
+# if QT_VERSION &gt;= 0x040000
+#  include &quot;ui_VRenderInterface.Qt4.h&quot;
+# else
+#  include &lt;qcheckbox.h&gt;
+#  include &lt;qcombobox.h&gt;
+#  if QT_VERSION &gt;= 0x030000
+#   include &quot;VRenderInterface.Qt3.h&quot;
+#  else
+#   include &quot;VRenderInterface.Qt2.h&quot;
+#  endif
+# endif
+# include &quot;VRender/VRender.h&quot;
+#endif
+
+#if QT_VERSION &gt;= 0x040000
+# include &quot;ui_ImageInterface.Qt4.h&quot;
+#else
+# include &lt;qspinbox.h&gt;
+# include &lt;qcheckbox.h&gt;
+# if QT_VERSION &gt;= 0x030000
+#  include &quot;ImageInterface.Qt3.h&quot;
+# else
+#  include &quot;ImageInterface.Qt2.h&quot;
+# endif
+#endif
+
+// Output format list
+#if QT_VERSION &lt; 0x040000
+# include &lt;qimage.h&gt;
+#else
+# include &lt;QImageWriter&gt;
+#endif
+
+#include &lt;qfileinfo.h&gt;
+#include &lt;qfiledialog.h&gt;
+#include &lt;qmessagebox.h&gt;
+#include &lt;qapplication.h&gt;
+#include &lt;qmap.h&gt;
+#include &lt;qinputdialog.h&gt;
+#include &lt;qprogressdialog.h&gt;
+#include &lt;qcursor.h&gt;
+
+using namespace std;
+
+////// Static global variables - local to this file //////
+// List of available output file formats, formatted for QFileDialog.
+static QString formats;
+// Converts QFileDialog resulting format to Qt snapshotFormat.
+static QMap&lt;QString, QString&gt; Qtformat;
+// Converts Qt snapshotFormat to QFileDialog menu string.
+static QMap&lt;QString, QString&gt; FDFormatString;
+// Converts snapshotFormat to file extension
+static QMap&lt;QString, QString&gt; extension;
+
+
+/*! Sets snapshotFileName(). */
+void QGLViewer::setSnapshotFileName(const QString&amp; name)
+{
+#if QT_VERSION &gt;= 0x040000
+  snapshotFileName_ = QFileInfo(name).absoluteFilePath();
+#else
+  snapshotFileName_ = QFileInfo(name).absFilePath();
+#endif
+}
+
+#ifndef DOXYGEN
+const QString&amp; QGLViewer::snapshotFilename() const
+{
+  qWarning(&quot;snapshotFilename is deprecated. Use snapshotFileName() (uppercase N) instead.&quot;);
+  return snapshotFileName();
+}
+#endif
+
+
+/*! Opens a dialog that displays the different available snapshot formats.
+
+Then calls setSnapshotFormat() with the selected one (unless the user cancels).
+
+Returns \c false if the user presses the Cancel button and \c true otherwise. */
+bool QGLViewer::openSnapshotFormatDialog()
+{
+  bool ok = false;
+#if QT_VERSION &gt;= 0x040000
+  QStringList list = formats.split(&quot;;;&quot;, QString::SkipEmptyParts);
+  int current = list.indexOf(FDFormatString[snapshotFormat()]);
+  QString format = QInputDialog::getItem(this, &quot;Snapshot format&quot;, &quot;Select a snapshot format&quot;, list, current, false, &amp;ok);
+#else
+  QStringList list = QStringList::split(&quot;;;&quot;, formats);
+  int current = list.findIndex(FDFormatString[snapshotFormat()]);
+  QString format = QInputDialog::getItem(&quot;Snapshot format&quot;, &quot;Select a snapshot format&quot;, list, current, false, &amp;ok, this);
+#endif
+  if (ok)
+    setSnapshotFormat(Qtformat[format]);
+  return ok;
+}
+
+
+// Finds all available Qt output formats, so that they can be available in
+// saveSnapshot dialog. Initialize snapshotFormat() to the first one.
+void QGLViewer::initializeSnapshotFormats()
+{
+#if QT_VERSION &gt;= 0x040000
+  QList&lt;QByteArray&gt; list = QImageWriter::supportedImageFormats();
+  QStringList formatList;
+  for (int i=0; i &lt; list.size(); ++i)
+    formatList &lt;&lt; QString(list.at(i).toUpper());
+#else
+  QStringList formatList = QImage::outputFormatList();
+#endif
+  //        qWarning(&quot;Available image formats: &quot;);
+  //        QStringList::Iterator it = formatList.begin();
+  //        while( it != formatList.end() )
+  //  	      qWarning((*it++).);  QT4 change this. qWarning no longer accepts QString
+
+#ifndef NO_VECTORIAL_RENDER
+  // We add the 3 vectorial formats to the list
+  formatList += &quot;EPS&quot;;
+  formatList += &quot;PS&quot;;
+  formatList += &quot;XFIG&quot;;
+#endif
+
+  // Check that the interesting formats are available and add them in &quot;formats&quot;
+  // Unused formats: XPM XBM PBM PGM
+  QStringList QtText, MenuText, Ext;
+  QtText += &quot;JPEG&quot;;	MenuText += &quot;JPEG (*.jpg)&quot;;		Ext += &quot;jpg&quot;;
+  QtText += &quot;PNG&quot;;	MenuText += &quot;PNG (*.png)&quot;;		Ext += &quot;png&quot;;
+  QtText += &quot;EPS&quot;;	MenuText += &quot;Encapsulated Postscript (*.eps)&quot;;	Ext += &quot;eps&quot;;
+  QtText += &quot;PS&quot;;	MenuText += &quot;Postscript (*.ps)&quot;;	Ext += &quot;ps&quot;;
+  QtText += &quot;PPM&quot;;	MenuText += &quot;24bit RGB Bitmap (*.ppm)&quot;;	Ext += &quot;ppm&quot;;
+  QtText += &quot;BMP&quot;;	MenuText += &quot;Windows Bitmap (*.bmp)&quot;;	Ext += &quot;bmp&quot;;
+  QtText += &quot;XFIG&quot;;	MenuText += &quot;XFig (*.fig)&quot;;		Ext += &quot;fig&quot;;
+
+#if QT_VERSION &lt; 0x030000
+  QStringList::Iterator itText = QtText.begin();
+  QStringList::Iterator itMenu = MenuText.begin();
+  QStringList::Iterator itExt  = Ext.begin();
+#else
+  QStringList::iterator itText = QtText.begin();
+  QStringList::iterator itMenu = MenuText.begin();
+  QStringList::iterator itExt  = Ext.begin();
+#endif
+  while (itText != QtText.end())
+    {
+      //QMessageBox::information(this, &quot;Snapshot &quot;, &quot;Trying format\n&quot;+(*itText));
+      if (formatList.contains((*itText)))
+	{
+	  //QMessageBox::information(this, &quot;Snapshot &quot;, &quot;Recognized format\n&quot;+(*itText));
+	  if (formats.isEmpty())
+	    setSnapshotFormat(*itText);
+	  else
+	    formats += &quot;;;&quot;;
+	  formats += (*itMenu);
+	  Qtformat[(*itMenu)]  = (*itText);
+	  FDFormatString[(*itText)]  = (*itMenu);
+	  extension[(*itText)] = (*itExt);
+	}
+      // Synchronize parsing
+      itText++;
+      itMenu++;
+      itExt++;
+    }
+}
+
+// Returns false if the user refused to use the fileName
+static bool checkFileName(QString&amp; fileName, QWidget* widget, const QString&amp; snapshotFormat)
+{
+  if (fileName.isEmpty())
+    return false;
+
+  // Check that extension has been provided
+  QFileInfo info(fileName);
+
+#if QT_VERSION &gt;= 0x040000
+  if (info.suffix().isEmpty())
+#else
+  if (info.extension(false).isEmpty())
+#endif
+    {
+      // No extension given. Silently add one
+      if (fileName.right(1) != &quot;.&quot;)
+	fileName += &quot;.&quot;;
+      fileName += extension[snapshotFormat];
+      info.setFile(fileName);
+    }
+#if QT_VERSION &gt;= 0x040000
+  else if (info.suffix() != extension[snapshotFormat])
+#else
+  else if (info.extension(false) != extension[snapshotFormat])
+#endif
+    {
+      // Extension is not appropriate. Propose a modification
+#if QT_VERSION &gt;= 0x040000
+      QString modifiedName = info.absolutePath() + '/' + info.baseName() + &quot;.&quot; + extension[snapshotFormat];
+#else
+# if QT_VERSION &gt;= 0x030000
+      QString modifiedName = info.dirPath() + '/' + info.baseName(true) + '.' + extension[snapshotFormat];
+# else
+      QString modifiedName = info.dirPath() + '/' + info.baseName() + '.' + extension[snapshotFormat];
+# endif
+#endif
+      QFileInfo modifInfo(modifiedName);
+      int i=(QMessageBox::warning(widget,&quot;Wrong extension&quot;,
+				  info.fileName()+&quot; has a wrong extension.\nSave as &quot;+modifInfo.fileName()+&quot; instead ?&quot;,
+				  QMessageBox::Yes,
+				  QMessageBox::No,
+				  QMessageBox::Cancel));
+      if (i==QMessageBox::Cancel)
+	return false;
+
+      if (i==QMessageBox::Yes)
+	{
+	  fileName = modifiedName;
+	  info.setFile(fileName);
+	}
+    }
+
+  return true;
+}
+
+#ifndef NO_VECTORIAL_RENDER
+// static void drawVectorial(void* param)
+void drawVectorial(void* param)
+{
+  ( (QGLViewer*) param )-&gt;drawVectorial();
+}
+
+#ifndef DOXYGEN
+class ProgressDialog
+{
+public:
+  static void showProgressDialog(QGLWidget* parent);
+  static void updateProgress(float progress, const std::string&amp; stepString);
+  static void hideProgressDialog();
+
+private:
+  static QProgressDialog* progressDialog;
+};
+
+QProgressDialog* ProgressDialog::progressDialog = NULL;
+
+void ProgressDialog::showProgressDialog(QGLWidget* parent)
+{
+  progressDialog = new QProgressDialog(parent);
+#if QT_VERSION &gt;= 0x040000
+  progressDialog-&gt;setWindowTitle(&quot;Image rendering progress&quot;);
+#else
+  progressDialog-&gt;setCaption(&quot;Image rendering progress&quot;);
+#endif
+  progressDialog-&gt;setMinimumSize(300, 40);
+  progressDialog-&gt;setCancelButton(NULL);
+  progressDialog-&gt;show();
+}
+
+void ProgressDialog::updateProgress(float progress, const std::string&amp; stepString)
+{
+#if QT_VERSION &gt;= 0x040000
+  progressDialog-&gt;setValue(int(progress*100));
+#else
+  progressDialog-&gt;setProgress(int(progress*100));
+#endif
+  QString message(stepString.c_str());
+  if (message.length() &gt; 33)
+    message = message.left(17) + &quot;...&quot; + message.right(12);
+  progressDialog-&gt;setLabelText(message);
+  progressDialog-&gt;update();
+  qApp-&gt;processEvents();
+}
+
+void ProgressDialog::hideProgressDialog()
+{
+  progressDialog-&gt;close();
+  delete progressDialog;
+  progressDialog = NULL;
+}
+
+#if QT_VERSION &gt;= 0x040000
+class VRenderInterface: public QDialog, public Ui::VRenderInterface
+{
+ public: VRenderInterface(QWidget *parent) : QDialog(parent) { setupUi(this); }
+};
+#endif
+
+#endif
+
+// Pops-up a vectorial output option dialog box and save to fileName
+// Returns -1 in case of Cancel, 0 for success and (todo) error code in case of problem.
+static int saveVectorialSnapshot(const QString&amp; fileName, QGLWidget* widget, const QString&amp; snapshotFormat)
+{
+  static VRenderInterface* VRinterface = NULL;
+
+  if (!VRinterface)
+#if QT_VERSION &gt;= 0x030000
+    VRinterface = new VRenderInterface(widget);
+#else
+    VRinterface = new VRenderInterface(widget, &quot;&quot;, true); // Make the dialog modal
+#endif
+
+  
+  // Configure interface according to selected snapshotFormat
+  if (snapshotFormat == &quot;XFIG&quot;)
+    {
+      VRinterface-&gt;tightenBBox-&gt;setEnabled(false);
+      VRinterface-&gt;colorBackground-&gt;setEnabled(false);
+    }
+  else
+    {
+      VRinterface-&gt;tightenBBox-&gt;setEnabled(true);
+      VRinterface-&gt;colorBackground-&gt;setEnabled(true);
+    }
+
+  if (VRinterface-&gt;exec() == QDialog::Rejected)
+    return -1;
+
+  vrender::VRenderParams vparams;
+#if QT_VERSION &gt;= 0x040000
+  vparams.setFilename(fileName.toLatin1().constData());
+#else
+  vparams.setFilename(fileName);
+#endif
+
+  if (snapshotFormat == &quot;EPS&quot;)	vparams.setFormat(vrender::VRenderParams::EPS);
+  if (snapshotFormat == &quot;PS&quot;)	vparams.setFormat(vrender::VRenderParams::PS);
+  if (snapshotFormat == &quot;XFIG&quot;)	vparams.setFormat(vrender::VRenderParams::XFIG);
+
+  vparams.setOption(vrender::VRenderParams::CullHiddenFaces, !(VRinterface-&gt;includeHidden-&gt;isChecked()));
+  vparams.setOption(vrender::VRenderParams::OptimizeBackFaceCulling, VRinterface-&gt;cullBackFaces-&gt;isChecked());
+  vparams.setOption(vrender::VRenderParams::RenderBlackAndWhite, VRinterface-&gt;blackAndWhite-&gt;isChecked());
+  vparams.setOption(vrender::VRenderParams::AddBackground, VRinterface-&gt;colorBackground-&gt;isChecked());
+  vparams.setOption(vrender::VRenderParams::TightenBoundingBox, VRinterface-&gt;tightenBBox-&gt;isChecked());
+
+#if QT_VERSION &gt;= 0x040000
+  switch (VRinterface-&gt;sortMethod-&gt;currentIndex())
+#else
+  switch (VRinterface-&gt;sortMethod-&gt;currentItem())
+#endif
+    {
+    case 0: vparams.setSortMethod(vrender::VRenderParams::NoSorting); 		break;
+    case 1: vparams.setSortMethod(vrender::VRenderParams::BSPSort); 		break;
+    case 2: vparams.setSortMethod(vrender::VRenderParams::TopologicalSort); 	break;
+    case 3: vparams.setSortMethod(vrender::VRenderParams::AdvancedTopologicalSort);	break;
+    default:
+      qWarning(&quot;VRenderInterface::saveVectorialSnapshot: Unknown SortMethod&quot;);
+    }
+
+  vparams.setProgressFunction(&amp;ProgressDialog::updateProgress);
+  ProgressDialog::showProgressDialog(widget);
+  widget-&gt;makeCurrent();
+  widget-&gt;raise();
+  vrender::VectorialRender(drawVectorial, (void*) widget, vparams);
+  ProgressDialog::hideProgressDialog();
+#if QT_VERSION &lt; 0x030000
+  widget-&gt;setCursor(Qt::arrowCursor);
+#else
+  widget-&gt;setCursor(QCursor(Qt::ArrowCursor));
+#endif
+
+  // Should return vparams.error(), but this is currently not set.
+  return 0;
+}
+#endif // NO_VECTORIAL_RENDER
+
+
+#if QT_VERSION &gt;= 0x040000
+class ImageInterface: public QDialog, public Ui::ImageInterface
+{
+ public: ImageInterface(QWidget *parent) : QDialog(parent) { setupUi(this); }
+};
+#endif
+
+
+// Pops-up an image settings dialog box and save to fileName.
+// Returns false in case of problem.
+bool QGLViewer::saveImageSnapshot(const QString&amp; fileName)
+{
+  static ImageInterface* imageInterface = NULL;
+
+  if (!imageInterface)
+#if QT_VERSION &gt;= 0x030000
+    imageInterface = new ImageInterface(this);
+#else
+    imageInterface = new ImageInterface(this, &quot;&quot;, true);  // Make the dialog modal
+#endif
+
+  // 1 means never set
+  //if (imageInterface-&gt;imgWidth-&gt;value() == 1)
+  imageInterface-&gt;imgWidth-&gt;setValue(width());
+  //if (imageInterface-&gt;imgHeight-&gt;value() == 1)
+  imageInterface-&gt;imgHeight-&gt;setValue(height());
+  imageInterface-&gt;imgQuality-&gt;setValue(snapshotQuality());
+
+  if (imageInterface-&gt;exec() == QDialog::Rejected)
+    return true;
+
+  // Hide Closed dialog
+  qApp-&gt;processEvents();
+  
+  setSnapshotQuality(imageInterface-&gt;imgQuality-&gt;value());
+  
+  QColor previousBGColor = backgroundColor();
+  if (imageInterface-&gt;whiteBackground-&gt;isChecked())
+    setBackgroundColor(Qt::white);
+
+  QSize finalSize(imageInterface-&gt;imgWidth-&gt;value(), imageInterface-&gt;imgHeight-&gt;value());
+
+  double oversampling = imageInterface-&gt;oversampling-&gt;value();
+  QSize subSize(int(this-&gt;width()/oversampling), int(this-&gt;height()/oversampling));
+
+  double aspectRatio = width() / static_cast&lt;double&gt;(height());
+  double newAspectRatio = finalSize.width() / static_cast&lt;double&gt;(finalSize.height());
+
+  double zNear = camera()-&gt;zNear();
+  double zFar = camera()-&gt;zFar();
+
+  double xMin, yMin;
+  bool expand = imageInterface-&gt;expandFrustum-&gt;isChecked();
+  if (camera()-&gt;type() == qglviewer::Camera::PERSPECTIVE)
+    if ((expand &amp;&amp; (newAspectRatio&gt;aspectRatio)) || (!expand &amp;&amp; (newAspectRatio&lt;aspectRatio)))
+      {
+	yMin = zNear * tan(camera()-&gt;fieldOfView() / 2.0);
+	xMin = newAspectRatio * yMin;
+      }
+    else
+      {
+	xMin = zNear * tan(camera()-&gt;fieldOfView() / 2.0) * aspectRatio;
+	yMin = xMin / newAspectRatio;
+      }
+  else
+    {
+      camera()-&gt;getOrthoWidthHeight(xMin, yMin);
+      if ((expand &amp;&amp; (newAspectRatio&gt;aspectRatio)) || (!expand &amp;&amp; (newAspectRatio&lt;aspectRatio)))
+	xMin = newAspectRatio * yMin;
+      else
+	yMin = xMin / newAspectRatio;
+    }
+  
+#if QT_VERSION &gt;= 0x040000
+  QImage image(finalSize.width(), finalSize.height(), QImage::Format_ARGB32);
+#else
+  QImage image(finalSize.width(), finalSize.height(), 32);
+#endif
+
+  if (image.isNull())
+    {
+      QMessageBox::warning(this, &quot;Image saving error&quot;,
+			   &quot;Unable to create resulting image&quot;,
+			   QMessageBox::Ok, QMessageBox::NoButton);
+      return false;
+    }
+
+  // ProgressDialog::showProgressDialog(this);
+
+  double deltaX = 2.0 * xMin * subSize.width() / finalSize.width();
+  double deltaY = 2.0 * yMin * subSize.height() / finalSize.height();
+
+  int nbX = finalSize.width() / subSize.width();
+  int nbY = finalSize.height() / subSize.height();
+
+  // Extra subimage on the border if needed
+  if (nbX * subSize.width() &lt; finalSize.width())
+    nbX++;
+  if (nbY * subSize.height() &lt; finalSize.height())
+    nbY++;
+
+  makeCurrent();
+
+  int count=0;
+  for (int i=0; i&lt;nbX; i++)
+    for (int j=0; j&lt;nbY; j++)
+      {
+	preDraw();
+	// Change projection matrix
+	glMatrixMode(GL_PROJECTION);
+	glLoadIdentity();
+	if (camera()-&gt;type() == qglviewer::Camera::PERSPECTIVE)
+	  glFrustum(-xMin + i*deltaX, -xMin + (i+1)*deltaX, yMin - (j+1)*deltaY, yMin - j*deltaY, zNear, zFar);
+	else
+	  glOrtho(-xMin + i*deltaX, -xMin + (i+1)*deltaX, yMin - (j+1)*deltaY, yMin - j*deltaY, zNear, zFar);
+	glMatrixMode(GL_MODELVIEW);
+	  
+	draw();
+	postDraw();
+
+	// ProgressDialog::hideProgressDialog();
+	// qApp-&gt;processEvents();
+
+	QImage snapshot = grabFrameBuffer(true);
+
+	// ProgressDialog::showProgressDialog(this);
+	// ProgressDialog::updateProgress(count / (float)(nbX*nbY),
+	// &quot;Generating image [&quot;+QString::number(count)+&quot;/&quot;+QString::number(nbX*nbY)+&quot;]&quot;);
+	// qApp-&gt;processEvents();
+
+#if QT_VERSION &gt;= 0x040000
+	QImage subImage = snapshot.scaled(subSize, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+#else
+# if QT_VERSION &gt;= 0x030000
+	QImage subImage = snapshot.scale(subSize, QImage::ScaleFree);
+# else
+	QImage subImage = snapshot.smoothScale(subSize.width(), subSize.height());
+# endif
+#endif
+
+	// Copy subImage in image
+	for (int ii=0; ii&lt;subSize.width(); ii++)
+	  {
+	    int fi = i*subSize.width() + ii;
+	    if (fi == image.width())
+	      break;
+	    for (int jj=0; jj&lt;subSize.height(); jj++)
+	      {
+		int fj = j*subSize.height() + jj;
+		if (fj == image.height())
+		  break;
+		image.setPixel(fi, fj, subImage.pixel(ii,jj));
+	      }
+	  }
+	count++;
+      }
+  
+#if QT_VERSION &gt;= 0x040000
+  bool saveOK = image.save(fileName, snapshotFormat().toLatin1().constData(), snapshotQuality());
+#else
+  bool saveOK = image.save(fileName, snapshotFormat(), snapshotQuality());
+#endif
+
+  // ProgressDialog::hideProgressDialog();
+
+  // #if QT_VERSION &lt; 0x030000
+  // setCursor(Qt::arrowCursor);
+  // #else
+  // setCursor(QCursor(Qt::ArrowCursor));
+  // #endif
+
+  if (imageInterface-&gt;whiteBackground-&gt;isChecked())
+    setBackgroundColor(previousBGColor);
+
+  return saveOK;
+}
+
+
+/*! Saves a snapshot of the current image displayed by the widget.
+
+ Options are set using snapshotFormat(), snapshotFileName() and snapshotQuality(). For non vectorial
+ image formats, the image size is equal to the current viewer's dimensions (see width() and
+ height()). See snapshotFormat() for details on supported formats.
+
+ If \p automatic is \c false (or if snapshotFileName() is empty), a file dialog is opened to ask for
+ the file name.
+
+ When \p automatic is \c true, the file name is set to \c NAME-NUMBER, where \c NAME is
+ snapshotFileName() and \c NUMBER is snapshotCounter(). The snapshotCounter() is automatically
+ incremented after each snapshot saving. This is useful to create videos from your application:
+ \code
+ void Viewer::init()
+ {
+   resize(720, 576); // PAL DV format (use 720x480 for NTSC DV)
+   connect(this, SIGNAL(drawFinished(bool)), SLOT(saveSnapshot(bool)));
+ }
+ \endcode
+ Then call draw() in a loop (for instance using animate() and/or a camera() KeyFrameInterpolator
+ replay) to create your image sequence.
+
+ If you want to create a Quicktime VR panoramic sequence, simply use code like this:
+ \code
+ void Viewer::createQuicktime()
+ {
+   const int nbImages = 36;
+   for (int i=0; i&lt;nbImages; ++i)
+     {
+       camera()-&gt;setOrientation(2.0*M_PI/nbImages, 0.0); // Theta-Phi orientation
+       showEntireScene();
+       updateGL(); // calls draw(), which emits drawFinished(), which calls saveSnapshot()
+     }
+ }
+ \endcode
+
+ If snapshotCounter() is negative, no number is appended to snapshotFileName() and the
+ snapshotCounter() is not incremented. This is useful to force the creation of a file, overwriting
+ the previous one.
+
+ When \p overwrite is set to \c false (default), a window asks for confirmation if the file already
+ exists. In \p automatic mode, the snapshotCounter() is incremented (if positive) until a
+ non-existing file name is found instead. Otherwise the file is overwritten without confirmation.
+
+ The VRender library was written by Cyril Soler (Cyril dot Soler at imag dot fr). If the generated
+ PS or EPS file is not properly displayed, remove the anti-aliasing option in your postscript viewer.
+
+ \note In order to correctly grab the frame buffer, the QGLViewer window is raised in front of
+ other windows by this method. */
+void QGLViewer::saveSnapshot(bool automatic, bool overwrite)
+{
+  // Ask for file name
+  if (snapshotFileName().isEmpty() || !automatic)
+    {
+      QString fileName;
+#if QT_VERSION &lt; 0x030000
+      if (openSnapshotFormatDialog())
+        fileName = QFileDialog::getSaveFileName(snapshotFileName(), FDFormatString[snapshotFormat()]+&quot;;;All files (*.*)&quot;, this, &quot;Save dialog&quot;);
+      else
+        return;
+#else
+      QString selectedFormat = FDFormatString[snapshotFormat()];
+# if QT_VERSION &gt;= 0x040000
+      fileName = QFileDialog::getSaveFileName(this, &quot;Choose a file name to save under&quot;, snapshotFileName(), formats, &amp;selectedFormat,
+					      overwrite?QFileDialog::DontConfirmOverwrite:QFlag(0));
+# else
+      fileName = QFileDialog::getSaveFileName(snapshotFileName(), formats, this,
+					      &quot;Save Snapshot dialog&quot;, &quot;Choose a file name to save under&quot;, &amp;selectedFormat);
+# endif
+      setSnapshotFormat(Qtformat[selectedFormat]);
+#endif
+
+      if (checkFileName(fileName, this, snapshotFormat()))
+	setSnapshotFileName(fileName);
+      else
+	return;
+    }
+
+  QFileInfo fileInfo(snapshotFileName());
+
+  if ((automatic) &amp;&amp; (snapshotCounter() &gt;= 0))
+    {
+      // In automatic mode, names have a number appended
+      const QString baseName = fileInfo.baseName();
+      QString count;
+      count.sprintf(&quot;%.04d&quot;, snapshotCounter_++);
+      QString suffix;
+#if QT_VERSION &gt;= 0x040000
+      suffix = fileInfo.suffix();
+      if (suffix.isEmpty())
+	suffix = extension[snapshotFormat()];
+      fileInfo.setFile(fileInfo.absolutePath()+ '/' + baseName + '-' + count + '.' + suffix);
+#else      
+      suffix = fileInfo.extension();
+      if (suffix.isEmpty())
+	suffix = extension[snapshotFormat()];
+      fileInfo.setFile(fileInfo.dirPath()+ '/' + baseName + '-' + count + '.' + suffix);
+#endif
+
+      if (!overwrite)
+	while (fileInfo.exists())
+	  {
+	    count.sprintf(&quot;%.04d&quot;, snapshotCounter_++);
+#if QT_VERSION &gt;= 0x040000
+	    fileInfo.setFile(fileInfo.absolutePath() + '/' +baseName + '-' + count + '.' + fileInfo.suffix());
+#else
+	    fileInfo.setFile(fileInfo.dirPath() + '/' + baseName + '-' + count + '.' + fileInfo.extension());
+#endif
+	  }
+    }
+
+#if QT_VERSION &lt; 0x040000
+  if ((fileInfo.exists()) &amp;&amp; (!overwrite) &amp;&amp;
+      (QMessageBox::warning(this,&quot;Overwrite file ?&quot;,
+			    &quot;File &quot;+fileInfo.fileName()+&quot; already exists.\nOverwrite ?&quot;,
+			    QMessageBox::Yes,
+			    QMessageBox::Cancel) == QMessageBox::Cancel))
+      return;
+#endif
+  
+  bool saveOK;
+#ifndef NO_VECTORIAL_RENDER
+  if ( (snapshotFormat() == &quot;EPS&quot;) || (snapshotFormat() == &quot;PS&quot;) || (snapshotFormat() == &quot;XFIG&quot;) )
+      // Vectorial snapshot. -1 means cancel, 0 is ok, &gt;0 (should be) an error
+      saveOK = (saveVectorialSnapshot(fileInfo.filePath(), this, snapshotFormat()) &lt;= 0);
+  else
+#endif
+    if (automatic)
+	{
+      // Viewer must be on top of other windows.
+      makeCurrent();
+      raise();
+      // Hack: Qt has problems if the frame buffer is grabbed after QFileDialog is displayed.
+      // We grab the frame buffer before, even if it might be not necessary (vectorial rendering).
+      // The problem could not be reproduced on a simple example to submit a Qt bug.
+      // However, only grabs the backgroundImage in the eponym example. May come from the driver.
+      QImage snapshot = grabFrameBuffer(true);
+#if QT_VERSION &gt;= 0x040000
+    saveOK = snapshot.save(fileInfo.filePath(), snapshotFormat().toLatin1().constData(), snapshotQuality());
+#else
+    saveOK = snapshot.save(fileInfo.filePath(), snapshotFormat(), snapshotQuality());
+#endif
+	}
+	else
+	  saveOK = saveImageSnapshot(fileInfo.filePath());
+
+  if (!saveOK)
+    QMessageBox::warning(this, &quot;Snapshot problem&quot;, &quot;Unable to save snapshot in\n&quot;+fileInfo.filePath());
+}
+
+/*! Same as saveSnapshot(), except that it uses \p fileName instead of snapshotFileName().
+
+ If \p fileName is empty, opens a file dialog to select the name.
+
+ Snapshot settings are set from snapshotFormat() and snapshotQuality().
+
+ Asks for confirmation when \p fileName already exists and \p overwrite is \c false (default).
+
+ \attention If \p fileName is a char* (as is &quot;myFile.jpg&quot;), it may be casted into a \c bool, and the
+ other saveSnapshot() method may be used instead. Pass QString(&quot;myFile.jpg&quot;) as a parameter to
+ prevent this. */
+void QGLViewer::saveSnapshot(const QString&amp; fileName, bool overwrite)
+{
+  const QString previousName = snapshotFileName();
+  const int previousCounter = snapshotCounter();
+  setSnapshotFileName(fileName);
+  setSnapshotCounter(-1);
+  saveSnapshot(true, overwrite);
+  setSnapshotFileName(previousName);
+  setSnapshotCounter(previousCounter);
+}
+
+
+#if QT_VERSION &lt; 0x030000
+// This code is largely inspired from Qt's method available in version 3
+// Copyright Trolltech AS
+QImage QGLViewer::grabFrameBuffer(bool withAlpha)
+{
+  makeCurrent();
+  QImage res;
+  int w = width();
+  int h = height();
+  if (format().rgba())
+  {
+	res = QImage(w, h, 32);
+	glReadPixels(0, 0, w, h, GL_RGBA, GL_UNSIGNED_BYTE, res.bits());
+	if (QImage::systemByteOrder() == QImage::BigEndian)
+	{
+	  // OpenGL gives RGBA; Qt wants ARGB
+	  uint *p = (uint*)res.bits();
+	  uint *end = p + w*h;
+	  if (withAlpha &amp;&amp; format().alpha())
+	  {
+		while (p &lt; end)
+		{
+		  uint a = *p &lt;&lt; 24;
+		  *p = (*p &gt;&gt; 8) | a;
+		  p++;
+		}
+	  }
+	  else
+	  {
+		while (p &lt; end)
+		  *p++ &gt;&gt;= 8;
+	  }
+	}
+	else
+	{
+	  // OpenGL gives ABGR (i.e. RGBA backwards); Qt wants ARGB
+	  res = res.swapRGB();
+	}
+	res.setAlphaBuffer(withAlpha &amp;&amp; format().alpha());
+  }
+  else
+  {
+#if defined (Q_WS_WIN)
+	res = QImage(w, h, 8);
+	glReadPixels(0, 0, w, h, GL_COLOR_INDEX, GL_UNSIGNED_BYTE, res.bits());
+	//int palSize = 0;
+	//const QRgb* pal = QColor::palette(&amp;palSize);
+	//if (pal &amp;&amp; palSize)
+	//{
+	//  res.setNumColors(palSize);
+	//  for (int i = 0; i &lt; palSize; i++)
+	//	res.setColor(i, pal[i]);
+	//}
+#endif
+  }
+
+  return res.mirror();
+}
+
+#endif // QT_VERSION &lt; 0x030000

Added: trunk/lib/QGLViewer/vec.cpp
===================================================================
--- trunk/lib/QGLViewer/vec.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/vec.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,171 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#include &quot;domUtils.h&quot;
+#include &quot;vec.h&quot;
+
+// Most of the methods are declared inline in vec.h
+
+using namespace qglviewer;
+using namespace std;
+
+/*! Projects the Vec on the axis of direction \p direction that passes through the origin.
+
+\p direction does not need to be normalized (but must be non null). */
+void Vec::projectOnAxis(const Vec&amp; direction)
+{
+#ifndef QT_NO_DEBUG
+  if (direction.squaredNorm() &lt; 1.0E-10)
+    qWarning(&quot;Vec::projectOnAxis: axis direction is not normalized (norm=%f).&quot;, direction.norm());
+#endif
+
+  *this = (((*this)*direction) / direction.squaredNorm()) * direction;
+}
+
+/*! Projects the Vec on the plane whose normal is \p normal that passes through the origin.
+
+\p normal does not need to be normalized (but must be non null). */
+void Vec::projectOnPlane(const Vec&amp; normal)
+{
+#ifndef QT_NO_DEBUG
+  if (normal.squaredNorm() &lt; 1.0E-10)
+    qWarning(&quot;Vec::projectOnPlane: plane normal is not normalized (norm=%f).&quot;, normal.norm());
+#endif
+
+  *this -= (((*this)*normal) / normal.squaredNorm()) * normal;
+}
+
+/*! Returns a Vec orthogonal to the Vec. Its norm() depends on the Vec, but is zero only for a
+ null Vec. Note that the function that associates an orthogonalVec() to a Vec is not continous. */
+Vec Vec::orthogonalVec() const
+{
+  // Find smallest component. Keep equal case for null values.
+  if ((fabs(y) &gt;= 0.9*fabs(x)) &amp;&amp; (fabs(z) &gt;= 0.9*fabs(x)))
+    return Vec(0.0, -z, y);
+  else
+    if ((fabs(x) &gt;= 0.9*fabs(y)) &amp;&amp; (fabs(z) &gt;= 0.9*fabs(y)))
+      return Vec(-z, 0.0, x);
+    else
+      return Vec(-y, x, 0.0);
+}
+
+/*! Constructs a Vec from a \c QDomElement representing an XML code of the form
+ \c &lt;anyTagName x=&quot;..&quot; y=&quot;..&quot; z=&quot;..&quot; /&gt;.
+
+If one of these attributes is missing or is not a number, a warning is displayed and the associated
+value is set to 0.0.
+
+See also domElement() and initFromDOMElement(). */
+Vec::Vec(const QDomElement&amp; element)
+{
+  QStringList attribute;
+  attribute &lt;&lt; &quot;x&quot; &lt;&lt; &quot;y&quot; &lt;&lt; &quot;z&quot;;
+#if QT_VERSION &gt;= 0x040000
+  for (int i=0; i&lt;attribute.size(); ++i)
+#else
+  for (unsigned int i=0; i&lt;attribute.count(); ++i)
+#endif
+#ifdef QGLVIEWER_UNION_NOT_SUPPORTED
+    this-&gt;operator[](i) = DomUtils::floatFromDom(element, attribute[i], 0.0);
+#else
+    v_[i] = DomUtils::floatFromDom(element, attribute[i], 0.0);
+#endif
+}
+
+/*! Returns an XML \c QDomElement that represents the Vec.
+
+ \p name is the name of the QDomElement tag. \p doc is the \c QDomDocument factory used to create
+ QDomElement.
+
+ When output to a file, the resulting QDomElement will look like:
+ \code
+ &lt;name x=&quot;..&quot; y=&quot;..&quot; z=&quot;..&quot; /&gt;
+ \endcode
+
+ Use initFromDOMElement() to restore the Vec state from the resulting \c QDomElement. See also the
+ Vec(const QDomElement&amp;) constructor.
+
+ Here is complete example that creates a QDomDocument and saves it into a file:
+ \code
+ Vec sunPos;
+ QDomDocument document(&quot;myDocument&quot;);
+ QDomElement sunElement = document.createElement(&quot;Sun&quot;);
+ document.appendChild(sunElement);
+ sunElement.setAttribute(&quot;brightness&quot;, sunBrightness());
+ sunElement.appendChild(sunPos.domElement(&quot;sunPosition&quot;, document));
+ // Other additions to the document hierarchy...
+
+ // Save doc document
+ QFile f(&quot;myFile.xml&quot;);
+ if (f.open(IO_WriteOnly))
+ {
+   QTextStream out(&amp;f);
+   document.save(out, 2);
+   f.close();
+ }
+ \endcode
+
+ See also Quaternion::domElement(), Frame::domElement(), Camera::domElement()... */
+QDomElement Vec::domElement(const QString&amp; name, QDomDocument&amp; document) const
+{
+  QDomElement de = document.createElement(name);
+  de.setAttribute(&quot;x&quot;, QString::number(x));
+  de.setAttribute(&quot;y&quot;, QString::number(y));
+  de.setAttribute(&quot;z&quot;, QString::number(z));
+  return de;
+}
+
+/*! Restores the Vec state from a \c QDomElement created by domElement().
+
+ The \c QDomElement should contain \c x, \c y and \c z attributes. If one of these attributes is
+ missing or is not a number, a warning is displayed and the associated value is set to 0.0.
+
+ To restore the Vec state from an xml file, use:
+ \code
+ // Load DOM from file
+ QDomDocument doc;
+ QFile f(&quot;myFile.xml&quot;);
+ if (f.open(IO_ReadOnly))
+ {
+   doc.setContent(&amp;f);
+   f.close();
+ }
+ // Parse the DOM tree and initialize
+ QDomElement main=doc.documentElement();
+ myVec.initFromDOMElement(main);
+ \endcode
+
+ See also the Vec(const QDomElement&amp;) constructor. */
+void Vec::initFromDOMElement(const QDomElement&amp; element)
+{
+  const Vec v(element);
+  *this = v;
+}
+
+ostream&amp; operator&lt;&lt;(ostream&amp; o, const Vec&amp; v)
+{
+  return o &lt;&lt; v.x &lt;&lt; '\t' &lt;&lt; v.y &lt;&lt; '\t' &lt;&lt; v.z;
+}
+

Added: trunk/lib/QGLViewer/vec.h
===================================================================
--- trunk/lib/QGLViewer/vec.h	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/QGLViewer/vec.h	2008-03-13 19:14:29 UTC (rev 1274)
@@ -0,0 +1,382 @@
+/****************************************************************************
+
+ Copyright (C) 2002-2007 Gilles Debunne (<A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">Gilles.Debunne at imag.fr</A>)
+
+ This file is part of the QGLViewer library.
+ Version 2.2.6-3, released on August 28, 2007.
+
+ <A HREF="http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer">http://artis.imag.fr/Members/Gilles.Debunne/QGLViewer</A>
+
+ libQGLViewer is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ libQGLViewer is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with libQGLViewer; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+*****************************************************************************/
+
+#ifndef QGLVIEWER_VEC_H
+#define QGLVIEWER_VEC_H
+
+#include &lt;math.h&gt;
+#include &lt;iostream&gt;
+
+#if QT_VERSION &gt;= 0x040000
+# include &lt;QDomElement&gt;
+#else
+# include &lt;qdom.h&gt;
+#endif
+
+// #include &lt;qapplication.h&gt;
+
+// Included by all files as vec.h is at the end of the include hierarchy
+#include &quot;config.h&quot; // Specific configuration options.
+
+namespace qglviewer {
+
+/*! \brief The Vec class represents 3D positions and 3D vectors.
+  \class Vec vec.h QGLViewer/vec.h
+
+  Vec is used as a parameter and return type by many methods of the library. It provides classical
+  algebraic computational methods and is compatible with OpenGL:
+
+  \code
+  // Draws a point located at 3.0 OpenGL units in front of the camera
+  Vec pos = camera()-&gt;position() + 3.0 * camera()-&gt;viewDirection();
+  glBegin(GL_POINTS);
+  glVertex3fv(pos);
+  glEnd();
+  \endcode
+
+  This makes of Vec a good candidate for representing positions and vectors in your programs. Since
+  it is part of the \c qglviewer namespace, specify \c qglviewer::Vec or use the qglviewer
+  namespace:
+  \code
+  using namespace qglviewer;
+  \endcode
+
+  &lt;h3&gt;Interface with other vector classes&lt;/h3&gt;
+
+  Vec implements a universal explicit converter, based on the \c [] \c operator.
+  Everywhere a \c const \c Vec&amp; argument is expected, you can use your own vector type
+  instead, as long as it implements this operator (see the Vec(const C&amp; c) documentation).
+
+  See also the Quaternion and the Frame documentations.
+  \nosubgrouping */
+class QGLVIEWER_EXPORT Vec
+{
+
+  // If your compiler complains the &quot;The class &quot;qglviewer::Vec&quot; has no member &quot;x&quot;.&quot;
+  // Add your architecture Q_OS_XXXX flag (see qglobal.h) in this list.
+#if defined (Q_OS_IRIX) || defined (Q_OS_AIX) || defined (Q_OS_HPUX)
+# define QGLVIEWER_UNION_NOT_SUPPORTED
+#endif
+
+public:
+  /*! The internal data representation is public. One can use v.x, v.y, v.z. See also operator[](). */
+#if defined (DOXYGEN) || defined (QGLVIEWER_UNION_NOT_SUPPORTED)
+  float x, y, z;
+#else
+  union
+  {
+    struct { float x, y, z; };
+    float v_[3];
+  };
+#endif
+
+  /*! @name Setting the value */
+  //@{
+  /*! Default constructor. Value is set to (0,0,0). */
+  Vec() : x(0.0), y(0.0), z(0.0) {}
+
+  /*! Standard constructor with the x, y and z values. */
+  Vec(float X, float Y, float Z) : x(X), y(Y), z(Z) {}
+
+  /*! Universal explicit converter from any class to Vec. You can use your own vector class everywhere
+  a \c const \c Vec&amp; parameter is required, as long as it implements the \c operator[ ]:
+
+  \code
+  class MyVec
+  {
+    // ...
+    float operator[](int i) const { returns x, y or z when i=0, 1 or 2; }
+  }
+
+  MyVec v(...);
+  camera()-&gt;setPosition(v);
+  \endcode
+
+  Note that standard vector types (stl, \c float[3], ...) implement this operator and can hence
+  be used in place of Vec. See also operator const float*() .*/
+  template &lt;class C&gt;
+  explicit Vec(const C&amp; c) : x(c[0]), y(c[1]), z(c[2]) {}
+  // Should NOT be explicit to prevent conflicts with operator&lt;&lt;.
+
+  // ! Copy constructor
+  // Vec(const Vec&amp; v) : x(v.x), y(v.y), z(v.z) {}
+
+  /*! Equal operator. */
+  Vec&amp; operator=(const Vec&amp; v)
+  {
+    x = v.x;   y = v.y;   z = v.z;
+    return *this;
+  }
+
+  /*! Set the current value. Maybe faster than using operator=() with a temporary Vec(x,y,z). */
+  void setValue(float X, float Y, float Z)
+  { x=X; y=Y; z=Z; }
+
+  // Universal equal operator which allows the use of any type in place of Vec,
+  // as long as the [] operator is implemented (v[0]=v.x, v[1]=v.y, v[2]=v.z).
+  // template &lt;class C&gt;
+  // Vec&amp; operator=(const C&amp; c)
+  // {
+  // x=c[0]; y=c[1]; z=c[2];
+  // return *this;
+  // }
+  //@}
+
+  /*! @name Accessing the value */
+  //@{
+  /*! Bracket operator, with a constant return value. \p i must range in [0..2]. */
+  float operator[](int i) const {
+#ifdef QGLVIEWER_UNION_NOT_SUPPORTED
+    return (&amp;x)[i];
+#else
+    return v_[i];
+#endif
+  }
+
+  /*! Bracket operator returning an l-value. \p i must range in [0..2]. */
+  float&amp; operator[](int i) {
+#ifdef QGLVIEWER_UNION_NOT_SUPPORTED
+    return (&amp;x)[i];
+#else
+    return v_[i];
+#endif
+  }
+
+#ifndef DOXYGEN
+  /*! This method is deprecated since version 2.0. Use operator const float* instead. */
+  const float* address() const { qWarning(&quot;Vec::address() is deprecated, use operator const float* instead.&quot;); return operator const float*(); };
+#endif
+
+  /*! Conversion operator returning the memory address of the vector.
+
+  Very convenient to pass a Vec pointer as a parameter to OpenGL functions:
+  \code
+  Vec pos, normal;
+  glNormal3fv(normal);
+  glVertex3fv(pos);
+  \endcode */
+  operator const float*() const {
+#ifdef QGLVIEWER_UNION_NOT_SUPPORTED
+    return &x;
+#else
+    return v_;
+#endif
+  }
+
+  /*! Non const conversion operator returning the memory address of the vector.
+
+  Useful to pass a Vec to a method that requires and fills a \c float*, as provided by certain libraries. */
+  operator float*() {
+#ifdef QGLVIEWER_UNION_NOT_SUPPORTED
+    return &x;
+#else
+    return v_;
+#endif
+  }
+  //@}
+
+  /*! @name Algebraic computations */
+  //@{
+  /*! Returns the sum of the two vectors. */
+  friend Vec operator+(const Vec &amp;a, const Vec &amp;b)
+  {
+    return Vec(a.x+b.x, a.y+b.y, a.z+b.z);
+  }
+
+  /*! Returns the difference of the two vectors. */
+  friend Vec operator-(const Vec &amp;a, const Vec &amp;b)
+  {
+    return Vec(a.x-b.x, a.y-b.y, a.z-b.z);
+  }
+
+  /*! Unary minus operator. */
+  friend Vec operator-(const Vec &amp;a)
+  {
+    return Vec(-a.x, -a.y, -a.z);
+  }
+
+  /*! Returns the product of the vector with a scalar. */
+  friend Vec operator*(const Vec &amp;a, float k)
+  {
+    return Vec(a.x*k, a.y*k, a.z*k);
+  }
+
+  /*! Returns the product of the vector with a scalar. */
+  friend Vec operator*(float k, const Vec &amp;a)
+  {
+    return a*k;
+  }
+
+  /*! Returns the division of the vector with a scalar.
+
+  Too small \p k values are \e not tested (unless the library was compiled with the &quot;debug&quot; Qt \c
+  CONFIG flag) and may result in \c NaN values. */
+  friend Vec operator/(const Vec &amp;a, float k)
+  {
+#ifndef QT_NO_DEBUG
+    if (fabs(k) &lt; 1.0E-10)
+      qWarning(&quot;Vec::operator / : dividing by a null value (%f)&quot;, k);
+#endif
+    return Vec(a.x/k, a.y/k, a.z/k);
+  }
+
+  /*! Returns \c true only when the two vector are not equal (see operator==()). */
+  friend bool operator!=(const Vec &amp;a, const Vec &amp;b)
+  {
+    return !(a==b);
+  }
+
+  /*! Returns \c true when the squaredNorm() of the difference vector is lower than 1E-10. */
+  friend bool operator==(const Vec &amp;a, const Vec &amp;b)
+  {
+    const float epsilon = 1.0E-10f;
+    return (a-b).squaredNorm() &lt; epsilon;
+  }
+
+  /*! Adds \p a to the vector. */
+  Vec&amp; operator+=(const Vec &amp;a)
+  {
+    x += a.x; y += a.y; z += a.z;
+    return *this;
+  }
+
+  /*! Subtracts \p a to the vector. */
+  Vec&amp; operator-=(const Vec &amp;a)
+  {
+    x -= a.x; y -= a.y; z -= a.z;
+    return *this;
+  }
+
+  /*! Multiply the vector by a scalar \p k. */
+  Vec&amp; operator*=(float k)
+  {
+    x *= k; y *= k; z *= k;
+    return *this;
+  }
+
+  /*! Divides the vector by a scalar \p k.
+
+  An absolute \p k value lower than 1E-10 will print a warning if the library was compiled with the
+  &quot;debug&quot; Qt \c CONFIG flag. Otherwise, no test is performed for efficiency reasons. */
+  Vec&amp; operator/=(float k)
+  {
+#ifndef QT_NO_DEBUG
+    if (fabs(k)&lt;1.0E-10)
+      qWarning(&quot;Vec::operator /= : dividing by a null value (%f)&quot;, k);
+#endif
+    x /= k; y /= k; z /= k;
+    return *this;
+  }
+
+  /*! Dot product of the two Vec. */
+  friend float operator*(const Vec &amp;a, const Vec &amp;b)
+  {
+    return a.x*b.x + a.y*b.y + a.z*b.z;
+  }
+
+  /*! Cross product of the two vectors. Same as cross(). */
+  friend Vec operator^(const Vec &amp;a, const Vec &amp;b)
+  {
+    return cross(a,b);
+  }
+
+  /*! Cross product of the two Vec. Mind the order ! */
+  friend Vec cross(const Vec &amp;a, const Vec &amp;b)
+  {
+    return Vec(a.y*b.z - a.z*b.y,
+	       a.z*b.x - a.x*b.z,
+	       a.x*b.y - a.y*b.x);
+  }
+
+  Vec orthogonalVec() const;
+  //@}
+
+  /*! @name Norm of the vector */
+  //@{
+#ifndef DOXYGEN
+  /*! This method is deprecated since version 2.0. Use squaredNorm() instead. */
+  float sqNorm() const { return x*x + y*y + z*z; }
+#endif
+
+  /*! Returns the \e squared norm of the Vec. */
+  float squaredNorm() const { return x*x + y*y + z*z; }
+
+  /*! Returns the norm of the vector. */
+  float norm() const { return sqrt(x*x + y*y + z*z); }
+
+  /*! Normalizes the Vec and returns its original norm.
+
+  Normalizing a null vector will result in \c NaN values. */
+  float normalize()
+  {
+    const float n = norm();
+#ifndef QT_NO_DEBUG
+    if (n &lt; 1.0E-10)
+      qWarning(&quot;Vec::normalize: normalizing a null vector (norm=%f)&quot;, n);
+#endif
+    *this /= n;
+    return n;
+  }
+
+  /*! Returns a unitary (normalized) \e representation of the vector. The original Vec is not modified. */
+  Vec unit() const
+  {
+    Vec v = *this;
+    v.normalize();
+    return v;
+  }
+  //@}
+
+  /*! @name Projection */
+  //@{
+  void projectOnAxis(const Vec&amp; direction);
+  void projectOnPlane(const Vec&amp; normal);
+  //@}
+
+  /*! @name XML representation */
+  //@{
+  explicit Vec(const QDomElement&amp; element);
+  QDomElement domElement(const QString&amp; name, QDomDocument&amp; document) const;
+  void initFromDOMElement(const QDomElement&amp; element);
+  //@}
+
+#ifdef DOXYGEN
+  /*! @name Output stream */
+  //@{
+  /*! Output stream operator. Enables debugging code like:
+  \code
+  Vec pos(...);
+  cout &lt;&lt; &quot;Position=&quot; &lt;&lt; pos &lt;&lt; endl;
+  \endcode */
+  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Vec&amp;);
+  //@}
+#endif
+};
+
+} // namespace
+
+std::ostream&amp; operator&lt;&lt;(std::ostream&amp; o, const qglviewer::Vec&amp;);
+
+#endif // QGLVIEWER_VEC_H

Modified: trunk/lib/SConscript
===================================================================
--- trunk/lib/SConscript	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/lib/SConscript	2008-03-13 19:14:29 UTC (rev 1274)
@@ -4,7 +4,46 @@
 	env.Install('$PREFIX/lib/yade$SUFFIX/lib',[
 		env.SharedLibrary('yade-serialization-qt',
 			['serialization-qt/QtGUIGenerator.cpp'],
-			LIBS=env['LIBS']+['yade-base','XMLFormatManager']),
+			LIBS=env['LIBS']+['yade-base','XMLFormatManager'])])
+	#if env['useLocalQGLViewer']:
+	env.Install('$PREFIX/lib/yade$SUFFIX/lib',[
+			#env.Uic(['QGLViewer/VRenderInterface.Qt3.ui','QGLViewer/ImageInterface.Qt3.ui']),
+			env.SharedLibrary('yade-QGLViewer',Split('''
+				QGLViewer/VRenderInterface.Qt3.cpp
+				QGLViewer/ImageInterface.Qt3.cpp
+				QGLViewer/qglviewer.cpp 
+				QGLViewer/camera.cpp 
+				QGLViewer/manipulatedFrame.cpp 
+				QGLViewer/manipulatedCameraFrame.cpp 
+				QGLViewer/frame.cpp 
+				QGLViewer/saveSnapshot.cpp 
+				QGLViewer/constraint.cpp 
+				QGLViewer/keyFrameInterpolator.cpp 
+				QGLViewer/mouseGrabber.cpp 
+				QGLViewer/quaternion.cpp 
+				QGLViewer/vec.cpp
+				QGLViewer/VRender/BackFaceCullingOptimizer.cpp 
+				QGLViewer/VRender/BSPSortMethod.cpp 
+				QGLViewer/VRender/EPSExporter.cpp 
+				QGLViewer/VRender/Exporter.cpp 
+				QGLViewer/VRender/FIGExporter.cpp 
+				QGLViewer/VRender/gpc.cpp 
+				QGLViewer/VRender/ParserGL.cpp 
+				QGLViewer/VRender/Primitive.cpp 
+				QGLViewer/VRender/PrimitivePositioning.cpp 
+				QGLViewer/VRender/TopologicalSortMethod.cpp 
+				QGLViewer/VRender/VisibilityOptimizer.cpp 
+				QGLViewer/VRender/Vector2.cpp 
+				QGLViewer/VRender/Vector3.cpp 
+				QGLViewer/VRender/NVector3.cpp 
+				QGLViewer/VRender/VRender.cpp
+				'''),
+				# we want to REALLY optimize this, even in debug builds of yade
+				CXXFLAGS=[x for x in env['CXXFLAGS'] if x not in ['-ggdb3','-g','-pg'] ]+['-O3','-g0'],
+				# HACK: uic generates files in the buildDir, but gcc is invoked on files in the original dir;
+				# since the generated header is #include'd &quot;...&quot;, it looks for it in the original dir
+				# no idea why this _does_ work with gui/qt3. Go figure.
+				CPPPATH=env['CPPPATH']+['${TARGET.dir}']),
 		])
 
 env.Install('$PREFIX/lib/yade$SUFFIX/lib',[

Modified: trunk/pkg/common/Engine/DeusExMachina/GravityEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/GravityEngine.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/pkg/common/Engine/DeusExMachina/GravityEngine.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -6,9 +6,9 @@
 *  GNU General Public License v2 or later. See file LICENSE for details. *
 *************************************************************************/
 
-#include &quot;GravityEngine.hpp&quot;
-#include &quot;ParticleParameters.hpp&quot;
-#include &quot;Force.hpp&quot;
+#include&quot;GravityEngine.hpp&quot;
+#include&lt;yade/pkg-common/ParticleParameters.hpp&gt;
+#include&lt;yade/pkg-common/Force.hpp&gt;
 #include&lt;yade/core/MetaBody.hpp&gt;
 
 GravityEngine::GravityEngine() : actionParameterForce(new Force), gravity(Vector3r::ZERO)

Modified: trunk/pkg/common/SConscript
===================================================================
--- trunk/pkg/common/SConscript	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/pkg/common/SConscript	2008-03-13 19:14:29 UTC (rev 1274)
@@ -109,7 +109,7 @@
 	env.SharedLibrary('Quadrilateral',
 		['DataClass/GeometricalModel/Quadrilateral.cpp'],
 		LIBS=env['LIBS']+['yade-base','yade-multimethods'],
-		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'DataClass/GeometricalModel']),
+		CPPPATH=env['CPPPATH']+['$PREFIX/include','DataClass/GeometricalModel']),
 
 	env.SharedLibrary('ForceEngine',
 		['Engine/DeusExMachina/ForceEngine.cpp'],
@@ -121,11 +121,16 @@
 
 	env.SharedLibrary('GravityEngine',
 		['Engine/DeusExMachina/GravityEngine.cpp'],
-		LIBS=env['LIBS']+['yade-base',  'Force', 'ParticleParameters'],
+		LIBS=env['LIBS']+['yade-base','Force','ParticleParameters'],
 		CPPPATH=env['CPPPATH']+['Engine/DeusExMachina',
 			'DataClass/PhysicalAction',
 			'$PREFIX/include',
 			'DataClass/PhysicalParameters']),
+	
+	env.SharedLibrary('CentralGravityEngine',
+		['Engine/DeusExMachina/CentralGravityEngine.cpp'],
+		LIBS=env['LIBS']+['yade-base','Force','ParticleParameters'],
+		),
 
 	env.SharedLibrary('RotationEngine',
 		['Engine/DeusExMachina/RotationEngine.cpp'],

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.cpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -20,10 +20,12 @@
 
 CREATE_LOGGER(TriaxialStressController);
 
-TriaxialStressController::TriaxialStressController() : actionParameterForce(new Force), wall_bottom_id(wall_id[0]), wall_top_id(wall_id[1]), wall_left_id(wall_id[2]), wall_right_id(wall_id[3]), wall_front_id(wall_id[4]), wall_back_id(wall_id[5])
+TriaxialStressController::TriaxialStressController(): wall_bottom_id(wall_id[0]), wall_top_id(wall_id[1]), wall_left_id(wall_id[2]), wall_right_id(wall_id[3]), wall_front_id(wall_id[4]), wall_back_id(wall_id[5])
 {
 	//StiffnessMatrixClassIndex = actionParameterStiffnessMatrix-&gt;getClassIndex();
-	ForceClassIndex = actionParameterForce-&gt;getClassIndex();
+	shared_ptr&lt;Force&gt; tmpF(new Force);
+	ForceClassIndex=tmpF-&gt;getClassIndex();
+
 	previousStress = 0;
 	previousMultiplier = 1;
 	
@@ -54,9 +56,6 @@
 	finalMaxMultiplier = 1.00001;
 	internalCompaction = true;
 	
-	//StiffnessMatrixClassIndex = actionParameterStiffnessMatrix-&gt;getClassIndex();
-	ForceClassIndex = actionParameterForce-&gt;getClassIndex();
-			
 	wall_bottom_activated = true;
 	wall_top_activated = true;
 	wall_left_activated = true;

Modified: trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp
===================================================================
--- trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/pkg/dem/Engine/DeusExMachina/TriaxialStressController.hpp	2008-03-13 19:14:29 UTC (rev 1274)
@@ -27,7 +27,8 @@
 class TriaxialStressController : public DeusExMachina 
 {
 	private :
-		shared_ptr&lt;PhysicalAction&gt; actionParameterForce;
+		//shared_ptr&lt;PhysicalAction&gt; actionParameterForce;
+		//int cachedForceClassIndex;
 		int ForceClassIndex;
 		Real previousStress, previousMultiplier; //previous mean stress and size multiplier		
 		

Modified: trunk/scripts/default-test.py
===================================================================
--- trunk/scripts/default-test.py	2008-03-03 15:51:38 UTC (rev 1273)
+++ trunk/scripts/default-test.py	2008-03-13 19:14:29 UTC (rev 1274)
@@ -36,6 +36,8 @@
 	if retval==0: return 'passed&#160;(%s iter/sec)'%(open(speedFile,'r').readline()[:-1])
 	else: return 'CRASHED&#160;(backtrace above)'
 
+generators=o.childClasses('FileGenerator')
+
 for pp in o.childClasses('FileGenerator'):
 	if pp in broken:
 		print &quot;============= (skipping broken &quot;+pp+&quot;)==============&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000238.html">[Yade-commits] r1273 - in trunk: .	pkg/common/Engine/StandAloneEngine
</A></li>
	<LI>Next message: <A HREF="000239.html">[Yade-commits] r1275 - in trunk: . lib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#240">[ date ]</a>
              <a href="thread.html#240">[ thread ]</a>
              <a href="subject.html#240">[ subject ]</a>
              <a href="author.html#240">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
