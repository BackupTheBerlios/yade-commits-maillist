<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1328 - in trunk/pkg/dem: .	DataClass/InteractionPhysics Engine/StandAloneEngine PreProcessor
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1328%20-%20in%20trunk/pkg/dem%3A%20.%0A%09DataClass/InteractionPhysics%20Engine/StandAloneEngine%20PreProcessor&In-Reply-To=%3C200804181558.m3IFwI7W016414%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000289.html">
   <LINK REL="Next"  HREF="000291.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1328 - in trunk/pkg/dem: .	DataClass/InteractionPhysics Engine/StandAloneEngine PreProcessor</H1>
    <B>cosurgi at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1328%20-%20in%20trunk/pkg/dem%3A%20.%0A%09DataClass/InteractionPhysics%20Engine/StandAloneEngine%20PreProcessor&In-Reply-To=%3C200804181558.m3IFwI7W016414%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1328 - in trunk/pkg/dem: .	DataClass/InteractionPhysics Engine/StandAloneEngine PreProcessor">cosurgi at mail.berlios.de
       </A><BR>
    <I>Fri Apr 18 17:58:18 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000289.html">[Yade-commits] r1327 - in trunk/pkg: common/Engine/DeusExMachina	dem/Engine/EngineUnit dem/Engine/StandAloneEngine
</A></li>
        <LI>Next message: <A HREF="000291.html">[Yade-commits] r1329 - in trunk: core extra extra/clump extra/tetra	extra/usct gui/cmd lib/QGLViewer lib/serialization	pkg/common/DataClass/PhysicalParameters	pkg/common/Engine/DeusExMachina pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/dem/DataClass/PhysicalParameters	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/StandAloneEngine	pkg/fem/Engine/StandAloneEngine pkg/lattice/Engine/StandAloneEngine	pkg/mass-spring/Engine/StandAloneEngine	pkg/realtime-rigidbody/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#290">[ date ]</a>
              <a href="thread.html#290">[ thread ]</a>
              <a href="subject.html#290">[ subject ]</a>
              <a href="author.html#290">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cosurgi
Date: 2008-04-18 17:58:17 +0200 (Fri, 18 Apr 2008)
New Revision: 1328

Added:
   trunk/pkg/dem/PreProcessor/SnowCreepTest.cpp
   trunk/pkg/dem/PreProcessor/SnowCreepTest.hpp
Modified:
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp
   trunk/pkg/dem/SConscript
Log:
- started snow creep test.
- added optional creep in CohesiveFrictionalContactLaw



Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -23,6 +23,7 @@
 	orientationToContact2 = Quaternionr(1.0,0.0,0.0,0.0);
 	initialOrientation1 = Quaternionr(1.0,0.0,0.0,0.0);
 	initialOrientation2 = Quaternionr(1.0,0.0,0.0,0.0);
+	twistCreep          = Quaternionr(1.0,0.0,0.0,0.0);
 	kr = 0;
 	currentContactOrientation = Quaternionr(1.0,0.0,0.0,0.0);
 	initialContactOrientation = Quaternionr(1.0,0.0,0.0,0.0);
@@ -73,6 +74,7 @@
 	REGISTER_ATTRIBUTE(initialContactOrientation);
 	REGISTER_ATTRIBUTE(initialPosition1);
 	REGISTER_ATTRIBUTE(initialPosition2);
+	REGISTER_ATTRIBUTE(twistCreep);
 //	REGISTER_ATTRIBUTE(prevX1);
 //	REGISTER_ATTRIBUTE(prevX2);
 //	REGISTER_ATTRIBUTE(initX1);

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -24,7 +24,8 @@
 
 		Quaternionr	initialOrientation1,initialOrientation2,
 				orientationToContact1,orientationToContact2,
-				currentContactOrientation,initialContactOrientation;
+				currentContactOrientation,initialContactOrientation,
+				twistCreep;
 		Vector3r	initialPosition1,initialPosition2;
 		Real		kr; // rolling stiffness
 	

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -29,6 +29,11 @@
 	erosionActivated = false;
 	detectBrokenBodies = false;
 	always_use_moment_law = false;
+
+//CREEP
+	shear_creep=false;
+	twist_creep=false;
+	creep_viscosity = 1.0;
 }
 
 
@@ -40,6 +45,10 @@
 	REGISTER_ATTRIBUTE(erosionActivated);
 	REGISTER_ATTRIBUTE(detectBrokenBodies);
 	REGISTER_ATTRIBUTE(always_use_moment_law);
+	
+	REGISTER_ATTRIBUTE(shear_creep);
+	REGISTER_ATTRIBUTE(twist_creep);
+	REGISTER_ATTRIBUTE(creep_viscosity);
 }
 
 void out(Quaternionr q)
@@ -187,10 +196,11 @@
 
 
 ///////////////////////// CREEP START (commented out) ///////////
-//	Real    viscosity = 300000.0;
-//	shearForce                            -= currentContactPhysics-&gt;ks*(shearDisplacement + shearForce*dt/viscosity);
-
+if(shear_creep){
+	shearForce                            -= currentContactPhysics-&gt;ks*(shearDisplacement + shearForce*dt/creep_viscosity);
+} else {
 shearForce 			       -= currentContactPhysics-&gt;ks*shearDisplacement;
+}
 ///////////////////////// CREEP END /////////////////////////////
 
                 //  cerr &lt;&lt; &quot;shearForce = &quot; &lt;&lt; shearForce &lt;&lt; endl;
@@ -300,15 +310,19 @@
 	/// Moment law					 	 ///
 		if(momentRotationLaw &amp;&amp; (currentContactPhysics-&gt;cohesionBroken == false || always_use_moment_law) )
 		{
-			{// updates only orientation of contact (local coordinate system)
-				Vector3r axis = currentContactPhysics-&gt;prevNormal.UnitCross(currentContactGeometry-&gt;normal);
-				Real angle =  unitVectorsAngle(currentContactPhysics-&gt;prevNormal,currentContactGeometry-&gt;normal);
-				Quaternionr align(axis,angle);
-				currentContactPhysics-&gt;currentContactOrientation =  align * currentContactPhysics-&gt;currentContactOrientation;
-			}
+			// Not necessary. OK.
+			//{// updates only orientation of contact (local coordinate system)
+			//	Vector3r axis = currentContactPhysics-&gt;prevNormal.UnitCross(currentContactGeometry-&gt;normal);
+			//	Real angle =  unitVectorsAngle(currentContactPhysics-&gt;prevNormal,currentContactGeometry-&gt;normal);
+			//	Quaternionr align(axis,angle);
+			//	currentContactPhysics-&gt;currentContactOrientation =  align * currentContactPhysics-&gt;currentContactOrientation;
+			//}
 
 			Quaternionr delta( de1-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation1.Conjugate() *
 		                           currentContactPhysics-&gt;initialOrientation2 * de2-&gt;se3.orientation.Conjugate());
+			if(twist_creep){
+				delta = delta * currentContactPhysics-&gt;twistCreep;
+			}
 
 			Vector3r axis;	// axis of rotation - this is the Moment direction UNIT vector.
 			Real angle;	// angle represents the power of resistant ELASTIC moment
@@ -320,6 +334,22 @@
 
 	Real angle_twist(angle * axis.Dot(currentContactGeometry-&gt;normal) );
 	Vector3r axis_twist(angle_twist * currentContactGeometry-&gt;normal);
+
+			if(twist_creep){
+				Real viscosity_twist = creep_viscosity * std::pow((2 * std::min(currentContactGeometry-&gt;radius1,currentContactGeometry-&gt;radius2)),2) / 16.0;
+				Real angle_twist_creeped = angle_twist * (1 - dt/viscosity_twist);
+				Quaternionr q_twist(currentContactGeometry-&gt;normal , angle_twist);
+				//Quaternionr q_twist_creeped(currentContactGeometry-&gt;normal , angle_twist*0.996);
+				Quaternionr q_twist_creeped(currentContactGeometry-&gt;normal , angle_twist_creeped);
+				Quaternionr q_twist_delta(q_twist_creeped * q_twist.Conjugate() );
+		currentContactPhysics-&gt;twistCreep = currentContactPhysics-&gt;twistCreep * q_twist_delta;
+				// modify the initialRelativeOrientation to substract some twisting
+			//	currentContactPhysics-&gt;initialRelativeOrientation = currentContactPhysics-&gt;initialRelativeOrientation * q_twist_delta;
+			//currentContactPhysics-&gt;initialOrientation1 = currentContactPhysics-&gt;initialOrientation1 * q_twist_delta;
+			//currentContactPhysics-&gt;initialOrientation2 = currentContactPhysics-&gt;initialOrientation2 * q_twist_delta.Conjugate();
+			}
+
+
 	Vector3r moment_twist(axis_twist * currentContactPhysics-&gt;kr);
 
 	Vector3r axis_bending(angle*axis - axis_twist);

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.hpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -26,6 +26,8 @@
 	public :
 		int sdecGroupMask;
 		bool momentRotationLaw, erosionActivated, detectBrokenBodies,always_use_moment_law;
+		bool shear_creep,twist_creep;
+		Real creep_viscosity; /// probably should be moved to CohesiveFrictionalRelationships...
 		long iter;/// used for checking if new iteration
 	
 		CohesiveFrictionalContactLaw();

Added: trunk/pkg/dem/PreProcessor/SnowCreepTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SnowCreepTest.cpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/PreProcessor/SnowCreepTest.cpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -0,0 +1,816 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*  Copyright (C) 2007 by Bruno Chareyre		                         *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">bruno.chareyre at hmg.inpg.fr</A>                                            *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;SnowCreepTest.hpp&quot;
+
+#include&lt;yade/pkg-dem/CohesiveFrictionalContactLaw.hpp&gt;
+#include&lt;yade/pkg-dem/CohesiveFrictionalRelationships.hpp&gt;
+#include&lt;yade/pkg-dem/CohesiveFrictionalBodyParameters.hpp&gt;
+#include&lt;yade/pkg-dem/SDECLinkGeometry.hpp&gt;
+#include&lt;yade/pkg-dem/SDECLinkPhysics.hpp&gt;
+#include&lt;yade/pkg-dem/GlobalStiffnessCounter.hpp&gt;
+#include&lt;yade/pkg-dem/GlobalStiffnessTimeStepper.hpp&gt;
+#include&lt;yade/pkg-dem/PositionOrientationRecorder.hpp&gt;
+
+#include&lt;yade/pkg-dem/AveragePositionRecorder.hpp&gt;
+#include&lt;yade/pkg-dem/ForceRecorder.hpp&gt;
+#include&lt;yade/pkg-dem/VelocityRecorder.hpp&gt;
+#include&lt;yade/pkg-dem/TriaxialStressController.hpp&gt;
+#include&lt;yade/pkg-dem/TriaxialCompressionEngine.hpp&gt;
+#include &lt;yade/pkg-dem/TriaxialStateRecorder.hpp&gt;
+
+#include&lt;yade/pkg-common/Box.hpp&gt;
+#include&lt;yade/pkg-common/AABB.hpp&gt;
+#include&lt;yade/pkg-common/Sphere.hpp&gt;
+#include&lt;yade/core/MetaBody.hpp&gt;
+#include&lt;yade/pkg-common/SAPCollider.hpp&gt;
+#include&lt;yade/pkg-common/DistantPersistentSAPCollider.hpp&gt;
+#include&lt;yade/lib-serialization/IOFormatManager.hpp&gt;
+#include&lt;yade/core/Interaction.hpp&gt;
+#include&lt;yade/pkg-common/BoundingVolumeMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/MetaInteractingGeometry2AABB.hpp&gt;
+#include&lt;yade/pkg-common/MetaInteractingGeometry.hpp&gt;
+
+#include&lt;yade/pkg-common/GravityEngine.hpp&gt;
+#include&lt;yade/pkg-dem/HydraulicForceEngine.hpp&gt;
+#include&lt;yade/pkg-dem/InteractingSphere2InteractingSphere4DistantSpheresContactGeometry.hpp&gt;
+#include&lt;yade/pkg-dem/InteractingBox2InteractingSphere4SpheresContactGeometry.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionApplier.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionDamper.hpp&gt;
+#include&lt;yade/pkg-common/CundallNonViscousForceDamping.hpp&gt;
+#include&lt;yade/pkg-common/CundallNonViscousMomentumDamping.hpp&gt;
+
+#include&lt;yade/pkg-common/InteractionGeometryMetaEngine.hpp&gt;
+#include&lt;yade/pkg-common/InteractionPhysicsMetaEngine.hpp&gt;
+#include&lt;yade/core/Body.hpp&gt;
+#include&lt;yade/pkg-common/InteractingBox.hpp&gt;
+#include&lt;yade/pkg-common/InteractingSphere.hpp&gt;
+
+#include&lt;yade/pkg-common/PhysicalActionContainerReseter.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionContainerInitializer.hpp&gt;
+
+#include&lt;yade/pkg-common/PhysicalParametersMetaEngine.hpp&gt;
+
+#include&lt;yade/pkg-common/BodyRedirectionVector.hpp&gt;
+#include&lt;yade/pkg-common/InteractionVecSet.hpp&gt;
+#include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
+#include&lt;yade/pkg-common/PhysicalActionVectorVector.hpp&gt;
+
+#include&lt;yade/extra/Shop.hpp&gt;
+
+#include &lt;boost/filesystem/convenience.hpp&gt;
+#include &lt;boost/lexical_cast.hpp&gt;
+#include &lt;boost/numeric/conversion/bounds.hpp&gt;
+#include &lt;boost/limits.hpp&gt;
+
+// random
+#include &lt;boost/random/linear_congruential.hpp&gt;
+#include &lt;boost/random/uniform_real.hpp&gt;
+#include &lt;boost/random/variate_generator.hpp&gt;
+#include &lt;boost/random/normal_distribution.hpp&gt;
+
+
+
+using namespace boost;
+using namespace std;
+
+
+typedef pair&lt;Vector3r, Real&gt; BasicSphere;
+//! make a list of spheres non-overlapping sphere
+string GenerateCloud(vector&lt;BasicSphere&gt;&amp; sphere_list, Vector3r lowerCorner, Vector3r upperCorner, long number, Real rad_std_dev, Real porosity);
+
+
+SnowCreepTest::SnowCreepTest () : FileGenerator()
+{
+	lowerCorner 		= Vector3r(0,0,0);
+	upperCorner 		= Vector3r(0.01,0.01,0.01);
+	thickness 		= 0.001;
+	importFilename 		= &quot;&quot;;
+	outputFileName 		= &quot;./SnowCreepTest.xml&quot;;
+	//nlayers = 1;
+	wall_top 		= true;
+	wall_bottom 		= true;
+	wall_1			= true;
+	wall_2			= true;
+	wall_3			= true;
+	wall_4			= true;
+	wall_top_wire 		= true;
+	wall_bottom_wire	= true;
+	wall_1_wire		= true;
+	wall_2_wire		= true;
+	wall_3_wire		= true;
+	wall_4_wire		= true;
+	spheresColor		= Vector3r(0.8,0.3,0.3);
+	spheresRandomColor	= false;
+	recordBottomForce	= true;
+	forceRecordFile		= &quot;./force&quot;;
+	recordAveragePositions	= true;
+	positionRecordFile	= &quot;./positions&quot;;
+	recordIntervalIter	= 20;
+	velocityRecordFile 	= &quot;./velocities&quot;;
+	saveAnimationSnapshots = false;
+	AnimationSnapshotsBaseName = &quot;./snapshots/snap&quot;;
+	WallStressRecordFile = &quot;./WallStresses&quot;;
+
+	rotationBlocked = false;
+	//	boxWalls 		= false;
+	boxWalls 		= true;
+	internalCompaction	=false;
+
+	dampingForce = 0.2;
+	dampingMomentum = 0.2;
+	defaultDt = 0.00001;
+	
+	timeStepUpdateInterval = 50;
+	timeStepOutputInterval = 50;
+	wallStiffnessUpdateInterval = 10;
+	radiusControlInterval = 10;
+	numberOfGrains = 100;
+	radiusDeviation = 0.3;
+	strainRate = 10;
+	StabilityCriterion = 0.01;
+	autoCompressionActivation = false;
+	maxMultiplier = 1.01;
+	finalMaxMultiplier = 1.0001;
+	
+	sphereYoungModulus  = 15000000.0;
+	spherePoissonRatio  = 0.5;
+	sphereFrictionDeg   = 18.0;
+	normalCohesion = 500000;
+	shearCohesion = 500000;
+	setCohesionOnNewContacts = false;
+	density			= 2600;
+	
+	boxYoungModulus   = 15000000.0;
+	boxPoissonRatio  = 0.2;
+	boxFrictionDeg   = 0.f;
+	gravity 	= Vector3r(0,-9.81,0);
+	
+	sigma_iso = 50000;
+	
+//	wall_top_id =0;
+// 	wall_bottom_id =0;
+// 	wall_left_id =0;
+// 	all_right_id =0;
+// 	wall_front_id =0;
+// 	wall_back_id =0;
+
+
+	creep_viscosity = 4000000;
+}
+
+
+SnowCreepTest::~SnowCreepTest ()
+{
+
+}
+
+
+void SnowCreepTest::registerAttributes()
+{
+	FileGenerator::registerAttributes();
+	REGISTER_ATTRIBUTE(lowerCorner);
+	REGISTER_ATTRIBUTE(upperCorner);
+//.	REGISTER_ATTRIBUTE(thickness);
+//.	REGISTER_ATTRIBUTE(importFilename);
+	//REGISTER_ATTRIBUTE(nlayers);
+	//REGISTER_ATTRIBUTE(boxWalls);
+//.	REGISTER_ATTRIBUTE(internalCompaction);
+//.	REGISTER_ATTRIBUTE(maxMultiplier);
+//.	REGISTER_ATTRIBUTE(finalMaxMultiplier);
+
+	REGISTER_ATTRIBUTE(sphereYoungModulus);
+	REGISTER_ATTRIBUTE(spherePoissonRatio);
+	REGISTER_ATTRIBUTE(sphereFrictionDeg);
+
+        	REGISTER_ATTRIBUTE(normalCohesion);
+		REGISTER_ATTRIBUTE(shearCohesion);
+
+		REGISTER_ATTRIBUTE(setCohesionOnNewContacts);
+
+	REGISTER_ATTRIBUTE(boxYoungModulus);
+	REGISTER_ATTRIBUTE(boxPoissonRatio);
+	REGISTER_ATTRIBUTE(boxFrictionDeg);
+
+	REGISTER_ATTRIBUTE(density);
+	REGISTER_ATTRIBUTE(defaultDt);
+	REGISTER_ATTRIBUTE(dampingForce);
+	REGISTER_ATTRIBUTE(dampingMomentum);
+//.	REGISTER_ATTRIBUTE(rotationBlocked);
+//.	REGISTER_ATTRIBUTE(timeStepUpdateInterval);
+//.	REGISTER_ATTRIBUTE(timeStepOutputInterval);
+//.	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
+//.	REGISTER_ATTRIBUTE(radiusControlInterval);
+	REGISTER_ATTRIBUTE(numberOfGrains);
+//.	REGISTER_ATTRIBUTE(radiusDeviation);
+//.	REGISTER_ATTRIBUTE(strainRate);
+//.	REGISTER_ATTRIBUTE(StabilityCriterion);
+//.	REGISTER_ATTRIBUTE(autoCompressionActivation);
+//	REGISTER_ATTRIBUTE(wall_top);
+//	REGISTER_ATTRIBUTE(wall_bottom);
+//	REGISTER_ATTRIBUTE(wall_1);
+//	REGISTER_ATTRIBUTE(wall_2);
+//	REGISTER_ATTRIBUTE(wall_3);
+//	REGISTER_ATTRIBUTE(wall_4);
+//	REGISTER_ATTRIBUTE(wall_top_wire);
+//	REGISTER_ATTRIBUTE(wall_bottom_wire);
+//	REGISTER_ATTRIBUTE(wall_1_wire);
+//	REGISTER_ATTRIBUTE(wall_2_wire);
+//	REGISTER_ATTRIBUTE(wall_3_wire);
+//	REGISTER_ATTRIBUTE(wall_4_wire);
+//	REGISTER_ATTRIBUTE(spheresColor);
+//	REGISTER_ATTRIBUTE(spheresRandomColor);
+//.	REGISTER_ATTRIBUTE(recordBottomForce);
+//.	REGISTER_ATTRIBUTE(forceRecordFile);
+//	REGISTER_ATTRIBUTE(recordAveragePositions);
+//.	REGISTER_ATTRIBUTE(positionRecordFile);
+//.	REGISTER_ATTRIBUTE(velocityRecordFile);
+//.	REGISTER_ATTRIBUTE(recordIntervalIter);
+//.	REGISTER_ATTRIBUTE(saveAnimationSnapshots);
+//.	REGISTER_ATTRIBUTE(AnimationSnapshotsBaseName);
+	REGISTER_ATTRIBUTE(WallStressRecordFile);
+
+//	REGISTER_ATTRIBUTE(gravity);
+	
+	//REGISTER_ATTRIBUTE(bigBall);
+	//REGISTER_ATTRIBUTE(bigBallRadius);
+	//REGISTER_ATTRIBUTE(bigBallDensity);
+	//REGISTER_ATTRIBUTE(bigBallDropTimeSeconds);
+	//REGISTER_ATTRIBUTE(bigBallFrictDeg);
+	//REGISTER_ATTRIBUTE(bigBallYoungModulus);
+	//REGISTER_ATTRIBUTE(bigBallPoissonRatio);
+	//REGISTER_ATTRIBUTE(bigBallDropHeight);
+
+		REGISTER_ATTRIBUTE(sigma_iso);
+
+        	REGISTER_ATTRIBUTE(creep_viscosity)
+}
+
+
+bool SnowCreepTest::generate()
+{
+//	unsigned int startId=boost::numeric::bounds&lt;unsigned int&gt;::highest(), endId=0; // record forces from group 2
+	
+	rootBody = shared_ptr&lt;MetaBody&gt;(new MetaBody);
+	createActors(rootBody);
+	positionRootBody(rootBody);
+
+// 	rootBody-&gt;persistentInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
+// 	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionVecSet);
+	rootBody-&gt;persistentInteractions	= shared_ptr&lt;InteractionContainer&gt;(new InteractionHashMap);
+	rootBody-&gt;transientInteractions		= shared_ptr&lt;InteractionContainer&gt;(new InteractionHashMap);
+	rootBody-&gt;physicalActions		= shared_ptr&lt;PhysicalActionContainer&gt;(new PhysicalActionVectorVector);
+	rootBody-&gt;bodies 			= shared_ptr&lt;BodyContainer&gt;(new BodyRedirectionVector);
+
+	shared_ptr&lt;Body&gt; body;
+	
+	if(boxWalls)
+	{
+	// bottom box
+	 	Vector3r center		= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						lowerCorner[1]-thickness/2.0,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+	 	Vector3r halfSize	= Vector3r(
+	 						1.5*fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+							thickness/2.0,
+	 						1.5*fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	
+		createBox(body,center,halfSize,wall_bottom_wire);
+	 	if(wall_bottom) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			//(resultantforceEngine-&gt;subscribedBodies).push_back(body-&gt;getId());
+			triaxialcompressionEngine-&gt;wall_bottom_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_bottom_id = body-&gt;getId();
+			forcerec-&gt;startId = body-&gt;getId();
+			forcerec-&gt;endId   = body-&gt;getId();
+			}
+		//forcerec-&gt;id = body-&gt;getId();
+	
+	// top box
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						upperCorner[1]+thickness/2.0,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+	 	halfSize		= Vector3r(
+	 						1.5*fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						thickness/2.0,
+	 						1.5*fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	
+		createBox(body,center,halfSize,wall_top_wire);
+	 	if(wall_top) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_top_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_top_id = body-&gt;getId();
+			}
+	// box 1
+	
+	 	center			= Vector3r(
+	 						lowerCorner[0]-thickness/2.0,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						(lowerCorner[2]+upperCorner[2])/2);
+		halfSize		= Vector3r(
+							thickness/2.0,
+	 						1.5*fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						1.5*fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+		createBox(body,center,halfSize,wall_1_wire);
+	 	if(wall_1) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_left_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_left_id = body-&gt;getId();
+			}
+	// box 2
+	 	center			= Vector3r(
+	 						upperCorner[0]+thickness/2.0,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+							(lowerCorner[2]+upperCorner[2])/2);
+	 	halfSize		= Vector3r(
+	 						thickness/2.0,
+	 						1.5*fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						1.5*fabs(lowerCorner[2]-upperCorner[2])/2+thickness);
+	 	
+		createBox(body,center,halfSize,wall_2_wire);
+	 	if(wall_2) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_right_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_right_id = body-&gt;getId();
+			}
+	// box 3
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						lowerCorner[2]-thickness/2.0);
+	 	halfSize		= Vector3r(
+	 						1.5*fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						1.5*fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						thickness/2.0);
+		createBox(body,center,halfSize,wall_3_wire);
+	 	if(wall_3) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_back_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_back_id = body-&gt;getId();
+			}
+	
+	// box 4
+	 	center			= Vector3r(
+	 						(lowerCorner[0]+upperCorner[0])/2,
+	 						(lowerCorner[1]+upperCorner[1])/2,
+	 						upperCorner[2]+thickness/2.0);
+	 	halfSize		= Vector3r(
+	 						1.5*fabs(lowerCorner[0]-upperCorner[0])/2+thickness,
+	 						1.5*fabs(lowerCorner[1]-upperCorner[1])/2+thickness,
+	 						thickness/2.0);
+		createBox(body,center,halfSize,wall_3_wire);
+	 	if(wall_4) {
+			rootBody-&gt;bodies-&gt;insert(body);
+			triaxialcompressionEngine-&gt;wall_front_id = body-&gt;getId();
+			//triaxialStateRecorder-&gt;wall_front_id = body-&gt;getId();
+			}
+			 
+	}
+	
+	vector&lt;BasicSphere&gt; sphere_list;
+	if(importFilename!=&quot;&quot;) sphere_list=Shop::loadSpheresFromFile(importFilename,lowerCorner,upperCorner);
+	else message=GenerateCloud(sphere_list, lowerCorner, upperCorner, numberOfGrains, radiusDeviation, 0.75);
+	
+	vector&lt;BasicSphere&gt;::iterator it = sphere_list.begin();
+	vector&lt;BasicSphere&gt;::iterator it_end = sphere_list.end();
+			
+	for (;it!=it_end; ++it)
+	{
+		cerr &lt;&lt; &quot;sphere (&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
+		createSphere(body,it-&gt;first,it-&gt;second,true);
+		rootBody-&gt;bodies-&gt;insert(body);
+	}
+	
+// 	if(importFilename.size() != 0 &amp;&amp; filesystem::exists(importFilename) )
+// 	{
+// 		
+// 		Vector3r layersDistance (Vector3r::ZERO); 
+// 		for (int layer=1; layer &lt;= nlayers; ++layer)
+// 		{			
+// 			ifstream loadFile(importFilename.c_str());
+// 			long int i=0;
+// 			Real f,g,x,y,z,radius;
+// 			while( ! loadFile.eof() )
+// 			{
+// 				++i;
+// 				loadFile &gt;&gt; x;
+// 				loadFile &gt;&gt; y;
+// 				loadFile &gt;&gt; z;
+// 				Vector3r position = (Vector3r(x,z,y) + layersDistance);
+// 				loadFile &gt;&gt; radius;
+// 			
+// 				loadFile &gt;&gt; f;
+// 				loadFile &gt;&gt; g;
+// 				if( boxWalls ? f&gt;1 : false ) // skip loading of SDEC walls
+// 					continue;
+// 				if(f==8)
+// 					continue;
+// 	
+// 		//		if( i % 100 == 0 ) // FIXME - should display a progress BAR !!
+// 		//			cout &lt;&lt; &quot;loaded: &quot; &lt;&lt; i &lt;&lt; endl;
+// 				if(f==1)
+// 				{
+// 					lowerCorner[0] = min(position[0]-radius , lowerCorner[0]);
+// 					lowerCorner[1] = min(position[1]-radius , lowerCorner[1]);
+// 					lowerCorner[2] = min(position[2]-radius , lowerCorner[2]);
+// 					upperCorner[0] = max(position[0]+radius , upperCorner[0]);
+// 					upperCorner[1] = max(position[1]+radius , upperCorner[1]);
+// 					upperCorner[2] = max(position[2]+radius , upperCorner[2]);
+// 				}
+// 				createSphere(body,position,radius,false,f==1);
+// 				rootBody-&gt;bodies-&gt;insert(body);
+// 				if(f == 2)
+// 				{
+// 					startId = std::min(body-&gt;getId() , startId);
+// 					endId   = std::max(body-&gt;getId() , endId);
+// 				}
+// 					
+// 			}
+// 			layersDistance.y() = upperCorner.y();
+// 		}
+// 	}
+
+// create bigBall
+	//Vector3r position = (upperCorner+lowerCorner)*0.5 + Vector3r(0,bigBallDropHeight,0);
+	//createSphere(body,position,bigBallRadius,true,false);	
+	//int bigId = 0;
+// 	if(bigBall)
+// 		rootBody-&gt;bodies-&gt;insert(body);
+// 	bigId = body-&gt;getId();
+	//forcerec-&gt;startId = startId;
+	//forcerec-&gt;endId   = endId;
+	//averagePositionRecorder-&gt;bigBallId = bigId;
+	//velocityRecorder-&gt;bigBallId = bigId;
+
+	
+	
+	return true;
+//  	return &quot;Generated a sample inside box of dimensions: (&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[0]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[1]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(lowerCorner[2]) + &quot;) and (&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[0]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[1]) + &quot;,&quot; 
+//  		+ lexical_cast&lt;string&gt;(upperCorner[2]) + &quot;).&quot;;
+
+}
+
+
+void SnowCreepTest::createSphere(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Real radius, bool dynamic )
+{
+	body = shared_ptr&lt;Body&gt;(new Body(body_id_t(0),2));
+	shared_ptr&lt;CohesiveFrictionalBodyParameters&gt; physics(new CohesiveFrictionalBodyParameters);
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
+	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
+	
+	Quaternionr q(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom());
+	q.Normalize();
+//	q.FromAxisAngle( Vector3r(0,0,1),0);
+	
+	body-&gt;isDynamic			= dynamic;
+	
+	physics-&gt;angularVelocity	= Vector3r(0,0,0);
+	physics-&gt;velocity		= Vector3r(0,0,0);
+	physics-&gt;mass			= 4.0/3.0*Mathr::PI*radius*radius*radius*density;
+	
+	physics-&gt;inertia		= Vector3r( 	2.0/5.0*physics-&gt;mass*radius*radius,
+							2.0/5.0*physics-&gt;mass*radius*radius,
+							2.0/5.0*physics-&gt;mass*radius*radius);
+	physics-&gt;se3			= Se3r(position,q);
+	physics-&gt;young			= sphereYoungModulus;
+	physics-&gt;poisson		= spherePoissonRatio;
+	physics-&gt;frictionAngle		= sphereFrictionDeg * Mathr::PI/180.0;
+
+	if((!dynamic) &amp;&amp; (!boxWalls))
+	{
+		physics-&gt;young			= boxYoungModulus;
+		physics-&gt;poisson		= boxPoissonRatio;
+		physics-&gt;frictionAngle		= boxFrictionDeg * Mathr::PI/180.0;
+	}
+	
+	aabb-&gt;diffuseColor		= Vector3r(0,1,0);
+
+
+	gSphere-&gt;radius			= radius;
+//	gSphere-&gt;diffuseColor		= ((int)(position[0]*400.0))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
+	gSphere-&gt;diffuseColor		= spheresColor;
+	gSphere-&gt;wire			= false;
+	gSphere-&gt;visible		= true;
+	gSphere-&gt;shadowCaster		= true;
+	
+	iSphere-&gt;radius			= radius;
+	iSphere-&gt;diffuseColor		= Vector3r(Mathr::UnitRandom(),Mathr::UnitRandom(),Mathr::UnitRandom());
+
+	body-&gt;interactingGeometry	= iSphere;
+	body-&gt;geometricalModel		= gSphere;
+	body-&gt;boundingVolume		= aabb;
+	body-&gt;physicalParameters	= physics;
+}
+
+
+void SnowCreepTest::createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents, bool wire)
+{
+	body = shared_ptr&lt;Body&gt;(new Body(body_id_t(0),2));
+	shared_ptr&lt;CohesiveFrictionalBodyParameters&gt; physics(new CohesiveFrictionalBodyParameters);
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	shared_ptr&lt;Box&gt; gBox(new Box);
+	shared_ptr&lt;InteractingBox&gt; iBox(new InteractingBox);
+	
+	Quaternionr q;
+	q.FromAxisAngle( Vector3r(0,0,1),0);
+
+	body-&gt;isDynamic			= false;
+	
+	physics-&gt;angularVelocity	= Vector3r(0,0,0);
+	physics-&gt;velocity		= Vector3r(0,0,0);
+	physics-&gt;mass			= 0; 
+	//physics-&gt;mass			= extents[0]*extents[1]*extents[2]*density*2; 
+	physics-&gt;inertia		= Vector3r(
+							  physics-&gt;mass*(extents[1]*extents[1]+extents[2]*extents[2])/3
+							, physics-&gt;mass*(extents[0]*extents[0]+extents[2]*extents[2])/3
+							, physics-&gt;mass*(extents[1]*extents[1]+extents[0]*extents[0])/3
+						);
+//	physics-&gt;mass			= 0;
+//	physics-&gt;inertia		= Vector3r(0,0,0);
+	physics-&gt;se3			= Se3r(position,q);
+
+	physics-&gt;young			= boxYoungModulus;
+	physics-&gt;poisson		= boxPoissonRatio;
+	physics-&gt;frictionAngle		= boxFrictionDeg * Mathr::PI/180.0;
+	physics-&gt;isCohesive		= false;
+
+	aabb-&gt;diffuseColor		= Vector3r(1,0,0);
+
+	gBox-&gt;extents			= extents;
+	gBox-&gt;diffuseColor		= Vector3r(1,1,1);
+	gBox-&gt;wire			= wire;
+	gBox-&gt;visible			= true;
+	gBox-&gt;shadowCaster		= false;
+	
+	iBox-&gt;extents			= extents;
+	iBox-&gt;diffuseColor		= Vector3r(1,1,1);
+
+	body-&gt;boundingVolume		= aabb;
+	body-&gt;interactingGeometry	= iBox;
+	body-&gt;geometricalModel		= gBox;
+	body-&gt;physicalParameters	= physics;
+}
+
+
+void SnowCreepTest::createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
+{
+// recording average positions
+	averagePositionRecorder = shared_ptr&lt;AveragePositionRecorder&gt;(new AveragePositionRecorder);
+	averagePositionRecorder -&gt; outputFile 		= positionRecordFile;
+	averagePositionRecorder -&gt; interval 		= recordIntervalIter;
+// recording forces
+	forcerec = shared_ptr&lt;ForceRecorder&gt;(new ForceRecorder);
+	forcerec -&gt; outputFile 	= forceRecordFile;
+	forcerec -&gt; interval 	= recordIntervalIter;
+// recording velocities
+	velocityRecorder = shared_ptr&lt;VelocityRecorder&gt;(new VelocityRecorder);
+	velocityRecorder-&gt; outputFile 	= velocityRecordFile;
+	velocityRecorder-&gt; interval 	= recordIntervalIter;
+
+	shared_ptr&lt;PhysicalActionContainerInitializer&gt; physicalActionInitializer(new PhysicalActionContainerInitializer);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Force&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;Momentum&quot;);
+	//physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;StiffnessMatrix&quot;);
+	physicalActionInitializer-&gt;physicalActionNames.push_back(&quot;GlobalStiffness&quot;);
+	
+	shared_ptr&lt;InteractionGeometryMetaEngine&gt; interactionGeometryDispatcher(new InteractionGeometryMetaEngine);
+	shared_ptr&lt;InteractionGeometryEngineUnit&gt; s1(new InteractingSphere2InteractingSphere4DistantSpheresContactGeometry);
+	interactionGeometryDispatcher-&gt;add(s1);
+	shared_ptr&lt;InteractionGeometryEngineUnit&gt; s2(new InteractingBox2InteractingSphere4SpheresContactGeometry);
+	interactionGeometryDispatcher-&gt;add(s2);
+
+	shared_ptr&lt;CohesiveFrictionalRelationships&gt; cohesiveFrictionalRelationships = shared_ptr&lt;CohesiveFrictionalRelationships&gt; (new CohesiveFrictionalRelationships);
+	cohesiveFrictionalRelationships-&gt;shearCohesion = shearCohesion;
+	cohesiveFrictionalRelationships-&gt;normalCohesion = normalCohesion;
+	cohesiveFrictionalRelationships-&gt;setCohesionOnNewContacts = setCohesionOnNewContacts;
+	shared_ptr&lt;InteractionPhysicsMetaEngine&gt; interactionPhysicsDispatcher(new InteractionPhysicsMetaEngine);
+	interactionPhysicsDispatcher-&gt;add(cohesiveFrictionalRelationships);
+		
+	shared_ptr&lt;BoundingVolumeMetaEngine&gt; boundingVolumeDispatcher	= shared_ptr&lt;BoundingVolumeMetaEngine&gt;(new BoundingVolumeMetaEngine);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingSphere2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;InteractingBox2AABB&quot;);
+	boundingVolumeDispatcher-&gt;add(&quot;MetaInteractingGeometry2AABB&quot;);
+
+	
+
+		
+	shared_ptr&lt;GravityEngine&gt; gravityCondition(new GravityEngine);
+	gravityCondition-&gt;gravity = gravity;
+	
+	shared_ptr&lt;CundallNonViscousForceDamping&gt; actionForceDamping(new CundallNonViscousForceDamping);
+	actionForceDamping-&gt;damping = dampingForce;
+	shared_ptr&lt;CundallNonViscousMomentumDamping&gt; actionMomentumDamping(new CundallNonViscousMomentumDamping);
+	actionMomentumDamping-&gt;damping = dampingMomentum;
+	shared_ptr&lt;PhysicalActionDamper&gt; actionDampingDispatcher(new PhysicalActionDamper);
+	actionDampingDispatcher-&gt;add(actionForceDamping);
+	actionDampingDispatcher-&gt;add(actionMomentumDamping);
+	
+	shared_ptr&lt;PhysicalActionApplier&gt; applyActionDispatcher(new PhysicalActionApplier);
+	applyActionDispatcher-&gt;add(&quot;NewtonsForceLaw&quot;);
+	applyActionDispatcher-&gt;add(&quot;NewtonsMomentumLaw&quot;);
+		
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; positionIntegrator(new PhysicalParametersMetaEngine);
+	positionIntegrator-&gt;add(&quot;LeapFrogPositionIntegrator&quot;);
+	shared_ptr&lt;PhysicalParametersMetaEngine&gt; orientationIntegrator(new PhysicalParametersMetaEngine);
+	orientationIntegrator-&gt;add(&quot;LeapFrogOrientationIntegrator&quot;);
+
+	//shared_ptr&lt;ElasticCriterionTimeStepper&gt; sdecTimeStepper(new ElasticCriterionTimeStepper);
+	//sdecTimeStepper-&gt;sdecGroupMask = 2;
+	//sdecTimeStepper-&gt;timeStepUpdateInterval = timeStepUpdateInterval;
+	
+	//shared_ptr&lt;StiffnessMatrixTimeStepper&gt; stiffnessMatrixTimeStepper(new StiffnessMatrixTimeStepper);
+	//stiffnessMatrixTimeStepper-&gt;sdecGroupMask = 2;
+	//stiffnessMatrixTimeStepper-&gt;timeStepUpdateInterval = timeStepUpdateInterval;
+	
+	shared_ptr&lt;GlobalStiffnessTimeStepper&gt; globalStiffnessTimeStepper(new GlobalStiffnessTimeStepper);
+	globalStiffnessTimeStepper-&gt;sdecGroupMask = 2;
+	globalStiffnessTimeStepper-&gt;timeStepUpdateInterval = timeStepUpdateInterval;
+	globalStiffnessTimeStepper-&gt;defaultDt = defaultDt;
+	globalStiffnessTimeStepper-&gt;timestepSafetyCoefficient = 0.2;
+	
+	shared_ptr&lt;CohesiveFrictionalContactLaw&gt; cohesiveFrictionalContactLaw(new CohesiveFrictionalContactLaw);
+	cohesiveFrictionalContactLaw-&gt;sdecGroupMask = 2;
+	cohesiveFrictionalContactLaw-&gt;shear_creep = false;
+	cohesiveFrictionalContactLaw-&gt;twist_creep = false;
+	cohesiveFrictionalContactLaw-&gt;creep_viscosity = creep_viscosity;
+	
+	//shared_ptr&lt;StiffnessCounter&gt; stiffnesscounter(new StiffnessCounter);
+	//stiffnesscounter-&gt;sdecGroupMask = 2;
+	//stiffnesscounter-&gt;interval = timeStepUpdateInterval;
+	
+	shared_ptr&lt;GlobalStiffnessCounter&gt; globalStiffnessCounter(new GlobalStiffnessCounter);
+	globalStiffnessCounter-&gt;sdecGroupMask = 2;
+	globalStiffnessCounter-&gt;interval = timeStepUpdateInterval;
+	
+	// moving walls to regulate the stress applied + compress when the packing is dense an stable
+	//cerr &lt;&lt; &quot;triaxialcompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (new TriaxialCompressionEngine);&quot; &lt;&lt; std::endl;
+	triaxialcompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (new TriaxialCompressionEngine);
+	triaxialcompressionEngine-&gt; stiffnessUpdateInterval = wallStiffnessUpdateInterval;// = stiffness update interval
+	triaxialcompressionEngine-&gt; radiusControlInterval = radiusControlInterval;// = stiffness update interval
+	triaxialcompressionEngine-&gt; sigma_iso = sigma_iso;
+	triaxialcompressionEngine-&gt; sigmaLateralConfinement = sigma_iso;
+	triaxialcompressionEngine-&gt; sigmaIsoCompaction = sigma_iso;
+	triaxialcompressionEngine-&gt; max_vel = 1;
+	triaxialcompressionEngine-&gt; thickness = thickness;
+	triaxialcompressionEngine-&gt;strainRate = strainRate;
+	triaxialcompressionEngine-&gt;StabilityCriterion = StabilityCriterion;
+	triaxialcompressionEngine-&gt;autoCompressionActivation = autoCompressionActivation;
+	triaxialcompressionEngine-&gt;internalCompaction = internalCompaction;
+	triaxialcompressionEngine-&gt;maxMultiplier = maxMultiplier;
+	
+	shared_ptr&lt;HydraulicForceEngine&gt; hydraulicForceEngine = shared_ptr&lt;HydraulicForceEngine&gt; (new HydraulicForceEngine);
+	hydraulicForceEngine-&gt;dummyParameter = true;
+		
+	//cerr &lt;&lt; &quot;fin de section triaxialcompressionEngine = shared_ptr&lt;TriaxialCompressionEngine&gt; (new TriaxialCompressionEngine);&quot; &lt;&lt; std::endl;
+	
+// recording global stress
+	triaxialStateRecorder = shared_ptr&lt;TriaxialStateRecorder&gt;(new
+	TriaxialStateRecorder);
+	triaxialStateRecorder-&gt; outputFile 	= WallStressRecordFile;
+	triaxialStateRecorder-&gt; interval 		= recordIntervalIter;
+	//triaxialStateRecorder-&gt; thickness 		= thickness;
+	
+	
+	// moving walls to regulate the stress applied
+	//cerr &lt;&lt; &quot;triaxialstressController = shared_ptr&lt;TriaxialStressController&gt; (new TriaxialStressController);&quot; &lt;&lt; std::endl;
+	triaxialstressController = shared_ptr&lt;TriaxialStressController&gt; (new TriaxialStressController);
+	triaxialstressController-&gt; stiffnessUpdateInterval = 20;// = recordIntervalIter
+	triaxialstressController-&gt; sigma_iso = sigma_iso;
+	triaxialstressController-&gt; max_vel = 0.0001;
+	triaxialstressController-&gt; thickness = thickness;
+	triaxialstressController-&gt;wall_bottom_activated = false;
+	triaxialstressController-&gt;wall_top_activated = false;	
+		//cerr &lt;&lt; &quot;fin de sezction triaxialstressController = shared_ptr&lt;TriaxialStressController&gt; (new TriaxialStressController);&quot; &lt;&lt; std::endl;
+	
+	rootBody-&gt;engines.clear();
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new PhysicalActionContainerReseter));
+//	rootBody-&gt;engines.push_back(sdecTimeStepper);	
+	rootBody-&gt;engines.push_back(boundingVolumeDispatcher);
+	rootBody-&gt;engines.push_back(shared_ptr&lt;Engine&gt;(new DistantPersistentSAPCollider));
+	rootBody-&gt;engines.push_back(interactionGeometryDispatcher);
+	rootBody-&gt;engines.push_back(interactionPhysicsDispatcher);
+	rootBody-&gt;engines.push_back(cohesiveFrictionalContactLaw);
+	rootBody-&gt;engines.push_back(triaxialcompressionEngine);
+	//rootBody-&gt;engines.push_back(stiffnesscounter);
+	//rootBody-&gt;engines.push_back(stiffnessMatrixTimeStepper);
+	rootBody-&gt;engines.push_back(globalStiffnessCounter);
+	rootBody-&gt;engines.push_back(globalStiffnessTimeStepper);
+	rootBody-&gt;engines.push_back(triaxialStateRecorder);
+	rootBody-&gt;engines.push_back(hydraulicForceEngine);//&lt;-------------HYDRAULIC ENGINE HERE
+	rootBody-&gt;engines.push_back(actionDampingDispatcher);
+	rootBody-&gt;engines.push_back(applyActionDispatcher);
+	rootBody-&gt;engines.push_back(positionIntegrator);
+	if(!rotationBlocked)
+		rootBody-&gt;engines.push_back(orientationIntegrator);
+	//rootBody-&gt;engines.push_back(resultantforceEngine);
+	//rootBody-&gt;engines.push_back(triaxialstressController);
+	
+		
+	//rootBody-&gt;engines.push_back(averagePositionRecorder);
+	//rootBody-&gt;engines.push_back(velocityRecorder);
+	//rootBody-&gt;engines.push_back(forcerec);
+	
+	if (saveAnimationSnapshots) {
+	shared_ptr&lt;PositionOrientationRecorder&gt; positionOrientationRecorder(new PositionOrientationRecorder);
+	positionOrientationRecorder-&gt;outputFile = AnimationSnapshotsBaseName;
+	rootBody-&gt;engines.push_back(positionOrientationRecorder);}
+	
+	rootBody-&gt;initializers.clear();
+	rootBody-&gt;initializers.push_back(physicalActionInitializer);
+	rootBody-&gt;initializers.push_back(boundingVolumeDispatcher);
+	
+}
+
+
+void SnowCreepTest::positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody)
+{
+	rootBody-&gt;isDynamic		= false;
+
+	Quaternionr q;
+	q.FromAxisAngle( Vector3r(0,0,1),0);
+	shared_ptr&lt;ParticleParameters&gt; physics(new ParticleParameters); // FIXME : fix indexable class PhysicalParameters
+	physics-&gt;se3			= Se3r(Vector3r(0,0,0),q);
+	physics-&gt;mass			= 0;
+	physics-&gt;velocity		= Vector3r::ZERO;
+	physics-&gt;acceleration		= Vector3r::ZERO;
+	
+	shared_ptr&lt;MetaInteractingGeometry&gt; set(new MetaInteractingGeometry());
+	
+	set-&gt;diffuseColor		= Vector3r(0,0,1);
+
+	shared_ptr&lt;AABB&gt; aabb(new AABB);
+	aabb-&gt;diffuseColor		= Vector3r(0,0,1);
+	
+	rootBody-&gt;interactingGeometry	= YADE_PTR_CAST&lt;InteractingGeometry&gt;(set);	
+	rootBody-&gt;boundingVolume	= YADE_PTR_CAST&lt;BoundingVolume&gt;(aabb);
+	rootBody-&gt;physicalParameters 	= physics;
+	
+}
+
+
+
+string GenerateCloud(vector&lt;BasicSphere&gt;&amp; sphere_list, Vector3r lowerCorner, Vector3r upperCorner, long number, Real rad_std_dev, Real porosity)
+{
+	typedef boost::minstd_rand StdGenerator;
+	static StdGenerator generator;
+	static boost::variate_generator&lt;StdGenerator&amp;, boost::uniform_real&lt;&gt; &gt;
+			random1(generator, boost::uniform_real&lt;&gt;(0,1));
+        //         static boost::variate_generator&lt;StdGenerator&amp;, boost::normal_distribution&lt;&gt; &gt;
+        //         randomN(generator, boost::normal_distribution&lt;&gt;(aggregateMeanRadius,aggregateSigmaRadius));
+
+	sphere_list.clear();
+	long tries = 1000; //nb of tries for positionning the next sphere
+	Vector3r dimensions = upperCorner - lowerCorner;
+		
+	Real mean_radius = std::pow(dimensions.X()*dimensions.Y()*dimensions.Z()*(1-porosity)/(3.1416*1.3333*number),0.333333);
+        //cerr &lt;&lt; mean_radius;
+
+	std::cerr &lt;&lt; &quot;generating aggregates ... &quot;;
+	
+	long t, i;
+	for (i=0; i&lt;number; ++i) {
+		BasicSphere s;
+		for (t=0; t&lt;tries; ++t) {
+			s.second = (random1()-0.5)*rad_std_dev*mean_radius+mean_radius;
+			s.first.X() = lowerCorner.X()+s.second+(dimensions.X()-2*s.second)*random1();
+			s.first.Y() = lowerCorner.Y()+s.second+(dimensions.Y()-2*s.second)*random1();
+			s.first.Z() = lowerCorner.Z()+s.second+(dimensions.Z()-2*s.second)*random1();
+			bool overlap=false;
+			for (long j=0; (j&lt;i &amp;&amp; !overlap); j++)
+				if ( pow(sphere_list[j].second+s.second, 2) &gt; (sphere_list[j].first-s.first).SquaredLength()) overlap=true;
+			if (!overlap)
+			{
+				sphere_list.push_back(s);
+				break;
+			}			
+		}
+		if (t==tries) return &quot;More than &quot; + lexical_cast&lt;string&gt;(tries) +
+					&quot; tries while generating sphere number &quot; +
+					lexical_cast&lt;string&gt;(i+1) + &quot;/&quot; + lexical_cast&lt;string&gt;(number) + &quot;.&quot;;
+	}
+	return &quot;Generated a sample with &quot; + lexical_cast&lt;string&gt;(number) + &quot;spheres inside box of dimensions: (&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[0]) + &quot;,&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[1]) + &quot;,&quot; 
+			+ lexical_cast&lt;string&gt;(dimensions[2]) + &quot;).&quot;;
+}
+
+
+
+YADE_PLUGIN();

Added: trunk/pkg/dem/PreProcessor/SnowCreepTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/SnowCreepTest.hpp	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/PreProcessor/SnowCreepTest.hpp	2008-04-18 15:58:17 UTC (rev 1328)
@@ -0,0 +1,140 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*  Copyright (C) 2007 by Bruno Chareyre		                         *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">bruno.chareyre at hmg.inpg.fr</A>                                            *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef SNOW_CREEP_TEST_HPP
+#define SNOW_CREEP_TEST_HPP
+
+#include&lt;yade/core/FileGenerator.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class ForceRecorder;
+class AveragePositionRecorder;
+class VelocityRecorder;
+class TriaxialStressController;
+class TriaxialCompressionEngine;
+class TriaxialStateRecorder;
+
+/*! \brief Isotropic compression + uniaxial compression test
+
+	detailed description...
+ */
+
+class SnowCreepTest : public FileGenerator
+{
+	private	:
+		Vector3r	 gravity
+				,lowerCorner
+				,upperCorner;
+
+		Vector3r	 spheresColor;
+
+		Real		 thickness
+				,sphereYoungModulus
+				,spherePoissonRatio
+				,sphereFrictionDeg
+				,normalCohesion
+				,shearCohesion
+				,boxYoungModulus
+				,boxPoissonRatio
+				,boxFrictionDeg
+				,density
+				,dampingForce
+				,dampingMomentum
+				,defaultDt
+				,radiusDeviation
+				,creep_viscosity
+
+// 				,bigBallRadius
+// 				,bigBallDensity
+// 				,bigBallDropTimeSeconds
+// 				,bigBallPoissonRatio
+// 				,bigBallYoungModulus
+// 				,bigBallFrictDeg
+// 				,bigBallDropHeight
+				
+				,sigma_iso
+				,strainRate
+				,StabilityCriterion
+				,maxMultiplier ///max multiplier of diameters during internal compaction
+				,finalMaxMultiplier;
+		 
+		bool		setCohesionOnNewContacts
+				,wall_top
+				,wall_bottom
+				,wall_1
+				,wall_2
+				,wall_3
+				,wall_4
+				,wall_top_wire
+				,wall_bottom_wire
+				,wall_1_wire
+				,wall_2_wire
+				,wall_3_wire
+				,wall_4_wire
+				,autoCompressionActivation
+				,bigBall
+				,rotationBlocked
+				,spheresRandomColor
+				,recordBottomForce
+				,recordAveragePositions
+				,boxWalls
+				,internalCompaction
+				,saveAnimationSnapshots;
+
+		int		 recordIntervalIter
+				,timeStepUpdateInterval
+				,timeStepOutputInterval
+				,wallStiffnessUpdateInterval
+				,radiusControlInterval
+				,numberOfGrains;
+				/*,wall_top_id
+				,wall_bottom_id
+				,wall_left_id
+				,all_right_id
+				,wall_front_id
+				,wall_back_id;*/
+		
+		string		 forceRecordFile
+				,positionRecordFile
+				,velocityRecordFile
+				,importFilename
+				,AnimationSnapshotsBaseName
+				,WallStressRecordFile;
+	
+		shared_ptr&lt;ForceRecorder&gt; forcerec;
+		shared_ptr&lt;VelocityRecorder&gt; velocityRecorder;
+		shared_ptr&lt;AveragePositionRecorder&gt; averagePositionRecorder;
+		shared_ptr&lt;TriaxialCompressionEngine&gt; triaxialcompressionEngine;
+		shared_ptr&lt;TriaxialStressController&gt; triaxialstressController;
+		shared_ptr&lt;TriaxialStateRecorder&gt; triaxialStateRecorder;
+			
+		void createBox(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Vector3r extents,bool wire);
+		void createSphere(shared_ptr&lt;Body&gt;&amp; body, Vector3r position, Real radius,bool dynamic);
+		void createActors(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
+		void positionRootBody(shared_ptr&lt;MetaBody&gt;&amp; rootBody);
+	
+	public : 
+		SnowCreepTest ();
+		~SnowCreepTest ();
+		bool generate();
+	
+	protected :
+		void registerAttributes();
+	REGISTER_CLASS_NAME(SnowCreepTest);
+	REGISTER_BASE_CLASS_NAME(FileGenerator);
+};
+
+REGISTER_SERIALIZABLE(SnowCreepTest,false);
+
+#endif // COHESIVE_TRIAXIAL_TEST_HPP
+

Modified: trunk/pkg/dem/SConscript
===================================================================
--- trunk/pkg/dem/SConscript	2008-04-18 05:57:16 UTC (rev 1327)
+++ trunk/pkg/dem/SConscript	2008-04-18 15:58:17 UTC (rev 1328)
@@ -626,6 +626,54 @@
 			'PositionOrientationRecorder',
 			'Shop']),
 			
+	env.SharedLibrary('SnowCreepTest',
+		['PreProcessor/SnowCreepTest.cpp'],
+		LIBS=env['LIBS']+['SDECLinkGeometry',
+			'CohesiveFrictionalContactLaw',
+			'AveragePositionRecorder',
+			'VelocityRecorder',
+			'ForceRecorder',
+			'CohesiveFrictionalRelationships',
+			'ElasticCriterionTimeStepper',
+			'PhysicalActionVectorVector',
+			'InteractionVecSet',
+			'InteractionHashMap',
+			'BodyRedirectionVector',
+			'InteractingSphere',
+			'InteractingBox',
+			'InteractingSphere2InteractingSphere4DistantSpheresContactGeometry',
+			'InteractingBox2InteractingSphere4SpheresContactGeometry',
+			'CundallNonViscousMomentumDamping',
+			'CundallNonViscousForceDamping',
+			'MetaInteractingGeometry',
+			'GravityEngine',
+			'yade-serialization',
+			'PhysicalActionContainerInitializer',
+			'PhysicalActionContainerReseter',
+			'InteractionGeometryMetaEngine',
+			'InteractionPhysicsMetaEngine',
+			'PhysicalActionApplier',
+			'PhysicalParametersMetaEngine',
+			'BoundingVolumeMetaEngine',
+			'yade-multimethods',
+			'Box',
+			'Sphere',
+			'AABB',
+			'DistantPersistentSAPCollider',
+			'SAPCollider',
+			'MetaInteractingGeometry2AABB',
+			'GlobalStiffness',
+			'GlobalStiffnessCounter',
+			'ResultantForceEngine',
+			'TriaxialStressController',
+			'TriaxialCompressionEngine',
+			'GlobalStiffnessTimeStepper',
+			'yade-base',
+			'Shop',
+			'TriaxialStateRecorder',
+			'PositionOrientationRecorder',
+			'HydraulicForceEngine']),
+
 	env.SharedLibrary('CohesiveTriaxialTest',
 		['PreProcessor/CohesiveTriaxialTest.cpp'],
 		LIBS=env['LIBS']+['SDECLinkGeometry',


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000289.html">[Yade-commits] r1327 - in trunk/pkg: common/Engine/DeusExMachina	dem/Engine/EngineUnit dem/Engine/StandAloneEngine
</A></li>
	<LI>Next message: <A HREF="000291.html">[Yade-commits] r1329 - in trunk: core extra extra/clump extra/tetra	extra/usct gui/cmd lib/QGLViewer lib/serialization	pkg/common/DataClass/PhysicalParameters	pkg/common/Engine/DeusExMachina pkg/common/Engine/MetaEngine	pkg/common/Engine/StandAloneEngine	pkg/dem/DataClass/PhysicalParameters	pkg/dem/Engine/DeusExMachina pkg/dem/Engine/StandAloneEngine	pkg/fem/Engine/StandAloneEngine pkg/lattice/Engine/StandAloneEngine	pkg/mass-spring/Engine/StandAloneEngine	pkg/realtime-rigidbody/Engine/StandAloneEngine
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#290">[ date ]</a>
              <a href="thread.html#290">[ thread ]</a>
              <a href="subject.html#290">[ subject ]</a>
              <a href="author.html#290">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
