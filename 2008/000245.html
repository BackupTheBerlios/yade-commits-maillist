<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1280 - in trunk: lib/serialization pkg/common	pkg/common/Engine/DeusExMachina pkg/common/Engine/MetaEngine	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem	pkg/dem/DataClass/InteractionPhysics	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/dem/RenderingEngine	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1280%20-%20in%20trunk%3A%20lib/serialization%20pkg/common%0A%09pkg/common/Engine/DeusExMachina%20pkg/common/Engine/MetaEngine%0A%09pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%09pkg/common/RenderingEngine/OpenGLRenderingEngine%20pkg/dem%0A%09pkg/dem/DataClass/InteractionPhysics%0A%09pkg/dem/Engine/EngineUnit%20pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20pkg/dem/RenderingEngine%0A%09pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction%0A%09pkg/dem/RenderingEngine/GLDrawElasticContactInteraction%0A%09pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor&In-Reply-To=%3C200803180519.m2I5JZWc000016%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000244.html">
   <LINK REL="Next"  HREF="000246.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1280 - in trunk: lib/serialization pkg/common	pkg/common/Engine/DeusExMachina pkg/common/Engine/MetaEngine	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem	pkg/dem/DataClass/InteractionPhysics	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/dem/RenderingEngine	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor</H1>
    <B>cosurgi at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1280%20-%20in%20trunk%3A%20lib/serialization%20pkg/common%0A%09pkg/common/Engine/DeusExMachina%20pkg/common/Engine/MetaEngine%0A%09pkg/common/RenderingEngine/GLDrawGeometricalModel%0A%09pkg/common/RenderingEngine/OpenGLRenderingEngine%20pkg/dem%0A%09pkg/dem/DataClass/InteractionPhysics%0A%09pkg/dem/Engine/EngineUnit%20pkg/dem/Engine/StandAloneEngine%0A%09pkg/dem/PreProcessor%20pkg/dem/RenderingEngine%0A%09pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction%0A%09pkg/dem/RenderingEngine/GLDrawElasticContactInteraction%0A%09pkg/lattice/Engine/StandAloneEngine%20pkg/lattice/PreProcessor&In-Reply-To=%3C200803180519.m2I5JZWc000016%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1280 - in trunk: lib/serialization pkg/common	pkg/common/Engine/DeusExMachina pkg/common/Engine/MetaEngine	pkg/common/RenderingEngine/GLDrawGeometricalModel	pkg/common/RenderingEngine/OpenGLRenderingEngine pkg/dem	pkg/dem/DataClass/InteractionPhysics	pkg/dem/Engine/EngineUnit pkg/dem/Engine/StandAloneEngine	pkg/dem/PreProcessor pkg/dem/RenderingEngine	pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction	pkg/dem/RenderingEngine/GLDrawElasticContactInteraction	pkg/lattice/Engine/StandAloneEngine pkg/lattice/PreProcessor">cosurgi at mail.berlios.de
       </A><BR>
    <I>Tue Mar 18 06:19:35 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000244.html">[Yade-commits] r1279 - in trunk: . lib
</A></li>
        <LI>Next message: <A HREF="000246.html">[Yade-commits] r1281 - in trunk: . extra gui gui/qt3	pkg/common/Engine/DeusExMachina	pkg/dem/Engine/StandAloneEngine scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#245">[ date ]</a>
              <a href="thread.html#245">[ thread ]</a>
              <a href="subject.html#245">[ subject ]</a>
              <a href="author.html#245">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: cosurgi
Date: 2008-03-18 06:19:31 +0100 (Tue, 18 Mar 2008)
New Revision: 1280

Added:
   trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp
   trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp
   trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp
   trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/
   trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp
   trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.hpp
   trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/
   trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp
   trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.hpp
Modified:
   trunk/lib/serialization/KnownFundamentalsHandler.tpp
   trunk/pkg/common/Engine/DeusExMachina/ForceEngine.cpp
   trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
   trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.cpp
   trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
   trunk/pkg/common/SConscript
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
   trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
   trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
   trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
   trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
   trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp
   trunk/pkg/dem/SConscript
   trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp
   trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
Log:
Moment law.

This commit contains
- lots of useless stuff which will be removed in subsequent commits, like
  * useless variables in CohesiveFrictionalContactInteraction
  * duplicate code in CohesiveFrictionalRelationships
  * lots of unnceseccary commented code in CohesiveFrictionalContactLaw (with the moment law!)
  * duplicate functions in new GLDraw* functors

- The moment law is written in CohesiveFrictionalContactLaw and as far as I
  tested it - it works. To test it I was genereting samples using
  CohesiveTriaxialTest of dimensions 20x1x1 with 20 spheres. I ran the
  simulation to let the sample compress. Then I was saving it, and editing .xml
  by hand: 
   * remove three useless engines: TriaxialCompressionEngine, TriaxialStateRecorder
     and HydraulicForceEngine. 

   * Then move first six bodies far away (the 6 boxes) by changing their Y position
     in se3.

   * Probably set isDynamic flag of one of spheres to 0 (to fix it).

   * Moment law works only if there is a cohesive bond! If you want moment law
     for not cohesive bonds you need to comment out the test if cohesionBroken==false.
     So we need to enable cohesion bo modifying this line:
     &lt;functorArguments _className_=&quot;CohesiveFrictionalRelationships&quot;  
     normalCohesion=&quot;50000000&quot; shearCohesion=&quot;50000000&quot; setCohesionNow=&quot;1&quot; setCohesionOnNewContacts=&quot;0&quot; /&gt;

   * And finally add some other engine like
     &lt;engines _className_=&quot;ForceEngine&quot; subscribedBodies=&quot;[18]&quot; force=&quot;{0 -4000 0}&quot; /&gt;
     or &lt;engines _className_=&quot;MomentEngine&quot;  subscribedBodies=&quot;[6]&quot; moment=&quot;{0 0 100000}&quot; /&gt;

- added GLDrawElasticContactInteraction and GLDrawCohesiveFrictionalContactInteraction
  you can enable them with flags Interaction_physics and Interaction_wire

- modified ForceEngine to work on subscribeBodies

- added MomentEngine and few other engines which I should have committed long time ago.

- fixed KnownFundamentalsHandler, because it wasn't compiling if you tried to
  save quaternions to file. Basically change the case of function calls: x(); into X();



Modified: trunk/lib/serialization/KnownFundamentalsHandler.tpp
===================================================================
--- trunk/lib/serialization/KnownFundamentalsHandler.tpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/lib/serialization/KnownFundamentalsHandler.tpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -109,8 +109,8 @@
 			vector&lt;string&gt; tokens;
 			IOFormatManager::parseFundamental(*tmpStr, tokens);
 		
-			tmp-&gt;x() = lexical_cast&lt;RealType&gt;(tokens[0]);
-			tmp-&gt;y() = lexical_cast&lt;RealType&gt;(tokens[1]);
+			tmp-&gt;X() = lexical_cast&lt;RealType&gt;(tokens[0]);
+			tmp-&gt;Y() = lexical_cast&lt;RealType&gt;(tokens[1]);
 		}
 		else if (a.type()==typeid(const vector&lt;unsigned char&gt;*)) // from binary stream to Type
 		{
@@ -119,8 +119,8 @@
 			static vector&lt;RealType&gt; content;
 			content.clear();
 			binary_to_data(*tmpBin,content);
-			tmp-&gt;x() = content[0];
-			tmp-&gt;y() = content[1];
+			tmp-&gt;X() = content[0];
+			tmp-&gt;Y() = content[1];
 		}
 		else
 			throw HandlerError(SerializationExceptions::ExtraCopyError);
@@ -132,9 +132,9 @@
 			string * tmpStr = any_cast&lt;string*&gt;(a);
 			Vector2&lt;RealType&gt; * tmp = any_cast&lt;Vector2&lt;RealType&gt;*&gt;(ac.getAddress());
 			*tmpStr =	IOFormatManager::getCustomFundamentalOpeningBracket()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;x())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;X())			+
 					IOFormatManager::getCustomFundamentalSeparator()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;y())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;Y())			+
 					IOFormatManager::getCustomFundamentalClosingBracket();
 		}
 		else if (a.type()==typeid(vector&lt;unsigned char&gt;*)) // from Vector2&lt;RealType&gt; to binary stream
@@ -144,8 +144,8 @@
 			(*tmpBin).clear();
 			static vector&lt;RealType&gt; content;
 			content.clear();
-			content.push_back(tmp-&gt;x());
-			content.push_back(tmp-&gt;y());
+			content.push_back(tmp-&gt;X());
+			content.push_back(tmp-&gt;Y());
 			data_to_binary(content,*tmpBin);
 		}
 		else
@@ -230,10 +230,10 @@
 			vector&lt;string&gt; tokens;
 			IOFormatManager::parseFundamental(*tmpStr, tokens);
 		
-			tmp-&gt;x() = lexical_cast&lt;RealType&gt;(tokens[0]);
-			tmp-&gt;y() = lexical_cast&lt;RealType&gt;(tokens[1]);
-			tmp-&gt;z() = lexical_cast&lt;RealType&gt;(tokens[2]);
-			tmp-&gt;w() = lexical_cast&lt;RealType&gt;(tokens[3]);
+			tmp-&gt;X() = lexical_cast&lt;RealType&gt;(tokens[0]);
+			tmp-&gt;Y() = lexical_cast&lt;RealType&gt;(tokens[1]);
+			tmp-&gt;Z() = lexical_cast&lt;RealType&gt;(tokens[2]);
+			tmp-&gt;W() = lexical_cast&lt;RealType&gt;(tokens[3]);
 		}
 		else if (a.type()==typeid(const vector&lt;unsigned char&gt;*)) // from binary stream to Type
 		{
@@ -242,10 +242,10 @@
 			static vector&lt;RealType&gt; content;
 			content.clear();
 			binary_to_data(*tmpBin,content);
-			tmp-&gt;w() = content[0];
-			tmp-&gt;x() = content[1];
-			tmp-&gt;y() = content[2];
-			tmp-&gt;z() = content[3];
+			tmp-&gt;W() = content[0];
+			tmp-&gt;X() = content[1];
+			tmp-&gt;Y() = content[2];
+			tmp-&gt;Z() = content[3];
 		}
 		else
 			throw HandlerError(SerializationExceptions::ExtraCopyError);
@@ -257,13 +257,13 @@
 			string * tmpStr = any_cast&lt;string*&gt;(a);
 			Vector4&lt;RealType&gt; * tmp = any_cast&lt;Vector4&lt;RealType&gt;*&gt;(ac.getAddress());
 			*tmpStr =	IOFormatManager::getCustomFundamentalOpeningBracket()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;x())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;X())			+
 					IOFormatManager::getCustomFundamentalSeparator()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;y())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;Y())			+
 					IOFormatManager::getCustomFundamentalSeparator()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;z())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;Z())			+
 					IOFormatManager::getCustomFundamentalSeparator()	+
-					lexical_cast&lt;string&gt;(tmp-&gt;w())			+
+					lexical_cast&lt;string&gt;(tmp-&gt;W())			+
 					IOFormatManager::getCustomFundamentalClosingBracket();
 		}
 		else if (a.type()==typeid(vector&lt;unsigned char&gt;*)) // from Vector2&lt;RealType&gt; to binary stream
@@ -273,10 +273,10 @@
 			(*tmpBin).clear();
 			static vector&lt;RealType&gt; content;
 			content.clear();
-			content.push_back(tmp-&gt;w());
-			content.push_back(tmp-&gt;x());
-			content.push_back(tmp-&gt;y());
-			content.push_back(tmp-&gt;z());
+			content.push_back(tmp-&gt;W());
+			content.push_back(tmp-&gt;X());
+			content.push_back(tmp-&gt;Y());
+			content.push_back(tmp-&gt;Z());
 			data_to_binary(content,*tmpBin);
 		}
 		else
@@ -596,7 +596,7 @@
 				axis[0] = lexical_cast&lt;RealType&gt;(tokens[0]);
 				axis[1] = lexical_cast&lt;RealType&gt;(tokens[1]);
 				axis[2] = lexical_cast&lt;RealType&gt;(tokens[2]);
-				angle = axis.normalize();
+				angle = axis.Normalize();
 			}
 			else // tokens.size()==4 Quaternion is written as axis angle
 			{
@@ -605,7 +605,7 @@
 				axis[2] = lexical_cast&lt;RealType&gt;(tokens[2]);
 				angle   = lexical_cast&lt;RealType&gt;(tokens[3]);
 			}
-			tmp-&gt;fromAxisAngle(axis,angle);
+			tmp-&gt;FromAxisAngle(axis,angle);
 		}
 		else if (a.type()==typeid(const vector&lt;unsigned char&gt;*)) // from binary stream to Type
 		{
@@ -614,10 +614,10 @@
 			static vector&lt;RealType&gt; content;
 			content.clear();
 			binary_to_data(*tmpBin,content);
-			tmp-&gt;w() = content[0];
-			tmp-&gt;x() = content[1];
-			tmp-&gt;y() = content[2];
-			tmp-&gt;z() = content[3];
+			tmp-&gt;W() = content[0];
+			tmp-&gt;X() = content[1];
+			tmp-&gt;Y() = content[2];
+			tmp-&gt;Z() = content[3];
 		}
 		else
 			throw HandlerError(SerializationExceptions::ExtraCopyError);
@@ -632,8 +632,8 @@
 		
 			RealType angle;
 			Vector3&lt;RealType&gt; axis;
-			tmp-&gt;toAxisAngle(axis,angle);
-			axis.normalize();
+			tmp-&gt;ToAxisAngle(axis,angle);
+			axis.Normalize();
 
 			*tmpStr =	IOFormatManager::getCustomFundamentalOpeningBracket()	+
 					lexical_cast&lt;string&gt;(axis[0])			+
@@ -652,10 +652,10 @@
 			(*tmpBin).clear();
 			static vector&lt;RealType&gt; content;
 			content.clear();
-			content.push_back(tmp-&gt;w());
-			content.push_back(tmp-&gt;x());
-			content.push_back(tmp-&gt;y());
-			content.push_back(tmp-&gt;z());
+			content.push_back(tmp-&gt;W());
+			content.push_back(tmp-&gt;X());
+			content.push_back(tmp-&gt;Y());
+			content.push_back(tmp-&gt;Z());
 			data_to_binary(content,*tmpBin);
 		}
 		else

Added: trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,82 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;DisplacementToForceEngine.hpp&quot;
+#include&lt;yade/core/MetaBody.hpp&gt;
+#include &quot;ParticleParameters.hpp&quot;
+#include &quot;Force.hpp&quot;
+
+DisplacementToForceEngine::DisplacementToForceEngine() : actionParameterForce(new Force), targetForce(Vector3r::ZERO), targetForceMask(Vector3r::ZERO) 
+{
+	direction=1.0;
+	old_direction=1.0;
+	target_length_sq=0;
+	oscillations=1.0;
+}
+
+DisplacementToForceEngine::~DisplacementToForceEngine()
+{
+}
+
+void DisplacementToForceEngine::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		translationAxis.Normalize();
+
+		std::cerr &lt;&lt; &quot;displacement: &quot; &lt;&lt; displacement &lt;&lt; &quot;\n&quot;;
+		std::cerr &lt;&lt; &quot;translationAxis: &quot; &lt;&lt; translationAxis&lt;&lt; &quot;\n&quot;;
+		std::cerr &lt;&lt; &quot;targetForce: &quot; &lt;&lt; targetForce&lt;&lt; &quot;\n&quot;;
+		std::cerr &lt;&lt; &quot;targetForceMask: &quot; &lt;&lt; targetForceMask&lt;&lt; &quot;\n\n&quot;;
+			
+		target_length_sq = targetForce.SquaredLength();
+	}
+}
+
+
+void DisplacementToForceEngine::registerAttributes()
+{
+	DeusExMachina::registerAttributes();
+	REGISTER_ATTRIBUTE(displacement);
+	REGISTER_ATTRIBUTE(translationAxis);
+	REGISTER_ATTRIBUTE(targetForce);
+	REGISTER_ATTRIBUTE(targetForceMask);
+}
+
+
+void DisplacementToForceEngine::applyCondition(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+
+	std::vector&lt;int&gt;::const_iterator ii = subscribedBodies.begin();
+	std::vector&lt;int&gt;::const_iterator iiEnd = subscribedBodies.end();
+
+	for(;ii!=iiEnd;++ii)
+		if( bodies-&gt;exists(*ii) )
+		{
+			Vector3r current_force=static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find( ((*bodies)[*ii])-&gt;getId() , actionParameterForce-&gt;getClassIndex() ).get() )-&gt;force;
+
+			Real current_length_sq = 
+				  (targetForceMask[0] != 0) ? current_force[0]*current_force[0]:0.0 
+				+ (targetForceMask[1] != 0) ? current_force[1]*current_force[1]:0.0 
+				+ (targetForceMask[2] != 0) ? current_force[2]*current_force[2]:0.0
+				;
+			old_direction=direction;
+			direction = (current_force.Dot(targetForce) &gt; 0) ? ( current_length_sq &gt; target_length_sq ? -1.0 : 1.0 ) : 1.0 ;
+			
+			if(old_direction*direction &lt; 0) oscillations+=1.0; else oscillations-=1.0;
+			if(oscillations&lt;1.0) oscillations = 1.0;
+			//if(current_length_sq==0.0) direction=1.0;
+
+			((*bodies)[*ii]-&gt;physicalParameters.get())-&gt;se3.position += displacement*translationAxis*direction/oscillations;
+		}
+		
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/DisplacementToForceEngine.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,43 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef DISPLACEMENT_FORCE_ENGINE_HPP
+#define DISPLACEMENT_FORCE_ENGINE_HPP
+
+#include&lt;yade/core/DeusExMachina.hpp&gt;
+#include&lt;Wm3Vector3.h&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class Force;
+
+class DisplacementToForceEngine : public DeusExMachina
+{
+	private :
+		shared_ptr&lt;Force&gt;	actionParameterForce;
+		Real			target_length_sq,direction,old_direction,oscillations;
+	public :
+		Vector3r		targetForce,targetForceMask;
+		Real			displacement;
+		Vector3r		translationAxis;
+
+		DisplacementToForceEngine();
+		virtual ~DisplacementToForceEngine();
+
+		virtual void applyCondition(Body * body);
+
+	protected :
+		virtual void postProcessAttributes(bool);
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(DisplacementToForceEngine);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+};
+
+REGISTER_SERIALIZABLE(DisplacementToForceEngine,false);
+
+#endif //  DISPLACEMENTENGINE_HPP
+

Added: trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,57 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;FixedOrientationEngine.hpp&quot;
+#include&lt;yade/core/MetaBody.hpp&gt;
+#include&lt;yade/lib-base/yadeWm3Extra.hpp&gt;
+
+FixedOrientationEngine::FixedOrientationEngine()
+{
+	fixedOrientation=Quaternionr(1.0,0.0,0.0,0.0);
+}
+
+void FixedOrientationEngine::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		std::cerr &lt;&lt; &quot;fixedOrientation: &quot; &lt;&lt; fixedOrientation.W() &lt;&lt; &quot; &quot; &lt;&lt; fixedOrientation.X() &lt;&lt; &quot; &quot; &lt;&lt;fixedOrientation.Y() &lt;&lt; &quot; &quot; &lt;&lt;fixedOrientation.Z() &lt;&lt; &quot;\n\n&quot;;
+	}
+}
+
+
+void FixedOrientationEngine::registerAttributes()
+{
+	DeusExMachina::registerAttributes();
+	REGISTER_ATTRIBUTE(fixedOrientation);
+}
+
+
+void FixedOrientationEngine::applyCondition(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+
+	std::vector&lt;int&gt;::const_iterator ii = subscribedBodies.begin();
+	std::vector&lt;int&gt;::const_iterator iiEnd = subscribedBodies.end();
+
+	for(;ii!=iiEnd;++ii)
+		if( bodies-&gt;exists(*ii) )
+			((*bodies)[*ii]-&gt;physicalParameters.get())-&gt;se3.orientation = fixedOrientation;
+
+//	BodyContainer::iterator bi    = bodies-&gt;begin();
+//	BodyContainer::iterator biEnd = bodies-&gt;end();
+//	for( ; bi!=biEnd ; ++bi )
+//	{
+//		shared_ptr&lt;Body&gt; b = *bi;
+//		if(mask[0] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[0] = fixedPosition[0];
+//		if(mask[1] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[1] = fixedPosition[1];
+//		if(mask[2] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[2] = fixedPosition[2];
+//	}
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedOrientationEngine.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,34 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef FIXED_ORIENTATION_ENGINE_HPP
+#define FIXED_ORIENTATION_ENGINE_HPP
+
+#include&lt;yade/core/DeusExMachina.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class FixedOrientationEngine : public DeusExMachina
+{
+	public :
+		Quaternionr fixedOrientation;
+		void applyCondition(Body * body);
+
+		FixedOrientationEngine();
+
+	protected :
+		virtual void postProcessAttributes(bool);
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(FixedOrientationEngine);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+};
+
+REGISTER_SERIALIZABLE(FixedOrientationEngine,false);
+
+#endif //  DISPLACEMENTENGINE_HPP
+

Added: trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,63 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;FixedPositionEngine.hpp&quot;
+#include&lt;yade/core/MetaBody.hpp&gt;
+
+FixedPositionEngine::FixedPositionEngine()
+{
+	fixedPosition=Vector3r(0,0,0);
+	mask=Vector3r(0,0,1);
+}
+
+void FixedPositionEngine::postProcessAttributes(bool deserializing)
+{
+	if(deserializing)
+	{
+		std::cerr &lt;&lt; &quot;fixedPosition: &quot; &lt;&lt; fixedPosition &lt;&lt; &quot;\n&quot;;
+		std::cerr &lt;&lt; &quot;mask: &quot; &lt;&lt; mask &lt;&lt; &quot;\n\n&quot;;
+	}
+}
+
+
+void FixedPositionEngine::registerAttributes()
+{
+//	DeusExMachina::registerAttributes();
+	REGISTER_ATTRIBUTE(fixedPosition);
+	REGISTER_ATTRIBUTE(mask);
+}
+
+
+void FixedPositionEngine::applyCondition(Body * body)
+{
+	MetaBody * ncb = static_cast&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+
+//	std::vector&lt;int&gt;::const_iterator ii = subscribedBodies.begin();
+//	std::vector&lt;int&gt;::const_iterator iiEnd = subscribedBodies.end();
+//
+//	for(;ii!=iiEnd;++ii)
+//		if( bodies-&gt;exists(*ii) )
+//		{
+//			if(mask[0] != 0)  ((*bodies)[*ii]-&gt;physicalParameters.get())-&gt;se3.position[0] = fixedPosition[0];
+//			if(mask[1] != 0)  ((*bodies)[*ii]-&gt;physicalParameters.get())-&gt;se3.position[1] = fixedPosition[1];
+//			if(mask[2] != 0)  ((*bodies)[*ii]-&gt;physicalParameters.get())-&gt;se3.position[2] = fixedPosition[2];
+//		}
+
+	BodyContainer::iterator bi    = bodies-&gt;begin();
+	BodyContainer::iterator biEnd = bodies-&gt;end();
+	for( ; bi!=biEnd ; ++bi )
+	{
+		shared_ptr&lt;Body&gt; b = *bi;
+		if(mask[0] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[0] = fixedPosition[0];
+		if(mask[1] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[1] = fixedPosition[1];
+		if(mask[2] != 0)  (b-&gt;physicalParameters.get())-&gt;se3.position[2] = fixedPosition[2];
+	}
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/FixedPositionEngine.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,34 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef FIXEDPOSITIONENGINE_HPP
+#define FIXEDPOSITIONENGINE_HPP
+
+#include&lt;yade/core/DeusExMachina.hpp&gt;
+#include &lt;Wm3Vector3.h&gt;
+#include&lt;yade/lib-base/yadeWm3.hpp&gt;
+
+class FixedPositionEngine : public DeusExMachina
+{
+	public :
+		Vector3r fixedPosition,mask;
+		void applyCondition(Body * body);
+
+		FixedPositionEngine();
+
+	protected :
+		virtual void postProcessAttributes(bool);
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(FixedPositionEngine);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+};
+
+REGISTER_SERIALIZABLE(FixedPositionEngine,false);
+
+#endif //  DISPLACEMENTENGINE_HPP
+

Modified: trunk/pkg/common/Engine/DeusExMachina/ForceEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/ForceEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/ForceEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -25,6 +25,7 @@
 
 void ForceEngine::registerAttributes()
 {
+	DeusExMachina::registerAttributes();
 	REGISTER_ATTRIBUTE(force);
 }
 
@@ -34,12 +35,17 @@
 	MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
 	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 	
-	BodyContainer::iterator bi    = bodies-&gt;begin();
-	BodyContainer::iterator biEnd = bodies-&gt;end();
-	for( ; bi!=biEnd ; ++bi )
+	std::vector&lt;int&gt;::const_iterator ii = subscribedBodies.begin();
+	std::vector&lt;int&gt;::const_iterator iiEnd = subscribedBodies.end();
+	
+	for( ; ii!=iiEnd ; ++ii )
 	{
-		shared_ptr&lt;Body&gt; b = *bi;
-		static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find( b-&gt;getId() , actionParameterForce-&gt;getClassIndex() ).get() )-&gt;force += force;
+		if(ncb-&gt;bodies-&gt;exists( *ii ))
+		{
+			static_cast&lt;Force*&gt;( ncb-&gt;physicalActions-&gt;find( *ii        , actionParameterForce-&gt;getClassIndex() ).get() )-&gt;force += force;
+		} else {
+			std::cerr &lt;&lt; &quot;ForceEngine: body &quot; &lt;&lt; *ii &lt;&lt; &quot;doesn't exist, cannot apply force.&quot;;
+		}
         }
 }
 

Added: trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/MomentEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,52 @@
+/*************************************************************************
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;MomentEngine.hpp&quot;
+#include &quot;ParticleParameters.hpp&quot;
+#include &quot;Momentum.hpp&quot;
+
+
+#include&lt;yade/core/MetaBody.hpp&gt;
+
+
+MomentEngine::MomentEngine() : actionParameterMoment(new Momentum), moment(Vector3r::ZERO)
+{
+}
+
+MomentEngine::~MomentEngine()
+{
+}
+
+
+void MomentEngine::registerAttributes()
+{
+	DeusExMachina::registerAttributes();
+	REGISTER_ATTRIBUTE(moment);
+}
+
+
+void MomentEngine::applyCondition(Body* body)
+{
+	MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
+	shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
+	
+	std::vector&lt;int&gt;::const_iterator ii = subscribedBodies.begin();
+	std::vector&lt;int&gt;::const_iterator iiEnd = subscribedBodies.end();
+	
+	for( ; ii!=iiEnd ; ++ii )
+	{
+		if(ncb-&gt;bodies-&gt;exists( *ii ))
+		{
+			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( *ii        , actionParameterMoment-&gt;getClassIndex() ).get() )-&gt;momentum += moment;
+		} else {
+			std::cerr &lt;&lt; &quot;MomentEngine: body &quot; &lt;&lt; *ii &lt;&lt; &quot;doesn't exist, cannot apply moment.&quot;;
+		}
+        }
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp
===================================================================
--- trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/DeusExMachina/MomentEngine.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,37 @@
+/*************************************************************************
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef MOMENT_ENGINE_HPP
+#define MOMENT_ENGINE_HPP
+
+#include&lt;yade/core/DeusExMachina.hpp&gt;
+
+class Momentum;
+
+class MomentEngine : public DeusExMachina 
+{
+	private :
+		shared_ptr&lt;Momentum&gt;	actionParameterMoment;
+	public :
+		Vector3r		moment;
+
+		MomentEngine();
+		virtual ~MomentEngine();
+	
+		virtual void applyCondition(Body*);
+	
+	protected :
+		virtual void registerAttributes();
+	REGISTER_CLASS_NAME(MomentEngine);
+	REGISTER_BASE_CLASS_NAME(DeusExMachina);
+};
+
+REGISTER_SERIALIZABLE(MomentEngine,false);
+
+#endif // FORCE_ENGINE_HPP
+

Modified: trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp
===================================================================
--- trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/Engine/MetaEngine/InteractionGeometryMetaEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -42,6 +42,7 @@
 		shared_ptr&lt;Body&gt;&amp; b1 = (*bodies)[interaction-&gt;getId1()];
 		shared_ptr&lt;Body&gt;&amp; b2 = (*bodies)[interaction-&gt;getId2()];
 		
+		bool wasReal = interaction-&gt;isReal;
 		interaction-&gt;isReal =
 			b1-&gt;interactingGeometry &amp;&amp; b2-&gt;interactingGeometry &amp;&amp; // some bodies do not have interactingGeometry
 			// FIXME put this inside VolatileInteractionCriterion dynlib
@@ -49,6 +50,9 @@
 		 	&amp;&amp;
 			operator()( b1-&gt;interactingGeometry , b2-&gt;interactingGeometry , b1-&gt;physicalParameters-&gt;se3 , b2-&gt;physicalParameters-&gt;se3 , interaction );
 
+		if(wasReal==false &amp;&amp; interaction-&gt;isReal)
+			interaction-&gt;isNew=true;
+
 		//tmp
 		if(!(b1-&gt;interactingGeometry&amp;&amp;b2-&gt;interactingGeometry)){
 			cerr&lt;&lt;__FILE__&lt;&lt;&quot;:&quot;&lt;&lt;__LINE__&lt;&lt;&quot;: no interacting geometry &quot;&lt;&lt; (b1-&gt;interactingGeometry?b1-&gt;getId():-1)&lt;&lt;&quot; &quot;&lt;&lt;(b2-&gt;interactingGeometry?b2-&gt;getId():-1)&lt;&lt;endl;

Modified: trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.cpp
===================================================================
--- trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/RenderingEngine/GLDrawGeometricalModel/GLDrawSphere.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -90,6 +90,10 @@
 	
 	glMaterialv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, Vector3f(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2]));
 	glColor3v(gm-&gt;diffuseColor);
+
+// transparent spheres
+//glColor4(gm-&gt;diffuseColor[0],gm-&gt;diffuseColor[1],gm-&gt;diffuseColor[2],0.4);
+
  	if (gm-&gt;wire || wire)
  	{
 		//glScalef(radius,radius,radius);
@@ -125,7 +129,10 @@
 		glDisable(GL_LIGHTING);
 		float vectorY1=radius,startY=vectorY1;
 		float vectorX1=0,startX=vectorX1;
-		glBegin(GL_LINE_STRIP);			
+	glBegin(GL_LINE_STRIP);
+//filled circle (why it doesn't work? in separate small test program - 20 lines - it works)
+//glBegin(GL_TRIANGLE_FAN);
+//glVertex2d(0.0,0.0);
 		for(float angle=0.0f ; angle &lt;= (2.0f*3.14159) ; angle+=0.31f)
 		{		
 			float vectorX=(radius*(float)sin((double)angle));

Modified: trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp
===================================================================
--- trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/RenderingEngine/OpenGLRenderingEngine/OpenGLRenderingEngine.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -116,6 +116,10 @@
 		int a=1;
 		char* b=(char*)&quot;./yade&quot;;
 		glutInit(&amp;a,&amp;b);
+// transparent spheres (still not working)
+//glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH | GLUT_MULTISAMPLE | GLUT_ALPHA);
+//glEnable(GL_BLEND);
+//glBlendFunc(GL_SRC_ALPHA, GL_ONE);
 		initDone=true;
 	}
 #endif

Modified: trunk/pkg/common/SConscript
===================================================================
--- trunk/pkg/common/SConscript	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/common/SConscript	2008-03-18 05:19:31 UTC (rev 1280)
@@ -111,6 +111,14 @@
 		LIBS=env['LIBS']+['yade-base','yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include','DataClass/GeometricalModel']),
 
+	env.SharedLibrary('MomentEngine',
+		['Engine/DeusExMachina/MomentEngine.cpp'],
+		LIBS=env['LIBS']+['yade-base',  'Momentum', 'ParticleParameters'],
+		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
+			'Engine/DeusExMachina',
+			'$PREFIX/include',
+			'DataClass/PhysicalAction']),
+
 	env.SharedLibrary('ForceEngine',
 		['Engine/DeusExMachina/ForceEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base',  'Force', 'ParticleParameters'],
@@ -119,6 +127,23 @@
 			'$PREFIX/include',
 			'DataClass/PhysicalAction']),
 
+	env.SharedLibrary('DisplacementToForceEngine',
+		['Engine/DeusExMachina/DisplacementToForceEngine.cpp'],
+		LIBS=env['LIBS']+['yade-base',
+			
+			'yade-factory',
+			'yade-base',
+
+			'Force',
+			'ParticleParameters',
+			
+			'yade-serialization',
+			'yade-multimethods'],
+		CPPPATH=env['CPPPATH']+['DataClass/PhysicalParameters',
+			'Engine/DeusExMachina',
+			'$PREFIX/include', 
+			'DataClass/PhysicalAction']),
+
 	env.SharedLibrary('GravityEngine',
 		['Engine/DeusExMachina/GravityEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base','Force','ParticleParameters'],
@@ -171,6 +196,29 @@
 			'yade-multimethods'],
 		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/DeusExMachina']),
 
+	env.SharedLibrary('FixedPositionEngine',
+		['Engine/DeusExMachina/FixedPositionEngine.cpp'],
+		LIBS=env['LIBS']+['yade-base',
+			
+			'yade-factory',
+			'yade-base',
+			
+			'yade-serialization',
+			'yade-multimethods'],
+		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/DeusExMachina']),
+
+	env.SharedLibrary('FixedOrientationEngine',
+		['Engine/DeusExMachina/FixedOrientationEngine.cpp'],
+		LIBS=env['LIBS']+['yade-base',
+			
+			'yade-factory',
+			'yade-base',
+			
+			'yade-serialization',
+			'yade-loki',
+			'yade-multimethods'],
+		CPPPATH=env['CPPPATH']+['$PREFIX/include', 'Engine/DeusExMachina']),
+
 	env.SharedLibrary('BoundingVolumeMetaEngine',
 		['Engine/MetaEngine/BoundingVolumeMetaEngine.cpp'],
 		LIBS=env['LIBS']+['yade-base'],

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -17,7 +17,16 @@
 	fragile = true;
 	normalAdhesion = 0;
 	shearAdhesion = 0;
-	
+
+// assign neutral value	
+	orientationToContact1 = Quaternionr(1.0,0.0,0.0,0.0);
+	orientationToContact2 = Quaternionr(1.0,0.0,0.0,0.0);
+	initialOrientation1 = Quaternionr(1.0,0.0,0.0,0.0);
+	initialOrientation2 = Quaternionr(1.0,0.0,0.0,0.0);
+	kr = 0;
+	currentContactOrientation = Quaternionr(1.0,0.0,0.0,0.0);
+	initialContactOrientation = Quaternionr(1.0,0.0,0.0,0.0);
+	initialPosition1=initialPosition2=Vector3r(1,0,0);
 }
 
 void CohesiveFrictionalContactInteraction::SetBreakingState()
@@ -53,6 +62,21 @@
 	REGISTER_ATTRIBUTE(cohesionBroken);
 	REGISTER_ATTRIBUTE(normalAdhesion);
 	REGISTER_ATTRIBUTE(shearAdhesion);
+
+// FIXME where this?
+	REGISTER_ATTRIBUTE(orientationToContact1);
+	REGISTER_ATTRIBUTE(orientationToContact2);
+	REGISTER_ATTRIBUTE(initialOrientation1);
+	REGISTER_ATTRIBUTE(initialOrientation2);
+	REGISTER_ATTRIBUTE(kr);
+	REGISTER_ATTRIBUTE(currentContactOrientation);
+	REGISTER_ATTRIBUTE(initialContactOrientation);
+	REGISTER_ATTRIBUTE(initialPosition1);
+	REGISTER_ATTRIBUTE(initialPosition2);
+//	REGISTER_ATTRIBUTE(prevX1);
+//	REGISTER_ATTRIBUTE(prevX2);
+//	REGISTER_ATTRIBUTE(initX1);
+//	REGISTER_ATTRIBUTE(initX2);
 //		Real		 kn				// normal elastic constant.
 //				,ks				// shear elastic constant.
 //				,initialKn			// initial normal elastic constant.

Modified: trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/DataClass/InteractionPhysics/CohesiveFrictionalContactInteraction.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -21,6 +21,12 @@
 
 		Real		normalAdhesion			// max tensile force
 				,shearAdhesion;			// max shear force (actual max force can include friction too depending on cohesionDisablesFriction)
+
+		Quaternionr	initialOrientation1,initialOrientation2,
+				orientationToContact1,orientationToContact2,
+				currentContactOrientation,initialContactOrientation;
+		Vector3r	initialPosition1,initialPosition2;
+		Real		kr; // rolling stiffness
 	
 		CohesiveFrictionalContactInteraction();
 		virtual ~CohesiveFrictionalContactInteraction();

Modified: trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp
===================================================================
--- trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/Engine/EngineUnit/CohesiveFrictionalRelationships.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -23,6 +23,8 @@
 		setCohesionNow = false;
 		setCohesionOnNewContacts = false;
 		cohesionDefinitionIteration = -1; 
+
+//		elasticRollingLimit = ;
 }
 
 
@@ -35,6 +37,15 @@
 }
 
 
+//
+//
+//
+/// Big WHAT THE FUCK? this code below is duplicated THREE times due to some weird IFs !
+/// need to FIXME that.
+/// but from all my testing it works currently. / janek
+//
+//
+
 void CohesiveFrictionalRelationships::go(	  const shared_ptr&lt;PhysicalParameters&gt;&amp; b1 // CohesiveFrictionalBodyParameters
 					, const shared_ptr&lt;PhysicalParameters&gt;&amp; b2 // CohesiveFrictionalBodyParameters
 					, const shared_ptr&lt;Interaction&gt;&amp; interaction)
@@ -55,6 +66,7 @@
 	{
 		if(interaction-&gt;isNew)
 		{
+//std::cerr &lt;&lt; &quot; isNew, id1: &quot; &lt;&lt; interaction-&gt;getId1() &lt;&lt; &quot; id2: &quot; &lt;&lt; interaction-&gt;getId2()  &lt;&lt; &quot;\n&quot;;
 			interaction-&gt;interactionPhysics = shared_ptr&lt;CohesiveFrictionalContactInteraction&gt;(new CohesiveFrictionalContactInteraction());
 			CohesiveFrictionalContactInteraction* contactPhysics = YADE_CAST&lt;CohesiveFrictionalContactInteraction*&gt;(interaction-&gt;interactionPhysics.get());
 
@@ -73,19 +85,47 @@
 			Real Dinit 	= Da+Db; 			// FIXME - is it just a sum?
 			//Real Sinit 	= Mathr::PI * std::pow( std::min(Da,Db) , 2);
 
-			Real Kn = 2*Ea*Da*Eb*Db/(Ea*Da+Eb*Db);//harmonic average of two stiffnesses
-			Real Ks = 2*Ea*Da*Va*Eb*Db*Vb/(Ea*Da*Va+Eb*Db*Va);//harmonic average of two stiffnesses with ks=V*kn for each sphere
+			Real Kn = 2.0*Ea*Da*Eb*Db/(Ea*Da+Eb*Db);//harmonic average of two stiffnesses
+			Real Ks = 2.0*Ea*Da*Va*Eb*Db*Vb/(Ea*Da*Va+Eb*Db*Va);//harmonic average of two stiffnesses with ks=V*kn for each sphere
 
+			// Jean-Patrick Plassiard, Noura Belhaine, Frederic
+			// Victor Donze, &quot;Calibration procedure for spherical
+			// discrete elements using a local moemnt law&quot;.
+			Real Kr = Da*Db*Ks*2.0; // just like &quot;2.0&quot; above - it's an arbitrary parameter
+
 			contactPhysics-&gt;initialKn			= Kn;
 			contactPhysics-&gt;initialKs			= Ks;
 //cerr &lt;&lt; &quot;Ks: &quot; &lt;&lt;       contactPhysics-&gt;initialKs			&lt;&lt; endl;
 			contactPhysics-&gt;frictionAngle			= std::min(fa,fb); // FIXME - this is actually a waste of memory space, just like initialKs and initialKn
 			contactPhysics-&gt;tangensOfFrictionAngle		= std::tan(contactPhysics-&gt;frictionAngle);
 
-			if ((setCohesionOnNewContacts || setCohesionNow) &amp;&amp; sdec1-&gt;isCohesive &amp;&amp; sdec2-&gt;isCohesive) { 
-			contactPhysics-&gt;cohesionBroken = false;
-			contactPhysics-&gt;normalAdhesion			= normalCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);
-			contactPhysics-&gt;shearAdhesion			= shearCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);;
+			if ((setCohesionOnNewContacts || setCohesionNow) &amp;&amp; sdec1-&gt;isCohesive &amp;&amp; sdec2-&gt;isCohesive) 
+			{
+				contactPhysics-&gt;cohesionBroken = false;
+				contactPhysics-&gt;normalAdhesion			= normalCohesion*pow(std::min(Db, Da),2);
+				contactPhysics-&gt;shearAdhesion			= shearCohesion*pow(std::min(Db, Da),2);;
+			
+				// FIXME - not sure: do I need to repeat it here [1] ?
+				contactPhysics-&gt;initialOrientation1	= sdec1-&gt;se3.orientation;
+				contactPhysics-&gt;initialOrientation2	= sdec2-&gt;se3.orientation;
+				contactPhysics-&gt;initialPosition1    = sdec1-&gt;se3.position;
+				contactPhysics-&gt;initialPosition2    = sdec2-&gt;se3.position;
+				contactPhysics-&gt;kr = Kr;
+				contactPhysics-&gt;initialContactOrientation.Align(Vector3r(1.0,0.0,0.0),interactionGeometry-&gt;normal);
+				contactPhysics-&gt;currentContactOrientation = contactPhysics-&gt;initialContactOrientation;
+				contactPhysics-&gt;orientationToContact1   = contactPhysics-&gt;initialOrientation1.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+				contactPhysics-&gt;orientationToContact2	= contactPhysics-&gt;initialOrientation2.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+
+
+//if((interaction-&gt;getId1()==7 &amp;&amp; interaction-&gt;getId2()==12)||(interaction-&gt;getId1()==12 &amp;&amp; interaction-&gt;getId2()==7)){
+//Vector3r axis0;
+//Real angle0;
+//contactPhysics-&gt;initialRelativeOrientation.ToAxisAngle(axis0,angle0);
+//std::cout &lt;&lt; &quot;-----------------------\n&quot;
+//                                               &lt;&lt; &quot; ax0: &quot; &lt;&lt;  axis0[0] &lt;&lt; &quot; &quot; &lt;&lt; axis0[1] &lt;&lt; &quot; &quot; &lt;&lt; axis0[2] &lt;&lt; &quot; an0: &quot; &lt;&lt; angle0 &lt;&lt; &quot;\n&quot;;
+//}
+
+				//contactPhysics-&gt;elasticRollingLimit = elasticRollingLimit;
 			}
 
 			contactPhysics-&gt;prevNormal 			= interactionGeometry-&gt;normal;
@@ -95,19 +135,54 @@
 			contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
 			contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
 
+			// FIXME - or here [1] ?
+			contactPhysics-&gt;initialOrientation1	= sdec1-&gt;se3.orientation;
+			contactPhysics-&gt;initialOrientation2	= sdec2-&gt;se3.orientation;
+			contactPhysics-&gt;initialPosition1    = sdec1-&gt;se3.position;
+			contactPhysics-&gt;initialPosition2    = sdec2-&gt;se3.position;
+			contactPhysics-&gt;kr = Kr;
+			contactPhysics-&gt;initialContactOrientation.Align(Vector3r(1.0,0.0,0.0),interactionGeometry-&gt;normal);
+			contactPhysics-&gt;currentContactOrientation = contactPhysics-&gt;initialContactOrientation;
+			contactPhysics-&gt;orientationToContact1   = contactPhysics-&gt;initialOrientation1.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+			contactPhysics-&gt;orientationToContact2	= contactPhysics-&gt;initialOrientation2.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+			//contactPhysics-&gt;elasticRollingLimit = elasticRollingLimit;
+			//
 		}
-		else
-		{	// FIXME - are those lines necessary ???? what they are doing in fact ???
+		else // !isNew
+		{	
+			// FIXME - are those lines necessary ???? what they are doing in fact ???
+			// ANSWER - they are used when you setCohesionNow (contact isNew not)
 			CohesiveFrictionalContactInteraction* contactPhysics = YADE_CAST&lt;CohesiveFrictionalContactInteraction*&gt;(interaction-&gt;interactionPhysics.get());
 
 			contactPhysics-&gt;kn = contactPhysics-&gt;initialKn;
 			contactPhysics-&gt;ks = contactPhysics-&gt;initialKs;
 			contactPhysics-&gt;equilibriumDistance = contactPhysics-&gt;initialEquilibriumDistance;
-			if (setCohesionNow &amp;&amp; sdec1-&gt;isCohesive &amp;&amp; sdec2-&gt;isCohesive) { 
-			contactPhysics-&gt;cohesionBroken = false;
-			contactPhysics-&gt;normalAdhesion			= normalCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);
-			contactPhysics-&gt;shearAdhesion			= shearCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);
-			//setCohesionNow = false;
+
+			if (setCohesionNow &amp;&amp; sdec1-&gt;isCohesive &amp;&amp; sdec2-&gt;isCohesive) 
+			{ 
+				contactPhysics-&gt;cohesionBroken = false;
+				contactPhysics-&gt;normalAdhesion			= normalCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);
+				contactPhysics-&gt;shearAdhesion			= shearCohesion*pow(std::min(interactionGeometry-&gt;radius2, interactionGeometry-&gt;radius1),2);
+				//setCohesionNow = false;
+
+			contactPhysics-&gt;initialOrientation1 = sdec1-&gt;se3.orientation;
+			contactPhysics-&gt;initialOrientation2 = sdec2-&gt;se3.orientation;
+			contactPhysics-&gt;initialPosition1    = sdec1-&gt;se3.position;
+			contactPhysics-&gt;initialPosition2    = sdec2-&gt;se3.position;
+			Real Da 	= interactionGeometry-&gt;radius1; // FIXME - multiply by factor of sphere interaction distance (so sphere interacts at bigger range that its geometrical size)
+			Real Db 	= interactionGeometry-&gt;radius2; // FIXME - as above
+			Real Kr = Da*Db*contactPhysics-&gt;ks*2.0; // just like &quot;2.0&quot; above - it's an arbitrary parameter
+			contactPhysics-&gt;kr = Kr;
+			contactPhysics-&gt;initialContactOrientation.Align(Vector3r(1.0,0.0,0.0),interactionGeometry-&gt;normal);
+			contactPhysics-&gt;currentContactOrientation = contactPhysics-&gt;initialContactOrientation;
+			contactPhysics-&gt;orientationToContact1   = contactPhysics-&gt;initialOrientation1.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+			contactPhysics-&gt;orientationToContact2	= contactPhysics-&gt;initialOrientation2.Conjugate() * contactPhysics-&gt;initialContactOrientation;
+//Vector3r axis0;
+//Real angle0;
+//contactPhysics-&gt;initialRelativeOrientation.ToAxisAngle(axis0,angle0);
+//std::cout &lt;&lt; &quot;id1: &quot; &lt;&lt; interaction-&gt;getId1() &lt;&lt; &quot; id2: &quot; &lt;&lt; interaction-&gt;getId2() &lt;&lt; &quot; | &quot;
+//                                               &lt;&lt; &quot; ax0: &quot; &lt;&lt;  axis0[0] &lt;&lt; &quot; &quot; &lt;&lt; axis0[1] &lt;&lt; &quot; &quot; &lt;&lt; axis0[2] &lt;&lt; &quot;, an0: &quot; &lt;&lt; angle0 &lt;&lt; &quot;\n&quot;;
+				//contactPhysics-&gt;elasticRollingLimit = elasticRollingLimit;
 			}
 		}	
 		

Modified: trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp
===================================================================
--- trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/Engine/StandAloneEngine/CohesiveFrictionalContactLaw.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -40,20 +40,31 @@
 	REGISTER_ATTRIBUTE(detectBrokenBodies);
 }
 
+void out(Quaternionr q)
+{
+	Vector3r axis;
+	Real angle;
+	q.ToAxisAngle(axis,angle);
+	std::cout &lt;&lt; &quot; axis: &quot; &lt;&lt;  axis[0] &lt;&lt; &quot; &quot; &lt;&lt; axis[1] &lt;&lt; &quot; &quot; &lt;&lt; axis[2] &lt;&lt; &quot;, angle: &quot; &lt;&lt; angle &lt;&lt; &quot; | &quot;;
+}
 
-//FIXME : remove bool first !!!!!
+void outv(Vector3r axis)
+{
+	std::cout &lt;&lt; &quot; axis: &quot; &lt;&lt;  axis[0] &lt;&lt; &quot; &quot; &lt;&lt; axis[1] &lt;&lt; &quot; &quot; &lt;&lt; axis[2] &lt;&lt; &quot;, length: &quot; &lt;&lt; axis.Length() &lt;&lt; &quot; | &quot;;
+}
+
 void CohesiveFrictionalContactLaw::action(Body* body)
 {
     MetaBody * ncb = YADE_CAST&lt;MetaBody*&gt;(body);
     shared_ptr&lt;BodyContainer&gt;&amp; bodies = ncb-&gt;bodies;
 
     Real dt = Omega::instance().getTimeStep();
-    static long ncount = 0;//REMOVE
-    ncount = 0;
+//    static long ncount = 0;//REMOVE
+//    ncount = 0;
 
     ///Reset the isBroken flag
     //if (iter != Omega::instance().getCurrentIteration())
-    // {
+    //
     if (detectBrokenBodies)
     {
         BodyContainer::iterator bi    = bodies-&gt;begin();
@@ -74,13 +85,17 @@
     InteractionContainer::iterator iiEnd = ncb-&gt;transientInteractions-&gt;end();
     for (  ; ii!=iiEnd ; ++ii )
     {
-
-
         //if ((*ii)-&gt;interactionGeometry &amp;&amp; (*ii)-&gt;interactionPhysics)
         if ((*ii)-&gt;isReal)
         {
-
-            if (detectBrokenBodies &amp;&amp; (*bodies)[(*ii)-&gt;getId1()]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot;  &amp;&amp; (*bodies)[(*ii)-&gt;getId2()]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot;)
+            if (detectBrokenBodies 
+		    /* FIXME - this had no effect. InteractingBox has its isBroken=false too.
+		     *
+		     * FIXME - got to replace this with a working test.
+		     *
+		     * &amp;&amp; (*bodies)[(*ii)-&gt;getId1()]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot;  
+		     * &amp;&amp; (*bodies)[(*ii)-&gt;getId2()]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot; */
+		    )
             {
                 YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[(*ii)-&gt;getId1()]-&gt;physicalParameters.get())-&gt;isBroken = false;
                 YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[(*ii)-&gt;getId2()]-&gt;physicalParameters.get())-&gt;isBroken = false;
@@ -93,23 +108,26 @@
             if ( !( (*bodies)[id1]-&gt;getGroupMask() &amp; (*bodies)[id2]-&gt;getGroupMask() &amp; sdecGroupMask)  )
                 continue; // skip other groups,
 
-            CohesiveFrictionalBodyParameters* de1 				= YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[id1]-&gt;physicalParameters.get());
-            CohesiveFrictionalBodyParameters* de2 				= YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
+            CohesiveFrictionalBodyParameters* de1 			= YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[id1]-&gt;physicalParameters.get());
+            CohesiveFrictionalBodyParameters* de2 			= YADE_CAST&lt;CohesiveFrictionalBodyParameters*&gt;((*bodies)[id2]-&gt;physicalParameters.get());
             SpheresContactGeometry* currentContactGeometry		= YADE_CAST&lt;SpheresContactGeometry*&gt;(contact-&gt;interactionGeometry.get());
-            CohesiveFrictionalContactInteraction* currentContactPhysics   	= YADE_CAST&lt;CohesiveFrictionalContactInteraction*&gt; (contact-&gt;interactionPhysics.get());
+            CohesiveFrictionalContactInteraction* currentContactPhysics = YADE_CAST&lt;CohesiveFrictionalContactInteraction*&gt; (contact-&gt;interactionPhysics.get());
 
-
-
-
             Vector3r&amp; shearForce 			= currentContactPhysics-&gt;shearForce;
 
             if (contact-&gt;isNew)
                 shearForce			= Vector3r::ZERO;
 
             Real un 				= currentContactGeometry-&gt;penetrationDepth;
-            currentContactPhysics-&gt;normalForce	= currentContactPhysics-&gt;kn*un*currentContactGeometry-&gt;normal;
-            if (un &lt; 0 &amp;&amp; (currentContactPhysics-&gt;normalForce.SquaredLength() &gt; pow(currentContactPhysics-&gt;normalAdhesion,2) || currentContactPhysics-&gt;normalAdhesion==0))
-            {
+            Real Fn				= currentContactPhysics-&gt;kn*un;
+            currentContactPhysics-&gt;normalForce	= Fn*currentContactGeometry-&gt;normal;
+            if (   un &lt; 0 
+		&amp;&amp; (   currentContactPhysics-&gt;normalForce.SquaredLength() &gt; pow(currentContactPhysics-&gt;normalAdhesion,2) 
+		    || currentContactPhysics-&gt;normalAdhesion==0
+		   )
+	       )
+            { // BREAK due to tension
+
                 //currentContactPhysics-&gt;SetBreakingState();
                 //if (currentContactPhysics-&gt;cohesionBroken) {
                 //cerr &lt;&lt; &quot;broken&quot; &lt;&lt; endl;
@@ -118,57 +136,147 @@
                 currentContactPhysics-&gt;cohesionBroken = true;
                 currentContactPhysics-&gt;normalForce = Vector3r::ZERO;
                 currentContactPhysics-&gt;shearForce = Vector3r::ZERO;
+
                 //return;
-                //                         } else
-                //                                 currentContactPhysics-&gt;normalForce	= -currentContactPhysics-&gt;normalAdhesion*currentContactGeometry-&gt;normal;
+                //    } else
+                //    currentContactPhysics-&gt;normalForce	= -currentContactPhysics-&gt;normalAdhesion*currentContactGeometry-&gt;normal;
             }
             else
             {
 
-                Vector3r axis;
-                Real angle;
+/* ORIG */                Vector3r axis;
+/* ORIG */                Real angle;
+/* ORIG */
+/* ORIG */                /// Here is the code with approximated rotations 	 ///
+/* ORIG */
+/* ORIG */		axis	 		= currentContactPhysics-&gt;prevNormal.Cross(currentContactGeometry-&gt;normal);
+/* ORIG */		shearForce 	       -= shearForce.Cross(axis);
+/* ORIG */		angle 			= dt*0.5*currentContactGeometry-&gt;normal.Dot(de1-&gt;angularVelocity+de2-&gt;angularVelocity);
+/* ORIG */		axis 			= angle*currentContactGeometry-&gt;normal;
+/* ORIG */		shearForce 	       -= shearForce.Cross(axis);
+/* ORIG */
+/* ORIG */                /// Here is the code with exact rotations 		 ///
+/* ORIG */
+/* ORIG */                // 		Quaternionr q;
+/* ORIG */                //
+/* ORIG */                // 		axis					= currentContactPhysics-&gt;prevNormal.cross(currentContactGeometry-&gt;normal);
+/* ORIG */                // 		angle					= acos(currentContactGeometry-&gt;normal.dot(currentContactPhysics-&gt;prevNormal));
+/* ORIG */                // 		q.fromAngleAxis(angle,axis);
+/* ORIG */                //
+/* ORIG */                // 		currentContactPhysics-&gt;shearForce	= currentContactPhysics-&gt;shearForce*q;
+/* ORIG */                //
+/* ORIG */                // 		angle					= dt*0.5*currentContactGeometry-&gt;normal.dot(de1-&gt;angularVelocity+de2-&gt;angularVelocity);
+/* ORIG */                // 		axis					= currentContactGeometry-&gt;normal;
+/* ORIG */                // 		q.fromAngleAxis(angle,axis);
+/* ORIG */                // 		currentContactPhysics-&gt;shearForce	= q*currentContactPhysics-&gt;shearForce;
+/* ORIG */
+/* ORIG */                /// 							 ///
+/* ORIG */
+/* ORIG */                Vector3r x				= currentContactGeometry-&gt;contactPoint;
+/* ORIG */                //Vector3r c1x				= (x - de1-&gt;se3.position);
+/* ORIG */                //Vector3r c2x				= (x - de2-&gt;se3.position);
+/* ORIG */                /// The following definition of c1x and c2x is to avoid &quot;granular ratcheting&quot; 
+/* ORIG */		///  (see F. ALONSO-MARROQUIN, R. GARCIA-ROJO, H.J. HERRMANN, 
+/* ORIG */		///   &quot;Micro-mechanical investigation of granular ratcheting, in Cyclic Behaviour of Soils and Liquefaction Phenomena&quot;,
+/* ORIG */		///   ed. T. Triantafyllidis (Balklema, London, 2004), p. 3-10 - and a lot more papers from the same authors)
+/* BRUNO's ERROR was here*/                Vector3r c1x	= currentContactGeometry-&gt;radius1*currentContactGeometry-&gt;normal;
+/* BRUNO's ERROR was here*/                Vector3r c2x	= -currentContactGeometry-&gt;radius2*currentContactGeometry-&gt;normal;
+/* ORIG */                Vector3r relativeVelocity		= (de2-&gt;velocity+de2-&gt;angularVelocity.Cross(c2x)) - (de1-&gt;velocity+de1-&gt;angularVelocity.Cross(c1x));
+/* ORIG */                Vector3r shearVelocity			= relativeVelocity-currentContactGeometry-&gt;normal.Dot(relativeVelocity)*currentContactGeometry-&gt;normal;
+/* ORIG */                Vector3r shearDisplacement		= shearVelocity*dt;
+/* ORIG */
+/* ORIG */
+/* ORIG *////////////////////////// CREEP START ///////////////////////////
+/* ORIG *///	Real    viscosity = 300000.0;
+/* ORIG *///	shearForce                            -= currentContactPhysics-&gt;ks*(shearDisplacement + shearForce*dt/viscosity);
+/* ORIG */
+/* ORIG */shearForce 			       -= currentContactPhysics-&gt;ks*shearDisplacement;
+/* ORIG *////////////////////////// CREEP END /////////////////////////////
 
-                /// Here is the code with approximated rotations 	 ///
+//DEBUGGING// if((id1==22 &amp;&amp; id2==6)){
+//DEBUGGING// std::cout.precision(17);
+//DEBUGGING// std::cout &lt;&lt; &quot;shearForce: &quot; &lt;&lt; shearForce &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;shearDisplacement: &quot; &lt;&lt; shearDisplacement &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;relativeVelocity: &quot; &lt;&lt; relativeVelocity &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;velocity1: &quot; &lt;&lt; de1-&gt;velocity &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;velocity2: &quot; &lt;&lt; de2-&gt;velocity &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;angularVelocity1: &quot; &lt;&lt; de1-&gt;angularVelocity &lt;&lt; &quot; &quot;;
+//DEBUGGING// std::cout &lt;&lt; &quot;angularVelocity2: &quot; &lt;&lt; de2-&gt;angularVelocity &lt;&lt; &quot; &quot;;
+//DEBUGGING// }
 
-                axis	 		= currentContactPhysics-&gt;prevNormal.Cross(currentContactGeometry-&gt;normal);
-                shearForce 	       -= shearForce.Cross(axis);
-                angle 			= dt*0.5*currentContactGeometry-&gt;normal.Dot(de1-&gt;angularVelocity+de2-&gt;angularVelocity);
-                axis 			= angle*currentContactGeometry-&gt;normal;
-                shearForce 	       -= shearForce.Cross(axis);
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//{
+//		Vector3r axis;//,axis1,axis2;
+//		Real angle,shearDisplacement;//,angle1,angle2;
+//		Quaternionr shear1(de1-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation1.Conjugate());
+//		Quaternionr shear2(de2-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation2.Conjugate());
+//		Quaternionr shearDelta( shear1 * shear2);
+//		//shear1.ToAxisAngle(axis1,angle1);
+//		//shear1.ToAxisAngle(axis2,angle2);
+//		//if(angle1 &gt; Mathr::PI) angle1 -= Mathr::TWO_PI;
+//		//if(angle2 &gt; Mathr::PI) angle2 -= Mathr::TWO_PI;
+//		shearDelta.ToAxisAngle(axis,angle);
+//		if(angle &gt; Mathr::PI) angle -= Mathr::TWO_PI;
+//		//angle1 *= currentContactGeometry-&gt;radius1;
+//		//angle2 *= currentContactGeometry-&gt;radius2;
+//		shearDisplacement = angle * std::min(currentContactGeometry-&gt;radius1,currentContactGeometry-&gt;radius2);//angle1+angle2;
+//		Vector3r shearForceXX = -currentContactPhysics-&gt;ks*axis.Cross(currentContactGeometry-&gt;normal)*shearDisplacement;
+//
+//if((id1==22 &amp;&amp; id2==6)){
+//std::cerr /*&lt;&lt; &quot;axis1: &quot; &lt;&lt; axis1 &lt;&lt; &quot; axis2: &quot; &lt;&lt; axis2*/ &lt;&lt; &quot; axis: &quot; &lt;&lt; axis &lt;&lt; &quot;\n&quot;;
+//std::cerr &lt;&lt; &quot;shearDisplacement: &quot; &lt;&lt; shearDisplacement &lt;&lt; &quot; angle: &quot; &lt;&lt; angle /*&lt;&lt; &quot; angle2: &quot; &lt;&lt; angle2*/ &lt;&lt; &quot;\n&quot;;
+//std::cerr &lt;&lt; &quot;shearForce  : &quot; &lt;&lt; shearForce &lt;&lt;   &quot; length: &quot; &lt;&lt; shearForce.Length() &lt;&lt; &quot;\n&quot;;
+//std::cerr &lt;&lt; &quot;shearForceXX: &quot; &lt;&lt; shearForceXX &lt;&lt; &quot; length: &quot; &lt;&lt; shearForceXX.Length() &lt;&lt; &quot;\n\n&quot;;
+//}
+//}
+//
+//Vector3r contactPointsSpringForce;
+//{
+//	Quaternionr curr1(de1-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact1);
+//	Quaternionr curr2(de2-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact2);
+//	Vector3r initialContactPoint1(de1-&gt;se3.position + curr1*Vector3r(     currentContactGeometry-&gt;radius1,0,0) );
+//	Vector3r initialContactPoint2(de2-&gt;se3.position + curr2*Vector3r(-1.0*currentContactGeometry-&gt;radius2,0,0) );
+//	Vector3r contactDist( initialContactPoint2 - initialContactPoint1 );
+//
+//	Vector3r contactDir(contactDist); contactDir.Normalize();
+//	//Vector3r shearDir(shearForce); shearDir.Normalize();
+//	//Vector3r contactShearDisplacement( shearDir * shearDir.Dot(contactDir) * contactDist.Length() );
+//	//Vector3r contactNormalDisplacement( contactDist - contactShearDisplacement );
+//	//contactPointsSpringForce=(contactShearDisplacement+contactNormalDisplacement) * currentContactPhysics-&gt;ks;
+//	//contactPointsSpringForce= contactDist * currentContactPhysics-&gt;ks;
+//	
+//	Vector3r contactNormalDisplacement(currentContactGeometry-&gt;normal * currentContactGeometry-&gt;normal.Dot(contactDir) * contactDist.Length());
+//	Vector3r contactShearDisplacement(contactDist - contactNormalDisplacement);
+//	contactPointsSpringForce=contactShearDisplacement * currentContactPhysics-&gt;ks;// - contactNormalDisplacement*currentContactPhysics-&gt;kn;
+//
+////if((id1==22 &amp;&amp; id2==6)){
+////std::cerr &lt;&lt; &quot;contactPointsSpringForce: &quot; &lt;&lt; contactPointsSpringForce &lt;&lt; &quot; length:&quot; &lt;&lt; contactPointsSpringForce.Length() &lt;&lt; &quot;\n&quot;;
+////std::cerr &lt;&lt; &quot;shearForce              : &quot; &lt;&lt; shearForce       &lt;&lt; &quot; length:&quot; &lt;&lt; shearForce      .Length() &lt;&lt; &quot;\n&quot;;
+////std::cerr &lt;&lt; &quot;shearForce - cpSpringF  : &quot; &lt;&lt; Vector3r(shearForce - contactPointsSpringForce) &lt;&lt; &quot; length:&quot; &lt;&lt; (shearForce - contactPointsSpringForce).Length() &lt;&lt; &quot;\n\n&quot;;
+////std::cerr &lt;&lt; contactDist * currentContactPhysics-&gt;ks &lt;&lt; &quot;\n&quot; &lt;&lt; contactPointsSpringForce &lt;&lt; &quot;\n\n&quot;;
+////}
+//}
 
-                /// Here is the code with exact rotations 		 ///
+//Vector3r WhatTheFuckForce(   de1-&gt;se3.position - currentContactPhysics-&gt;initialPosition1 
+//                           - de2-&gt;se3.position + currentContactPhysics-&gt;initialPosition2 );
+//WhatTheFuckForce *= currentContactPhysics-&gt;ks;
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////
 
-                // 		Quaternionr q;
-                //
-                // 		axis					= currentContactPhysics-&gt;prevNormal.cross(currentContactGeometry-&gt;normal);
-                // 		angle					= acos(currentContactGeometry-&gt;normal.dot(currentContactPhysics-&gt;prevNormal));
-                // 		q.fromAngleAxis(angle,axis);
-                //
-                // 		currentContactPhysics-&gt;shearForce	= currentContactPhysics-&gt;shearForce*q;
-                //
-                // 		angle					= dt*0.5*currentContactGeometry-&gt;normal.dot(de1-&gt;angularVelocity+de2-&gt;angularVelocity);
-                // 		axis					= currentContactGeometry-&gt;normal;
-                // 		q.fromAngleAxis(angle,axis);
-                // 		currentContactPhysics-&gt;shearForce	= q*currentContactPhysics-&gt;shearForce;
-
-                /// 							 ///
-
-                Vector3r x				= currentContactGeometry-&gt;contactPoint;
-                //Vector3r c1x				= (x - de1-&gt;se3.position);
-                //Vector3r c2x				= (x - de2-&gt;se3.position);
-                ///The following definition of c1x and c2x is to avoid &quot;granular ratcheting&quot; (see F. ALONSO-MARROQUIN, R. GARCIA-ROJO, H.J. HERRMANN, Micro-mechanical investigation of granular ratcheting, in Cyclic Behaviour of Soils and Liquefaction Phenomena, ed. T. Triantafyllidis (Balklema, London, 2004), p. 3-10 - and a lot more papers from the same authors)
-                Vector3r c1x	= -currentContactGeometry-&gt;radius1*currentContactGeometry-&gt;normal;
-                Vector3r c2x	= currentContactGeometry-&gt;radius2*currentContactGeometry-&gt;normal;
-                Vector3r relativeVelocity		= (de2-&gt;velocity+de2-&gt;angularVelocity.Cross(c2x)) - (de1-&gt;velocity+de1-&gt;angularVelocity.Cross(c1x));
-                Vector3r shearVelocity			= relativeVelocity-currentContactGeometry-&gt;normal.Dot(relativeVelocity)*currentContactGeometry-&gt;normal;
-                Vector3r shearDisplacement		= shearVelocity*dt;
-                shearForce 			       -= currentContactPhysics-&gt;ks*shearDisplacement;
-                //  cerr &lt;&lt; &quot;shearForce0 = &quot; &lt;&lt; shearForce &lt;&lt; endl;
+                //  cerr &lt;&lt; &quot;shearForce = &quot; &lt;&lt; shearForce &lt;&lt; endl;
                 Real maxFs = 0;
-                Real Fn = currentContactPhysics-&gt;kn*un;
                 Real Fs = currentContactPhysics-&gt;shearForce.Length();
                 //if (!currentContactPhysics-&gt;cohesionBroken) {
-                maxFs = max((Real) 0, currentContactPhysics-&gt;shearAdhesion + Fn*currentContactPhysics-&gt;tangensOfFrictionAngle);
+                maxFs = std::max((Real) 0, currentContactPhysics-&gt;shearAdhesion + Fn*currentContactPhysics-&gt;tangensOfFrictionAngle);
                 // if (!currentContactPhysics-&gt;cohesionDisablesFriction)
                 //         maxFs += Fn * currentContactPhysics-&gt;tangensOfFrictionAngle;
                 //} else
@@ -176,14 +284,19 @@
                 //  cerr &lt;&lt; &quot;maxFs = &quot; &lt;&lt; maxFs &lt;&lt; &quot;     Fs = &quot; &lt;&lt; Fs&lt;&lt; endl;
                 if ( Fs  &gt; maxFs )
                 {
-                    currentContactPhysics-&gt;cohesionBroken = true;
+			currentContactPhysics-&gt;cohesionBroken = true;
+
                     // brokenStatus[
-                    //if (currentContactPhysics-&gt;fragile &amp;&amp; !currentContactPhysics-&gt;cohesionBroken) {
-                    currentContactPhysics-&gt;SetBreakingState();
+                    //if (currentContactPhysics-&gt;fragile &amp;&amp; !currentContactPhysics-&gt;cohesionBroken)
+		    
+			currentContactPhysics-&gt;SetBreakingState();
+
                     //     maxFs = currentContactPhysics-&gt;shearAdhesion;
                     //    if (!currentContactPhysics-&gt;cohesionDisablesFriction &amp;&amp; un&gt;0)
                     //         maxFs += Fn * currentContactPhysics-&gt;tangensOfFrictionAngle;
+
                     maxFs = max((Real) 0, Fn * currentContactPhysics-&gt;tangensOfFrictionAngle);
+
                     //cerr &lt;&lt; &quot;currentContactPhysics-&gt;tangensOfFrictionAngle = &quot; &lt;&lt; currentContactPhysics-&gt;tangensOfFrictionAngle &lt;&lt; endl;
                     // cerr &lt;&lt; &quot;maxFs = &quot; &lt;&lt; maxFs &lt;&lt; endl;
 
@@ -192,7 +305,7 @@
                     if (maxFs&gt;1)
                         cerr &lt;&lt; &quot;maxFs&gt;1!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; endl;
                     shearForce *= maxFs;
-                    if (Fn&lt;0)  currentContactPhysics-&gt;normalForce = Vector3r::ZERO;
+			if (Fn&lt;0)  currentContactPhysics-&gt;normalForce = Vector3r::ZERO;
                 }
 
                 //if (!currentContactPhysics-&gt;cohesionBroken)
@@ -201,7 +314,7 @@
 //                     if ((*bodies)[id1]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot;  &amp;&amp; (*bodies)[id2]-&gt;interactingGeometry-&gt;getClassName() != &quot;box&quot;)
 //                     de1-&gt;isBroken = false;
 //                     de2-&gt;isBroken = false;
-                ++ncount;//REMOVE
+//                ++ncount;//REMOVE
                 //(*bodies)[id1]-&gt;geometricalModel-&gt;diffuseColor= Vector3r(0.8,0.3,0.3);
                 //(*bodies)[id2]-&gt;geometricalModel-&gt;diffuseColor= Vector3r(0.8,0.3,0.3);
                 //}
@@ -219,6 +332,158 @@
                 static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id1 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum -= c1x.Cross(f);
                 static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id2 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum += c2x.Cross(f);
 
+/////	/// Moment law					 	 ///
+/////		if(momentRotationLaw /*&amp;&amp; currentContactPhysics-&gt;cohesionBroken == false*/ )
+/////		{	
+/////			Quaternionr initialRelativeOrientation = currentContactPhysics-&gt;initialOrientation1 * currentContactPhysics-&gt;initialOrientation2.Conjugate();
+/////			Quaternionr currentRelativeOrientation = de1-&gt;se3.orientation * de2-&gt;se3.orientation.Conjugate();
+/////			// difference of rotations between two spheres
+/////			Quaternionr delta = /*initialRelativeOrientation */ currentRelativeOrientation.Conjugate();
+/////			Vector3r axis;	// axis of rotation - this is the Moment direction UNIT vector.
+/////			Real angle;	// angle represents the power of resistant ELASTIC moment
+/////			delta.ToAxisAngle(axis,angle);
+/////			if(angle &gt; Mathr::PI) angle -= Mathr::TWO_PI; // angle is between 0 and 2*pi, but should be between -pi and pi 
+/////
+///////if((id1==18 &amp;&amp; id2==12)||(id1==12 &amp;&amp; id2==18)){
+///////out(currentContactPhysics-&gt;initialOrientation1 * currentContactPhysics-&gt;initialOrientation2.Conjugate());std::cout &lt;&lt; &quot;\n&quot;;
+///////out(currentContactPhysics-&gt;initialOrientation2);std::cout &lt;&lt; &quot;\n&quot;;
+///////out(delta * de1-&gt;se3.orientation * de2-&gt;se3.orientation.Conjugate());std::cout &lt;&lt; &quot;\n&quot;;
+///////out(de2-&gt;se3.orientation * delta);std::cout &lt;&lt; &quot;\n&quot;;
+/////
+///////Quaternionr A(de1-&gt;se3.orientation), B(de2-&gt;se3.orientation);
+///////out( (  A * B.Conjugate() ).Conjugate() );std::cout &lt;&lt; &quot;\n&quot;;
+///////out( (  B * A.Conjugate() ) );std::cout &lt;&lt; &quot;\n&quot;;
+///////out( (  A.Conjugate() * B ).Conjugate() );std::cout &lt;&lt; &quot;\n&quot;;
+///////out( (  B.Conjugate() * A ) );std::cout &lt;&lt; &quot;\n&quot;;
+///////}
+/////
+/////	//This indentation is a rewrite of original equations (the two commented lines), should work exactly the same.
+///////Real elasticMoment = currentContactPhysics-&gt;kr * std::abs(angle); // positive value (*)
+/////
+/////	Real angle_twist(angle * axis.Dot(currentContactGeometry-&gt;normal) );
+/////	Vector3r axis_twist(angle_twist * currentContactGeometry-&gt;normal);
+//////* no creep	
+////////////////////////////// CREEP START ///////////////////////////
+/////			Real viscosity_twist = viscosity * std::pow((2 * std::min(currentContactGeometry-&gt;radius1,currentContactGeometry-&gt;radius2)),2) / 16.0;
+/////			Real angle_twist_creeped = angle_twist * (1 - dt/viscosity_twist);
+/////			Quaternionr q_twist(currentContactGeometry-&gt;normal , angle_twist);
+/////			//Quaternionr q_twist_creeped(currentContactGeometry-&gt;normal , angle_twist*0.996);
+/////			Quaternionr q_twist_creeped(currentContactGeometry-&gt;normal , angle_twist_creeped);
+/////			Quaternionr q_twist_delta(q_twist_creeped * q_twist.Conjugate() );
+/////			// modify the initialRelativeOrientation to substract some twisting
+/////			currentContactPhysics-&gt;initialRelativeOrientation = currentContactPhysics-&gt;initialRelativeOrientation * q_twist_delta;
+////////////////////////////// CREEP END /////////////////////////////
+/////*/
+/////	Vector3r moment_twist(axis_twist * currentContactPhysics-&gt;kr);
+/////
+/////	Vector3r axis_bending(angle*axis - axis_twist);
+/////	Vector3r moment_bending(axis_bending * currentContactPhysics-&gt;kr);
+/////
+/////			/*
+/////			// We cannot have insanely big moment, so we take a min value of ELASTIC and PLASTIC moment.
+/////			Real avgRadius = 0.5 * (currentContactGeometry-&gt;radius1 + currentContactGeometry-&gt;radius2);
+/////			// FIXME - elasticRollingLimit is currently assumed to be 1.0
+/////			Real plasticMoment = currentContactPhysics-&gt;elasticRollingLimit * avgRadius * std::abs(Fn); // positive value (*)
+/////			Real moment(std::min(elasticMoment, plasticMoment)); // RESULT
+/////			*/
+/////
+///////Vector3r moment = axis * elasticMoment * (angle&lt;0.0?-1.0:1.0); // restore sign. (*)
+/////
+/////	Vector3r moment = moment_twist + moment_bending;
+/////
+///////if((id1==18 &amp;&amp; id2==12)||(id1==12 &amp;&amp; id2==18)){
+///////outv(moment);std::cout &lt;&lt; &quot;\n&quot;;
+///////}
+/////
+/////			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id1 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum += moment;
+/////			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id2 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum -= moment;
+/////		}
+/////	/// Moment law	END				 	 ///
+
+/* RATHER CORRECT */	/// Moment law					 	 ///
+/* RATHER CORRECT */		if(momentRotationLaw &amp;&amp; currentContactPhysics-&gt;cohesionBroken == false )
+/* RATHER CORRECT */		{
+/* RATHER CORRECT */			{// updates only orientation of contact (local coordinate system)
+/* RATHER CORRECT */				Vector3r axis = currentContactPhysics-&gt;prevNormal.UnitCross(currentContactGeometry-&gt;normal);
+/* RATHER CORRECT */				Real angle =  unitVectorsAngle(currentContactPhysics-&gt;prevNormal,currentContactGeometry-&gt;normal);
+/* RATHER CORRECT */				Quaternionr align(axis,angle);
+/* RATHER CORRECT */				currentContactPhysics-&gt;currentContactOrientation =  align * currentContactPhysics-&gt;currentContactOrientation;
+/* RATHER CORRECT */			}
+/* RATHER CORRECT */
+/* RATHER CORRECT *///			Quaternionr curr1(de1-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact1);
+/* RATHER CORRECT *///			Quaternionr curr2(de2-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact2);
+/* RATHER CORRECT *///			Quaternionr delta=curr1 * curr2.Conjugate();
+/* RATHER CORRECT */
+/* RATHER CORRECT */			Quaternionr delta( de1-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation1.Conjugate() *
+/* RATHER CORRECT */		                           currentContactPhysics-&gt;initialOrientation2 * de2-&gt;se3.orientation.Conjugate());
+/* RATHER CORRECT */
+/* RATHER CORRECT */			Vector3r axis;	// axis of rotation - this is the Moment direction UNIT vector.
+/* RATHER CORRECT */			Real angle;	// angle represents the power of resistant ELASTIC moment
+/* RATHER CORRECT */			delta.ToAxisAngle(axis,angle);
+/* RATHER CORRECT */			if(angle &gt; Mathr::PI) angle -= Mathr::TWO_PI; // angle is between 0 and 2*pi, but should be between -pi and pi 
+/* RATHER CORRECT */
+/* RATHER CORRECT */	//This indentation is a rewrite of original equations (the two commented lines), should work exactly the same.
+/* RATHER CORRECT *///Real elasticMoment = currentContactPhysics-&gt;kr * std::abs(angle); // positive value (*)
+/* RATHER CORRECT */
+/* RATHER CORRECT */	Real angle_twist(angle * axis.Dot(currentContactGeometry-&gt;normal) );
+/* RATHER CORRECT */	Vector3r axis_twist(angle_twist * currentContactGeometry-&gt;normal);
+/* RATHER CORRECT */	Vector3r moment_twist(axis_twist * currentContactPhysics-&gt;kr);
+/* RATHER CORRECT */
+/* RATHER CORRECT */	Vector3r axis_bending(angle*axis - axis_twist);
+/* RATHER CORRECT */	Vector3r moment_bending(axis_bending * currentContactPhysics-&gt;kr);
+/* RATHER CORRECT */
+/* RATHER CORRECT *///Vector3r moment = axis * elasticMoment * (angle&lt;0.0?-1.0:1.0); // restore sign. (*)
+/* RATHER CORRECT */
+/* RATHER CORRECT */	Vector3r moment = moment_twist + moment_bending;
+/* RATHER CORRECT */
+/* RATHER CORRECT *///DEBUGGING// if((id1==22 &amp;&amp; id2==6)){
+/* RATHER CORRECT *///DEBUGGING// std::cout &lt;&lt; &quot;moment: &quot; &lt;&lt; moment &lt;&lt; &quot; &quot;;
+/* RATHER CORRECT *///DEBUGGING// std::cout &lt;&lt; &quot;normal: &quot; &lt;&lt; currentContactGeometry-&gt;normal &lt;&lt; &quot;\n&quot;;
+/* RATHER CORRECT *///DEBUGGING// }
+/* RATHER CORRECT */
+/* RATHER CORRECT */			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id1 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum -= moment;
+/* RATHER CORRECT */			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id2 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum += moment;
+/* RATHER CORRECT */		}
+/* RATHER CORRECT */	/// Moment law	END				 	 ///
+///*EXPERIMENT*/	/// Moment law					 	 ///
+///*EXPERIMENT*/		if(momentRotationLaw &amp;&amp; currentContactPhysics-&gt;cohesionBroken == false )
+///*EXPERIMENT*/		{
+///*EXPERIMENT*/			{// updates only orientation of contact (local coordinate system)
+///*EXPERIMENT*/				Vector3r axis = currentContactPhysics-&gt;prevNormal.UnitCross(currentContactGeometry-&gt;normal);
+///*EXPERIMENT*/				Real angle =  unitVectorsAngle(currentContactPhysics-&gt;prevNormal,currentContactGeometry-&gt;normal);
+///*EXPERIMENT*/				Quaternionr align(axis,angle);
+///*EXPERIMENT*/				currentContactPhysics-&gt;currentContactOrientation =  align * currentContactPhysics-&gt;currentContactOrientation;
+///*EXPERIMENT*/			}
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Quaternionr delta1( de1-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation1.Conjugate() *
+///*EXPERIMENT*/		                           currentContactPhysics-&gt;initialOrientation2 * de2-&gt;se3.orientation.Conjugate());
+///*EXPERIMENT*/		                           //currentContactPhysics-&gt;initialContactOrientation * currentContactPhysics-&gt;currentContactOrientation.Conjugate());
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Vector3r axis1;
+///*EXPERIMENT*/			Real angle1;
+///*EXPERIMENT*/			delta1.ToAxisAngle(axis1,angle1);
+///*EXPERIMENT*/			if(angle1 &gt; Mathr::PI) angle1 -= Mathr::TWO_PI;
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Vector3r moment1 = axis1 * currentContactPhysics-&gt;kr * angle1;
+///*EXPERIMENT*/
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Quaternionr delta2( de1-&gt;se3.orientation * currentContactPhysics-&gt;initialOrientation1.Conjugate() *
+///*EXPERIMENT*/			//Quaternionr delta2( currentContactPhysics-&gt;currentContactOrientation * currentContactPhysics-&gt;initialContactOrientation.Conjugate() *
+///*EXPERIMENT*/		                            currentContactPhysics-&gt;initialOrientation2 * de2-&gt;se3.orientation.Conjugate());
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Vector3r axis2;
+///*EXPERIMENT*/			Real angle2;
+///*EXPERIMENT*/			delta2.ToAxisAngle(axis2,angle2);
+///*EXPERIMENT*/			if(angle2 &gt; Mathr::PI) angle2 -= Mathr::TWO_PI;
+///*EXPERIMENT*/
+///*EXPERIMENT*/			Vector3r moment2 = axis2 * currentContactPhysics-&gt;kr * angle2;
+///*EXPERIMENT*/
+///*EXPERIMENT*/			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id1 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum -= moment1;
+///*EXPERIMENT*/			static_cast&lt;Momentum*&gt;( ncb-&gt;physicalActions-&gt;find( id2 , actionMomentum-&gt;getClassIndex() ).get() )-&gt;momentum += moment2;
+///*EXPERIMENT*/		}
+///*EXPERIMENT*/	/// Moment law	END				 	 ///
+
+
                 currentContactPhysics-&gt;prevNormal = currentContactGeometry-&gt;normal;
             }
         }

Modified: trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp
===================================================================
--- trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -65,6 +65,8 @@
 #include&lt;yade/pkg-common/InteractionHashMap.hpp&gt;
 #include&lt;yade/pkg-common/PhysicalActionVectorVector.hpp&gt;
 
+#include&lt;yade/extra/Shop.hpp&gt;
+
 #include &lt;boost/filesystem/convenience.hpp&gt;
 #include &lt;boost/lexical_cast.hpp&gt;
 #include &lt;boost/numeric/conversion/bounds.hpp&gt;
@@ -92,7 +94,7 @@
 	lowerCorner 		= Vector3r(0,0,0);
 	upperCorner 		= Vector3r(1,1,1);
 	thickness 		= 0.001;
-	importFilename 		= &quot;./small.sdec.xyz&quot;;
+	importFilename 		= &quot;&quot;;
 	outputFileName 		= &quot;./CohesiveTriaxialTest.xml&quot;;
 	//nlayers = 1;
 	wall_top 		= true;
@@ -133,6 +135,7 @@
 	wallStiffnessUpdateInterval = 10;
 	radiusControlInterval = 10;
 	numberOfGrains = 400;
+	radiusDeviation = 0.3;
 	strainRate = 10;
 	StabilityCriterion = 0.01;
 	autoCompressionActivation = false;
@@ -203,6 +206,7 @@
 	REGISTER_ATTRIBUTE(wallStiffnessUpdateInterval);
 	REGISTER_ATTRIBUTE(radiusControlInterval);
 	REGISTER_ATTRIBUTE(numberOfGrains);
+	REGISTER_ATTRIBUTE(radiusDeviation);
 	REGISTER_ATTRIBUTE(strainRate);
 	REGISTER_ATTRIBUTE(StabilityCriterion);
 	REGISTER_ATTRIBUTE(autoCompressionActivation);
@@ -368,7 +372,8 @@
 	}
 	
 	vector&lt;BasicSphere&gt; sphere_list;
-	message=GenerateCloud(sphere_list, lowerCorner, upperCorner, numberOfGrains, 0.3, 0.75);
+	if(importFilename!=&quot;&quot;) sphere_list=Shop::loadSpheresFromFile(importFilename,lowerCorner,upperCorner);
+	else message=GenerateCloud(sphere_list, lowerCorner, upperCorner, numberOfGrains, radiusDeviation, 0.75);
 	
 	vector&lt;BasicSphere&gt;::iterator it = sphere_list.begin();
 	vector&lt;BasicSphere&gt;::iterator it_end = sphere_list.end();
@@ -463,8 +468,9 @@
 	shared_ptr&lt;Sphere&gt; gSphere(new Sphere);
 	shared_ptr&lt;InteractingSphere&gt; iSphere(new InteractingSphere);
 	
-	Quaternionr q;
-	q.FromAxisAngle( Vector3r(0,0,1),0);
+	Quaternionr q(Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom(),Mathr::SymmetricRandom());
+	q.Normalize();
+//	q.FromAxisAngle( Vector3r(0,0,1),0);
 	
 	body-&gt;isDynamic			= dynamic;
 	
@@ -491,6 +497,7 @@
 
 
 	gSphere-&gt;radius			= radius;
+//	gSphere-&gt;diffuseColor		= ((int)(position[0]*400.0))%2?Vector3r(0.7,0.7,0.7):Vector3r(0.45,0.45,0.45);
 	gSphere-&gt;diffuseColor		= spheresColor;
 	gSphere-&gt;wire			= false;
 	gSphere-&gt;visible		= true;
@@ -650,7 +657,7 @@
 	triaxialcompressionEngine-&gt; sigma_iso = sigma_iso;
 	triaxialcompressionEngine-&gt; sigmaLateralConfinement = sigma_iso;
 	triaxialcompressionEngine-&gt; sigmaIsoCompaction = sigma_iso;
-	triaxialcompressionEngine-&gt; max_vel = 0.01;
+	triaxialcompressionEngine-&gt; max_vel = 1;
 	triaxialcompressionEngine-&gt; thickness = thickness;
 	triaxialcompressionEngine-&gt;strainRate = strainRate;
 	triaxialcompressionEngine-&gt;StabilityCriterion = StabilityCriterion;

Modified: trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp
===================================================================
--- trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/PreProcessor/CohesiveTriaxialTest.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -51,6 +51,7 @@
 				,dampingForce
 				,dampingMomentum
 				,defaultDt
+				,radiusDeviation
 
 // 				,bigBallRadius
 // 				,bigBallDensity

Added: trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,246 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at mail.berlios.de</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;GLDrawCohesiveFrictionalContactInteraction.hpp&quot;
+#include&lt;yade/pkg-dem/CohesiveFrictionalContactInteraction.hpp&gt;
+#include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include&lt;yade/pkg-common/SimpleElasticInteraction.hpp&gt;
+#include&lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+
+#include&lt;yade/lib-opengl/OpenGLWrapper.hpp&gt;
+#include&lt;yade/lib-QGLViewer/qglviewer.h&gt;
+
+GLDrawCohesiveFrictionalContactInteraction::GLDrawCohesiveFrictionalContactInteraction() : boxIndex(-1)
+{
+}
+
+void GLDrawCohesiveFrictionalContactInteraction::drawAxis(const Vector3r pos,const Quaternionr q,Real size,const int old)
+{
+	if(old==1) { // stupid way to change axis' color
+		const GLfloat ambientColor[4]	= {0.0,0.0,isReal?10.0:0.1,1.0};
+		glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+	} else if(old==2){
+		const GLfloat ambientColor[4]	= {0.0,isReal?10.0:0.1,0.0,1.0};
+		glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+	} else if(old==4){
+		const GLfloat ambientColor[4]	= {isReal?10.0:0.1,0.0,0.0,1.0};
+		glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+	} else {
+		const GLfloat ambientColor[4]	= {isReal?10.0:0.1,isReal?10.0:0.1,0.0,1.0};
+		glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+	}
+
+	Real matrix[16];
+
+	glPushMatrix();
+	glTranslatev(pos);
+	quaterniontoGLMatrix(q,matrix);
+	glMultMatrixd(matrix);
+	QGLViewer::drawAxis(size);
+	glPopMatrix();
+
+	const GLfloat ambientColor[4]	= {0.5,0.5,0.5,1.0};	
+	glLightModelfv(GL_LIGHT_MODEL_AMBIENT,ambientColor);
+};
+		
+void GLDrawCohesiveFrictionalContactInteraction::drawArrow(const Vector3r from,const Vector3r to,const Vector3r color)
+{
+	glEnable(GL_LIGHTING);
+	glColor3v(color);
+	qglviewer::Vec a(from[0],from[1],from[2]),b(to[0],to[1],to[2]);
+	QGLViewer::drawArrow(a,b);	
+};
+
+void GLDrawCohesiveFrictionalContactInteraction::drawFlatText(const Vector3r pos,const std::string txt)
+{
+	glPushMatrix();
+	glTranslatev(pos);
+	glColor3(1.0,1.0,0.0);
+	glRasterPos2i(0,0);
+	for(unsigned int i=0;i&lt;txt.length();i++)
+		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, txt[i]);
+	glPopMatrix();
+};
+
+Vector3r GLDrawCohesiveFrictionalContactInteraction::drawRotationAxis(
+	const Quaternionr q,
+	const std::string txt,
+	const Vector3r pos,
+	const Real size,
+	const Vector3r color)
+{
+	Vector3r axis;Real angle;
+	Quaternionr delta(q);
+	delta.ToAxisAngle(axis,angle);
+	if(angle==0) return Vector3r(0,0,0);
+	if(angle &gt; Mathr::PI) angle -= Mathr::TWO_PI; // angle is between 0 and 2*pi, but should be between -pi and pi 
+	//Vector3r m(pos+axis*size*(angle&gt;0?1.0:-1.0));
+	Vector3r ret = axis*angle;
+	Vector3r m(pos+ret*size);
+	drawArrow(pos, m ,color);
+	drawFlatText(m,txt);
+	return ret;
+}
+
+void GLDrawCohesiveFrictionalContactInteraction::go(
+		const shared_ptr&lt;InteractionPhysics&gt;&amp; ih,
+		const shared_ptr&lt;Interaction&gt;&amp; i,
+		const shared_ptr&lt;Body&gt;&amp; b1,
+		const shared_ptr&lt;Body&gt;&amp; b2,
+		bool wireFrame)
+{
+//	if(!i-&gt;isReal) return;
+	isReal=i-&gt;isReal;
+
+	CohesiveFrictionalContactInteraction*    ph = static_cast&lt;CohesiveFrictionalContactInteraction*&gt;(ih.get());
+	SpheresContactGeometry*    sc = static_cast&lt;SpheresContactGeometry*&gt;(i-&gt;interactionGeometry.get());
+	Vector3r pos1   = b1-&gt;physicalParameters-&gt;se3.position;
+	Vector3r pos2   = b2-&gt;physicalParameters-&gt;se3.position;
+
+	/// skip drawing interaction with boxes....
+		if(boxIndex == -1 &amp;&amp; b1-&gt;geometricalModel-&gt;getClassName() == &quot;Box&quot;) boxIndex = b1-&gt;geometricalModel-&gt;getClassIndex();
+		if(boxIndex == -1 &amp;&amp; b2-&gt;geometricalModel-&gt;getClassName() == &quot;Box&quot;) boxIndex = b2-&gt;geometricalModel-&gt;getClassIndex();
+		if(b1-&gt;geometricalModel-&gt;getClassIndex() == boxIndex || b2-&gt;geometricalModel-&gt;getClassIndex() == boxIndex) return;
+	//
+
+	Vector3r middle = 0.5*(pos1+pos2);
+	Vector3r dist   = 0.5*(pos2-pos1);
+	Vector3r pos1d  = 0.9*pos1 + 0.1*pos2;
+	Vector3r pos2d  = 0.1*pos1 + 0.9*pos2;
+	Real     size   = dist.Length()*0.5;
+	Vector3r color(isReal?1:0.4,isReal?1:0.4,isReal?1:0.4);
+
+// draw 1st body
+// 1st body initial orientation
+	drawAxis(pos1,ph-&gt;initialOrientation1                 * ph-&gt;orientationToContact1,size,1);
+// 1st body real orientation
+	drawAxis(pos1,b1-&gt;physicalParameters-&gt;se3.orientation                            ,size,4);
+// 1st body current orientation
+	drawAxis(pos1,b1-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact1,size);
+                                                                                         
+// draw 2st body                                                                         
+// 2nd body initial orientation
+	drawAxis(pos2,ph-&gt;initialOrientation2                 * ph-&gt;orientationToContact2,size,1);
+// 2st body real orientation
+	drawAxis(pos2,b2-&gt;physicalParameters-&gt;se3.orientation                            ,size,4);
+// 2nd body current orientation
+	drawAxis(pos2,b2-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact2,size);
+
+// draw middle
+// middle initial orientation
+	drawAxis(middle,ph-&gt;initialContactOrientation,size,1);
+// middle current orientation
+	drawAxis(middle,ph-&gt;currentContactOrientation,size);
+
+
+
+	Quaternionr init1(ph-&gt;initialOrientation1                 * ph-&gt;orientationToContact1);
+	Quaternionr init2(ph-&gt;initialOrientation2                 * ph-&gt;orientationToContact2);
+
+	Quaternionr curr1(b1-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact1);
+	Quaternionr curr2(b2-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact2);
+	
+	Vector3r M1 = drawRotationAxis(curr1 * init1.Conjugate() , &quot;  M1&quot;, pos1, size*0.9,color);
+	Vector3r M2 = drawRotationAxis(curr2 * init2.Conjugate() , &quot;  M2&quot;, pos2, size*0.9,color);
+
+//		drawRotationAxis(curr1 * init1.Conjugate() , &quot;  M1&quot;, middle, size*0.9,color);
+//		drawRotationAxis(curr2 * init2.Conjugate() , &quot;  M2&quot;, middle, size*0.9,color);
+
+if(wireFrame)
+{
+	drawRotationAxis(curr1 * curr2.Conjugate() , &quot;  M&quot;, middle, size*50, Vector3r(isReal?1.0:0.4,0,0));
+
+//	drawArrow(middle, middle+ph-&gt;shearDisplacement*size ,Vector3r(0,0,isReal?1:0.4));
+//	drawFlatText(     middle+ph-&gt;shearDisplacement*size ,std::string(&quot;  shearDisplacement&quot;));
+	
+//	drawArrow(middle        , middle+(M2-M1)*size ,Vector3r(2.0,0.4,0.4));
+//	drawArrow(middle+M2*size, middle+(M2-M1)*size ,Vector3r(1.0,0.4,0.4));
+
+
+	drawArrow(middle, middle+ph-&gt;shearForce*size/4000.0 ,Vector3r(isReal?1:0.4,0,isReal?1:0.4));
+	drawFlatText(     middle+ph-&gt;shearForce*size/4000.0 ,std::string(&quot; Fs&quot;));
+
+// draw normal
+	drawArrow(middle, middle+sc-&gt;normal*size*0.9 ,Vector3r(0,isReal?1:0.4,0));
+	drawFlatText(     middle+sc-&gt;normal*size*0.9 ,std::string(&quot; N&quot;));
+
+// draw prevNormal
+//	drawArrow(middle, middle+ph-&gt;prevNormal*size*0.9 ,Vector3r(isReal?1:0.4,0,0));
+// draw initial normal
+//	drawArrow(middle, middle+(ph-&gt;initialContactOrientation*Vector3r(1,0,0))*size*0.4 ,Vector3r(0,0,isReal?1:0.4));
+// draw current normal
+//	drawArrow(middle, middle+(ph-&gt;currentContactOrientation*Vector3r(1,0,0))*size*0.4 ,Vector3r(isReal?1:0.4,isReal?1:0.4,0));
+
+//// draw initX1
+//	drawArrow(pos1, pos1+ph-&gt;initX1*size*0.4 ,Vector3r(0,0,isReal?1:0.4));
+//	drawFlatText(pos1+ph-&gt;initX1*size*0.4,std::string(&quot;  initX1&quot;));
+//// draw prevX1
+//	drawArrow(pos1, pos1+ph-&gt;prevX1*size*0.4 ,Vector3r(isReal?1:0.4,isReal?1:0.4,0));
+//	drawFlatText(pos1+ph-&gt;prevX1*size*0.4,std::string(&quot;  prevX1&quot;));
+//// draw initX2
+//	drawArrow(pos2, pos2+ph-&gt;initX2*size*0.4 ,Vector3r(0,0,isReal?1:0.4));
+//	drawFlatText(pos2+ph-&gt;initX2*size*0.4,std::string(&quot;  initX2&quot;));
+//// draw prevX2
+//	drawArrow(pos2, pos2+ph-&gt;prevX2*size*0.4 ,Vector3r(isReal?1:0.4,isReal?1:0.4,0));
+//	drawFlatText(pos2+ph-&gt;prevX2*size*0.4,std::string(&quot;  prevX2&quot;));
+
+// draw moment
+//	drawRotationAxis(ph-&gt;currentContactOrientation             * ph-&gt;initialContactOrientation.Conjugate() , &quot;  ref&quot;, middle, size*0.9,color);
+}
+
+//{// draw contact vector
+//	//Quaternionr curr1(de1-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact1);
+//	//Quaternionr curr2(de2-&gt;se3.orientation * currentContactPhysics-&gt;orientationToContact2);
+//	Vector3r initialContactPoint1(pos1 + curr1*Vector3r(     sc-&gt;radius1,0,0) );
+//	Vector3r initialContactPoint2(pos2 + curr2*Vector3r(-1.0*sc-&gt;radius2,0,0) );
+//	Vector3r contactDist( initialContactPoint2 - initialContactPoint1 );
+////	Vector3r shearDir(ph-&gt;shearForce); shearDir.Normalize();
+////	Vector3r contactDir(contactDist); contactDir.Normalize();
+////	Vector3r contactShear( shearDir * shearDir.Dot(contactDir) * contactDist.Length() );
+//	drawArrow(initialContactPoint1, initialContactPoint1+contactDist ,Vector3r(0.2,0.2,0.2));
+////	drawArrow(initialContactPoint1, initialContactPoint1+contactShear ,Vector3r(0.2,0.2,0.2));
+//
+////if((b1-&gt;getId()==22 &amp;&amp; b2-&gt;getId()==6)){
+////std::cerr &lt;&lt; &quot;contactShearDisplacementGL: &quot; &lt;&lt; contactShear &lt;&lt; &quot; length:&quot; &lt;&lt; contactShear.Length() &lt;&lt; &quot;\n&quot;;
+////}
+//
+//}
+// draw initial contact point 1st body
+	glColor3(1.0,1.0,0.0);
+	Real matrix[16];
+	glPushMatrix();
+	glTranslatev(pos1);
+	quaterniontoGLMatrix(b1-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact1,matrix);
+	glMultMatrixd(matrix);
+	glTranslate(sc-&gt;radius1,0.0,0.0);
+	glutSolidSphere(size*0.1,4,4);
+	glPopMatrix();
+
+// draw initial contact point 2nd body
+	glPushMatrix();
+	glTranslatev(pos2);
+	quaterniontoGLMatrix(b2-&gt;physicalParameters-&gt;se3.orientation * ph-&gt;orientationToContact2,matrix);
+	glMultMatrixd(matrix);
+	glTranslate(-1.0*sc-&gt;radius2,0.0,0.0);
+	glutSolidSphere(size*0.1,4,4);
+	glPopMatrix();
+
+// draw connecting line.
+	glBegin(GL_LINES);
+	glColor3(1.4,1.4,0.4);
+	glVertex3v(pos1);
+	glVertex3v(pos2);
+	glEnd();
+
+// write A,B
+	drawFlatText(pos1d,std::string(&quot;  A &quot;) + boost::lexical_cast&lt;std::string&gt;(b1-&gt;getId()));
+	drawFlatText(pos2d,std::string(&quot;  B &quot;) + boost::lexical_cast&lt;std::string&gt;(b2-&gt;getId()));
+
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,34 @@
+/*************************************************************************
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at mail.berlios.de</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef GLDRAW_CohesiveFrictionalContactInteraction_HPP
+#define GLDRAW_CohesiveFrictionalContactInteraction_HPP
+
+#include&lt;yade/pkg-common/GLDrawInteractionPhysicsFunctor.hpp&gt;
+
+class GLDrawCohesiveFrictionalContactInteraction : public GLDrawInteractionPhysicsFunctor
+{	
+	int boxIndex;
+	bool isReal;
+	public :
+		GLDrawCohesiveFrictionalContactInteraction();
+		virtual void go(const shared_ptr&lt;InteractionPhysics&gt;&amp;,const shared_ptr&lt;Interaction&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,bool wireFrame);
+		void drawAxis(const Vector3r pos,const Quaternionr q,const Real size,const int old=0);
+		void drawArrow(const Vector3r from,const Vector3r to,const Vector3r color);
+		void drawFlatText(const Vector3r pos,const std::string txt);
+		Vector3r drawRotationAxis(const Quaternionr q,const std::string txt,const Vector3r pos,const Real size,const Vector3r color);
+
+	RENDERS(CohesiveFrictionalContactInteraction);
+	REGISTER_CLASS_NAME(GLDrawCohesiveFrictionalContactInteraction);
+	REGISTER_BASE_CLASS_NAME(GLDrawInteractionPhysicsFunctor);
+};
+
+REGISTER_SERIALIZABLE(GLDrawCohesiveFrictionalContactInteraction,false);
+
+#endif 
+

Added: trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,88 @@
+/*************************************************************************
+*  Copyright (C) 2007 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at mail.berlios.de</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;GLDrawElasticContactInteraction.hpp&quot;
+#include&lt;yade/pkg-dem/SpheresContactGeometry.hpp&gt;
+#include&lt;yade/pkg-common/SimpleElasticInteraction.hpp&gt;
+#include&lt;yade/pkg-dem/ElasticContactInteraction.hpp&gt;
+
+#include&lt;yade/lib-opengl/OpenGLWrapper.hpp&gt;
+#include&lt;yade/lib-QGLViewer/qglviewer.h&gt;
+
+GLDrawElasticContactInteraction::GLDrawElasticContactInteraction() : boxIndex(-1), maxLength(0.0000001)
+{
+}
+
+void GLDrawElasticContactInteraction::drawArrow(const Vector3r from,const Vector3r to,const Vector3r color)
+{
+	glEnable(GL_LIGHTING);
+	glColor3v(color);
+	qglviewer::Vec a(from[0],from[1],from[2]),b(to[0],to[1],to[2]);
+	QGLViewer::drawArrow(a,b);	
+};
+
+void GLDrawElasticContactInteraction::drawFlatText(const Vector3r pos,const std::string txt)
+{
+	glPushMatrix();
+	glTranslatev(pos);
+	glColor3(1.0,1.0,0.0);
+	glRasterPos2i(0,0);
+	for(unsigned int i=0;i&lt;txt.length();i++)
+		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, txt[i]);
+	glPopMatrix();
+};
+
+void GLDrawElasticContactInteraction::go(
+		const shared_ptr&lt;InteractionPhysics&gt;&amp; ih,
+		const shared_ptr&lt;Interaction&gt;&amp; i,
+		const shared_ptr&lt;Body&gt;&amp; b1,
+		const shared_ptr&lt;Body&gt;&amp; b2,
+		bool wireFrame)
+{
+//	if(!i-&gt;isReal) return;
+
+	ElasticContactInteraction*    ph = static_cast&lt;ElasticContactInteraction*&gt;(ih.get());
+	SpheresContactGeometry*    sc = static_cast&lt;SpheresContactGeometry*&gt;(i-&gt;interactionGeometry.get());
+	Vector3r pos1   = b1-&gt;physicalParameters-&gt;se3.position;
+	Vector3r pos2   = b2-&gt;physicalParameters-&gt;se3.position;
+
+	/// skip drawing interaction with boxes....
+		if(boxIndex == -1 &amp;&amp; b1-&gt;geometricalModel-&gt;getClassName() == &quot;Box&quot;) boxIndex = b1-&gt;geometricalModel-&gt;getClassIndex();
+		if(boxIndex == -1 &amp;&amp; b2-&gt;geometricalModel-&gt;getClassName() == &quot;Box&quot;) boxIndex = b2-&gt;geometricalModel-&gt;getClassIndex();
+		if(b1-&gt;geometricalModel-&gt;getClassIndex() == boxIndex || b2-&gt;geometricalModel-&gt;getClassIndex() == boxIndex) return;
+	//
+
+	Vector3r middle = 0.5*(pos1+pos2);
+	Vector3r dist   = 0.5*(pos2-pos1);
+	Vector3r pos1d  = 0.9*pos1 + 0.1*pos2;
+	Vector3r pos2d  = 0.1*pos1 + 0.9*pos2;
+	Real     size   = dist.Length()*0.5;
+
+// draw connecting line.
+	glBegin(GL_LINES);
+	glColor3(1.4,1.4,0.4);
+	glVertex3v(pos1);
+	glVertex3v(pos2);
+	glEnd();
+
+// draw normal
+	drawArrow(middle, middle+sc-&gt;normal*size*0.9 ,Vector3r(0,i-&gt;isReal?1:0.4,0));
+// draw prevNormal
+//	drawArrow(middle, middle+ph-&gt;prevNormal*size*0.9 ,Vector3r(i-&gt;isReal?1:0.4,0,0));
+// draw shearForce
+	maxLength = std::max(maxLength,ph-&gt;shearForce.Length());
+	if(wireFrame) maxLength = 0.0000001;
+	drawArrow(middle, middle+ph-&gt;shearForce*size*10.0/maxLength ,Vector3r(0,0,i-&gt;isReal?1:0.4));
+
+// write A,B
+	drawFlatText(pos1d,std::string(&quot;  A &quot;) + boost::lexical_cast&lt;std::string&gt;(b1-&gt;getId()));
+	drawFlatText(pos2d,std::string(&quot;  B &quot;) + boost::lexical_cast&lt;std::string&gt;(b2-&gt;getId()));
+
+}
+
+YADE_PLUGIN();

Added: trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.hpp
===================================================================
--- trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.hpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.hpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -0,0 +1,32 @@
+/*************************************************************************
+*  Copyright (C) 2008 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at mail.berlios.de</A>                                               *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef GLDRAW_ElasticContactInteraction_HPP
+#define GLDRAW_ElasticContactInteraction_HPP
+
+#include&lt;yade/pkg-common/GLDrawInteractionPhysicsFunctor.hpp&gt;
+
+class GLDrawElasticContactInteraction : public GLDrawInteractionPhysicsFunctor
+{	
+	int boxIndex;
+	Real maxLength;
+	public :
+		GLDrawElasticContactInteraction();
+		virtual void go(const shared_ptr&lt;InteractionPhysics&gt;&amp;,const shared_ptr&lt;Interaction&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,const shared_ptr&lt;Body&gt;&amp;,bool wireFrame);
+		void drawArrow(const Vector3r from,const Vector3r to,const Vector3r color);
+		void drawFlatText(const Vector3r pos,const std::string txt);
+
+	RENDERS(ElasticContactInteraction);
+	REGISTER_CLASS_NAME(GLDrawElasticContactInteraction);
+	REGISTER_BASE_CLASS_NAME(GLDrawInteractionPhysicsFunctor);
+};
+
+REGISTER_SERIALIZABLE(GLDrawElasticContactInteraction,false);
+
+#endif 
+

Modified: trunk/pkg/dem/SConscript
===================================================================
--- trunk/pkg/dem/SConscript	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/dem/SConscript	2008-03-18 05:19:31 UTC (rev 1280)
@@ -285,6 +285,21 @@
 		['RenderingEngine/GLDrawInteractingMyTetrahedron/GLDrawInteractingMyTetrahedron.cpp'],
 		LIBS=env['LIBS']+['InteractingMyTetrahedron', 'yade-opengl']),
 
+	env.SharedLibrary('GLDrawCohesiveFrictionalContactInteraction',
+		['RenderingEngine/GLDrawCohesiveFrictionalContactInteraction/GLDrawCohesiveFrictionalContactInteraction.cpp'],
+		LIBS=env['LIBS']+['CohesiveFrictionalContactInteraction','SpheresContactGeometry',
+			'GLDrawElasticContactInteraction',
+			'ElasticContactInteraction',
+			'SimpleElasticInteraction',
+			'yade-opengl','$QGLVIEWER_LIB']),
+
+	env.SharedLibrary('GLDrawElasticContactInteraction',
+		['RenderingEngine/GLDrawElasticContactInteraction/GLDrawElasticContactInteraction.cpp'],
+		LIBS=env['LIBS']+['SpheresContactGeometry',
+			'ElasticContactInteraction',
+			'SimpleElasticInteraction',
+			'yade-opengl','$QGLVIEWER_LIB']),
+
 	env.SharedLibrary('GLDrawSpheresContactGeometry',
 		['RenderingEngine/GLDrawSpheresContactGeometry/GLDrawSpheresContactGeometry.cpp'],
 		LIBS=env['LIBS']+['SpheresContactGeometry',
@@ -595,6 +610,7 @@
 			'TriaxialCompressionEngine',
 			'GlobalStiffnessTimeStepper',
 			'yade-base',
+			'Shop',
 			'TriaxialStateRecorder',
 			'PositionOrientationRecorder',
 			'HydraulicForceEngine']),

Modified: trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp
===================================================================
--- trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/lattice/Engine/StandAloneEngine/LatticeLaw.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -289,7 +289,7 @@
 		{ // 'E_min' 'E_max' criterion
 			if( deleteBeam(lattice , beam, body) ) // calculates strain
 			{
-				std::cerr &lt;&lt; &quot;one beam deleted\n&quot;;
+				//std::cerr &lt;&lt; &quot;one beam deleted\n&quot;;
 				futureDeletes.push_back(body-&gt;getId());
 				continue;
 			}
@@ -383,7 +383,7 @@
 		}
 	}
 
-	std::cout &lt;&lt; &quot;iter:&quot; &lt;&lt; Omega::instance().getCurrentIteration() &lt;&lt; &quot; beams_deleted: &quot; &lt;&lt; futureDeletes.size() &lt;&lt; std::endl;
+	//std::cout &lt;&lt; &quot;iter:&quot; &lt;&lt; Omega::instance().getCurrentIteration() &lt;&lt; &quot; beams_deleted: &quot; &lt;&lt; futureDeletes.size() &lt;&lt; std::endl;
 	
 	{ // move nodes
 		bi    = bodies-&gt;begin();

Modified: trunk/pkg/lattice/PreProcessor/LatticeExample.cpp
===================================================================
--- trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2008-03-17 19:12:09 UTC (rev 1279)
+++ trunk/pkg/lattice/PreProcessor/LatticeExample.cpp	2008-03-18 05:19:31 UTC (rev 1280)
@@ -64,7 +64,7 @@
 	quadGroupMask		= 4;
         
         speciemen_size_in_meters = Vector3r(0.1,0.1,0.0001);
-        cellsizeUnit_in_meters   = 0.003;
+        cellsizeUnit_in_meters   = 0.01;//0.003;
 #ifndef MINIWM3
 	use_Delaunay		 = true;
 #else


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000244.html">[Yade-commits] r1279 - in trunk: . lib
</A></li>
	<LI>Next message: <A HREF="000246.html">[Yade-commits] r1281 - in trunk: . extra gui gui/qt3	pkg/common/Engine/DeusExMachina	pkg/dem/Engine/StandAloneEngine scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#245">[ date ]</a>
              <a href="thread.html#245">[ thread ]</a>
              <a href="subject.html#245">[ subject ]</a>
              <a href="author.html#245">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
