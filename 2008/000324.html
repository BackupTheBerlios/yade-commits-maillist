<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Yade-commits] r1362 - in trunk: core	core/DefaultContainerImplementations pkg/common/Container
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/yade-commits/2008/index.html" >
   <LINK REL="made" HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1362%20-%20in%20trunk%3A%20core%0A%09core/DefaultContainerImplementations%20pkg/common/Container&In-Reply-To=%3C200805241246.m4OCk3Pv017474%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000323.html">
   <LINK REL="Next"  HREF="000325.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Yade-commits] r1362 - in trunk: core	core/DefaultContainerImplementations pkg/common/Container</H1>
    <B>eudoxos at BerliOS</B> 
    <A HREF="mailto:yade-commits%40lists.berlios.de?Subject=Re%3A%20%5BYade-commits%5D%20r1362%20-%20in%20trunk%3A%20core%0A%09core/DefaultContainerImplementations%20pkg/common/Container&In-Reply-To=%3C200805241246.m4OCk3Pv017474%40sheep.berlios.de%3E"
       TITLE="[Yade-commits] r1362 - in trunk: core	core/DefaultContainerImplementations pkg/common/Container">eudoxos at mail.berlios.de
       </A><BR>
    <I>Sat May 24 14:46:03 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000323.html">[Yade-commits] r1361 - in trunk: core gui gui/py gui/qt3 pkg/common	pkg/common/Container scripts
</A></li>
        <LI>Next message: <A HREF="000325.html">[Yade-commits] r1363 - trunk/gui/qt3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: eudoxos
Date: 2008-05-24 14:46:02 +0200 (Sat, 24 May 2008)
New Revision: 1362

Added:
   trunk/core/DefaultContainerImplementations/
   trunk/core/DefaultContainerImplementations/BodyRedirectionVector.cpp
   trunk/core/DefaultContainerImplementations/BodyRedirectionVector.hpp
   trunk/core/DefaultContainerImplementations/InteractionVecSet.cpp
   trunk/core/DefaultContainerImplementations/InteractionVecSet.hpp
   trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.cpp
   trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.hpp
   trunk/pkg/common/Container/BodyRedirectionVector.hpp
   trunk/pkg/common/Container/InteractionVecSet.hpp
   trunk/pkg/common/Container/PhysicalActionVectorVector.hpp
Removed:
   trunk/pkg/common/Container/BodyRedirectionVector.cpp
   trunk/pkg/common/Container/BodyRedirectionVector.hpp
   trunk/pkg/common/Container/InteractionVecSet.cpp
   trunk/pkg/common/Container/InteractionVecSet.hpp
   trunk/pkg/common/Container/PhysicalActionVectorVector.cpp
   trunk/pkg/common/Container/PhysicalActionVectorVector.hpp
Log:
Fix: move files properly (with svn)


Copied: trunk/core/DefaultContainerImplementations/BodyRedirectionVector.cpp (from rev 1360, trunk/pkg/common/Container/BodyRedirectionVector.cpp)
===================================================================
--- trunk/pkg/common/Container/BodyRedirectionVector.cpp	2008-05-23 18:32:59 UTC (rev 1360)
+++ trunk/core/DefaultContainerImplementations/BodyRedirectionVector.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,258 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include&quot;BodyRedirectionVector.hpp&quot;
+
+
+#include&lt;yade/core/Body.hpp&gt;
+
+
+BodyRedirectionVectorIterator::BodyRedirectionVectorIterator() : BodyContainerIterator()
+{
+
+}
+
+
+BodyRedirectionVectorIterator::~BodyRedirectionVectorIterator()
+{
+
+}
+
+
+bool BodyRedirectionVectorIterator::isDifferent(const BodyContainerIterator&amp; i)
+{
+	return (vii != static_cast&lt;const BodyRedirectionVectorIterator&amp;&gt;(i).vii );
+}
+
+
+void BodyRedirectionVectorIterator::increment()
+{
+	++vii;
+}
+
+
+void BodyRedirectionVectorIterator::affect(const BodyContainerIterator&amp; i)
+{
+	vii = static_cast&lt;const BodyRedirectionVectorIterator&amp;&gt;(i).vii;
+}
+
+
+shared_ptr&lt;Body&gt; BodyRedirectionVectorIterator::getValue()
+{
+	return (*vii);
+}
+
+
+shared_ptr&lt;BodyContainerIterator&gt; BodyRedirectionVectorIterator::createPtr()
+{
+	return shared_ptr&lt;BodyContainerIterator&gt;(new BodyRedirectionVectorIterator());
+}
+
+/*****************************************************************/
+/*****************************************************************/
+/*****************************************************************/
+/*****************************************************************/
+
+
+BodyRedirectionVector::BodyRedirectionVector()
+{
+	clear();
+}
+
+
+BodyRedirectionVector::~BodyRedirectionVector()
+{
+}
+
+
+// FIXME - make sure that this is correct
+unsigned int BodyRedirectionVector::insert(shared_ptr&lt;Body&gt;&amp; b)
+{
+	unsigned int position = b-&gt;getId();
+
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
+//	tmpVii = bodies.find(position);
+
+	bool used = false;
+
+//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
+//		if(position == (*tmpVii)-&gt;getId() )
+
+	if( (indexes.size() &gt; position)  &amp;&amp; (indexes[position] != -1) )
+			used = true;
+
+	if( used )
+	{
+		unsigned int newPosition = position;
+		// finds the first free key, which is bigger than id.
+		bool newUsed = true;
+		while( newUsed )
+		{
+			newUsed = false;
+			++newPosition;
+
+//			tmpVii    = bodies.begin();
+//			tmpViiEnd = bodies.end();
+//			for( ; tmpVii != tmpViiEnd ; ++tmpVii )
+//				if(newPosition == (*tmpVii)-&gt;getId() )
+			if( (indexes.size() &gt; newPosition)  &amp;&amp; (indexes[newPosition] != -1) )
+					newUsed = true;
+		}
+		//cerr &lt;&lt; &quot;WARNING: body id=\&quot;&quot; &lt;&lt; position &lt;&lt; &quot;\&quot; is already used. Using first free id=\&quot;&quot; &lt;&lt; newPosition &lt;&lt; &quot;\&quot;, beware - if you are loading a file, this will break transientInteractions for this body!\n&quot;;
+		position = newPosition;
+	}
+	BodyContainer::setId(b,position);
+	bodies.push_back(b);
+	
+	if(indexes.size() &lt; position+1)
+		indexes.resize(position+1, -1 );
+
+	indexes[position] = bodies.size()-1;
+	
+	return position;
+}
+
+
+unsigned int BodyRedirectionVector::insert(shared_ptr&lt;Body&gt;&amp; b, unsigned int newId)
+{
+	BodyContainer::setId(b,newId);
+	return insert(b);
+}
+
+
+void BodyRedirectionVector::clear()
+{
+	bodies.clear();
+	indexes.clear();
+}
+
+
+bool BodyRedirectionVector::erase(unsigned int id)
+{
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
+//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
+//		if(id == (*tmpVii)-&gt;getId() )
+//		{
+//			bodies.erase(tmpVii); // WRONG - bodies do change their indexes!
+//			indexes[id] = -1;
+//			return true;
+//		}
+//	return false;
+
+	long int deleted = indexes[id];
+	if( deleted != -1 )
+	{
+		std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin(); 
+		tmpVii += deleted;
+//		assert( (*tmpVii)-&gt;getId() == id );
+		bodies.erase(tmpVii);
+		indexes[id] = -1;
+		
+		std::vector&lt;long int&gt;::iterator scan = indexes.begin();
+		std::vector&lt;long int&gt;::iterator end  = indexes.end();
+		for( ; scan != end ; ++scan )
+			if( *scan &gt; deleted )
+				--(*scan); 
+		return true;
+	}
+	else
+		return false;
+}
+
+
+bool BodyRedirectionVector::exists(unsigned int id) const
+{
+        return id&lt;indexes.size() &amp;&amp; (indexes[id] != -1);
+}
+
+bool BodyRedirectionVector::find(unsigned int id , shared_ptr&lt;Body&gt;&amp; b) const
+{
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
+//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
+//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
+//		if(id == tmpVii-&gt;getId())
+//		{
+//			b = *tmpBii;
+//			return true;
+//		}
+
+	if(indexes[id] == -1)
+		return false;
+	else
+	{
+		b = bodies[ indexes[id] ];
+		return true;
+	}
+}
+
+
+shared_ptr&lt;Body&gt;&amp; BodyRedirectionVector::operator[](unsigned int id)
+{
+	// do not modify bii iterator
+//	temporaryBii = bodies.find(id);
+//	if (bii != bodies.end())
+//		return (*temporaryBii).second;
+//	else
+//		return shared_ptr&lt;Body&gt;();
+
+	return bodies[ indexes[id] ];
+}
+
+
+const shared_ptr&lt;Body&gt;&amp; BodyRedirectionVector::operator[](unsigned int id) const
+{
+//	Loki::AssocVector&lt;unsigned int , shared_ptr&lt;Body&gt; &gt;::const_iterator tmpBii;
+//	tmpBii = bodies.find(id);
+//	return (*tmpBii).second;
+	
+	return bodies[ indexes[id] ];
+}
+
+
+BodyContainer::iterator BodyRedirectionVector::begin()
+{
+	shared_ptr&lt;BodyRedirectionVectorIterator&gt; it(new BodyRedirectionVectorIterator());
+	it-&gt;vii   = bodies.begin();
+
+	return BodyContainer::iterator(it);
+}
+
+
+BodyContainer::iterator BodyRedirectionVector::end()
+{
+	shared_ptr&lt;BodyRedirectionVectorIterator&gt; it(new BodyRedirectionVectorIterator());
+	it-&gt;vii   = bodies.end();
+
+	return BodyContainer::iterator(it);
+}
+
+
+
+// 
+// void BodyRedirectionVector::pushIterator()
+// {// FIXME - make sure that this is FIFO (I'm tired now...)
+// 	iteratorList.push_front(vii);
+// }
+// 
+// 
+// void BodyRedirectionVector::popIterator()
+// {
+// 	vii = iteratorList.front();
+// 	iteratorList.pop_front();
+// }
+// 
+
+unsigned int BodyRedirectionVector::size()
+{
+	return bodies.size();
+}
+
+
+// YADE_PLUGIN();

Copied: trunk/core/DefaultContainerImplementations/BodyRedirectionVector.hpp (from rev 1361, trunk/pkg/common/Container/BodyRedirectionVector.hpp)
===================================================================
--- trunk/pkg/common/Container/BodyRedirectionVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/core/DefaultContainerImplementations/BodyRedirectionVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,66 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#pragma once
+
+#include&lt;yade/core/BodyContainer.hpp&gt;
+
+#include &lt;vector&gt;
+
+class Body;
+
+using namespace boost;
+using namespace std;
+
+class BodyRedirectionVectorIterator : public BodyContainerIterator 
+{
+	public :
+		vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator vii;
+
+		BodyRedirectionVectorIterator();
+		~BodyRedirectionVectorIterator();
+
+		virtual bool isDifferent(const BodyContainerIterator&amp; i);
+		virtual void affect(const BodyContainerIterator&amp; i);
+		virtual void increment();
+		virtual shared_ptr&lt;Body&gt; getValue();
+		virtual shared_ptr&lt;BodyContainerIterator&gt; createPtr();
+};
+
+
+class BodyRedirectionVector : public BodyContainer
+{
+	private	:
+		std::vector&lt; shared_ptr&lt;Body&gt; &gt; bodies;
+		std::vector&lt; long int &gt; indexes;
+
+	public :
+		BodyRedirectionVector();
+		virtual ~BodyRedirectionVector();
+	
+		virtual unsigned int insert(shared_ptr&lt;Body&gt;&amp;);
+		virtual unsigned int insert(shared_ptr&lt;Body&gt;&amp; , unsigned int);
+		virtual void clear();
+		virtual bool erase(unsigned int);
+		virtual bool find(unsigned int , shared_ptr&lt;Body&gt;&amp;) const;
+		virtual bool exists(unsigned int id) const;
+		virtual shared_ptr&lt;Body&gt;&amp; operator[](unsigned int);
+		virtual const shared_ptr&lt;Body&gt;&amp; operator[](unsigned int) const;
+	
+		virtual BodyContainer::iterator begin();
+	        virtual BodyContainer::iterator end();
+		
+		virtual unsigned int size();
+
+	// serialization of this class...
+	REGISTER_CLASS_NAME(BodyRedirectionVector);
+	REGISTER_BASE_CLASS_NAME(BodyContainer);
+};
+
+REGISTER_SERIALIZABLE(BodyRedirectionVector,false);
+

Copied: trunk/core/DefaultContainerImplementations/InteractionVecSet.cpp (from rev 1360, trunk/pkg/common/Container/InteractionVecSet.cpp)
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.cpp	2008-05-23 18:32:59 UTC (rev 1360)
+++ trunk/core/DefaultContainerImplementations/InteractionVecSet.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,261 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include &quot;InteractionVecSet.hpp&quot;
+#include &lt;iostream&gt;
+
+
+InteractionVecSetIterator::InteractionVecSetIterator() : InteractionContainerIterator()
+{
+
+}
+
+
+InteractionVecSetIterator::~InteractionVecSetIterator()
+{
+
+}
+
+
+bool InteractionVecSetIterator::isDifferent(const InteractionContainerIterator&amp; i)
+{
+	const InteractionVecSetIterator&amp; it = static_cast&lt;const InteractionVecSetIterator&amp;&gt;(i);
+	if (it.vii == it.viiEnd) // we are at end of container
+		return !(vii==viiEnd);
+	else
+		return (sii != it.sii );
+}
+
+
+void InteractionVecSetIterator::increment()
+{
+	if ( sii != siiEnd )
+		++sii;
+	while( sii == siiEnd )
+	{
+		++vii;
+		if(vii != viiEnd)
+		{
+			sii	= (*vii).begin();
+			siiEnd	= (*vii).end();
+		}
+		else
+			break;
+	}
+}
+
+
+void InteractionVecSetIterator::affect(const InteractionContainerIterator&amp; i)
+{
+	const InteractionVecSetIterator&amp; tmpi = static_cast&lt;const InteractionVecSetIterator&amp;&gt;(i);
+	vii    = tmpi.vii;
+	viiEnd = tmpi.viiEnd;
+	sii    = tmpi.sii;
+	siiEnd = tmpi.siiEnd;
+}
+
+
+shared_ptr&lt;Interaction&gt; InteractionVecSetIterator::getValue()
+{
+	return (*sii).second;
+}
+
+
+shared_ptr&lt;InteractionContainerIterator&gt; InteractionVecSetIterator::createPtr()
+{
+	return shared_ptr&lt;InteractionContainerIterator&gt;(new InteractionVecSetIterator());
+}
+
+
+/*********************************************************************/
+/*********************************************************************/
+/*********************************************************************/
+/*********************************************************************/
+
+InteractionVecSet::InteractionVecSet()
+{
+	currentSize = 0;
+	clear();
+}
+
+
+InteractionVecSet::~InteractionVecSet()
+{
+}
+
+
+bool InteractionVecSet::insert(shared_ptr&lt;Interaction&gt;&amp; i)
+{
+	boost::mutex::scoped_lock lock(drawloopmutex);
+
+	body_id_t id1 = i-&gt;getId1();
+	body_id_t id2 = i-&gt;getId2();
+
+	if (id1&gt;id2)
+		swap(id1,id2);
+
+	if ( static_cast&lt;unsigned int&gt;(id1) &gt;=interactions.size())
+		interactions.resize(id1+1);
+
+	if (interactions[id1].insert(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,i)).second)
+	{
+		currentSize++;
+		return true;
+	}
+	else
+		return false;
+}
+
+
+bool InteractionVecSet::insert(body_id_t id1,body_id_t id2)
+{
+	shared_ptr&lt;Interaction&gt; i(new Interaction(id1,id2) );
+	return insert(i);	
+}
+
+
+void InteractionVecSet::clear()
+{
+	boost::mutex::scoped_lock lock(drawloopmutex);
+
+	interactions.clear();
+	currentSize=0;
+}
+
+
+bool InteractionVecSet::erase(body_id_t id1,body_id_t id2)
+{
+	boost::mutex::scoped_lock lock(drawloopmutex);
+
+	if (id1&gt;id2)
+		swap(id1,id2);
+
+	if ( static_cast&lt;unsigned int&gt;(id1) &lt; interactions.size())
+	{
+		shared_ptr&lt;Interaction&gt; tmpI;
+		if (interactions[id1].erase(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI)))
+		{
+			currentSize--;
+			return true;
+		}
+		else
+			return false;
+	}
+
+	return false;
+
+}
+
+
+const shared_ptr&lt;Interaction&gt;&amp; InteractionVecSet::find(body_id_t id1,body_id_t id2)
+{
+	if (id1&gt;id2)
+		swap(id1,id2);
+
+	if (static_cast&lt;unsigned int&gt;(id1)&lt;interactions.size())
+	{
+		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator sii;
+		shared_ptr&lt;Interaction&gt; tmpI;
+		sii = interactions[id1].find(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI));
+		if (sii!=interactions[id1].end())
+			return (*sii).second;
+		else
+		{
+			empty = shared_ptr&lt;Interaction&gt;();
+			return empty;
+		}
+	}
+	else
+	{
+		empty = shared_ptr&lt;Interaction&gt;();
+		return empty;
+	}
+}
+
+
+InteractionContainer::iterator InteractionVecSet::begin()
+{
+	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
+	it-&gt;vii    = interactions.begin();
+	it-&gt;viiEnd = interactions.end();
+ 
+	if (it-&gt;vii!=it-&gt;viiEnd)
+	{
+		it-&gt;sii    = (*it-&gt;vii).begin();
+ 		it-&gt;siiEnd = (*it-&gt;vii).end();
+	
+		while( it-&gt;sii == it-&gt;siiEnd )
+		{
+			++it-&gt;vii;
+			if(it-&gt;vii != it-&gt;viiEnd)
+			{
+				it-&gt;sii	   = (*it-&gt;vii).begin();
+				it-&gt;siiEnd = (*it-&gt;vii).end();
+			}
+			else
+				return InteractionContainer::iterator(it);
+		}
+	}
+
+	return InteractionContainer::iterator(it);
+}
+
+
+InteractionContainer::iterator InteractionVecSet::end()
+{
+
+	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
+
+	it-&gt;vii		= interactions.end();
+	it-&gt;viiEnd	= interactions.end();
+	
+// in fact it is not possible to assign ssi, because it doesn't exist at all. (both begin() and end() do not exist)
+
+//	it-&gt;sii		= interactions.begin()-&gt;end();
+//	it-&gt;siiEnd	= interactions.begin()-&gt;end();
+// trying to access out of memory bounds: end() points behind LAST element. so accessing it causes segfault.
+//	it-&gt;sii		= (*it-&gt;vii).end();
+//	it-&gt;siiEnd	= (*it-&gt;vii).end();
+
+	return InteractionContainer::iterator(it);
+
+}
+
+
+// 
+// void InteractionVecSet::eraseCurrentAndGotoNextPotential()
+// {
+// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
+// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
+// 	
+// 	gotoNextPotential();
+// 	
+// 	(*tmpVii).erase(tmpSii);
+// 	currentSize--;	
+// }
+// 
+// void InteractionVecSet::eraseCurrentAndGotoNext()
+// {
+// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
+// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
+// 	
+// 	gotoNext();
+// 	
+// 	(*tmpVii).erase(tmpSii);
+// 	currentSize--;	
+// 	
+// }
+
+unsigned int InteractionVecSet::size()
+{
+	return currentSize;
+}
+
+// YADE_PLUGIN();

Copied: trunk/core/DefaultContainerImplementations/InteractionVecSet.hpp (from rev 1361, trunk/pkg/common/Container/InteractionVecSet.hpp)
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/core/DefaultContainerImplementations/InteractionVecSet.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,78 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+#pragma once
+
+#include&lt;yade/core/InteractionContainer.hpp&gt;
+#include&lt;yade/core/Interaction.hpp&gt;
+#include&lt;set&gt;
+#include&lt;vector&gt;
+
+using namespace std;
+
+struct lessThanPair
+{
+	bool operator()(const pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;&amp; p1, const pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;&amp; p2) const
+	{
+		return (p1.first&lt;p2.first);
+	}
+};
+
+class InteractionVecSetIterator : public InteractionContainerIterator 
+{
+	public :
+		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator vii;
+		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator viiEnd;
+		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator sii;
+		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator siiEnd;
+
+		InteractionVecSetIterator();
+		~InteractionVecSetIterator();
+
+		virtual bool isDifferent(const InteractionContainerIterator&amp; i);
+		virtual void affect(const InteractionContainerIterator&amp; i);
+		virtual void increment();
+		virtual shared_ptr&lt;Interaction&gt; getValue();
+		virtual shared_ptr&lt;InteractionContainerIterator&gt; createPtr();
+
+};
+
+
+using namespace __gnu_cxx;
+
+class InteractionVecSet : public InteractionContainer
+{
+	private :
+		vector&lt;set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt; interactions;
+		unsigned int currentSize;
+		shared_ptr&lt;Interaction&gt; empty;
+
+
+	public :
+		InteractionVecSet();
+		virtual ~InteractionVecSet();
+
+		virtual bool insert(body_id_t id1,body_id_t id2);
+		virtual bool insert(shared_ptr&lt;Interaction&gt;&amp; i);
+		virtual void clear();
+		virtual bool erase(body_id_t id1,body_id_t id2);
+		virtual const shared_ptr&lt;Interaction&gt;&amp; find(body_id_t id1,body_id_t id2);
+
+		virtual InteractionContainer::iterator begin();
+     	virtual InteractionContainer::iterator end();
+
+		virtual unsigned int size();
+
+	REGISTER_CLASS_NAME(InteractionVecSet);
+	REGISTER_BASE_CLASS_NAME(InteractionContainer);
+
+};
+
+REGISTER_SERIALIZABLE(InteractionVecSet,false);
+

Copied: trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.cpp (from rev 1360, trunk/pkg/common/Container/PhysicalActionVectorVector.cpp)
===================================================================
--- trunk/pkg/common/Container/PhysicalActionVectorVector.cpp	2008-05-23 18:32:59 UTC (rev 1360)
+++ trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,213 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#include&quot;PhysicalActionVectorVector.hpp&quot;
+#include&lt;yade/core/Body.hpp&gt;
+#include&lt;yade/core/PhysicalAction.hpp&gt;
+
+PhysicalActionVectorVectorIterator::PhysicalActionVectorVectorIterator() : PhysicalActionContainerIterator()
+{
+	currentIndex = -1;
+}
+
+
+PhysicalActionVectorVectorIterator::~PhysicalActionVectorVectorIterator()
+{
+
+}
+
+
+bool PhysicalActionVectorVectorIterator::isDifferent(const PhysicalActionContainerIterator&amp; i)
+{
+	const PhysicalActionVectorVectorIterator&amp; it = static_cast&lt;const PhysicalActionVectorVectorIterator&amp;&gt;(i);
+	if (it.vvi==it.vviEnd)
+		return !(vvi==vviEnd);
+	else
+		return (vi != it.vi );
+}
+
+
+void PhysicalActionVectorVectorIterator::increment()
+{
+	++vi;
+	if(vi == viEnd)
+	{
+		++vvi;
+		++currentIndex;
+		while(!(*usedIds)[currentIndex] &amp;&amp; vvi != vviEnd)
+		{
+			++currentIndex;
+			++vvi;
+		}
+		if(vvi != vviEnd)
+		{
+			vi	= (*vvi).begin();
+			viEnd	= (*vvi).end();
+		}
+	}
+}
+
+
+void PhysicalActionVectorVectorIterator::affect(const PhysicalActionContainerIterator&amp; i)
+{
+	const PhysicalActionVectorVectorIterator&amp; tmpi = static_cast&lt;const PhysicalActionVectorVectorIterator&amp;&gt;(i);
+	vi     = tmpi.vi;
+	viEnd  = tmpi.viEnd;
+	vvi    = tmpi.vvi;
+	vviEnd = tmpi.vviEnd;
+	currentIndex = tmpi.currentIndex;
+	usedIds	= tmpi.usedIds;
+}
+
+
+shared_ptr&lt;PhysicalAction&gt; PhysicalActionVectorVectorIterator::getValue()
+{	
+	return *vi;
+}
+
+
+int PhysicalActionVectorVectorIterator::getCurrentIndex()
+{
+	return currentIndex;
+}
+
+
+shared_ptr&lt;PhysicalActionContainerIterator&gt; PhysicalActionVectorVectorIterator::createPtr()
+{
+	return shared_ptr&lt;PhysicalActionContainerIterator&gt;(new PhysicalActionVectorVectorIterator());
+}
+
+
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+/**************************************************************************/
+
+PhysicalActionVectorVector::PhysicalActionVectorVector()
+{
+	clear();
+//	currentIndex = -1;
+	current_size = 0;
+}
+
+
+PhysicalActionVectorVector::~PhysicalActionVectorVector()
+{
+}
+
+
+void PhysicalActionVectorVector::clear()
+{
+	physicalActions.clear();
+	usedIds.clear();
+	current_size = physicalActions.size();
+}
+
+
+// doesn't not delete all, just resets data
+void PhysicalActionVectorVector::reset()
+{
+	vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vvi    = physicalActions.begin();
+	vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vviEnd = physicalActions.end();
+	for( ; vvi != vviEnd ; ++vvi )
+	{
+		vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;::iterator vi    = (*vvi).begin();
+		vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;::iterator viEnd = (*vvi).end();
+		for( ; vi != viEnd ; ++vi)
+		//if(*vi) // FIXME ?? do not check - all fields are NOT empty.
+			(*vi)-&gt;reset();
+	}
+}
+
+
+unsigned int PhysicalActionVectorVector::size()
+{
+	return current_size;
+}
+
+
+// fills container with resetted fields. argument here, should be all PhysicalAction types that are planned to use
+void PhysicalActionVectorVector::prepare(std::vector&lt;shared_ptr&lt;PhysicalAction&gt; &gt;&amp; actionTypes)
+{
+	unsigned int size = actionTypes.size();
+	int maxSize = 0;
+	for(unsigned int i = 0 ; i &lt; size ; ++i)
+		maxSize = max(maxSize , actionTypes[i]-&gt;getClassIndex() );
+	++maxSize;
+	actionTypesResetted.resize(maxSize);
+	for(unsigned int i = 0 ; i &lt; size ; ++i )
+	{
+		actionTypesResetted[actionTypes[i]-&gt;getClassIndex()] = actionTypes[i]-&gt;clone();
+		actionTypesResetted[actionTypes[i]-&gt;getClassIndex()] -&gt; reset();
+	}
+}
+
+
+// finds and returns action of given polymorphic type, for body of given Id,
+// should be always succesfull. if it is not - you forgot to call prepare()
+shared_ptr&lt;PhysicalAction&gt;&amp; PhysicalActionVectorVector::find(unsigned int id , int actionIndex )
+{
+	if( current_size &lt;= id ) // this is very rarely executed, only at beginning.
+	// somebody is accesing out of bounds, make sure he will find, what he needs - a resetted PhysicalAction of his type
+	{
+		unsigned int oldSize = physicalActions.size();
+		unsigned int newSize = id+1;
+		current_size = newSize;
+		usedIds.resize(newSize,false);
+		physicalActions.resize(newSize);
+		for(unsigned int i = oldSize ; i &lt; newSize ; ++i )
+		{
+			unsigned int actionTypesSize = actionTypesResetted.size();
+			physicalActions[i].resize(actionTypesSize);
+			for( unsigned int j = 0 ; j &lt; actionTypesSize ; ++j )
+				physicalActions[i][j] = actionTypesResetted[j]-&gt;clone();
+		}
+	}
+	usedIds[id] = true;
+	return physicalActions[id][actionIndex];
+}
+
+
+PhysicalActionContainer::iterator PhysicalActionVectorVector::begin()
+{
+	shared_ptr&lt;PhysicalActionVectorVectorIterator&gt; it(new PhysicalActionVectorVectorIterator());
+	it-&gt;currentIndex = 0;
+	it-&gt;usedIds	 = &usedIds;
+	it-&gt;vvi		 = physicalActions.begin();
+	it-&gt;vviEnd	 = physicalActions.end();
+	while(it-&gt;vvi!=it-&gt;vviEnd &amp;&amp; !usedIds[it-&gt;currentIndex])
+	{
+		++(it-&gt;currentIndex);
+		++(it-&gt;vvi);
+	}
+	if(it-&gt;vvi != it-&gt;vviEnd)
+	{
+		it-&gt;vi     = (*it-&gt;vvi).begin();
+		it-&gt;viEnd  = (*it-&gt;vvi).end();
+	}
+
+	return PhysicalActionContainer::iterator(it);
+}
+
+
+PhysicalActionContainer::iterator PhysicalActionVectorVector::end()
+{
+	shared_ptr&lt;PhysicalActionVectorVectorIterator&gt; it(new PhysicalActionVectorVectorIterator());
+	it-&gt;currentIndex = physicalActions.size();
+	it-&gt;vvi		 = physicalActions.end();
+	it-&gt;vviEnd	 = physicalActions.end();
+	/* Using nested iterator when the first one is end() already would be error, therefore we leave it-&gt;vi and it-&gt;viEnd alone.
+	 * (see PhysicalActionVectorVectorIterator::isDifferent for exact implementation of !=end()) */
+	return PhysicalActionContainer::iterator(it);
+
+}
+
+
+// YADE_PLUGIN();

Copied: trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.hpp (from rev 1361, trunk/pkg/common/Container/PhysicalActionVectorVector.hpp)
===================================================================
--- trunk/pkg/common/Container/PhysicalActionVectorVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/core/DefaultContainerImplementations/PhysicalActionVectorVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1,91 @@
+/*************************************************************************
+*  Copyright (C) 2004 by Olivier Galizzi                                 *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
+*  Copyright (C) 2004 by Janek Kozicki                                   *
+*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
+*                                                                        *
+*  This program is free software; it is licensed under the terms of the  *
+*  GNU General Public License v2 or later. See file LICENSE for details. *
+*************************************************************************/
+
+#ifndef PHYSICALACTIONVECTORVECTOR_HPP
+#define PHYSICALACTIONVECTORVECTOR_HPP
+
+#include&lt;yade/core/PhysicalActionContainer.hpp&gt;
+#include&lt;list&gt;
+#include&lt;vector&gt;
+
+class PhysicalAction;
+
+using namespace boost;
+using namespace std;
+
+class PhysicalActionVectorVectorIterator : public PhysicalActionContainerIterator
+{
+	public :
+		vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vvi;
+		vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vviEnd;
+			vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;  ::iterator vi;
+		vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;  ::iterator viEnd;
+		vector&lt; bool &gt; * usedIds;
+
+	public :
+		PhysicalActionVectorVectorIterator();
+		~PhysicalActionVectorVectorIterator();
+
+		virtual bool isDifferent(const PhysicalActionContainerIterator&amp; i);
+		virtual void affect(const PhysicalActionContainerIterator&amp; i);
+		virtual void increment();
+		virtual shared_ptr&lt;PhysicalAction&gt; getValue();
+		virtual shared_ptr&lt;PhysicalActionContainerIterator&gt; createPtr();
+		virtual int getCurrentIndex();
+};
+
+
+
+class PhysicalActionVectorVector : public PhysicalActionContainer
+{
+	private	:
+	// this in fact should be also a RedirectionVector in respect to the Body.id
+	// this container is memory-consuming, because size of this vector is depending on highest id
+	// from all bodies, not on the number of bodies
+	
+	// in this two-dimensional table:
+	// 	- first  dimension is Body-&gt;getId() number
+	//	- second dimension is PhysicalAction-&gt;getClassIndex() number
+		vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt; physicalActions;
+			vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;   actionTypesResetted;
+		vector&lt; bool &gt; usedIds;
+		unsigned int current_size;
+	
+	public :
+		PhysicalActionVectorVector();
+		virtual ~PhysicalActionVectorVector();
+
+		virtual void clear();
+
+		// doesn't delete all, just resets data
+		virtual void reset();
+		virtual unsigned int size();
+		// fills container with resetted fields. argument here, should be all PhysicalAction types that are planned to use
+		virtual void prepare(std::vector&lt;shared_ptr&lt;PhysicalAction&gt; &gt;&amp; );
+	
+		// finds and returns action of given polymorphic type, for body of given Id,
+		// should be always succesfull. if it is not - you forgot to call prepare()
+		virtual shared_ptr&lt;PhysicalAction&gt;&amp; find(
+					  unsigned int /*Body-&gt;getId() */
+					, int /*ActionForce::getClassIndexStatic()*/);
+
+		virtual PhysicalActionContainer::iterator begin();
+		virtual PhysicalActionContainer::iterator end();
+
+/// Serialization
+	REGISTER_CLASS_NAME(PhysicalActionVectorVector);
+	REGISTER_BASE_CLASS_NAME(PhysicalActionContainer);
+
+};
+
+REGISTER_SERIALIZABLE(PhysicalActionVectorVector,false);
+
+#endif // __ACTION_VEC_VEC_HPP__
+

Deleted: trunk/pkg/common/Container/BodyRedirectionVector.cpp
===================================================================
--- trunk/pkg/common/Container/BodyRedirectionVector.cpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/BodyRedirectionVector.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1,213 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Janek Kozicki                                   *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;BodyRedirectionVector.hpp&quot;
-#include &quot;BodyRedirectionVectorIterator.hpp&quot;
-
-
-#include&lt;yade/core/Body.hpp&gt;
-
-
-BodyRedirectionVector::BodyRedirectionVector()
-{
-	clear();
-}
-
-
-BodyRedirectionVector::~BodyRedirectionVector()
-{
-}
-
-
-// FIXME - make sure that this is correct
-unsigned int BodyRedirectionVector::insert(shared_ptr&lt;Body&gt;&amp; b)
-{
-	unsigned int position = b-&gt;getId();
-
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
-//	tmpVii = bodies.find(position);
-
-	bool used = false;
-
-//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
-//		if(position == (*tmpVii)-&gt;getId() )
-
-	if( (indexes.size() &gt; position)  &amp;&amp; (indexes[position] != -1) )
-			used = true;
-
-	if( used )
-	{
-		unsigned int newPosition = position;
-		// finds the first free key, which is bigger than id.
-		bool newUsed = true;
-		while( newUsed )
-		{
-			newUsed = false;
-			++newPosition;
-
-//			tmpVii    = bodies.begin();
-//			tmpViiEnd = bodies.end();
-//			for( ; tmpVii != tmpViiEnd ; ++tmpVii )
-//				if(newPosition == (*tmpVii)-&gt;getId() )
-			if( (indexes.size() &gt; newPosition)  &amp;&amp; (indexes[newPosition] != -1) )
-					newUsed = true;
-		}
-		//cerr &lt;&lt; &quot;WARNING: body id=\&quot;&quot; &lt;&lt; position &lt;&lt; &quot;\&quot; is already used. Using first free id=\&quot;&quot; &lt;&lt; newPosition &lt;&lt; &quot;\&quot;, beware - if you are loading a file, this will break transientInteractions for this body!\n&quot;;
-		position = newPosition;
-	}
-	BodyContainer::setId(b,position);
-	bodies.push_back(b);
-	
-	if(indexes.size() &lt; position+1)
-		indexes.resize(position+1, -1 );
-
-	indexes[position] = bodies.size()-1;
-	
-	return position;
-}
-
-
-unsigned int BodyRedirectionVector::insert(shared_ptr&lt;Body&gt;&amp; b, unsigned int newId)
-{
-	BodyContainer::setId(b,newId);
-	return insert(b);
-}
-
-
-void BodyRedirectionVector::clear()
-{
-	bodies.clear();
-	indexes.clear();
-}
-
-
-bool BodyRedirectionVector::erase(unsigned int id)
-{
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
-//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
-//		if(id == (*tmpVii)-&gt;getId() )
-//		{
-//			bodies.erase(tmpVii); // WRONG - bodies do change their indexes!
-//			indexes[id] = -1;
-//			return true;
-//		}
-//	return false;
-
-	long int deleted = indexes[id];
-	if( deleted != -1 )
-	{
-		std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin(); 
-		tmpVii += deleted;
-//		assert( (*tmpVii)-&gt;getId() == id );
-		bodies.erase(tmpVii);
-		indexes[id] = -1;
-		
-		std::vector&lt;long int&gt;::iterator scan = indexes.begin();
-		std::vector&lt;long int&gt;::iterator end  = indexes.end();
-		for( ; scan != end ; ++scan )
-			if( *scan &gt; deleted )
-				--(*scan); 
-		return true;
-	}
-	else
-		return false;
-}
-
-
-bool BodyRedirectionVector::exists(unsigned int id) const
-{
-        return id&lt;indexes.size() &amp;&amp; (indexes[id] != -1);
-}
-
-bool BodyRedirectionVector::find(unsigned int id , shared_ptr&lt;Body&gt;&amp; b) const
-{
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpVii    = bodies.begin();
-//	std::vector&lt; shared_ptr&lt;Body&gt; &gt;::iterator tmpViiEnd = bodies.end();
-//	for( ; tmpVii != tmpViiEnd ; ++tmpVii )
-//		if(id == tmpVii-&gt;getId())
-//		{
-//			b = *tmpBii;
-//			return true;
-//		}
-
-	if(indexes[id] == -1)
-		return false;
-	else
-	{
-		b = bodies[ indexes[id] ];
-		return true;
-	}
-}
-
-
-shared_ptr&lt;Body&gt;&amp; BodyRedirectionVector::operator[](unsigned int id)
-{
-	// do not modify bii iterator
-//	temporaryBii = bodies.find(id);
-//	if (bii != bodies.end())
-//		return (*temporaryBii).second;
-//	else
-//		return shared_ptr&lt;Body&gt;();
-
-	return bodies[ indexes[id] ];
-}
-
-
-const shared_ptr&lt;Body&gt;&amp; BodyRedirectionVector::operator[](unsigned int id) const
-{
-//	Loki::AssocVector&lt;unsigned int , shared_ptr&lt;Body&gt; &gt;::const_iterator tmpBii;
-//	tmpBii = bodies.find(id);
-//	return (*tmpBii).second;
-	
-	return bodies[ indexes[id] ];
-}
-
-
-BodyContainer::iterator BodyRedirectionVector::begin()
-{
-	shared_ptr&lt;BodyRedirectionVectorIterator&gt; it(new BodyRedirectionVectorIterator());
-	it-&gt;vii   = bodies.begin();
-
-	return BodyContainer::iterator(it);
-}
-
-
-BodyContainer::iterator BodyRedirectionVector::end()
-{
-	shared_ptr&lt;BodyRedirectionVectorIterator&gt; it(new BodyRedirectionVectorIterator());
-	it-&gt;vii   = bodies.end();
-
-	return BodyContainer::iterator(it);
-}
-
-
-
-// 
-// void BodyRedirectionVector::pushIterator()
-// {// FIXME - make sure that this is FIFO (I'm tired now...)
-// 	iteratorList.push_front(vii);
-// }
-// 
-// 
-// void BodyRedirectionVector::popIterator()
-// {
-// 	vii = iteratorList.front();
-// 	iteratorList.pop_front();
-// }
-// 
-
-unsigned int BodyRedirectionVector::size()
-{
-	return bodies.size();
-}
-
-
-
-YADE_PLUGIN();

Deleted: trunk/pkg/common/Container/BodyRedirectionVector.hpp
===================================================================
--- trunk/pkg/common/Container/BodyRedirectionVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/BodyRedirectionVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1 +0,0 @@
-#include&lt;yade/core/BodyRedirectionVector.hpp&gt;

Added: trunk/pkg/common/Container/BodyRedirectionVector.hpp
===================================================================
--- trunk/pkg/common/Container/BodyRedirectionVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/BodyRedirectionVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1 @@
+#include&lt;yade/core/BodyRedirectionVector.hpp&gt;

Deleted: trunk/pkg/common/Container/InteractionVecSet.cpp
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.cpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/InteractionVecSet.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1,194 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*  Copyright (C) 2004 by Janek Kozicki                                   *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;InteractionVecSet.hpp&quot;
-#include &quot;InteractionVecSetIterator.hpp&quot;
-#include &lt;iostream&gt;
-
-InteractionVecSet::InteractionVecSet()
-{
-	currentSize = 0;
-	clear();
-}
-
-
-InteractionVecSet::~InteractionVecSet()
-{
-}
-
-
-bool InteractionVecSet::insert(shared_ptr&lt;Interaction&gt;&amp; i)
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	body_id_t id1 = i-&gt;getId1();
-	body_id_t id2 = i-&gt;getId2();
-
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if ( static_cast&lt;unsigned int&gt;(id1) &gt;=interactions.size())
-		interactions.resize(id1+1);
-
-	if (interactions[id1].insert(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,i)).second)
-	{
-		currentSize++;
-		return true;
-	}
-	else
-		return false;
-}
-
-
-bool InteractionVecSet::insert(body_id_t id1,body_id_t id2)
-{
-	shared_ptr&lt;Interaction&gt; i(new Interaction(id1,id2) );
-	return insert(i);	
-}
-
-
-void InteractionVecSet::clear()
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	interactions.clear();
-	currentSize=0;
-}
-
-
-bool InteractionVecSet::erase(body_id_t id1,body_id_t id2)
-{
-	boost::mutex::scoped_lock lock(drawloopmutex);
-
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if ( static_cast&lt;unsigned int&gt;(id1) &lt; interactions.size())
-	{
-		shared_ptr&lt;Interaction&gt; tmpI;
-		if (interactions[id1].erase(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI)))
-		{
-			currentSize--;
-			return true;
-		}
-		else
-			return false;
-	}
-
-	return false;
-
-}
-
-
-const shared_ptr&lt;Interaction&gt;&amp; InteractionVecSet::find(body_id_t id1,body_id_t id2)
-{
-	if (id1&gt;id2)
-		swap(id1,id2);
-
-	if (static_cast&lt;unsigned int&gt;(id1)&lt;interactions.size())
-	{
-		set&lt;pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator sii;
-		shared_ptr&lt;Interaction&gt; tmpI;
-		sii = interactions[id1].find(pair&lt;body_id_t,shared_ptr&lt;Interaction&gt; &gt;(id2,tmpI));
-		if (sii!=interactions[id1].end())
-			return (*sii).second;
-		else
-		{
-			empty = shared_ptr&lt;Interaction&gt;();
-			return empty;
-		}
-	}
-	else
-	{
-		empty = shared_ptr&lt;Interaction&gt;();
-		return empty;
-	}
-}
-
-
-InteractionContainer::iterator InteractionVecSet::begin()
-{
-	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
-	it-&gt;vii    = interactions.begin();
-	it-&gt;viiEnd = interactions.end();
- 
-	if (it-&gt;vii!=it-&gt;viiEnd)
-	{
-		it-&gt;sii    = (*it-&gt;vii).begin();
- 		it-&gt;siiEnd = (*it-&gt;vii).end();
-	
-		while( it-&gt;sii == it-&gt;siiEnd )
-		{
-			++it-&gt;vii;
-			if(it-&gt;vii != it-&gt;viiEnd)
-			{
-				it-&gt;sii	   = (*it-&gt;vii).begin();
-				it-&gt;siiEnd = (*it-&gt;vii).end();
-			}
-			else
-				return InteractionContainer::iterator(it);
-		}
-	}
-
-	return InteractionContainer::iterator(it);
-}
-
-
-InteractionContainer::iterator InteractionVecSet::end()
-{
-
-	shared_ptr&lt;InteractionVecSetIterator&gt; it(new InteractionVecSetIterator());
-
-	it-&gt;vii		= interactions.end();
-	it-&gt;viiEnd	= interactions.end();
-	
-// in fact it is not possible to assign ssi, because it doesn't exist at all. (both begin() and end() do not exist)
-
-//	it-&gt;sii		= interactions.begin()-&gt;end();
-//	it-&gt;siiEnd	= interactions.begin()-&gt;end();
-// trying to access out of memory bounds: end() points behind LAST element. so accessing it causes segfault.
-//	it-&gt;sii		= (*it-&gt;vii).end();
-//	it-&gt;siiEnd	= (*it-&gt;vii).end();
-
-	return InteractionContainer::iterator(it);
-
-}
-
-
-// 
-// void InteractionVecSet::eraseCurrentAndGotoNextPotential()
-// {
-// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
-// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
-// 	
-// 	gotoNextPotential();
-// 	
-// 	(*tmpVii).erase(tmpSii);
-// 	currentSize--;	
-// }
-// 
-// void InteractionVecSet::eraseCurrentAndGotoNext()
-// {
-// 	vector&lt;set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt; &gt;::iterator tmpVii = vii;
-// 	set&lt;pair&lt;unsigned int,shared_ptr&lt;Interaction&gt; &gt;,lessThanPair &gt;::iterator tmpSii          = sii;
-// 	
-// 	gotoNext();
-// 	
-// 	(*tmpVii).erase(tmpSii);
-// 	currentSize--;	
-// 	
-// }
-
-unsigned int InteractionVecSet::size()
-{
-	return currentSize;
-}
-
-YADE_PLUGIN();

Deleted: trunk/pkg/common/Container/InteractionVecSet.hpp
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/InteractionVecSet.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1 +0,0 @@
-#include&lt;yade/core/InteractionVecSet.hpp&gt;

Added: trunk/pkg/common/Container/InteractionVecSet.hpp
===================================================================
--- trunk/pkg/common/Container/InteractionVecSet.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/InteractionVecSet.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1 @@
+#include&lt;yade/core/InteractionVecSet.hpp&gt;

Deleted: trunk/pkg/common/Container/PhysicalActionVectorVector.cpp
===================================================================
--- trunk/pkg/common/Container/PhysicalActionVectorVector.cpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/PhysicalActionVectorVector.cpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1,137 +0,0 @@
-/*************************************************************************
-*  Copyright (C) 2004 by Olivier Galizzi                                 *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">olivier.galizzi at imag.fr</A>                                               *
-*  Copyright (C) 2004 by Janek Kozicki                                   *
-*  <A HREF="https://lists.berlios.de/mailman/listinfo/yade-commits">cosurgi at berlios.de</A>                                                    *
-*                                                                        *
-*  This program is free software; it is licensed under the terms of the  *
-*  GNU General Public License v2 or later. See file LICENSE for details. *
-*************************************************************************/
-
-#include &quot;PhysicalActionVectorVector.hpp&quot;
-#include &quot;PhysicalActionVectorVectorIterator.hpp&quot;
-#include&lt;yade/core/Body.hpp&gt;
-#include&lt;yade/core/PhysicalAction.hpp&gt;
-
-
-PhysicalActionVectorVector::PhysicalActionVectorVector()
-{
-	clear();
-//	currentIndex = -1;
-	current_size = 0;
-}
-
-
-PhysicalActionVectorVector::~PhysicalActionVectorVector()
-{
-}
-
-
-void PhysicalActionVectorVector::clear()
-{
-	physicalActions.clear();
-	usedIds.clear();
-	current_size = physicalActions.size();
-}
-
-
-// doesn't not delete all, just resets data
-void PhysicalActionVectorVector::reset()
-{
-	vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vvi    = physicalActions.begin();
-	vector&lt; vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt; &gt;::iterator vviEnd = physicalActions.end();
-	for( ; vvi != vviEnd ; ++vvi )
-	{
-		vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;::iterator vi    = (*vvi).begin();
-		vector&lt; shared_ptr&lt;PhysicalAction&gt; &gt;::iterator viEnd = (*vvi).end();
-		for( ; vi != viEnd ; ++vi)
-		//if(*vi) // FIXME ?? do not check - all fields are NOT empty.
-			(*vi)-&gt;reset();
-	}
-}
-
-
-unsigned int PhysicalActionVectorVector::size()
-{
-	return current_size;
-}
-
-
-// fills container with resetted fields. argument here, should be all PhysicalAction types that are planned to use
-void PhysicalActionVectorVector::prepare(std::vector&lt;shared_ptr&lt;PhysicalAction&gt; &gt;&amp; actionTypes)
-{
-	unsigned int size = actionTypes.size();
-	int maxSize = 0;
-	for(unsigned int i = 0 ; i &lt; size ; ++i)
-		maxSize = max(maxSize , actionTypes[i]-&gt;getClassIndex() );
-	++maxSize;
-	actionTypesResetted.resize(maxSize);
-	for(unsigned int i = 0 ; i &lt; size ; ++i )
-	{
-		actionTypesResetted[actionTypes[i]-&gt;getClassIndex()] = actionTypes[i]-&gt;clone();
-		actionTypesResetted[actionTypes[i]-&gt;getClassIndex()] -&gt; reset();
-	}
-}
-
-
-// finds and returns action of given polymorphic type, for body of given Id,
-// should be always succesfull. if it is not - you forgot to call prepare()
-shared_ptr&lt;PhysicalAction&gt;&amp; PhysicalActionVectorVector::find(unsigned int id , int actionIndex )
-{
-	if( current_size &lt;= id ) // this is very rarely executed, only at beginning.
-	// somebody is accesing out of bounds, make sure he will find, what he needs - a resetted PhysicalAction of his type
-	{
-		unsigned int oldSize = physicalActions.size();
-		unsigned int newSize = id+1;
-		current_size = newSize;
-		usedIds.resize(newSize,false);
-		physicalActions.resize(newSize);
-		for(unsigned int i = oldSize ; i &lt; newSize ; ++i )
-		{
-			unsigned int actionTypesSize = actionTypesResetted.size();
-			physicalActions[i].resize(actionTypesSize);
-			for( unsigned int j = 0 ; j &lt; actionTypesSize ; ++j )
-				physicalActions[i][j] = actionTypesResetted[j]-&gt;clone();
-		}
-	}
-	usedIds[id] = true;
-	return physicalActions[id][actionIndex];
-}
-
-
-PhysicalActionContainer::iterator PhysicalActionVectorVector::begin()
-{
-	shared_ptr&lt;PhysicalActionVectorVectorIterator&gt; it(new PhysicalActionVectorVectorIterator());
-	it-&gt;currentIndex = 0;
-	it-&gt;usedIds	 = &usedIds;
-	it-&gt;vvi		 = physicalActions.begin();
-	it-&gt;vviEnd	 = physicalActions.end();
-	while(it-&gt;vvi!=it-&gt;vviEnd &amp;&amp; !usedIds[it-&gt;currentIndex])
-	{
-		++(it-&gt;currentIndex);
-		++(it-&gt;vvi);
-	}
-	if(it-&gt;vvi != it-&gt;vviEnd)
-	{
-		it-&gt;vi     = (*it-&gt;vvi).begin();
-		it-&gt;viEnd  = (*it-&gt;vvi).end();
-	}
-
-	return PhysicalActionContainer::iterator(it);
-}
-
-
-PhysicalActionContainer::iterator PhysicalActionVectorVector::end()
-{
-	shared_ptr&lt;PhysicalActionVectorVectorIterator&gt; it(new PhysicalActionVectorVectorIterator());
-	it-&gt;currentIndex = physicalActions.size();
-	it-&gt;vvi		 = physicalActions.end();
-	it-&gt;vviEnd	 = physicalActions.end();
-	/* Using nested iterator when the first one is end() already would be error, therefore we leave it-&gt;vi and it-&gt;viEnd alone.
-	 * (see PhysicalActionVectorVectorIterator::isDifferent for exact implementation of !=end()) */
-	return PhysicalActionContainer::iterator(it);
-
-}
-
-
-YADE_PLUGIN();

Deleted: trunk/pkg/common/Container/PhysicalActionVectorVector.hpp
===================================================================
--- trunk/pkg/common/Container/PhysicalActionVectorVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/PhysicalActionVectorVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -1 +0,0 @@
-#include&lt;yade/core/PhysicalActionVectorVector.hpp&gt;

Added: trunk/pkg/common/Container/PhysicalActionVectorVector.hpp
===================================================================
--- trunk/pkg/common/Container/PhysicalActionVectorVector.hpp	2008-05-24 12:36:34 UTC (rev 1361)
+++ trunk/pkg/common/Container/PhysicalActionVectorVector.hpp	2008-05-24 12:46:02 UTC (rev 1362)
@@ -0,0 +1 @@
+#include&lt;yade/core/PhysicalActionVectorVector.hpp&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000323.html">[Yade-commits] r1361 - in trunk: core gui gui/py gui/qt3 pkg/common	pkg/common/Container scripts
</A></li>
	<LI>Next message: <A HREF="000325.html">[Yade-commits] r1363 - trunk/gui/qt3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/yade-commits">More information about the Yade-commits
mailing list</a><br>
</body></html>
